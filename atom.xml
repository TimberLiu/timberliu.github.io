<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimberLiu&#39;s Blog</title>
  
  <subtitle>Easy coding, easy life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.timberliu.com/"/>
  <updated>2018-11-05T16:00:00.000Z</updated>
  <id>https://blog.timberliu.com/</id>
  
  <author>
    <name>TimberLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抽象类和接口</title>
    <link href="https://blog.timberliu.com/2018/11/06/AbstractClassAndInterface/"/>
    <id>https://blog.timberliu.com/2018/11/06/AbstractClassAndInterface/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2018-11-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象方法指的是仅有声明而没有方法体的方法。<a id="more"></a>使用 <code>abstract</code> 关键字进行声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abstract void f()</span><br></pre></td></tr></table></figure></p><p>而包含一个或多个抽象方法的类，就叫抽象类，用 <code>abstract</code>关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。</p><p>抽象类的主要目的是代码重用。大多用于抽象相关 <code>Java</code> 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 <code>java.util.AbstractList</code>。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 <code>static</code> 和 <code>final</code> 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 <code>enum</code> 枚举类。</p><p>接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 <code>Cloneable</code>、<code>Serializable</code>，表示这个类可以克隆或者可以序列化。</p><p><code>Java</code> 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Play</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Class Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Study</span>, <span class="title">Play</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"student doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"study"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Diner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sleeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以继承接口（支持多继承）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Diner</span>, <span class="title">Sleeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类可以实现接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Undergraduate</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类与接口比较"><a href="#抽象类与接口比较" class="headerlink" title="抽象类与接口比较"></a>抽象类与接口比较</h2><ul><li>一个类只能继承一个抽象类，但可以实现多个接口；</li><li>接口中的字段只能是 <code>static</code> 和 <code>final</code> 的，而抽象类的字段没有限制；</li><li>接口中的方法只能是 <code>public</code> 的，而抽象类的方法则没有限制。</li></ul><p>一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 <code>Java8</code> 开始也增加了默认方法，使得修改接口的成本也降低很多。</p><p>如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。</p><p>所以从 <code>Java8</code> 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，Java 8 中 List 接口的 sort 方法就是默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="inline-toc">1.</span><strong>可选方法</strong></p><p>默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。</p><p>例如，在 <code>Java8</code> 中，<code>Iterator</code> 接口为 <code>remove</code> 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 <code>Iterator</code> 接口的每一个类都声明一个空的 <code>remove</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnSupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="inline-toc">2.</span><strong>行为的多继承</strong></p><p>默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveHorizontally</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setX(getX() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">resizeWidth</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setWidth(getWidth() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">Moveable</span>, <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Change c = <span class="keyword">new</span> Change();</span><br><span class="line">        c.moveHorizontally(<span class="number">10</span>);</span><br><span class="line">        c.resizeWidth(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p><code>Java</code> 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。</p><p><strong>第一条规则</strong></p><p>在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello form B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。</p><p><strong>第二条规则</strong></p><p>如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello form B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello form B</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。</p><p><strong>第三条规则</strong></p><p>如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello from A</span></span><br></pre></td></tr></table></figure><p>上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 <code>hello</code> 方法，并且在调用时，使用 <code>X.super.f()</code> 这种语法，显式地指定使用哪一个接口中的方法。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java 编程思想》</li><li>《Java8 实战》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;抽象方法指的是仅有声明而没有方法体的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>Java 中的运算</title>
    <link href="https://blog.timberliu.com/2018/11/05/JavaOperation/"/>
    <id>https://blog.timberliu.com/2018/11/05/JavaOperation/</id>
    <published>2018-11-04T16:00:00.000Z</published>
    <updated>2018-11-04T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p>先来看一下值传递与引用传递的概念：</p><ul><li>值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。</li><li>引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。<a id="more"></a>那么 <code>Java</code> 中到底是值传递还是引用传递？先来看下面的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    j = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: j = "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    change(i);</span><br><span class="line">    System.out.println(<span class="string">"main: i = "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: j = 2</span></span><br><span class="line"><span class="comment">// main: i = 1</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>change</code> 方法内部并没有改变实际参数的值，那么 <code>Java</code> 就是值传递吗？再来看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"Timber"</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    change(user);</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: User&#123;name='Timber', age=21&#125;</span></span><br><span class="line"><span class="comment">// main: User&#123;name='Timber', age=21&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，实际参数的值被改变了，那么 <code>Java</code> 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">    name2 = <span class="string">"TimberLiu"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + name2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String name1 = <span class="string">"Timber"</span>;</span><br><span class="line">    change(name1);</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + name1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: TimberLiu</span></span><br><span class="line"><span class="comment">// main: Timber</span></span><br></pre></td></tr></table></figure><p>可以看到，实际参数的值又被改变了，这又作何解释呢？</p><h2 id="Java-的值传递"><a href="#Java-的值传递" class="headerlink" title="Java 的值传递"></a>Java 的值传递</h2><p>其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 <strong>传递参数时是否会进行拷贝，创建一个副本</strong>。</p><p>再来看一下上面的第二个例子，是如何传递的呢？</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/%E5%80%BC%E4%BC%A0%E9%80%921.png" width="80%"></p><p>可以看到，当把 <code>user</code> 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(User user2)</span> </span>&#123;</span><br><span class="line">    user2 = <span class="keyword">new</span> User();</span><br><span class="line">    user2.setName(<span class="string">"TimberLiu"</span>);</span><br><span class="line">    user2.setAge(<span class="number">21</span>);</span><br><span class="line">    System.out.println(<span class="string">"change:"</span> + user2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User();</span><br><span class="line">    user1.setName(<span class="string">"Timber"</span>);</span><br><span class="line">    user1.setAge(<span class="number">20</span>);</span><br><span class="line">    change(user1);</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: User&#123;name='TimberLiu', age=21&#125;</span></span><br><span class="line"><span class="comment">// main: User&#123;name='Timber', age=20&#125;</span></span><br></pre></td></tr></table></figure><p>这个过程发生了什么呢？看下图：</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/%E5%80%BC%E4%BC%A0%E9%80%922.png" width="80%"></p><p>可以看到，这里把 <code>user1</code> 传递给 <code>change</code> 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 <code>change</code> 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 <code>user2</code> 的修改并不会影响到 <code>user1</code> 中的内容。</p><p>所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。</p><p>那么，为什么上面在传递 <code>String</code> 对象和 <code>User</code> 对象结果不一样呢？这是因为 <code>String</code> 类型是不可变的，在赋值 <code>name2 = &quot;TimberLiu&quot;</code> 时，会重新创建一个 <code>String</code>，而并没有修改实际参数的值。</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/%E5%80%BC%E4%BC%A0%E9%80%923.png" width="80%"></p><p>所以，<strong>Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用</strong>。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><code>Java</code> 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下：</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" width="80%"></p><p>在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。</p><p>另外，在对基本数据进行运算时，所有 <code>byte</code>、<code>short</code>、<code>char</code> 类型的值都会自动被提升为 <code>int</code>。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。</p><p>在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = Integer.MAX_VALUE;</span><br><span class="line">        System.out.println(<span class="string">"big = "</span> + big);</span><br><span class="line">        System.out.println(<span class="string">"bigger = "</span> + (big + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// big = 2147483647</span></span><br><span class="line"><span class="comment">// bigger = -2147483648</span></span><br></pre></td></tr></table></figure><h2 id="switch-对-String-的支持"><a href="#switch-对-String-的支持" class="headerlink" title="switch 对 String 的支持"></a>switch 对 String 的支持</h2><p><code>switch</code> 原本只支持整型，而 <code>byte</code>、<code>short</code>、<code>char</code> 可以转换为 <code>int</code> 型，所以也可以使用。但从 <code>Java7</code> 开始，在 <code>switch</code> 条件判断语句中也可以使用 <code>String</code> 类型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decompile</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"aaa"</span>:</span><br><span class="line">            System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bbb"</span>:</span><br><span class="line">            System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译后，可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decompile</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">96321</span>:</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">"aaa"</span>)) &#123;</span><br><span class="line">            var3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">97314</span>:</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">"bbb"</span>)) &#123;</span><br><span class="line">            var3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>String</code> 的 <code>switch</code> 还是比较的 <code>byte</code> 类型。先声明了一个 <code>byte</code> 类型，然后通过 <code>hashCode</code> 和 <code>equals</code> 两个方法先后进行比较来赋予 <code>byte</code> 变量不同的值，最后 <code>switch</code> 来执行不同的代码。这里在 <code>hash</code> 之后再进行 <code>equals</code> 判断是有必要的，因为 <code>hash</code> 可能发生碰撞。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Hollis：<a href="https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A" target="_blank" rel="noopener">为什么说Java中只有值传递</a></li><li>SEU_Calvin：<a href="https://blog.csdn.net/seu_calvin/article/details/70089977" target="_blank" rel="noopener">Java技术——Java中的参数传值方式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;值传递与引用传递&quot;&gt;&lt;a href=&quot;#值传递与引用传递&quot; class=&quot;headerlink&quot; title=&quot;值传递与引用传递&quot;&gt;&lt;/a&gt;值传递与引用传递&lt;/h2&gt;&lt;p&gt;先来看一下值传递与引用传递的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。&lt;/li&gt;
&lt;li&gt;引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>基本数据类型</title>
    <link href="https://blog.timberliu.com/2018/11/03/BasicDateType/"/>
    <id>https://blog.timberliu.com/2018/11/03/BasicDateType/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2018-11-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><code>Java</code> 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。<a id="more"></a>它们的大小、最大最小值、包装类型、默认值如下：</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png" width="80%"></p><p><code>Java</code> 中的 <code>char</code> 使用 <code>Unicode</code> 编码，占两个字节。所以在 <code>Unicode</code> 编码中存在的中文，都可以用 <code>char</code> 存储。</p><p>在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">Java中，为什么 <code>byte</code> 类型的取值范围为-128~127?</a>。</p><p>浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。<code>Java</code> 中使用 <code>IEEE754</code>表示法，分为单精度和双精度两种，也就是 <code>float</code> 和 <code>double</code>，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别：</p><ul><li>默认值不同。基本类型的默认值为 0、<code>false</code> 等；而包装类默认为 <code>null</code></li><li>初始化不同。基本类型不需要初始化；而包装类需要 <code>new</code>。</li><li>存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中</li><li>元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法</li></ul><p>基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 <code>Java5</code> 提供的一个语法糖。自动装箱就是 <code>Java</code>自动将原始类型值转换为对应的对象；自动拆箱就是 <code>Java</code> 自动将对象转换为对应的基本类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Integer n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Integer n = Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，自动装箱就是调用 <code>Integer</code> 的 <code>valueOf()</code> 方法实现的；而自动拆箱是调用 <code>Integer</code> 的 <code>xxxValue()</code> 方法实现的。</p><h2 id="整型的缓存机制"><a href="#整型的缓存机制" class="headerlink" title="整型的缓存机制"></a>整型的缓存机制</h2><p><code>Java5</code> 中，<code>Integer</code> 引入了一个新功能来节省内存和提高性能。在使用 <code>Integer.valueOf()</code>方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。</p><p><code>valueOf()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 <code>Integer</code> 对象。</p><p><code>IntegerCache</code> 是 <code>Integer</code> 的一个内部类，缓存池的大小默认为 <code>-128~127</code>。最大值可通过 <code>-XX:AutoBoxCacheMax=xxx</code> 修改。这个缓存在 <code>Integer</code> 类第一次被使用时，通过一个 <code>for</code> 循环存储在一个整数数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编译器在自动装箱时会调用 <code>valueOf</code> 方法，所以创建多个相同的值时，会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="number">123</span>;</span><br><span class="line">    Integer j = <span class="number">123</span>;</span><br><span class="line">    System.out.println(i == j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所有的包装类都有类似的缓存机制：</p><ul><li><code>ByteCache</code> 可以缓存 <code>Byte</code> 对象</li><li><code>ShortCache</code> 可以缓存 <code>Short</code> 对象</li><li><code>LongCache</code> 可以缓存 <code>Long</code> 对象</li><li><code>CharacterCache</code> 可以缓存 <code>Character</code> 对象</li></ul><p><code>Byte</code>、<code>Short</code>、<code>Long</code> 的缓存范围都是固定的，为 <code>-128~127</code>。而 <code>CharacterCache</code> 的范围为 <code>0~127</code>。除了 <code>Integer</code>，这个范围都不能改变。</p><h2 id="高精度类型"><a href="#高精度类型" class="headerlink" title="高精度类型"></a>高精度类型</h2><p>Java 还提供了两个用于高精度计算的类：<code>BigInteger</code> 和 <code>BigDecimal</code>。</p><ul><li><code>BigInteger</code> 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。</li><li><code>BigDecimal</code> 支持任意精度的定点数。可以用它进行精确的货币运算。</li></ul><p>在 <code>Java</code> 中，对于金额的运算和在数据库中的存储，一般有两种方式：</p><ul><li>以元为单位。Java 中存储类型为 <code>BigDecimal</code>，在数据库中的存储类型为 <code>number(10, 2)</code>，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。</li><li>以分为单位。<code>Java</code> 中存储类型为 <code>Long</code>，在数据库中存储类型为 <code>big int</code>。取整和保留方式如前面一样。</li></ul><p>看一下下面的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static BigDecimal div(double v1, double v2) &#123;</span><br><span class="line">    BigDecimal b1 = new BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = new BigDecimal(Double.toString(v2));</span><br><span class="line">    // 保留两位小数，使用四舍五入模式</span><br><span class="line">    return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行金额运算时，使用 <code>BigDecimal</code> 类，并且将 <code>double</code> 转为 <code>String</code> 类型进行运算。在使用 <code>divide</code> 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Hollis：<a href="https://www.hollischuang.com/archives/1174" target="_blank" rel="noopener">[译]Java中整型的缓存机制</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象中的一些概念</title>
    <link href="https://blog.timberliu.com/2018/11/01/Object-orientedConcept/"/>
    <id>https://blog.timberliu.com/2018/11/01/Object-orientedConcept/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-10-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this、super"><a href="#this、super" class="headerlink" title="this、super"></a>this、super</h2><p><code>this</code> 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 <code>this</code> 调用构造器，但必须将构造器置于最起始处。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>super</code> 关键字表示如果子类重写了父类的某个方法，可以通过 <code>super</code> 关键字来调用父类的方法实现，也可以用来调用父类的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">":"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();</span><br><span class="line">        System.out.println(name + <span class="string">":"</span> + age + <span class="string">","</span> + score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"Timber"</span>, <span class="number">20</span>, <span class="number">80</span>);</span><br><span class="line">        student.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Timber:20</span></span><br><span class="line"><span class="comment">// Timber:20,80</span></span><br></pre></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><code>final</code> 关键字可用于三种情况：变量、方法和类。</p><p><span id="inline-toc">1.</span><strong>变量</strong></p><p>对于基本类型时，<code>final</code> 使数值恒定不变；对于引用类型时，<code>final</code> 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。</p><p>另外，在参数列表中还可以将参数声明为 <code>final</code>，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。</p><p><span id="inline-toc">2.</span><strong>方法</strong></p><p>final 方法不可以被重写。</p><p>类中所有的 <code>private</code> 方法都隐式地指定为 <code>final</code>，所以 <code>private</code> 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。</p><p><span id="inline-toc">3.</span><strong>类</strong></p><p><code>final</code> 类不能被继承，而且 <code>final</code> 类中的所有方法都隐式地被指定为 <code>final</code>，无法覆盖它们。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 <code>static</code> 方法或访问其 <code>static</code> 域。</p><p><span id="inline-toc">1.</span><strong>变量</strong></p><p>当 <code>static</code> 作用于某个字段时，会改变数据的创建方式，因为 <code>static</code> 字段对每个类只有一份存储空间，存放在方法区中；而非 <code>static</code> 字段则对每个对象都有一个存储空间，存放在堆中。</p><p><span id="inline-toc">2.</span><strong>方法</strong></p><p>对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 <code>this</code> 关键字。而 <code>static</code> 方法就是没有 <code>this</code> 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 <code>static</code> 方法，实际上这正是 <code>static</code> 方法的主要用途。</p><p><span id="inline-toc">3.</span><strong>静态块</strong></p><p><code>Java</code> 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class User &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        name = <span class="string">"Timber"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。</p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p><span id="inline-toc">1.</span><strong>重写</strong></p><p>重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"studying"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        person.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// studying</span></span><br></pre></td></tr></table></figure><p>上面就是一个重写的例子。重写一般需要注意以下几点：</p><ul><li>子类方法的方法签名必须和父类方法相同；</li><li>子类方法的返回类型必须小于等于父类的方法；</li><li>子类中的访问权限必须大于等于父类的方法；</li><li>子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常</li><li>不能重写被标识为 final 的方法</li></ul><p>重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"student"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person a1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"a1.s: "</span> + a1.s);</span><br><span class="line">        Student a2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"a2.s: "</span> + a2.s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a1.s: person</span></span><br><span class="line"><span class="comment">// a2.s: student</span></span><br></pre></td></tr></table></figure><p><span id="inline-toc">2.</span><strong>重载</strong></p><p>重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"studying"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String thing)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"studying "</span> + thing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个重载的例子。重载一般需要注意几点：</p><ul><li>被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。</li><li>根据方法的返回值不能区分重载</li><li>重载涉及到基本类型的自动提升时可能会造成混淆。</li></ul><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 <code>new</code> 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。</p><p>一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 <code>new Person()</code> 创建对象时就会报错。</p><p>对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 <code>int</code> 初始化为 <code>0</code>，引用类型初始化为 <code>null</code>等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。</p><p>对象的创建过程如下：</p><ul><li>当首次创建类对象，或者类的静态方法/静态域被首次访问时，<code>Java</code> 解释器查找类文件；</li><li>然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。</li><li>如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 <code>null</code>；</li><li>然后执行出现于成员变量定义处的初始化动作；</li><li>然后再执行构造器。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件：</p><ul><li>有类继承或接口实现</li><li>子类要重写父类的方法</li><li>父类的引用指向子类的对象</li></ul><p>根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this、super&quot;&gt;&lt;a href=&quot;#this、super&quot; class=&quot;headerlink&quot; title=&quot;this、super&quot;&gt;&lt;/a&gt;this、super&lt;/h2&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 &lt;code&gt;this&lt;/code&gt; 调用构造器，但必须将构造器置于最起始处。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>对 Java 平台的理解</title>
    <link href="https://blog.timberliu.com/2018/10/30/TheJavaPlatform/"/>
    <id>https://blog.timberliu.com/2018/10/30/TheJavaPlatform/</id>
    <published>2018-10-29T16:00:00.000Z</published>
    <updated>2018-10-29T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code> 是一种面向对象的语言，最显著的特性有两个方面：   </p><ol><li>跨平台特性。也就是“编译一次，到处运行”（<code>Compile once, run anywhere</code>)，能够非常容易地获得跨平台能力；</li><li>垃圾回收机制。<code>Java</code> 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。<a id="more"></a>  </li></ol><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：<code>C/C++</code> 等。</p><p>解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：<code>Java</code>、<code>python</code> 等。</p><p>严格来说，传统的 <code>Java</code> 是解释型语言，但加入了 <code>JIT</code>、<code>AOT</code> 编译器后，让 <code>Java</code> 也拥有了编译型语言的特性。它总共有三种执行的方式：</p><ul><li><code>Java</code> 源代码首先经过 <code>Javac</code> 编译成 <code>.class</code> 文件，然后：<ul><li>解释执行：<code>.class</code> 文件经过 JVM 内嵌的解释器解释执行。  </li><li>编译执行：即时编译器（<code>Just In Time</code> 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热）</li></ul></li><li>编译执行: <code>Java</code> 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成）</li></ul><h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><p><code>Java</code> 和 <code>C++</code> 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：<code>C++</code> 是编译型语言，<code>Java</code> 是解释型语言。</p><p>二者主要区别如下：</p><table><thead><tr><th>-</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>语言类型</td><td>解释型</td><td>编译型 </td></tr><tr><td>平台相关性</td><td>跨平台</td><td>平台相关的</td></tr><tr><td>语言</td><td>纯粹的面向对象语言</td><td>既支持面向对象也支持面向过程</td></tr><tr><td>数字类型</td><td>在所有平台上基本类型<br>有标准的范围限制和字节长度</td><td>对数字类型有标准的范围限制<br>但字节长度跟具体实现有关</td></tr><tr><td>参数传递</td><td>只有值传递<br>它的引用可以理解为安全指针</td><td>有值传递和引用传递</td></tr><tr><td>内存管理</td><td>自动垃圾回收</td><td>需要显示的内存管理，支持析构函数</td></tr><tr><td>继承与实现</td><td>支持多重继承</td><td>只允许单继承，但可以多实现</td></tr><tr><td>操作符</td><td>不支持操作符重载<br>仅对 String 有两个内置的加法运算</td><td>支持操作符重载</td></tr></tbody></table><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><p>下图是 <code>Oracle</code> 官方文档中的 <code>JDK</code>、<code>JRE</code>、<code>JVM</code> 三者间的关系：</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/blog/2018/11/jdk_jre_jvm.png" width="80%"></p><p>三者详细：</p><ul><li>JDK：<code>Java Development Kit</code>（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。</li><li>JRE: <code>Java Runtime Enviroment</code>（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。</li><li>JVM：<code>Java Virtual Machine</code>（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。</li></ul><h2 id="跨平台特性"><a href="#跨平台特性" class="headerlink" title="跨平台特性"></a>跨平台特性</h2><p><code>Java</code> 的跨平台特性与 <code>Java</code> 虚拟机的存在密不可分。其实 <code>Java</code> 语言本身与其他编程语言没有特别大的差异，并不是说 <code>Java</code> 语言可以跨平台，而是在不同的平台都有可以让 <code>Java</code> 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 <code>JDK</code>，安装 <code>JDK</code> 也就有了 <code>Java</code> 的运行环境。</p><p>简单来说，<code>Java</code> 首先通过 <code>javac</code> 编译器将源码编译为字节码 <code>.class</code> 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 <code>JVM</code> 会可以根据不同的平台，使用不同的 <code>JVM</code> 映射规则，生成对应的机器码，让其与操作系统无关。所以 <code>Java</code> 才有了“编译一次，到处运行”的效果。</p><h2 id="Java-平台"><a href="#Java-平台" class="headerlink" title="Java 平台"></a>Java 平台</h2><p>对于 <code>Java</code> 平台，有很多个方面可以谈：</p><ul><li><code>Java</code> 语言特性：面向对象特性、泛型、<code>Lamdba</code> 等</li><li>基础类库：集合、<code>IO/NIO</code>、网络、并发等基础类库</li><li><code>JVM</code>：类加载机制、垃圾回收、常用工具</li><li><code>Java</code> 生态：<code>JavaEE</code>、<code>Spring</code>、<code>Maven</code>、<code>Hadoop</code> 等</li></ul><p>下图是总结的一个蓝图：</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/Java%E5%B9%B3%E5%8F%B0.png" width="90%"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 是一种面向对象的语言，最显著的特性有两个方面：   &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;跨平台特性。也就是“编译一次，到处运行”（&lt;code&gt;Compile once, run anywhere&lt;/code&gt;)，能够非常容易地获得跨平台能力；&lt;/li&gt;
&lt;li&gt;垃圾回收机制。&lt;code&gt;Java&lt;/code&gt; 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>理解面向对象思想</title>
    <link href="https://blog.timberliu.com/2018/10/28/Object-orientedThought/"/>
    <id>https://blog.timberliu.com/2018/10/28/Object-orientedThought/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2018-10-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习 <code>Java</code> 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。</p></blockquote><p><code>Java</code> 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 <code>Java</code> 平台又该如何理解？今天就来学习一下。<a id="more"></a></p><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><p>所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。</p><p>而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。</p><p>在面向对象程序设计中会创建抽象数据类型，也就是类 <code>class</code>，它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。</p><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><p><span id="inline-toc">1.</span><strong>封装</strong></p><p>封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。</p><p>Java 用三个关键字在类内设定边界：<code>public</code>、<code>protected</code>、<code>private</code>，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。</p><p><span id="inline-toc">2.</span><strong>继承</strong></p><p>代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 <code>private</code>，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。</p><p>另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写 <code>overriding</code>。</p><p>那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。</p><p><span id="inline-toc">3.</span><strong>多态</strong></p><p>在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。</p><p>在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。</p><h2 id="五大设计原则"><a href="#五大设计原则" class="headerlink" title="五大设计原则"></a>五大设计原则</h2><p>面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。</p><ul><li><p>单一职责（<code>Single Responsibility</code>）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。  </p></li><li><p>开关封闭（<code>Open-Closed</code>）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。</p></li><li><p>里氏替换（<code>Liskov Substitution</code>）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。</p></li><li><p>接口隔离（<code>Interface-Segregation</code>）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。</p></li><li><p>依赖倒置（<code>Dependency Inversion</code>）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。</p></li></ul><p>对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java 编程思想》</li><li>Hollis：<a href="https://www.hollischuang.com/archives/220" target="_blank" rel="noopener">牢记面向对象五个基本原则</a></li><li>十四期_李光：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习 &lt;code&gt;Java&lt;/code&gt; 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 &lt;code&gt;Java&lt;/code&gt; 平台又该如何理解？今天就来学习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
