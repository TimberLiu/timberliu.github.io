<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimberLiu&#39;s Blog</title>
  
  <subtitle>Easy coding, easy life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.timberliu.com/"/>
  <updated>2019-02-13T16:00:00.000Z</updated>
  <id>https://blog.timberliu.com/</id>
  
  <author>
    <name>TimberLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mmall_v2.0 分布式锁实现定时关单</title>
    <link href="https://blog.timberliu.com/2019/02/14/mmallv2.0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9A%E6%97%B6%E5%85%B3%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/02/14/mmallv2.0分布式锁定时关单/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在电商项目中，用户购买商品在生成订单后，一定时间内如果没有付款，应该将订单关闭。这里，主要用 <code>Spring Schedule</code>和分布式锁来实现，而分布式锁也分别用 <code>Redis</code> 命令原生实现和 <code>Redisson</code> 框架两种方式。</p><h1 id="Spring-Schedule-介绍"><a href="#Spring-Schedule-介绍" class="headerlink" title="Spring Schedule 介绍"></a>Spring Schedule 介绍</h1><p><code>Spring Schedule</code> 是一个任务调度框架，用于定时任务调度等。主要通过 <code>@Scheduled</code> 注解来创建定时任务，可通过 <code>cron</code> 表达式来指定任务特定的执行时间。<a id="more"></a></p><h2 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h2><p><code>Cron</code> 表达式是一个字符串，由 <code>6</code> 或 <code>7</code> 个字段组成，对应为 秒、分、时、日、月、周、年(可选)。 </p><p><strong>允许的值和特殊字符</strong></p><table><thead><tr><th>字段名</th><th>允许的值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * / </td></tr><tr><td>分</td><td>0-59</td><td>, - * / </td></tr><tr><td>时</td><td>0-23</td><td>, - * / </td></tr><tr><td>月内第几天</td><td>1-31</td><td>, - * / ? L W C</td></tr><tr><td>月</td><td>1-12 或 JAN-DEC</td><td>, - * / </td></tr><tr><td>周内第几天</td><td>1-7 或 SUN-SAT</td><td>, - * / ? L  C # </td></tr><tr><td>年(可选)</td><td>留空，1970-2099</td><td>, - * / </td></tr></tbody></table><p><strong>特殊字符的含义</strong></p><ul><li><code>*</code>：匹配任意值，例如秒域为 <code>*</code> 表示每秒都会触发事件；</li><li><code>?</code>: 只能在月内第几天和周内第几天两个域使用，用于执行不明确的值。当两个域之一被指定值后，为避免冲突，需要将另一个的值设为 <code>?</code>；</li><li><code>-</code>: 指定一个范围，例如分域为 <code>3-6</code>，表示从 <code>3</code> 分到 <code>6</code> 分钟每分钟触发一次；  </li><li><code>/</code> : 指定增量，表示起始时间开始触发，然后每隔固定时间触发一次，例如分域为 <code>5/15</code>，则意味着 <code>5</code> 分、<code>20</code> 分、<code>35</code> 分、<code>50</code> 分，分别触发一次；  </li><li><code>,</code>：指定几个可选值。例如在分域使用 <code>5,15</code>，则意味着在 <code>5</code> 和 <code>20</code> 分各触发一次；  </li><li><code>L</code> : 表示最后，只能出现在周内第几天和月内第几天域，表示一月的最后一天，或一周的最后一天。如果在周内第几天域前加上数字，表示一月的最后一个第几天。例如 <code>5L</code> 表示一个月的最后一个周五；</li><li><code>W</code> : 指定有效工作日(周一到周五)，只能在月内第几天域使用，系统将在离指定日期的最近的有效工作日触发。注意一点，<code>W</code> 的最近寻找不会跨过月份；  </li><li><code>LW</code> : 两个字符可以连用，表示一月的最后一个工作日，即最后一个星期五。  </li><li><code>#</code> : 指定一月的周内第几天，只能出现在月内第几天域。例如在 <code>2#3</code>，表示一月的第三个星期一(<code>2</code> 表示周一，<code>3</code> 表示第三周)。</li><li><code>C</code>：可以在月内第几天和周内第几天使用。</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"0 1 * * * *"</span>               表示每小时<span class="number">1</span>分<span class="number">0</span>秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"*/20 * * * * *"</span>            表示每<span class="number">20</span>秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0 9-12 * * *"</span>            表示每天<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>点执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0/20 9-12 * * *"</span>         表示每天<span class="number">9</span>点到<span class="number">12</span>点，每<span class="number">20</span>分钟执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0 9-12 * * 2-6"</span>          表示每周一至周五，<span class="number">9</span>点到<span class="number">12</span>点的<span class="number">0</span>分<span class="number">0</span>秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0 0 1 4 ?"</span>               表示<span class="number">4</span>月<span class="number">1</span>日<span class="number">0</span>时<span class="number">0</span>分<span class="number">0</span>秒执行一次</span><br></pre></td></tr></table></figure><h2 id="实现定时任务"><a href="#实现定时任务" class="headerlink" title="实现定时任务"></a>实现定时任务</h2><p>首先，在 <code>applicationContext.xml</code> 文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>开启定时任务。注意，导入约束时导入的是 <code>http://www.springframework.org/schema/task</code>。</p><p>然后，创建定时关闭订单的 <code>task</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseOrderTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IOrderService iOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">        <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>, <span class="string">"1"</span>));</span><br><span class="line">        iOrderService.closeOrder(hour);</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示每隔一分钟就查看是否有超过一个小时的订单未付款，如果有则进行关闭。<code>IOrderServiceImpl</code> 的 <code>closeOrder</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">    Date closeDateTime = DateUtils.addHours(<span class="keyword">new</span> Date(), -hour);</span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(), DateTimeUtil.dateToStr(closeDateTime));</span><br><span class="line">    <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo());</span><br><span class="line">        <span class="keyword">for</span> (OrderItem orderItem : orderItemList) &#123;</span><br><span class="line">            Integer stock = productMapper.selectStockByProductId(orderItem.getId());</span><br><span class="line">            <span class="keyword">if</span> (stock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(orderItem.getProductId());</span><br><span class="line">            product.setStock(stock + orderItem.getQuantity());</span><br><span class="line">            productMapper.updateByPrimaryKeySelective(product);</span><br><span class="line">        &#125;</span><br><span class="line">        orderMapper.closeOrderByOrderId(order.getId());</span><br><span class="line">        log.info(<span class="string">"关闭订单OrderNo：&#123;&#125;"</span>, order.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要逻辑是，首先查询超过一个小时的订单列表，然后对列表中的每一条订单，根据订单号查询商品列表，对每一件商品的库存进行更新，最后，对订单的状态进行修改，即意味着删除。</p><p>如此，定时关闭一定时间内未付款的订单的 <code>v1</code> 版本就完成了。但是在 <code>tomcat</code> 集群环境下，每次只需要一台机器执行即可，不用每台机器都执行；而且，多台机器同时执行也容易造成数据错乱。所以，这就需要使用分布式锁来进行保证。</p><h1 id="Redis-命令实现分布式锁"><a href="#Redis-命令实现分布式锁" class="headerlink" title="Redis 命令实现分布式锁"></a>Redis 命令实现分布式锁</h1><h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><p>下面是其中会用到的一下 Redis 命令：</p><p>1).<code>setnx key value</code></p><p><code>SET if Not eXists</code> 的简称。如果键不存在，则将键 <code>key</code> 的值设置为 <code>value</code>。否则如果键已经存在，则不做任何操作。</p><p>设置成功时返回 <code>1</code>，设置失败时返回 <code>0</code>。</p><p>2).<code>getset key value</code></p><p>将键 <code>key</code> 的值设为 <code>value</code>，并返回键 <code>key</code> 在被设置之前的旧值。</p><p>如果键 <code>key</code> 存在旧值，则会返回。否则如果不存在旧值，也就是键 <code>key</code> 在设置之前并不存在，则返回 <code>nil</code>。</p><p>3).<code>expire key seconds</code></p><p>为给定的键 <code>key</code> 设置生存时间，当 <code>key</code> 的生存时间为 <code>0</code>(过期) 时，它会被自动删除。</p><p>4).<code>del key [key...]</code></p><p>删除给定的一个或多个 <code>key</code>。</p><h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><p><strong>Redis 分布式锁原理</strong> </p><p><code>Redis</code> 分布式锁的流程图如下:</p><p><img src="http://media.timberliu.com/image/2019/2/11/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" width="40%"></p><p>它的主要原理是：首先，通过 <code>setnx</code> 存入一个 <code>lockkey</code>，如果设置成功，也就是获取锁成功，就为锁设置一个有效期，然后执行业务，之后将 <code>lockkey</code> 删除，最后将锁释放。如果设置失败，也就是获取锁失败，则直接结束。</p><p>这里使用 <code>setnx</code> 命令，开始时 <code>Redis</code> 中不存在 <code>lockkey</code>，<code>setnx(lockkey)</code> 就会返回 <code>1</code>，表示本台机器获取到了锁，可以定时执行业务。而其他机器在有效期内获取锁时，<code>lockkey</code> 已经存在，就会返回 <code>0</code>，表示没有获取到锁，其他机器正在执行业务。</p><p><strong>构建分布式任务调度</strong></p><p>利用 <code>Spring Schedule + Redis</code> 分布式锁构建分布式任务调度，方法 <code>closeOrderTaskV2</code> 版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>, <span class="string">"5000"</span>));</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));</span><br><span class="line">    <span class="keyword">if</span> (setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回值是 1，代表设置成功，获取锁</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"没有获取到分布式锁：&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改存活时间</span></span><br><span class="line">    RedisShardedPoolUtil.expire(lockName, <span class="number">5</span>);</span><br><span class="line">    log.info(<span class="string">"获取&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>, <span class="string">"2"</span>));</span><br><span class="line">    iOrderService.closeOrder(hour);</span><br><span class="line">    <span class="comment">// 删除 key</span></span><br><span class="line">    RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    log.info(<span class="string">"释放&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><p>如果某台 <code>tomcat</code> 机器成功获取到锁，但在为锁设置有效期之前，<code>tomcat</code> 机器意外关闭，这时就会产生死锁。</p><p>可以在 <code>CloseOrderTask</code> 中添加一个 <code>delLock</code> 方法，在销毁之前删除分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果直接 <code>kill</code> 掉 <code>tomcat</code> 进程，仍然不会调用这个方法，从而产生死锁。</p><h2 id="Redis-分布式锁双重防死锁"><a href="#Redis-分布式锁双重防死锁" class="headerlink" title="Redis 分布式锁双重防死锁"></a>Redis 分布式锁双重防死锁</h2><p><strong>Redis 分布式锁优化原理</strong></p><p><code>Redis</code> 分布式锁优化后的流程图如下:</p><p><img src="http://media.timberliu.com/image/2019/2/11/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" width="70%"></p><p>它的原理是：同样首先通过 <code>setnx</code> 存入一个 <code>lockkey</code>，如果设置成功，同之前一样。否则，通过 <code>get</code> 获得之前设置的 <code>currentTime + timeout</code>，判断 <code>lockValeA</code> 是否不为 <code>null</code>，并且 <code>currentTime</code> 大于 <code>lockValueA</code>，即分布式锁是否过期。</p><p>如果过期，通过 <code>getset</code> 将 <code>lockkey</code> 对应的 <code>value</code> 设置为 <code>currentTime + timeout</code>，并得到之前的旧值 <code>lockValueB</code>，判断 <code>lockValueB</code> 是否为 <code>null</code>，即 <code>lockkey</code> 是否还存在，或者 <code>lockValueA</code> 是否等于 <code>lockValueB</code>，即在这个过程中锁没有改变。如果条件满足，则表示获取锁成功，同 <code>setnx</code> 获取锁成功一样。</p><p>如果锁没有过期，则表示获取锁失败，直接结束。在 <code>getset</code> 后，如果 <code>lockValueB</code> 不为空，即 <code>lockkey</code> 仍然存在，或者锁被改变了，也表示获取锁失败，直接结束。</p><p><strong>构建分布式任务调度</strong></p><p>利用 <code>Spring Schedule + Redis</code> 分布式锁构建分布式任务调度，方法 <code>closeOrderTaskV3</code> 版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>, <span class="string">"5000"</span>));</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));</span><br><span class="line">    <span class="keyword">if</span> (setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回值是 1，代表设置成功，获取锁</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未获取到锁，继续判断时间戳，看锁是否过期</span></span><br><span class="line">        String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        <span class="keyword">if</span> (lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 锁过期，重置并获取锁</span></span><br><span class="line">            String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));</span><br><span class="line">            <span class="keyword">if</span> (getSetResult == <span class="keyword">null</span> || (getSetResult != <span class="keyword">null</span> &amp;&amp; StringUtils.equals(lockValueStr, getSetResult))) &#123;</span><br><span class="line">                closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"没有获取到分布式锁：&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"没有获取到分布式锁：&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h1><p><code>Redisson</code> 是架设在 <code>Redis</code> 上的一个 <code>Java</code> 驻内存数据网格，它在基于 <code>NIO</code> 的 <code>Netty</code> 框架上，充分地利用了 <code>Redis</code> 键值数据库提供的一系列优势。</p><p>将 <code>Redisson</code> 集成到项目中，只需要在 <code>pom.xml</code> 文件需要添加 <code>redisson</code> 和 <code>jackson-dataformat-avro</code> 的依赖。</p><p><strong>Redisson 初始化类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String redis1IP = PropertiesUtil.getProperty(<span class="string">"redis1.ip"</span>, <span class="string">"192.168.23.130"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis1.port"</span>, <span class="string">"6379"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            config.useSingleServer().setAddress(redis1IP + <span class="string">":"</span> + redis1Port);</span><br><span class="line">            redisson = (Redisson) Redisson.create(config);</span><br><span class="line">            log.info(<span class="string">"初始化 Redisson 结束"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"初始化 Redisson 失败"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">getRedisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用单服务器模式，在传入地址时采用 <code>ip:port</code> 格式。</p><p><strong>任务调度 v4 版本</strong></p><p><code>tryLock</code> 方法在获取锁时，三个参数分别为：尝试获取锁最多等待的时间、获取锁后自动释放的时间、时间单元。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(locked = lock.tryLock(<span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            log.info(<span class="string">"Redisson 获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>, <span class="string">"2"</span>));</span><br><span class="line">            iOrderService.closeOrder(hour);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Redisson 没有获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">"Redisson 获取分布式锁异常"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">"Redisson 释放分布式锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>tryLock</code> 方法在获取锁之后，如果后续的执行业务时间小于 <code>1</code> 秒，而另外的 <code>tomcat</code> 在等待 <code>1</code> 秒后，又能重新获取锁，就会出现两个进程都获得锁的情况。</p><p>所以，应该将 <code>waitTime</code> 设置为 <code>0</code>（<code>waitTime</code> 时间小于业务执行时间）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在电商项目中，用户购买商品在生成订单后，一定时间内如果没有付款，应该将订单关闭。这里，主要用 &lt;code&gt;Spring Schedule&lt;/code&gt;和分布式锁来实现，而分布式锁也分别用 &lt;code&gt;Redis&lt;/code&gt; 命令原生实现和 &lt;code&gt;Redisson&lt;/code&gt; 框架两种方式。&lt;/p&gt;
&lt;h1 id=&quot;Spring-Schedule-介绍&quot;&gt;&lt;a href=&quot;#Spring-Schedule-介绍&quot; class=&quot;headerlink&quot; title=&quot;Spring Schedule 介绍&quot;&gt;&lt;/a&gt;Spring Schedule 介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Spring Schedule&lt;/code&gt; 是一个任务调度框架，用于定时任务调度等。主要通过 &lt;code&gt;@Scheduled&lt;/code&gt; 注解来创建定时任务，可通过 &lt;code&gt;cron&lt;/code&gt; 表达式来指定任务特定的执行时间。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 Redis + Cookie 实现单点登录</title>
    <link href="https://blog.timberliu.com/2019/02/14/mmallv2.0redis+cookie%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://blog.timberliu.com/2019/02/14/mmallv2.0redis+cookie实现单点登录/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>电商项目中，在单服务器时，用户登录时将用户信息设置到 <code>session</code> 中，获取用户信息从 <code>session</code> 中获取，退出时从 <code>session</code> 中删除即可。</p><p>但在搭建 <code>Tomcat</code> 集群后，就需要考虑 <code>Session</code> 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 <code>Redis + Cookie</code> 自己实现，另一种是借助 <code>Spring Session</code> 框架解决。<a id="more"></a></p><h1 id="Redis-Cookie-实现"><a href="#Redis-Cookie-实现" class="headerlink" title="Redis+Cookie 实现"></a>Redis+Cookie 实现</h1><h2 id="单点登录的思路"><a href="#单点登录的思路" class="headerlink" title="单点登录的思路"></a>单点登录的思路</h2><p>用户登录：</p><ul><li>首先验证用户密码是否正确，并返回用户信息；</li><li>使用 <code>uuid</code> 或 <code>session.getId</code> 生成唯一 <code>id(token)</code>，设置到 <code>cookie</code> 中，将其写给客户端；</li><li>将用户信息(<code>user</code> 对象)转换为 <code>json</code> 格式；</li><li>以 <code>key=token</code>，<code>value=(user 的 json 格式)</code>，写到 <code>redis</code> 中，并设置过期时间；</li></ul><p>退出登录：</p><ul><li>用户请求时会携带 <code>cookie</code>，从 <code>cookie</code> 中获取到 <code>token</code>；</li><li>从请求中获取到 <code>cookie</code>，将其过期时间设置为 <code>0</code>，再写入到响应中，即删除了 <code>token</code>；</li><li>再从 <code>redis</code> 中删除 <code>token</code>；</li></ul><p>获取用户信息：</p><ul><li>从请求携带的 <code>cookie</code> 中获取到 <code>token</code>；</li><li>根据 <code>token</code> 在 <code>redis</code> 中查询相应的 <code>user</code> 对象的 <code>json</code> 串；</li><li>将 <code>json</code> 串转换为 <code>user</code> 对象；</li></ul><h2 id="Redis-连接池及工具类"><a href="#Redis-连接池及工具类" class="headerlink" title="Redis 连接池及工具类"></a>Redis 连接池及工具类</h2><p>由于 <code>token</code> 和 <code>user</code> 对象都会存储在 <code>redis</code> 中，所以这里封装一个 <code>redis</code> 的连接池和工具类。</p><p>首先，封装一个 <code>redis</code> 连接池，每次直接从连接池中获取 <code>jedis</code> 实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String redisIP = PropertiesUtil.getProperty(<span class="string">"redis.ip"</span>, <span class="string">"192.168.23.130"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.port"</span>, <span class="string">"6379"</span>));</span><br><span class="line">    <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.max.total"</span>, <span class="string">"20"</span>));</span><br><span class="line">    <span class="comment">// 最大的 idle 状态的 jedis 实例个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.max.idle"</span>, <span class="string">"10"</span>));</span><br><span class="line">    <span class="comment">// 最小的 idle 状态的 jedis 实例个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.min.idle"</span>, <span class="string">"2"</span>));</span><br><span class="line">    <span class="comment">// 在 borrow 一个 jedis 实例时，是否要进行验证操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty(<span class="string">"redis.test.borrow"</span>, <span class="string">"true"</span>));</span><br><span class="line">    <span class="comment">// 在 return 一个 jedis 实例时，是否要进行验证操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty(<span class="string">"redis.test.return"</span>, <span class="string">"true"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(maxTotal);</span><br><span class="line">        config.setMaxIdle(maxIdle);</span><br><span class="line">        config.setMinIdle(minIdle);</span><br><span class="line">        config.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        config.setTestOnReturn(testOnReturn);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config, redisIP, redisPort, <span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">returnJedis</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再将其封装成一个工具类，基本操作就是从 <code>redis</code> 连接池中获取 <code>jedis</code> 实例，进行 <code>set/get/expire</code> 等操作，然后将其放回到 <code>redis</code> 连接池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exTime 以秒为单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> exTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Long result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.expire(key, exTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"expire key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Long result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.del(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"del key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"get key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.set(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"set key:&#123;&#125;, value:&#123;&#125;, error"</span>, key, value, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exTime 以秒为单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setEx</span><span class="params">(String key, String value, <span class="keyword">int</span> exTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.setex(key, exTime, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"setex key:&#123;&#125;, value:&#123;&#125;, error"</span>, key, value, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JsonUtil-工具类"><a href="#JsonUtil-工具类" class="headerlink" title="JsonUtil 工具类"></a>JsonUtil 工具类</h2><p>将 <code>user</code> 对象存储在 <code>redis</code> 中，需要转换为 <code>json</code> 格式，从 <code>redis</code> 中获取 <code>user</code> 对象，又需要转换为 <code>user</code> 对象。这里封装一个 <code>json</code> 的工具类。</p><p><code>JsonUtil</code> 工具类主要使用 <code>ObjectMapper</code> 类。</p><ul><li><code>bean</code> 类转换为 <code>String</code> 类型，使用 <code>writerValueAsString</code> 方法。</li><li><code>String</code> 类型转换为 <code>bean</code> 类，使用 <code>readValue</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化时将所有字段列入</span></span><br><span class="line">        objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.ALWAYS);</span><br><span class="line">        <span class="comment">// 取消默认将 DATES 转换为 TIMESTAMPS</span></span><br><span class="line">        objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 忽略空 bean 转 json 的错误</span></span><br><span class="line">        objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 所有日期样式统一</span></span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        <span class="comment">// 忽略 在 json 字符串中存在，在 java 对象中不存在对应属性的情况</span></span><br><span class="line">        objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">obj2Str</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> String ? (String) obj : objectMapper.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse Object to String error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">obj2StrPretty</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> String ? (String) obj :</span><br><span class="line">                    objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse Object to String error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str) || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.equals(String.class) ? (T)str : objectMapper.readValue(str, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, TypeReference&lt;T&gt; typeReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str) || typeReference == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typeReference.getType().equals(String.class) ? (T)str : objectMapper.readValue(str, typeReference);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, Class&lt;?&gt; collectionClass, Class&lt;?&gt; elementClass)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(str, javaType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CookieUtil-工具类"><a href="#CookieUtil-工具类" class="headerlink" title="CookieUtil 工具类"></a>CookieUtil 工具类</h2><p>登录时需要将 <code>token</code> 设置到 <code>cookie</code> 中返回给客户端，退出时需要从 <code>request</code> 中携带的 <code>cookie</code> 中读取 <code>token</code>，设置过期时间后，又将其设置到 <code>cookie</code> 中返回给客户端，获取用户信息时，获取用户信息时，需要从 <code>request</code> 中携带的 <code>cookie</code> 中读取 <code>token</code>，在 <code>redis</code> 中查询后获得 <code>user</code> 对象。这里呢，也封装一个 <code>cookie</code> 的工具类。</p><p>在 <code>CookieUtil</code> 中：</p><ul><li><code>readLoginToken</code> 方法主要从 <code>request</code> 读取 <code>Cookie</code>；</li><li><code>writeLoginToken</code> 方法主要设置 <code>Cookie</code> 对象加到 <code>response</code> 中；</li><li><code>delLoginToken</code> 方法主要从 <code>request</code> 中读取 <code>Cookie</code>，将其 <code>maxAge</code> 设置为 <code>0</code>，再添加到 <code>response</code> 中；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_DOMAIN = <span class="string">".happymmall.com"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_NAME = <span class="string">"mmall_login_token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readLoginToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                log.info(<span class="string">"read cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123;</span><br><span class="line">                    log.info(<span class="string">"return cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                    <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeLoginToken</span><span class="params">(HttpServletResponse response, String token)</span> </span>&#123;</span><br><span class="line">        Cookie cookie  = <span class="keyword">new</span> Cookie(COOKIE_NAME, token);</span><br><span class="line">        cookie.setDomain(COOKIE_DOMAIN);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 防止脚本攻击</span></span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 单位是秒，如果是 -1，代表永久；</span></span><br><span class="line">        <span class="comment">// 如果 MaxAge 不设置，cookie 不会写入硬盘，而是在内存，只在当前页面有效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span>);</span><br><span class="line">        log.info(<span class="string">"write cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delLoginToken</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123;</span><br><span class="line">                    cookie.setDomain(COOKIE_DOMAIN);</span><br><span class="line">                    cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">                    <span class="comment">// maxAge 设置为 0，表示将其删除</span></span><br><span class="line">                    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                    log.info(<span class="string">"del cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="具体业务"><a href="#具体业务" class="headerlink" title="具体业务"></a>具体业务</h2><p>登录时验证密码后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CookieUtil.writeLoginToken(response, session.getId());</span><br><span class="line">RedisShardedPoolUtil.setEx(session.getId(), JsonUtil.obj2Str(serverResponse.getData()), Const.RedisCacheExtime.REDIS_SESSION_EXTIME);</span><br></pre></td></tr></table></figure><p>退出登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String loginToken = CookieUtil.readLoginToken(request);</span><br><span class="line">CookieUtil.delLoginToken(request, response);</span><br><span class="line">RedisShardedPoolUtil.del(loginToken);</span><br></pre></td></tr></table></figure><p>获取用户信息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String loginToken = CookieUtil.readLoginToken(request);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(loginToken)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"用户未登录，无法获取当前用户信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String userJsonStr = RedisShardedPoolUtil.get(loginToken);</span><br><span class="line">User user = JsonUtil.str2Obj(userJsonStr, User.class);</span><br></pre></td></tr></table></figure><h2 id="SessionExpireFilter-过滤器"><a href="#SessionExpireFilter-过滤器" class="headerlink" title="SessionExpireFilter 过滤器"></a>SessionExpireFilter 过滤器</h2><p>另外，在用户登录后，每次操作后，都需要重置 <code>Session</code> 的有效期。可以使用过滤器来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionExpireFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        String loginToken = CookieUtil.readLoginToken(httpServletRequest);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(loginToken)) &#123;</span><br><span class="line">            String userJsonStr = RedisShardedPoolUtil.get(loginToken);</span><br><span class="line">            User user = JsonUtil.str2Obj(userJsonStr, User.class);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在 <code>web.xml</code> 文件中进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">mmall</span>.<span class="title">controller</span>.<span class="title">common</span>.<span class="title">SessionExpireFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">sessionExpireFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="此方式的缺陷"><a href="#此方式的缺陷" class="headerlink" title="此方式的缺陷"></a>此方式的缺陷</h2><ul><li><code>redis + cookie</code> 方式实现的单点登录对代码侵入性比较大；</li><li>客户端必须启用 <code>cookie</code>，而有些浏览器不支持 <code>cookie</code>；</li><li><code>Cookie</code> 设置 <code>domain</code> 时必须统一，服务器也必须统一域名方式；</li></ul><h1 id="Spring-Session-实现"><a href="#Spring-Session-实现" class="headerlink" title="Spring Session 实现"></a>Spring Session 实现</h1><p><code>Spring Session</code> 是 <code>Spring</code> 的项目之一，它提供了创建和管理 <code>Server</code> <code>HTTPSession</code> 的方案。并提供了集群 <code>Session</code> 功能，默认采用外置的 <code>Redis</code> 来存储 <code>Session</code> 数据，以此来解决 <code>Session</code> 共享的问题。</p><p><code>Spring Session</code> 可以无侵入式地解决 <code>Session</code> 共享问题，但是不能进行分片。</p><h2 id="Spring-Session-项目集成"><a href="#Spring-Session-项目集成" class="headerlink" title="Spring Session 项目集成"></a>Spring Session 项目集成</h2><p>1、引入 <code>Spring Session pom</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置 <code>DelegatingFilterProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">DelegatingFilterProxy</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">springSessionRepositoryFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、配置 <code>RedisHttpSessionConfiguration</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"redisHttpSessionConfiguration"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxInactiveIntervalInSeconds"</span> value=<span class="string">"1800"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、配置 <code>JedisPoolConfig</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"jedisPoolConfig"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxTotal"</span> value=<span class="string">"20"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>5、配置 <code>JedisSessionFactory</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"jedisConnectionFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> &gt;</span><br><span class="line">    &lt;property name=<span class="string">"hostName"</span> value=<span class="string">"192.168.23.130"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"port"</span> value=<span class="string">"6379"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"database"</span> value=<span class="string">"0"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"poolConfig"</span> ref=<span class="string">"jedisPoolConfig"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>6、配置 <code>DefaultCookieSerializer</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"defaultCookieSerializer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.session.web.http.DefaultCookieSerializer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieName"</span> value=<span class="string">"SESSION_NAME"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"domainName"</span> value=<span class="string">".happymmall.com"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"useHttpOnlyCookie"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookiePath"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieMaxAge"</span> value=<span class="string">"31536000"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h2 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h2><p>用户登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(Const.CURRENT_USER, response.getData());</span><br></pre></td></tr></table></figure><p>退出登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.removeAttribute(Const.CURRENT_USER);</span><br></pre></td></tr></table></figure><p>获得用户信息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User) session.getAttribute(Const.CURRENT_USER);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电商项目中，在单服务器时，用户登录时将用户信息设置到 &lt;code&gt;session&lt;/code&gt; 中，获取用户信息从 &lt;code&gt;session&lt;/code&gt; 中获取，退出时从 &lt;code&gt;session&lt;/code&gt; 中删除即可。&lt;/p&gt;
&lt;p&gt;但在搭建 &lt;code&gt;Tomcat&lt;/code&gt; 集群后，就需要考虑 &lt;code&gt;Session&lt;/code&gt; 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 &lt;code&gt;Redis + Cookie&lt;/code&gt; 自己实现，另一种是借助 &lt;code&gt;Spring Session&lt;/code&gt; 框架解决。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 环境搭建</title>
    <link href="https://blog.timberliu.com/2019/02/14/mmallv2.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.timberliu.com/2019/02/14/mmallv2.0项目环境搭建/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-配置与安装"><a href="#Redis-配置与安装" class="headerlink" title="Redis 配置与安装"></a>Redis 配置与安装</h1><p>从官网下载 <code>redis</code> 到 <code>/developer/setup</code> 目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//download.redis.io/releases/redis-4.0.12.tar.gz</span></span><br></pre></td></tr></table></figure><p>然后，将其解压到 <code>/developer</code> 目录下，进入到 <code>redis-4.0.12</code> 目录下，进行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-<span class="number">4.0</span>.12.tar.gz -C ../</span><br><span class="line">cd redis-<span class="number">4.0</span>.12/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><a id="more"></a><p>再将其名修改为 <code>redis-4.0.12_1</code>，另外再拷贝一份为 <code>redis-4.0.12_2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv redis-<span class="number">4.0</span>.12/ redis-<span class="number">4.0</span>.12_1</span><br><span class="line">cp redis-<span class="number">4.0</span>.12_1/ redis-<span class="number">4.0</span>.12_2/ -R</span><br></pre></td></tr></table></figure><p>然后，修改 <code>redis-4.0.12_2/src/</code> 目录下的 <code>redis.conf</code> 文件，端口修改为 <code>6380</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">6380</span></span><br></pre></td></tr></table></figure><p>然后，分别进入到 <code>src/</code> 目录下，后台启动 <code>redis</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf &amp;</span><br></pre></td></tr></table></figure><h1 id="Tomcat-配置多实例"><a href="#Tomcat-配置多实例" class="headerlink" title="Tomcat 配置多实例"></a>Tomcat 配置多实例</h1><p>在单机部署多应用时，官方不建议复制一个又一份的全部 <code>Tomcat</code> 目录进行多实例的部署，而是按照如下图实现：</p><p><img src="http://media.timberliu.com/image/2019/1/30/Tomcat%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%83%A8%E7%BD%B2.png" width="60%"></p><p><code>CATALINA_HOME</code> 指 <code>Tomcat</code> 的安装路径，包含 <code>bin</code> 和 <code>lib</code> 目录，而 <code>CATALINA_BASE</code> 指实例存放路径，包含 <code>conf</code>、<code>webapps</code>、<code>logs</code> 等目录。</p><p><strong>复制出两个实例</strong></p><p>首先新建两个 <code>tomcat1</code>、<code>tomcat2</code> 文件夹，并把 <code>apache-tomcat-8.5.35</code> 目录下的 <code>conf</code>、<code>webapps</code>、<code>temp</code>、<code>logs</code>、<code>work</code> 五个文件移动到 <code>tomcat1</code> 中，再将其复制一份到 <code>tomcat2</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat1 tomcat2</span><br><span class="line">cd apache-tomcat-<span class="number">8.5</span>.11</span><br><span class="line">mv conf/ webapps/ temp/ logs/ work/ -t ../tomcat1</span><br><span class="line">cp -r ../tomcat1<span class="comment">/* ../tomcat2</span></span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="http://media.timberliu.com/image/2019/1/30/%E5%A4%8D%E5%88%B6%E5%87%BA%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BE%8B.png" width="80%"></p><p><strong>配置 server.xml 端口</strong></p><p>修改 <code>conf/server.xml</code> 中的三个端口：</p><ul><li><code>Server port</code>：用于监听关闭 <code>Tomcat</code> 的 shutdown 命令，默认为 <code>8005</code></li><li><code>Connector port</code>：用于监听 <code>HTTP</code> 请求，默认为 8080</li><li><code>Connector port</code>（protocol=”AJP/1.3”）：用于监听 <code>AJP</code> 协议上的请求，通常用于整合 <code>Apache Server</code> 等其他 <code>HTTP</code> 服务器，默认为 <code>8009</code></li></ul><p>将 <code>tomcat2</code> 实例的端口分别修改为 <code>8006</code>、<code>8080</code>、<code>8010</code>，并对 <code>webapps/ROOT</code> 下的 <code>index.jsp</code> 首页作相应修改。</p><p><strong>创建启动、关闭脚本</strong></p><p>新建一个 <code>tomcat-shell</code> 文件夹，存放启动和关闭脚本，并赋予其执行权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat-shell</span><br><span class="line">cd tomcat-shell/</span><br><span class="line">vim start.sh</span><br><span class="line">vim shutdown.sh</span><br><span class="line">chmod u+x start.sh shutdown.sh</span><br></pre></td></tr></table></figure><p>start.sh 脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/developer/$<span class="number">1</span></span><br><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line"></span><br><span class="line">cd $CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><p>shutdown.sh 脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/developer/$<span class="number">1</span></span><br><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line"></span><br><span class="line">cd $CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">sh shutdown.sh</span><br></pre></td></tr></table></figure><p>启动和关闭脚本中，<code>$1</code> 表示执行时的第一个参数。</p><p><strong>启动实例</strong></p><p>执行以下命令，启动两个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start.sh tomcat1</span><br><span class="line">./start.sh tomcat2</span><br></pre></td></tr></table></figure><p><img src="http://media.timberliu.com/image/2019/1/30/%E5%AE%9E%E4%BE%8B%E5%90%AF%E5%8A%A8.png" width="80%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-配置与安装&quot;&gt;&lt;a href=&quot;#Redis-配置与安装&quot; class=&quot;headerlink&quot; title=&quot;Redis 配置与安装&quot;&gt;&lt;/a&gt;Redis 配置与安装&lt;/h1&gt;&lt;p&gt;从官网下载 &lt;code&gt;redis&lt;/code&gt; 到 &lt;code&gt;/developer/setup&lt;/code&gt; 目录下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//download.redis.io/releases/redis-4.0.12.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，将其解压到 &lt;code&gt;/developer&lt;/code&gt; 目录下，进入到 &lt;code&gt;redis-4.0.12&lt;/code&gt; 目录下，进行编译：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf redis-&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.12.tar.gz -C ../&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd redis-&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.12/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之环境搭建</title>
    <link href="https://blog.timberliu.com/2019/01/29/mmallv1.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.timberliu.com/2019/01/29/mmallv1.0项目环境搭建/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-01-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h2><p>首先，需要进行源配置，可使用阿里云的源，可查看：<a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener"> https://opsx.alibaba.com/mirror</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、备份</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="number">2</span>、下载新的CentOS-Base.repo 到/etc/yum.repos.d/</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http:<span class="comment">//mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="number">3</span>、生成缓存</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="创建用户并修改密码"><a href="#创建用户并修改密码" class="headerlink" title="创建用户并修改密码"></a>创建用户并修改密码</h2><p>首先，添加普通用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd  timberliu</span><br></pre></td></tr></table></figure><p>再更改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd timberliu</span><br></pre></td></tr></table></figure><p>之后退出重新登录验证。</p><h2 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h2><p><strong style="color:#ff6600">删除系统自带 jdk</strong></p><p>首先，执行以下命令查看自带的 <code>jdk</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br></pre></td></tr></table></figure><p>然后，使用 <code>sudo yum remove xxx</code> 命令进行删除。</p><p><strong style="color:#ff6600">下载与安装</strong></p><p>首先，在根目录创建一个 <code>developer</code>，再创建一个 <code>setup</code>，用于存放安装包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /developer/setup</span><br></pre></td></tr></table></figure><p>从 <code>Oracle</code> 官网得到 <code>jdk1.8</code> 的下载地址（可能会改变）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm</span></span><br></pre></td></tr></table></figure><p>使用 <code>wget</code> 命令安装到 <code>setup</code> 下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cookie --header <span class="string">"Cookie:oraclelicense=accept-securebackup-cookie"</span> https:<span class="comment">//download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm</span></span><br></pre></td></tr></table></figure><p>需要注意的是：在 Oracle 官网下载 rpm 时需要在 <code>wget</code> 后面加上 <code>--no-cookie --header &quot;Cookie:oraclelicense=accept-securebackup-cookie&quot;</code> 接受许可协议。</p><p>然后执行下面的命令进行安装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-<span class="number">8</span>u201-linux-x64.rpm</span><br></pre></td></tr></table></figure><p>默认会安装到 <code>/usr/java</code> 目录下。</p><p><strong style="color:#ff6600">配置环境变量</strong></p><p>执行 <code>sudo vim /etc/profile</code> 命令配置环境变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>然后，执行 <code>source /etc/profile</code> 使配置生效。使用 <code>java -version</code>，查看是否配置成功：</p><h2 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h2><p>首先，使用 <code>wget</code> 命令从阿里云镜像网站下载 <code>tomcat</code>，到 <code>setup</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz</span></span><br></pre></td></tr></table></figure><p>再使用 <code>tar</code> 命令解压缩到 <code>developer</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-<span class="number">8.5</span>.35.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>再执行 <code>vim /etc/profile</code> 配置环境变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line">export PATH=$CATALINA_HOME/bin:</span><br></pre></td></tr></table></figure><p>再修改 <code>apache-tomcat-8.5.35</code> 下的 <code>conf/server.xml</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/server.xml</span><br></pre></td></tr></table></figure><p>修改 <code>8080</code> 端口的 <code>URI</code> 的字符编码为 <code>&quot;UTF-8&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">   connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">   redirectPort=<span class="string">"8443"</span> URIEncoding=<span class="string">"UTF-8"</span> /&gt;</span><br></pre></td></tr></table></figure><p>最后，启动 <code>tomcat</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure><h2 id="安装-Maven"><a href="#安装-Maven" class="headerlink" title="安装 Maven"></a>安装 Maven</h2><p>和 <code>tomcat</code> 一样，得到 <code>maven</code> 的下载地址，进行下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//mirrors.aliyun.com/apache/maven/maven-3/3.0.5/binaries/apache-maven-3.0.5-bin.tar.gz</span></span><br></pre></td></tr></table></figure><p>然后，使用 <code>tar</code> 解压缩到 <code>developer</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-maven-<span class="number">3.0</span>.5-bin.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>然后，将 <code>maven</code> 配置到环境变量中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/developer/apache-maven-<span class="number">3.0</span>.5</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><p>执行 <code>source /etc/profile</code> 使配置生效。执行 <code>mvn -version</code> 查看是否安装成功。</p><h2 id="安装-vsftpd"><a href="#安装-vsftpd" class="headerlink" title="安装 vsftpd"></a>安装 vsftpd</h2><p><strong style="color:#ff6600">下载与安装</strong></p><p>使用 <code>yum</code> 直接执行下面的命令安装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure><p>在根目录下创建 <code>product</code> 目录，再创建 <code>ftpfile</code> 目录，用于存放上传的文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /product/ftpfile</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">添加匿名用户</strong></p><p>首先，添加一个匿名用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd ftpuser -d /product/ftpfile -s /sbin/nologin</span><br></pre></td></tr></table></figure><p>修改 <code>ftpfile</code> 文件夹的权限，用户组和用户都是 <code>ftpuser</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R ftpuser.ftpuser ./ftpfile/</span><br></pre></td></tr></table></figure><p>修改 <code>ftpuser</code> 的密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd ftpuser</span><br></pre></td></tr></table></figure><p>然后，在 <code>etc/vsftpd</code> 下创建 chroot_list 文件，在其中添加用户名，这里就是 <code>ftpuser</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/vsftpd/</span><br><span class="line">vim chroot_list</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">确认安全策略</strong></p><p>查看安全策略，确保其中的 <code>SELINUX</code> 为 <code>disabled</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p>为避免验证时碰到 550 拒绝访问错误，执行下面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[timberliu<span class="meta">@iZ</span>2ze222ncoofcesrn22waZ vsftpd]$ sudo setsebool -P ftp_home_dir <span class="number">1</span></span><br><span class="line">setsebool:  SELinux is disabled.</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">配置 vsftpd.conf 文件</strong></p><p>使用 <code>sudo vim vsftpd.conf</code> 命令编辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">local_root=/product/ftpfile</span><br><span class="line">#chroot_local_user=YES</span><br><span class="line">anon_root=/product/ftpfile</span><br><span class="line">use_localtime=YES</span><br><span class="line"></span><br><span class="line">#匿名</span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line">chroot_local_user=NO</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"># (default follows)</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line"></span><br><span class="line">#pasv_enable=YES</span><br><span class="line">pasv_min_port=<span class="number">61001</span></span><br><span class="line">pasv_max_port=<span class="number">62000</span></span><br></pre></td></tr></table></figure><p><strong>启动 vsftpd</strong></p><p>启动 <code>vsftpd</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure></p><p>查看 <code>vsftpd</code> 服务的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status vsftpd.service</span><br></pre></td></tr></table></figure><p>将其设置开机自启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vsftpd.service</span><br></pre></td></tr></table></figure><h2 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h2><p><strong style="color:#ff6600">下载与安装</strong></p><p>首先，安装 <code>Nginx</code> 需要依赖的环境：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><p>使用 <code>wget</code> 命令从官网下载 <code>Nginx</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//nginx.org/download/nginx-1.14.0.tar.gz</span></span><br></pre></td></tr></table></figure><p>使用 <code>tar</code> 解压缩到 <code>setup</code> 目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-<span class="number">1.14</span>.0.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>进入 <code>Nginx</code> 目录，分别执行以下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">更改配置</strong></p><p>然后，进入到 <code>Nginx</code> 安装目录的 <code>conf</code>下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br></pre></td></tr></table></figure><p>编辑 <code>nginx.conf</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>在其中添加如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include vhost<span class="comment">/*.conf;</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>conf</code> 目录下创建 <code>vhost</code> 文件夹。在 <code>vhost</code> 文件夹中创建 <code>admin.timberliu.com.conf</code>、<code>timberliu.com.conf</code>、<code>s.timberliu.com.conf</code> 和 <code>img.timberliu.com.conf</code> 文件。</p><p>在启动 <code>Nginx</code> 后，访问 <code>123.56.9.126</code>，即可看到 <code>Nginx</code> 页面。</p><h2 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h2><p>首先，需要删除掉系统自装或以前安装的 <code>mysql</code>：</p><blockquote><p>rosten：<a href="https://blog.csdn.net/rosten/article/details/25096159?utm_source=blogxgwz2" target="_blank" rel="noopener">centos下完全卸载mysql</a></p></blockquote><p>下载与安装： </p><blockquote><p>近博：<a href="https://www.cnblogs.com/jimboi/p/6405560.html" target="_blank" rel="noopener">Centos6.8通过yum安装mysql5.7</a><br>Linux社区-xyang81：<a href="https://www.linuxidc.com/Linux/2016-09/135288.htm" target="_blank" rel="noopener">CentOS7 64位下MySQL5.7安装与配置（YUM）</a></p></blockquote><p>注意：<code>CentOS 6</code> 和 <code>7</code> 中对于服务的管理也出现不同。<code>CentOS 6</code> 中使用 <code>service</code> 命令进行启动停止服务，使用 <code>chkconfig</code> 命令设置开机自启；而在 <code>CentOS 7</code> 中对所有服务都集中在到 <code>systemctl</code> 中，通过 <code>/usr/lib/systemd/system</code> 下以 <code>.service</code> 结尾的配置文件来管理。</p><p>在安装完 <code>MySQL</code> 后，使用 <code>mysql -u root</code> 进入 <code>mysql</code>，通过如下方式修改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set authentication_string=password(<span class="string">'root'</span>) where user=<span class="string">'root'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>然后退出 <code>mysql</code>，重新登录。使用如下命令创建一个新用户 <code>mmall</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant usage on *.* to <span class="string">'username'</span>@<span class="string">'localhost'</span> identified by <span class="string">'password'</span> with grant option;</span><br></pre></td></tr></table></figure><p>然后创建数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database `mmall` <span class="keyword">default</span> character set utf8 COLLATE utf8_genernal_ci;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>对新建的用户赋予权限，并刷新权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on mmall.* to <span class="string">'username'</span>@<span class="string">'localhost'</span> identified by <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure><p>再导入 <code>sql</code> 文件创建表。这里需要先将 <code>sql</code> 文件上传到服务器上，然后使用 <code>source</code> 命令就可以创建表了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /developer/mmall.sql</span><br></pre></td></tr></table></figure><h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>首先，安装 <code>git</code> 环境需要的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder</span><br></pre></td></tr></table></figure><p>再下载 <code>git</code> 的压缩包到 <code>setup</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//www.kernel.org/pub/software/scm/git/git-2.11.1.tar.gz</span></span><br></pre></td></tr></table></figure><p>对刚才的包解压缩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf git-<span class="number">2.11</span>.1.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>然后进行编译，安装:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /developer/git-<span class="number">2.11</span>.1</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure><p>打开 <code>vim /etc/profile</code> 配置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin:/usr/local/git/bin</span><br></pre></td></tr></table></figure><p>执行 <code>source /etc/profile</code> 使之生效。可以使用 <code>git --version</code> 查看版本。</p><p>然后，添加用户名和邮箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourusername"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>另外，在 linux 和 windows 下换行符不同，这里配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>表示使 <code>git</code> 不要转换换行符。还需要配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath off</span><br></pre></td></tr></table></figure><p>表示防止中文乱码问题。然后，设置编码为 <code>utf-8</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui.encoding utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>创建密钥，默认即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>然后，执行下面的命令:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>如果出现 <code>Could not open a connection to your authentication agent.</code>，则执行 <code>eval</code>，再执行上面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent`</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>然后，使用下面的命令获取公钥：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将其复制到 <code>github</code> 的 <code>SSH keys</code> 中即可。</p><h2 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h2><p>在阿里云服务器中，需要配置规则，放行所需端口入方向规则。可以参考这篇文章：aquarius_wing：<a href="https://www.jianshu.com/p/087774e1cc22" target="_blank" rel="noopener">阿里云服务器上tomcat无法访问的问题</a></p><p>在 <code>CentOS7</code> 下默认使用 <code>firewall</code> 作为防火墙，使用 <code>iptables</code> 需要重新设置一下。在 <code>/etc/sysconfig</code> 目录下没有 <code>iptables</code> 文件，需要执行以下命令进行安装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iptables-services</span><br></pre></td></tr></table></figure><p>然后在 <code>iptables</code> 文件中配置端口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">:FORWARD ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">:OUTPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line">#ssh port </span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">#vsftpd</span><br><span class="line">-A INPUT -p TCP --dport <span class="number">61001</span>:<span class="number">62000</span> -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport <span class="number">61001</span>:<span class="number">62000</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p TCP --dport <span class="number">20</span> -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport <span class="number">20</span> -j ACCEPT</span><br><span class="line">-A INPUT -p TCP --dport <span class="number">21</span> -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport <span class="number">21</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">#nginx</span><br><span class="line">-A INPUT -p tcp -m tcp --dport <span class="number">80</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>保存退出后，执行以下命令启动防火墙:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart iptables.service</span><br></pre></td></tr></table></figure><p>然后，设置防火墙开机自启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable iptables.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;配置软件源&quot;&gt;&lt;a href=&quot;#配置软件源&quot; class=&quot;headerlink&quot; title=&quot;配置软件源&quot;&gt;&lt;/a&gt;配置软件源&lt;/h2&gt;&lt;p&gt;首先，需要进行源配置，可使用阿里云的源，可查看：&lt;a href=&quot;https://opsx.alibaba.com/mirror&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; https://opsx.alibaba.com/mirror&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、备份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、下载新的CentOS-Base.repo 到/etc/yum.repos.d/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget -O /etc/yum.repos.d/CentOS-Base.repo http:&lt;span class=&quot;comment&quot;&gt;//mirrors.aliyun.com/repo/Centos-7.repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、生成缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum makecache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之支付模块</title>
    <link href="https://blog.timberliu.com/2019/01/28/mmallv1.0%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.timberliu.com/2019/01/28/mmallv1.0支付模块/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="扫码支付支付流程"><a href="#扫码支付支付流程" class="headerlink" title="扫码支付支付流程"></a>扫码支付支付流程</h2><p><img src="http://media.timberliu.com/image/2019/1/29/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.png" width="80%"></p><p>在商家发出预下单请求后，支付宝后台会返回二维码信息给用户，然后用户通过支付宝钱包扫码，之后支付宝后台会把支付结果信息返回给商家后台。<a id="more"></a></p><h2 id="扫码支付调用流程"><a href="#扫码支付调用流程" class="headerlink" title="扫码支付调用流程"></a>扫码支付调用流程</h2><p><img src="http://media.timberliu.com/image/2019/1/29/%E6%94%AF%E4%BB%98%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" width="60%"></p><p>主要的思路如下：</p><ol><li>商家系统调用支付宝接口发起预下单请求，获得二维码图片地址；然后通过二维码串生成二维码图片，上传至图片服务器，并将 <code>url</code> 返回给前台；</li><li>发起轮询获得支付结果：通过支付时传入的商品订单号查询支付结果；</li><li>还可以通过异步通知获得支付结果，注意：一定要对异步通知进行验签，确保通知是支付宝发出的。另外，还要更新数据库中的信息</li></ol><h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><p><strong style="color:#ff6600">预下单请求</strong></p><p>首先，创建扫码支付请求 <code>builder</code>，并设置标题、总金额、交易号、回调地址、商品列表集合等请求参数。在创建商品时，可以使用 <code>newInstance</code>方法传入商品 <code>id</code>、名称、单价、数量等信息创建，然后添加到商品列表集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodsDetail&gt; goodsDetailList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo, userId);</span><br><span class="line"><span class="keyword">for</span> (OrderItem orderItem : orderItemList) &#123;</span><br><span class="line">    <span class="comment">// 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail</span></span><br><span class="line">    GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(),</span><br><span class="line">            BigDecimalUtil.add(orderItem.getCurrentUnitPrice().doubleValue(), <span class="number">100.0</span>).longValue(), orderItem.getQuantity());</span><br><span class="line">    <span class="comment">// 创建好一个商品后添加至商品明细列表</span></span><br><span class="line">    goodsDetailList.add(goods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlipayTradePrecreateRequestBuilder builder = <span class="keyword">new</span> AlipayTradePrecreateRequestBuilder()</span><br><span class="line">    .setSubject(subject).setTotalAmount(totalAmount)</span><br><span class="line">    .setOutTradeNo(outTradeNo).setUndiscountableAmount(undiscountableAmount)</span><br><span class="line">    .setSellerId(sellerId).setBody(body).setOperatorId(operatorId)</span><br><span class="line">    .setStoreId(storeId).setExtendParams(extendParams).setTimeoutExpress(timeoutExpress)</span><br><span class="line">    .setNotifyUrl(PropertiesUtil.getProperty(<span class="string">"alipay.callback.url"</span>))   <span class="comment">//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</span></span><br><span class="line">    .setGoodsDetailList(goodsDetailList);</span><br></pre></td></tr></table></figure><p>然后，使用 <code>Config.init()</code> 加载 <code>zbinfo</code> 配置文件，其中配置了支付宝的支付宝网关名、<code>pid</code>、<code>appid</code>、<code>RSA</code>私钥、公钥等。注意：加载文件一定要在创建 <code>AlipayTradeService</code> 对象之前调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configs.init(<span class="string">"zfbinfo.properties"</span>);</span><br></pre></td></tr></table></figure><p>再然后，创建 <code>AlipayTradeService</code> 单例或静态对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlipayTradeService tradeService = <span class="keyword">new</span> AlipayTradeServiceImpl.ClientBuilder().build();</span><br></pre></td></tr></table></figure><p>最后，使用 <code>tradePrecreate()</code> 方法发起预下单请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">同步订单的二维码串，并生成二维码</strong></p><p>首先，判断上一步中 <code>result</code> 的订单状态，如果为 <code>SUCCESS</code>，则表示预下单成功；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (result.getTradeStatus()) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUCCESS:</span><br><span class="line">        log.info(<span class="string">"支付宝预下单成功: )"</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，可以使用 <code>result.getResponse()</code> 得到响应对象。再使用 <code>response.getOutTradeNo()</code> 得到订单号，并创建上传到服务器的存放路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AlipayTradePrecreateResponse response = result.getResponse();</span><br><span class="line">···</span><br><span class="line">String qrPath = String.format(path + <span class="string">"/qr-%s.png"</span>, response.getOutTradeNo());</span><br></pre></td></tr></table></figure><p>然后，使用 <code>ZxingUtils.getQRCodeImge()</code> 方法将 <code>getQrCode()</code> 得到的二维码串转换为宽度为 <code>256</code> 的图片存放在 <code>qrPath</code> 下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZxingUtils.getQRCodeImge(response.getQrCode(), <span class="number">256</span>, qrPath);</span><br></pre></td></tr></table></figure><p>最后，使用 <code>FtpUtil.uploadFile</code> 方法将图片上传到图片服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File targetFile = <span class="keyword">new</span> File(qrPath);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FtpUtil.uploadFile(Lists.newArrayList(targetFile));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">"上传二维码失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">轮询查看交易的状态</strong></p><p>这里，主要是到数据库中查询订单信息，判断订单状态即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Order order = orderMapper.selectByUserIdAndOrderNo(userId, orderNo);</span><br><span class="line">···</span><br><span class="line"><span class="keyword">if</span>(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.createBySuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">异步通知结果</strong></p><p>首先，在收到异步通知时，参数以 <code>Map&lt;String, String[]&gt;</code> 的形式封装在 <code>request</code> 中，需要将其转换为 <code>Map&lt;String, String&gt;</code> 形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; params = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String[]&gt; requestParams = request.getParameterMap();</span><br><span class="line"><span class="keyword">for</span>(Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">    String name = (String) iter.next();</span><br><span class="line">    String[] values = (String[]) requestParams.get(name);</span><br><span class="line">    String valueStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        valueStr = (i == values.length - <span class="number">1</span>) ? valueStr + values[i] : valueStr + values[i] + <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    params.put(name, valueStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，对于返回的结果，除了 <code>sign</code>、<code>sign_type</code> 两个参数，其他都需要验签。在源码实现中，已经移除了 <code>sign</code> 参数，只需要移除 <code>sign_type</code> 即可。另外对剩余参数进行 <code>url_encode</code>，并进行字段排序组成待验签字符串，还有将 <code>sign</code> 使用 <code>base64</code> 解码为字节码串也都已实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params.remove(<span class="string">"sign_type"</span>);</span><br></pre></td></tr></table></figure><p>然后，使用 <code>RSA</code> 验签方法，通过签名字符串、支付宝公钥、字符编码、<code>signType</code> 验证签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> alipayRSACheckedV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), <span class="string">"utf-8"</span>, Configs.getSignType());</span><br></pre></td></tr></table></figure><p>然后，在服务层中，需要更改订单的支付时间与支付状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)) &#123;</span><br><span class="line">    order.setPaymentTime(DateTimeUtil.strToDate(params.get(<span class="string">"gmt_payment"</span>)));</span><br><span class="line">    order.setStatus(Const.OrderStatusEnum.PAID.getCode());</span><br><span class="line">    orderMapper.updateByPrimaryKeySelective(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再将支付信息添加到支付信息表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PayInfo payInfo = <span class="keyword">new</span> PayInfo();</span><br><span class="line">payInfo.setUserId(order.getUserId());</span><br><span class="line">payInfo.setOrderNo(orderNo);</span><br><span class="line">payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode());</span><br><span class="line">payInfo.setPlatformNumber(tradeNo);</span><br><span class="line">payInfo.setPlatformStatus(tradeStatus);</span><br><span class="line"></span><br><span class="line">payInfoMapper.insert(payInfo);</span><br></pre></td></tr></table></figure><h2 id="NatAPP-内网穿透"><a href="#NatAPP-内网穿透" class="headerlink" title="NatAPP 内网穿透"></a>NatAPP 内网穿透</h2><p>在支付时，支付宝异步回调需要让回调地址可以被外网访问，可以使用 <code>natapp</code> 进行内网穿透。这里参考文档 <a href="https://natapp.cn/article/natapp_newbie" target="_blank" rel="noopener">NATAPP1分钟快速新手图文教程</a> 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;扫码支付支付流程&quot;&gt;&lt;a href=&quot;#扫码支付支付流程&quot; class=&quot;headerlink&quot; title=&quot;扫码支付支付流程&quot;&gt;&lt;/a&gt;扫码支付支付流程&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;http://media.timberliu.com/image/2019/1/29/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.png&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;在商家发出预下单请求后，支付宝后台会返回二维码信息给用户，然后用户通过支付宝钱包扫码，之后支付宝后台会把支付结果信息返回给商家后台。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之购物车、收货地址、订单模块</title>
    <link href="https://blog.timberliu.com/2019/01/28/mmallv1.0%E8%B4%AD%E7%89%A9%E8%BD%A6%E3%80%81%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E3%80%81%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.timberliu.com/2019/01/28/mmallv1.0购物车、收货地址、订单模块/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="购物车模块"><a href="#购物车模块" class="headerlink" title="购物车模块"></a>购物车模块</h2><p>1、购物车模块中购物车的设计，购物车对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 商品集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CartProductVo&gt; cartProductVoList;</span><br><span class="line">    <span class="comment">// 购物车总价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal cartTotalPrice;</span><br><span class="line">    <span class="comment">// 是否全被选中</span></span><br><span class="line">    <span class="keyword">private</span> Boolean allChecked;</span><br><span class="line">    <span class="comment">// 图片域名</span></span><br><span class="line">    <span class="keyword">private</span> String imageHost;</span><br><span class="line">    <span class="comment">// getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中，购物车每一件商品 <code>CartProductVo</code> 对象设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartProductVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> Integer productId;</span><br><span class="line">    <span class="comment">// 商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> String productSubtitle;</span><br><span class="line">    <span class="keyword">private</span> String productMainImage;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer productStatus;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal productTotalPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer productStock;</span><br><span class="line">    <span class="comment">// 此商品是否勾选</span></span><br><span class="line">    <span class="keyword">private</span> Integer productChecked;</span><br><span class="line">    <span class="comment">// 限制数量的一个返回结果</span></span><br><span class="line">    <span class="keyword">private</span> String limitQuantity;</span><br><span class="line">    <span class="comment">// getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、封装一个高可用的购物车核心方法：获取购物车中所有商品信息 <code>getCartVoLimit()</code> 方法。设计思想如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CartVo <span class="title">getCartVoLimit</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">    CartVo cartVo = <span class="keyword">new</span> CartVo();</span><br><span class="line">    <span class="comment">// 根据用户 Id 查询购物车信息</span></span><br><span class="line">    List&lt;Cart&gt; cartList = cartMapper.selectCartByUserId(userId);</span><br><span class="line"></span><br><span class="line">    List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList();</span><br><span class="line">    BigDecimal cartTotalPrice = <span class="keyword">new</span> BigDecimal(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(cartList)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Cart cart : cartList) &#123;</span><br><span class="line">            CartProductVo cartProductVo = <span class="keyword">new</span> CartProductVo();</span><br><span class="line">            cartProductVo.setId(cart.getId());</span><br><span class="line">            cartProductVo.setUserId(cart.getUserId());</span><br><span class="line">            cartProductVo.setProductId(cart.getProductId());</span><br><span class="line"></span><br><span class="line">            Product product = productMapper.selectByPrimaryKey(cart.getProductId());</span><br><span class="line">            <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cartProductVo.setProductMainImage(product.getMainImage());</span><br><span class="line">                cartProductVo.setProductName(product.getName());</span><br><span class="line">                cartProductVo.setProductSubtitle(product.getSubtitle());</span><br><span class="line">                cartProductVo.setProductStatus(product.getStatus());</span><br><span class="line">                cartProductVo.setPrice(product.getPrice());</span><br><span class="line">                cartProductVo.setProductStock(product.getStock());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> buyLimitCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (product.getStock() &gt;= cart.getQuantity()) &#123;</span><br><span class="line">                    <span class="comment">// 库存足够</span></span><br><span class="line">                    buyLimitCount = cart.getQuantity();</span><br><span class="line">                    cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_SECCESS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 库存不足</span></span><br><span class="line">                    buyLimitCount = product.getStock();</span><br><span class="line">                    cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_FAIL);</span><br><span class="line">                    <span class="comment">// 购物车中更新为有效的库存</span></span><br><span class="line">                    Cart cartForQuantity = <span class="keyword">new</span> Cart();</span><br><span class="line">                    cartForQuantity.setId(cart.getId());</span><br><span class="line">                    cartForQuantity.setQuantity(buyLimitCount);</span><br><span class="line">                    cartMapper.updateByPrimaryKeySelective(cartForQuantity);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cartProductVo.setQuantity(buyLimitCount);</span><br><span class="line">                <span class="comment">// 计算单件商品总价</span></span><br><span class="line">                cartProductVo.setProductTotalPrice(BigDecimalUtil.mul(product.getPrice().doubleValue(), cartProductVo.getQuantity().doubleValue()));</span><br><span class="line">                cartProductVo.setProductChecked(cart.getChecked());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果商品被选中，则相加到购物中总价中</span></span><br><span class="line">            <span class="keyword">if</span> (cart.getChecked() == Const.Cart.CHECKED) &#123;</span><br><span class="line">                cartTotalPrice = BigDecimalUtil.add(cartTotalPrice.doubleValue(), cartProductVo.getProductTotalPrice().doubleValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cartProductVoList.add(cartProductVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cartVo.setCartProductVoList(cartProductVoList);</span><br><span class="line">    cartVo.setAllChecked(getAllCheckedStatus(userId));</span><br><span class="line">    cartVo.setCartTotalPrice(cartTotalPrice);</span><br><span class="line">    cartVo.setImageHost(PropertiesUtil.getProperty(<span class="string">"ftp.server.http.prefix"</span>));</span><br><span class="line">    <span class="keyword">return</span> cartVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、对于浮点型在商业运算中丢失精度问题，可以使用 <code>BigDecimal</code> 对象，将参数转为 <code>String</code> 类型进行计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="comment">// 保留两位小数，使用四舍五入模式</span></span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2, <span class="number">2</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="收货地址模块"><a href="#收货地址模块" class="headerlink" title="收货地址模块"></a>收货地址模块</h2><p>1、<code>Mybatis</code> 自动生成主键、配置和使用</p><p>在添加收货地址时，可以自动生成主键，这里指定为 <code>id</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"insert"</span> parameterType=<span class="string">"com.mmall.pojo.Shipping"</span> useGeneratedKeys=<span class="string">"true"</span> keyProperty=<span class="string">"id"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>然后，就可以使用 <code>shipping.getId()</code> 得到新添加收货地址后的 <code>id</code>。</p><p>2、在更新收货地址信息时，为防止横向越权，在 <code>ShippingMapper.xml</code> 文件中，根据用户 <code>Id</code> 和 <code>ShippingId</code> 进行更新：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateByShipping"</span> parameterType=<span class="string">"com.mmall.pojo.Shipping"</span>&gt;</span><br><span class="line">    update mmall_shipping</span><br><span class="line">    set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;,</span><br><span class="line">      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      update_time = now()</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">          and user_id = #&#123;userId,jdbcType=INTEGER&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><h2 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h2><p>1、创建订单时需要将订单详情插入到数据库中，可以使用 MyBatis 的批量插入。使用 foreach 标签，集合中每一个对象使用括号括起来，用逗号进行分隔。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"batchInsert"</span> parameterType=<span class="string">"list"</span>&gt;</span><br><span class="line">    <span class="function">insert into <span class="title">mmall_order_item</span> <span class="params">(id, user_id, order_no,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  product_id, product_name, product_image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  current_unit_price, quantity, total_price,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  create_time, update_time)</span></span></span><br><span class="line"><span class="function">    values</span></span><br><span class="line"><span class="function">    &lt;foreach collection</span>=<span class="string">"list"</span> index=<span class="string">"index"</span> item=<span class="string">"item"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">      (</span><br><span class="line">      #&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.userId,jdbcType=INTEGER&#125;, #&#123;item.orderNo,jdbcType=BIGINT&#125;,</span><br><span class="line">      #&#123;item.productId,jdbcType=INTEGER&#125;, #&#123;item.productName,jdbcType=VARCHAR&#125;, #&#123;item.productImage,jdbcType=VARCHAR&#125;,</span><br><span class="line">      #&#123;item.currentUnitPrice,jdbcType=DECIMAL&#125;, #&#123;item.quantity,jdbcType=INTEGER&#125;, #&#123;item.totalPrice,jdbcType=DECIMAL&#125;,</span><br><span class="line">      now(), now()</span><br><span class="line">      )</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>另外，需要注意的是：Mybatis 批量插入时默认的最大数据量是 1 M，如果超过则会报 <code>PacketTooBigException</code> 异常。可以通过 mysql 安装目录下的 my.ini 文件中，mysqld 段的 <code>max_allowed_packet = 1 M</code> 进行调整；</p><p>2、对于产品状态、订单状态、支付平台、支付方式，都使用枚举类表示。如何设计一个实用安全扩展性强大的枚举类？例如，订单状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatusEnum &#123;</span><br><span class="line">    CANCELED(<span class="number">0</span>, <span class="string">"已取消"</span>),</span><br><span class="line">    NO_PAY(<span class="number">10</span>, <span class="string">"未支付"</span>),</span><br><span class="line">    PAID(<span class="number">20</span>, <span class="string">"已支付"</span>),</span><br><span class="line">    SHIPPED(<span class="number">40</span>, <span class="string">"已发货"</span>),</span><br><span class="line">    ORDER_SUCCESS(<span class="number">50</span>, <span class="string">"订单完成"</span>),</span><br><span class="line">    ORDER_CLOSED(<span class="number">60</span>, <span class="string">"订单关闭"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    OrderStatusEnum(<span class="keyword">int</span> code, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrderStatusEnum <span class="title">codeOf</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OrderStatusEnum orderStatusEnum : values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(orderStatusEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> orderStatusEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到对应的枚举"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、订单号的生成规则，必须唯一严谨。由于这里用户量不多，并发量小，可使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">generateOrderNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> currentTime + <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用当前时间戳并加上一个 100 以内的随机数生成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;购物车模块&quot;&gt;&lt;a href=&quot;#购物车模块&quot; class=&quot;headerlink&quot; title=&quot;购物车模块&quot;&gt;&lt;/a&gt;购物车模块&lt;/h2&gt;&lt;p&gt;1、购物车模块中购物车的设计，购物车对象如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CartVo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 商品集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;CartProductVo&amp;gt; cartProductVoList;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 购物车总价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; BigDecimal cartTotalPrice;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否全被选中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Boolean allChecked;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 图片域名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String imageHost;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// getter/setter 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之用户、分类、商品模块</title>
    <link href="https://blog.timberliu.com/2019/01/27/mmallv1.0%E7%94%A8%E6%88%B7%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.timberliu.com/2019/01/27/mmallv1.0用户、分类、商品模块/</id>
    <published>2019-01-26T16:00:00.000Z</published>
    <updated>2019-01-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>使用 <code>IDEA</code> 创建项目，并上传到 <code>Github</code> 上。</p><p>参考文章：<a href="https://blog.csdn.net/stevennest/article/details/77877074" target="_blank" rel="noopener">stevennest：IDEA创建项目及上传到github</a></p><h2 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h2><p>在用户模块中，主要包括以下几个功能：</p><p><img src="http://media.timberliu.com/image/2019/1/27/mmall-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97.jpg" width="80%"><a id="more"></a></p><p>需要注意的问题有以下几点：</p><p>1、在忘记密码-检查问题时，使用 <code>UUID</code> 生成唯一标识，存储在缓存中，并将这个标识传递给前端；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String forgetToken = UUID.randomUUID().toString();</span><br><span class="line">TokenCache.setKey(TokenCache.TOKEN_PREFIX + username, forgetToken);</span><br></pre></td></tr></table></figure><p>在忘记密码-重置密码时，前端需要携带 <code>token</code>，服务器端需要判断 <code>token</code> 是否过期，并与缓存中的 <code>token</code> 进行对比，以防止横向越权访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX + username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StringUtils.equals(forgetToken, token)) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在后台管理模块中，为防止纵向越权，在数据表设计时添加了 <code>role</code> 属性，在登录后台，或修改其数据时，都需要检验该用户的 <code>role</code>。</p><p>3、对于密码的存储，使用 <code>MD5</code> 进行加密，并且增加了 <code>Salt</code> 值。</p><p>4、在忘记密码-检查问题时，生成的 <code>token</code> 使用 <code>Guava</code> 进行缓存，以 <code>key/value</code> 形式进行存储。缓存使用主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; localCache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(<span class="number">1000</span>)</span><br><span class="line">            <span class="comment">// 设置缓存最大值为 10000，如果超过这个值，会使用 LRU 算法进行清除</span></span><br><span class="line">            .maximumSize(<span class="number">10000</span>)</span><br><span class="line">            <span class="comment">// 过期时间，及单位</span></span><br><span class="line">            .expireAfterAccess(<span class="number">12</span>, TimeUnit.HOURS)</span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>然后，可通过 <code>set/get</code> 方法设置、并获取值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    localCache.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    value = localCache.get(key);</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、使用 <code>ServerResponse</code> 高复用响应式对象。其中三个属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">private</span> String msg;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br></pre></td></tr></table></figure><p>使用 <code>enum</code> 枚举类来表示不同的响应码。主要有四种响应码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ResponseCode &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">0</span>, <span class="string">"SUCCESS"</span>),</span><br><span class="line">    ERROR(<span class="number">1</span>, <span class="string">"ERROR"</span>),</span><br><span class="line">    NEED_LOGIN(<span class="number">10</span>, <span class="string">"NEED_LOGIN"</span>),</span><br><span class="line">    ILLEGAL_ARGUMENT(<span class="number">2</span>, <span class="string">"ILLEGAL_ARGUMENT"</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，其中使用了 <code>@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)</code> 标记 <code>ServerResponse</code>，表示在序列化对象时，忽略为空的属性，使用了 <code>@JsonIgnore</code> 标记 <code>isSuccess</code> 方法，表示在序列化时，忽略此方法。</p><p>6、用户登录信息使用 <code>Session</code> 进行存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(Const.CURRENT_USER, response.getData());</span><br></pre></td></tr></table></figure><p>7、使用 <code>StringUtils</code>、<code>CollectionUtils</code> 等工具类简化操作。</p><p>8、使用 <code>slf4j</code> 的 <code>LoggerFactory</code> 生成 <code>logger</code> 对象，打印日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TokenCache.class);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"···"</span>);</span><br></pre></td></tr></table></figure><h2 id="分类管理模块"><a href="#分类管理模块" class="headerlink" title="分类管理模块"></a>分类管理模块</h2><p>1、在分类管理中，需要用到无限层级的树状数据结构显示分类。可以在设计数据表时添加 <code>parentId</code> 属性，表示其父结点的 <code>Id</code>。另外，如果 <code>parentId</code> 为 <code>0</code>，表示当前结点为根结点分类。</p><p>2、在查询子结点分类时，需要用到递归算法。首先，根据前台传来的 <code>id</code> 判断该结点是否存在，如果存在，则添加到 <code>categorySet</code> 中。然后调用 <code>findChildCategory</code> 方法查询子节点分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Category category = categoryMapper.selectByPrimaryKey(categoryId);</span><br><span class="line"><span class="keyword">if</span>(category != <span class="keyword">null</span>) &#123;</span><br><span class="line">    categorySet.add(category);</span><br><span class="line">&#125;</span><br><span class="line">findChildCategory(categorySet, categoryId);</span><br></pre></td></tr></table></figure><p>其中，会根据 <code>parentId</code> 查询与子分类平级的结点得到一个 <code>List</code> 集合。然后遍历此集合，将子分类结点添加到 <code>categroySet</code>，再递归查询子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findChildCategory</span><span class="params">(Set&lt;Category&gt; categorySet, Integer parentId)</span> </span>&#123;</span><br><span class="line">    List&lt;Category&gt; categoryList = categoryMapper.getChildrenCategoryByParentId(parentId);</span><br><span class="line">    <span class="keyword">for</span> (Category category: categoryList) &#123;</span><br><span class="line">        categorySet.add(category);</span><br><span class="line">        findChildCategory(categorySet, category.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，创建 <code>List</code> 集合，遍历 <code>categorySet</code>，将 <code>category</code> 的 <code>id</code> 添加到 <code>categoryIdList</code> 中，返回给前端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; categoryIdList = Lists.newArrayList();</span><br><span class="line"><span class="keyword">if</span>(categoryId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Category categoryItem: categorySet) &#123;</span><br><span class="line">        categoryIdList.add(categoryItem.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在存储 <code>category</code> 时，为了防止对象重复，这里使用 <code>Set</code> 进行排重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Category&gt; categorySet = Sets.newHashSet();</span><br></pre></td></tr></table></figure><p>另外，<code>Set</code> 中存放的对象 <code>Category</code> 要判断是否相等，这里针对 <code>id</code>，重写了 <code>hashCode</code> 和 <code>equals</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Category)) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    Category category = (Category) o;</span><br><span class="line">    <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.equals(category.id) : category.id == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="商品管理模块"><a href="#商品管理模块" class="headerlink" title="商品管理模块"></a>商品管理模块</h2><p>1、<code>SpringMVC</code> 文件上传使用 <code>FTPClient</code>。在上传文件之前，首先需要连接服务并登陆。另外，还需要设置远程目录、缓存大小、编码格式等。最后，使用 <code>storeFile</code> 方法传入文件名和文件输入流，上传文件。需要注意的是，上传后要关闭输入流和 <code>FtpClient</code>。主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(String remotePath, List&lt;File&gt; fileList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> uploaded = <span class="keyword">false</span>;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = connectServer(ip, port, user, password); <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(isSuccess) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ftpClient.changeWorkingDirectory(remotePath); <span class="comment">// 远程目录</span></span><br><span class="line">            ftpClient.setBufferSize(<span class="number">1024</span>); <span class="comment">// 缓存</span></span><br><span class="line">            ftpClient.setControlEncoding(<span class="string">"UTF-8"</span>); <span class="comment">// 编码格式            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 文件类型</span></span><br><span class="line">            ftpClient.enterLocalPassiveMode();</span><br><span class="line">            <span class="keyword">for</span> (File fileItem : fileList) &#123;</span><br><span class="line">                fis = <span class="keyword">new</span> FileInputStream(fileItem);</span><br><span class="line">                ftpClient.storeFile(fileItem.getName(), fis);</span><br><span class="line">            &#125;</span><br><span class="line">            uploaded = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"上传文件异常"</span>, e);</span><br><span class="line">            uploaded = <span class="keyword">false</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>) &#123; fis.close(); &#125;</span><br><span class="line">            ftpClient.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uploaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">connectServer</span><span class="params">(String ip, <span class="keyword">int</span> port, String user, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">    ftpClient = <span class="keyword">new</span> FTPClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ftpClient.connect(ip, port); <span class="comment">// 连接服务器</span></span><br><span class="line">        isSuccess = ftpClient.login(user, password); <span class="comment">// 登录</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"连接 FTP 服务器失败"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用流来读取 <code>Properties</code> 配置文件，这里使用 <code>java.util.Properties</code> 类的 <code>load</code> 方法来加载 <code>mmall.properties</code> 文件，再使用 <code>getProperty</code> 方法得到配置。主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用静态块来初始化并加载配置文件</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    String fileName = <span class="string">"mmall.properties"</span>;</span><br><span class="line">    props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        props.load(<span class="keyword">new</span> InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"配置文件读取异常"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后，可以使用 getProperty 获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span></span>&#123;</span><br><span class="line">    String value = props.getProperty(key.trim());</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(value))&#123;</span><br><span class="line">        value = defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用 <code>joda-time</code> 处理时间。主要有两种形式：分别为将 <code>String</code> 转为 <code>Date</code> 和将 <code>Date</code> 转为 <code>String</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 String 转为 Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">strToDate</span><span class="params">(String str, String formatStr)</span> </span>&#123;</span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr);</span><br><span class="line">    DateTime dateTime = dateTimeFormatter.parseDateTime(str);</span><br><span class="line">    <span class="keyword">return</span> dateTime.toDate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 Date 转为 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStr</span><span class="params">(Date date, String formatStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(date == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    DateTime dateTime = <span class="keyword">new</span> DateTime(date);</span><br><span class="line">    <span class="keyword">return</span> dateTime.toString(formatStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、对于 <code>dao</code> 层生成的 <code>pojo</code>，在 <code>service</code> 和 <code>controller</code> 层使用时，可能由于其他业务逻辑，已不能满足需求，这时就可以使用 <code>BO</code>（<code>business Object</code>）、<code>VO</code>（<code>view Object</code>） 对象。它是在原有 <code>pojo</code> 对象的基础上另外添加一些属性以满足业务的需求。</p><p>项目中，由于业务逻辑还不是特别复杂，所以使用的是简化版本，即 <code>VO</code>(<code>value Object</code>) 对象。</p><p>5、使用 <code>MyBatis-PageHelper</code> 分页及动态排序。一般，都需要先设置页数和每页数量。然后创建 <code>PageInfo</code> 对象，设置 <code>List</code> 集合对象。最后将 <code>PageInfo</code> 对象返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line"></span><br><span class="line">PageInfo pageInfo = <span class="keyword">new</span> PageInfo(productList);</span><br><span class="line">pageInfo.setList(productListVoList);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;项目搭建&quot;&gt;&lt;a href=&quot;#项目搭建&quot; class=&quot;headerlink&quot; title=&quot;项目搭建&quot;&gt;&lt;/a&gt;项目搭建&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;IDEA&lt;/code&gt; 创建项目，并上传到 &lt;code&gt;Github&lt;/code&gt; 上。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/stevennest/article/details/77877074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stevennest：IDEA创建项目及上传到github&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;用户模块&quot;&gt;&lt;a href=&quot;#用户模块&quot; class=&quot;headerlink&quot; title=&quot;用户模块&quot;&gt;&lt;/a&gt;用户模块&lt;/h2&gt;&lt;p&gt;在用户模块中，主要包括以下几个功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://media.timberliu.com/image/2019/1/27/mmall-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(6)-虚拟内存和文件分配</title>
    <link href="https://blog.timberliu.com/2019/01/11/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>https://blog.timberliu.com/2019/01/11/虚拟内存/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虚拟内存在逻辑上实现了对内存容量的扩充，既满足了用户的需要，又改善了系统性能。这篇文章总结了虚拟内存的基本概念、实现方式以及几种页面置换算法。最后是几种文件分配方式。</p></blockquote><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>局部性原理：程序执行时，在一较短时间内，程序的执行仅仅局限于某一部分，其访问的存储空间也局限于某个区域。主要表现在两个方面：</p><ul><li>时间局限性：如果某条指令被执行，不久以后该指令可能再次执行；如果某些数据被访问，不久以后该数据可能再次被访问；</li><li>空间局限性：如果某段存储单元被访问，其附近的存储单元可能也会被访问。<a id="more"></a>  </li></ul><p>基于局部性原理，在加载程序时，只需将当前执行所需的部分页面或段装入内存。程序执行时，如果要访问的页面或段不在内存中，则发生缺页中断，于是 <code>OS</code> 利用请求调页功能将相应的页面或段调入内存，继续执行。如果内存已满，则利用置换功能，将内存中暂时不用的页面或段调出到外存，再将所需的页面或段调入内存，使程序继续执行。</p><p>虚拟内存是指具有请求调入功能和置换功能，从逻辑上对内存容量进行扩充的一种内存系统。实现方式有三种：请求分页存储管理方式、请求段式存储管理方式和请求段页式存储管理方式。</p><h2 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h2><p>请求分页存储管理是在分页存储管理的基础上，增加请求调页和页面置换功能。它允许用户程序只装入部分页面就启动程序运行。在运行中如果发现所需页面不在内存中，则发出缺页中断，<code>OS</code> 就会将外存中相应的页面调入内存使其继续运行。每次调入和换出的基本单位是长度固定的页面。</p><p>请求分页存储管理中的地址转换与分页式相比，在页表项中添加了一些标志位：</p><ul><li>状态位：表示该页是否已调入内存。</li><li>修改位：表示该页在调入内存后是否被修改过。在置换该页时，判断是否要把它写回外存。</li><li>访问位：表示该页在一段时间内被访问的次数。供置换算法在选择换出页面时参考。</li><li>外存地址：表示该页在外存上的地址。</li></ul><p>请求分页存储管理系统中，在进行地址转换时，首先在快表中查找要访问的页。如果找到，便修改页表项中的访问位，供置换算法选择换出页面时参考。如果是写指令，还需要将修改位置为 <code>1</code>，表示该页在调入内存后被修改过。然后利用页表项中的物理块号和页内地址，得到物理地址。</p><p>如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位来判断该页是否调入内存。如果该页已调入，则应将该页的页表项写入快表；如果该页没有调入内存，则应该产生缺页中断，操作系统从外存中找到缺失的页面。</p><p>如果内存已满，则利用置换算法选择一页换出，如果该页被修改过，则需要将该页写回到外存中。最后将缺页从外存换入到内存中，继续运行程序。</p><h2 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h2><p><strong>最优算法（Optimal）</strong></p><p>置换在未来最长时间内不再被访问的页面。这只是一种理想情况，只能用来评价其他置换算法的性能。</p><p><strong>先进先出算法（FIFO）</strong></p><p>选择进入内存时间最长的页面进行置换。在实现时维护一个所有已调入内存的页面的链表，按照进入内存的先后次序排序，链首最早，链尾最进。在出现缺页时，选择链首的页面进行置换，将新页面添加到链尾。</p><p>这种算法实现简单。但调出的页面可能会经常访问，性能较差，一般和其他算法结合使用。</p><p><strong>最近最久未使用算法（LRU）</strong></p><p>选择最长时间没有使用的页面进行置换。它依据的是如果某个页面长时间没有被访问，则在将来一段时间可能还不会访问。</p><p>在实现时维护一个按最近一次访问时间排序的链表，链表首是刚使用过的页面，链表尾是最久未使用的页面。在访问页面时，找到相应的页面，将其移动到链表首；在出现缺页时，删除链表尾节点，将新页面添加到链表首。</p><p>这种算法是最优算法的一种近似，但实现起来仍然比较复杂。</p><p><strong>时钟算法（Clock）</strong></p><p>也称为最近未使用算法（<code>NRU</code>）。在实现时，在页表项中增加一个访问位，表示过去一段时间内是否被访问过，初始时都置为 <code>0</code>，另外将页面组织成环形链表，添加一条指针指向最先被调入内存的页面。</p><p>当访问某页面时，将其访问项置为 <code>1</code>。在出现缺页异常时，从指针处开始查找，如果页面没有被访问过，即访问项为 <code>0</code>，则进行置换；如果被访问过，则将访问项置为 <code>0</code>，暂不换出，再将指针指向下一个页面继续查找，直到找到可以置换的页面。</p><p><strong>最少使用算法（LFU）</strong></p><p>置换最近一段时间访问次数最少的页面。在实现时，对每个页面设置一个访问计数，在访问页面时，对访问计数加 <code>1</code>；在出现缺页异常时，置换访问计数最少的页面。</p><h2 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h2><p>文件分配实际上是如何表示分配给一个文件的数据块的位置和顺序。主要有以下几种分配方式：连续分配、链式分配和索引分配。</p><p><strong>连续分配</strong></p><p>使用连续的若干个数据块来存储文件。它在文件控制块中记录起始第一个数据块的位置和长度。</p><p>采用连续分配方式，读取文件的顺序访问和随机访问效率较高，但是剩余的碎片难以利用，另外文件长度增长也比较复杂。</p><p><strong>链式分配</strong></p><p>将文件以数据块链表的形式存储。文件控制块中包含了第一个数据块和最后一个数据块的指针。</p><p>链式分配方式在创建、增大、缩小文件时比较容易，而且没有碎片，但是不能实现真正的随机访问，另外一个数据块被破坏，后面的数据块就都丢了。</p><p><strong>索引分配</strong></p><p>为每个文件创建一个索引数据块，索引数据块中存储了指向文件数据块的指针列表，文件控制块中包含了指向索引数据块的指针。</p><p>这种实现在创建文件、增大、缩小文件时比较容易，也没有碎片，也支持随机访问。但是在文件很小时，存储索引开销相对较大，在文件很大时，需要增加额外的索引快。</p><p><strong>UFS（Unix File System）</strong></p><p>UFS 的多级索引分配：在文件控制块中，如果数据块小于 <code>10</code>，采用直接索引；如果大于 <code>10</code> 块，第 <code>11</code> 块开始采用一级间接索引，它先指向一个索引块，索引块中再指向实际的数据块。如果数据块大到一定程度，会采用二级间接索引，依次类推。</p><p>多级索引分配方式大大提高了文件大小的限制阈值，可以动态分配数据块，文件扩展很容易，对于小文件开销较小，对于大文件使用间接索引也比较合理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;虚拟内存在逻辑上实现了对内存容量的扩充，既满足了用户的需要，又改善了系统性能。这篇文章总结了虚拟内存的基本概念、实现方式以及几种页面置换算法。最后是几种文件分配方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;局部性原理：程序执行时，在一较短时间内，程序的执行仅仅局限于某一部分，其访问的存储空间也局限于某个区域。主要表现在两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间局限性：如果某条指令被执行，不久以后该指令可能再次执行；如果某些数据被访问，不久以后该数据可能再次被访问；&lt;/li&gt;
&lt;li&gt;空间局限性：如果某段存储单元被访问，其附近的存储单元可能也会被访问。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(5)-内存管理</title>
    <link href="https://blog.timberliu.com/2019/01/11/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://blog.timberliu.com/2019/01/11/内存分配/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。</p></blockquote><h2 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h2><p>在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。</p><p>动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。<a id="more"></a>  </p><h3 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h3><p>为实现动态分区分配，系统必须对空闲的内存进行管理，主要有两种方法：位图法和空闲区链表。</p><p><strong>位图法</strong></p><p>使用位图方法时，内存可能被划分为小到几个字或大到几千个字节的分配单元。每个分配单元对应位图中的一位，<code>0</code> 表示空闲，<code>1</code> 表示占用。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c362872002dc?w=1100&h=355&f=png&s=17765" width="80%"></p><p>位图的缺点是如果想要调入一个占 <code>k</code> 个分配单元的进程，必须搜索位图，找出有 <code>k</code> 个连续 <code>0</code> 的串。查找位图中指定长度的连续 <code>0</code> 串的操作很耗时。</p><p><strong>空闲区链表法</strong></p><p>链表法是维护一个已分配内存段和空闲内存段的链表。链表的结点包括一个进程，或两个进程间的一块空闲区。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628979c765?w=887&h=282&f=png&s=16628" width="80%"></p><h3 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h3><p>在将程序加载入内存时，需要按照一定的算法，从位图或空闲链表中选择分区分配给进程。</p><p><strong>首次适配(first fit)</strong></p><p>首次适配算法要求空闲区链表按照地址递增的顺序排序。在分配内存时，沿着链表进行搜索，直到找到一个足够大的分区，将其分为两部分，一部分供进程使用，一部分形成新的空闲区。</p><p>它的实现比较简单，但是低地址部分不断被划分，会留下许多小空闲分区。</p><p><strong>下次适配(next fit)</strong></p><p>下次适配算法和首次适配算法类似，只是不再像首次适配算法那样每次都从头开始，而是从上次找到的空闲分区的下一个空闲分区开始搜索。</p><p><strong>最佳适配(best fit)</strong></p><p>最佳适配算法要求将空闲分区按照其容量大小进行排序。在分配内存时，查找一个能满足要求、又是最小的的空闲分区，分配给进程。</p><p>这种算法的缺点是分区在每次分配后的剩余部分总是最小的，会留下许多难以利用的碎片。</p><p><strong>最差适配(worst fit)</strong></p><p>最差适配算法在分配内存时，总是选择一个最大的空闲分区，划分为两部分，一部分给进程使用，另一部分形成新的空闲分区。</p><p>最差适配算法使得剩下的空闲分区不至于产生太小的碎片；但是这样容易破坏大的空闲分区，后续难以找到大的分区。</p><p><strong>快速适配(quick fit)</strong></p><p>快速适配算法是将空闲分区按照其容量进行分类，为每一类相同容量的空闲分区单独维护一个链表。同时，设立一张管理索引表，表中每一项对应一种空闲分区类型。</p><p>快速适配算法的缺点是在进程被终止或换出释放分区时，有效地合并分区非常耗时。</p><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><p>在非连续分配时，根据所分配地址空间的基本单位不同，可将其分为分页存储管理、分段存储管理、段页式存储管理三种方式。</p><h3 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h3><p>在分页存储管理方式中，把用户程序的地址空间划分为若干个固定大小的页。典型的页面大小为 <code>1KB</code>。相应地，也将内存空闲分为若干个物理块，页和块大小相同，这样可以将用户程序的任一页放入任一物理快中实现非连续分配。</p><p>分页地址中的地址结构为：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628983ec51?w=561&h=149&f=png&s=5286" width="40%"></p><p>地址长度为 <code>32</code> 位，其中 <code>0~11</code> 位为页内地址，即每页的大小为 <code>4KB</code>；<code>12~31</code> 位为页号，最多允许有 <code>1M</code> 页。</p><p>系统为每一个进程建立了一张页表，它负责逻辑页号到物理块号之间的地址转换。每一个页面对应一个页表项，记录了相应页在内存中对应的物理块号。</p><p>在 <code>CPU</code> 中设置一个页表基址寄存器，存储着页表的起始地址和页表的长度。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628b5610bf?w=810&h=426&f=png&s=20679" width="60%"></p><p>在进行地址转换时，首先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问地址已超过进程的地址空间，产生越界中断。如果没有发生越界中断，则将页表始址与页号和页表项长度的乘积相加，得到该页表项在页表中的位置，于是可从中得到该页的物理块号，最后根据物理块号和页内地址便可得到物理地址。</p><p>分页式存储管理方式主要有两个缺点：</p><ul><li>性能问题：访问一个内存单元需要两次内存访问，第一次访问获取页表项，第二次访问才访问数据。（快表）</li><li>如果每页太小，页表可能会非常大，较难找到连续的大内存空间。（多级页表）</li></ul><h3 id="页表改进"><a href="#页表改进" class="headerlink" title="页表改进"></a>页表改进</h3><p><strong>快表</strong></p><p>为提高地址转换速度，可在地址转换机构中增加一个可并行查询的缓冲寄存器，称为快表。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c36289e63a6f?w=934&h=601&f=png&s=33581" width="70%"></p><p>在进行地址转换时，首先将页号与快表中的所有页号进行比较，如果其中有与此相匹配的页号，便可直接从快表中读出该页所对应的物理块号。如果在快表中没有对应的页表项，则还需要去访问内存中的页表，在找到物理块号后，得到要访问的物理地址。另外，还要将此页表项存入到快表中。如果快表已满，则需要找到一个合适的页表项，将其换出。</p><p><strong>两级页表或多级页表</strong></p><p>两级页表或多级页表的方法，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。同样，建立一张外层页表，每个页表项中记录了页表层面的物理块号。</p><p>在进行地址变换时，需要增加一个外层页表寄存器，用于存放外层页表的起始地址。利用外层页表始址和逻辑地址中的外层页号找到指定页表分页的始址，再利用外层页内地址找到指定的页表项，从中得到该页在内存的物理块号，最终得到物理地址。访问一次内存单元一共需要 <code>3</code> 次内存访问。</p><h3 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h3><p>在分段式存储管理方式中，进程的地址空间被划分为若干个段，例如主代码段、子模块代码段、堆栈段、初始化数据段、符号表等。每个段都从 <code>0</code> 开始编址，采用连续的地址空间，各段的长度也并不相等。</p><p>分段地址中的地址结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628abeddf3?w=561&h=151&f=png&s=4715" width="50%"></p><p>该地址结构中，允许一个进程最多有 <code>64K</code> 个段，每个段的最大长度为 <code>64KB</code>。</p><p>系统为每个进程建立了一张段表，用于实现从逻辑段到物理内存区的映射。每个段在表中占有一个表项，其中记录了该段在内存中的基址和段的长度。</p><p>系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址转换时，首先将段号与段表长度进行比较。如果段号大于段表长度，则访问越界。</p><p>如果没有越界，则根据段表的始址和该段的段号，得到该段对应段表项的位置，从中读出该段在内存的起始地址。再检查段内地址是否超过该段的段长。如果超过，同样产生越界中断；否则将该段的基址和段内地址相加，最后得到要访问的内存地址。</p><h3 id="分页式和分段式比较"><a href="#分页式和分段式比较" class="headerlink" title="分页式和分段式比较"></a>分页式和分段式比较</h3><ul><li>采用分页存储是为了提高内存的利用率；采用分段是为了更好地满足用户的需要。</li><li>分页存储中，页面的大小由系统决定，而且大小固定；分段存储中，段的长度由用户程序决定。</li><li>分页存储中，页表中主要存储物理块号；分段存储中，段表中主要存储段基址和段长。</li></ul><h3 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h3><p>段页式存储是分段和分页的结合，先将用户程序分为若干个段，再把每个段分成若干个页。段页式的地址结构为段号、段内页号和页内地址三部分。</p><p>为实现地址转换，系统中需要同时设置段表和页表。不过这里的段表中存储的是页表始址和段长。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c2eba0bb6bb7?w=886&h=525&f=png&s=30075" width="60%"></p><p>在进行地址转换时，首先将段号与段长进行比较，如果段号小于段长表示未越界，于是利用段表始址和段号求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号来获得对应页的页表项位置，从中读出该页所在的物理块号，再利用块号和页内地址来得到物理地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;连续内存分配&quot;&gt;&lt;a href=&quot;#连续内存分配&quot; class=&quot;headerlink&quot; title=&quot;连续内存分配&quot;&gt;&lt;/a&gt;连续内存分配&lt;/h2&gt;&lt;p&gt;在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。&lt;/p&gt;
&lt;p&gt;动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(4)--死锁</title>
    <link href="https://blog.timberliu.com/2019/01/10/%E6%AD%BB%E9%94%81/"/>
    <id>https://blog.timberliu.com/2019/01/10/死锁/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h2><p>在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。</p><p>死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。</p><p>出现死锁的四个必要条件：</p><ul><li>互斥。在任何时刻一个资源只能被一个进程使用。</li><li>拥有和请求。已经得到某个资源的进程可以再请求新的资源；</li><li>不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放；</li><li>循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。<a id="more"></a>  </li></ul><p>对于死锁，有四种处理的策略：1. 忽略；2. 预防死锁；3. 避免死锁；4. 检测死锁并恢复。</p><h2 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h2><p>预防是指通过破坏死锁产生的四个必要条件的一个或多个，以避免发生死锁。</p><ul><li>破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源；</li><li>破坏拥有和请求：有两种方案：<ul><li>已拥有资源的进程不能再去请求其他资源。一种实现方法是要求进程在开始执行前请求需要的所有资源。</li><li>要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源。</li></ul></li><li>破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占；</li><li>破坏循环等待：有两种方案：<ul><li>一种方法是保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源；</li><li>另一种方法是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源。</li></ul></li></ul><h2 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h2><p>死锁避免是利用一些事先已知的信息，在分配资源时判断是否会出现死锁，如果不会出现死锁才会分配资源。</p><p>而判断是否会出现死锁就是看是否能找到一个安全序列，系统能按照这个安全序列，也就是进程的推进顺序为每个进程分配其所需资源，直到满足每个进程所需的资源，使每个进程都能顺序执行。</p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><p>为实现银行家算法，进程在进入系统时，要求进程声明需要资源的最大数目，但不能超过系统能提供的最大资源数目。当一个进程请求资源时，需要确定是否有足够资源分配给该进程，如果有，再检查在分配资源后，系统是否安全。</p><p>假定线程数量为 <code>n</code>，资源类型数量为 <code>m</code>，银行家算法的数据结构如下：</p><ul><li><code>Max</code> (总需求量)：<code>n*m</code> 矩阵，表示进程 <code>Ti</code> 最多请求 <code>Max[i, j]</code> 个类型为 <code>Rj</code> 的资源；</li><li><code>Available</code> (剩余空闲量)：长度为 <code>m</code> 的向量，表示当前有 <code>Available[i]</code> 个类型 <code>Rj</code> 的可用资源；</li><li><code>Allocation</code> (已分配量)：<code>n*m</code> 矩阵，表示进程 <code>Ti</code> 当前分配了 <code>Allocation[i, j]</code> 个类型为 <code>Rj</code> 的资源；</li><li><code>Need</code> (未来需要量)：<code>n*m</code> 矩阵，表示进程 <code>Ti</code> 未来需要 <code>Need[i, j]</code> 个类型为 <code>Rj</code> 资源；</li></ul><p>可以得出它们满足等式：<code>Need[i, j] = Max[i, j] - Allocation[i, j]</code>。</p><p>银行家算法的核心部分，安全状态的判断如下：</p><ol><li>创建长度为 <code>m</code> 的向量 <code>Work</code>，表示当前资源剩余量，并进行初始化：<code>Work = Avaiable;</code></li><li>在未运行的进程中寻找未来需要量 <code>Need[i]</code> 比当前可用量 <code>Work</code> 小的进程 <code>Ti</code>，如果找到则继续执行 <code>3</code>，否则转 <code>4</code>；</li><li>执行 <code>Work = Work + Allocation[j];</code> ，将资源分配给进程 <code>Ti</code> 运行完毕后，回收其资源。转 <code>2</code>：</li><li>如果资源可以分配给所有进程，则系统处于安全状态；</li></ol><p>如此完整的银行家算法如下：首先进行初始化，<code>Request_i</code> 表示进程 <code>Ti</code> 的资源请求向量，<code>Request_i[j]</code> 表示进程 <code>Ti</code> 请求资源 <code>Rj</code> 的实例。然后循环判断：</p><ol><li>如果 <code>Request_i &lt;= Need[i]</code>，转到 <code>2</code>。否则拒绝资源请求，因为进程已经超过最大要求；</li><li>如果 <code>Request_i &lt;= Available</code>，转到 <code>3</code>。否则进程 <code>Ti</code> 必须等待，因为现在可用资源不足；</li><li>通过安全状态判断来确定是否分配资源给 <code>Ti</code>，如果安全则分配，否则拒绝 <code>Ti</code> 的资源请求。</li></ol><h2 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h2><p>可以允许系统进入死锁状态，但会维护一个系统的资源分配图，定期调用死锁检测算法来检测途中是否存在死锁，检测到死锁发生后，采取死锁恢复算法进行恢复。</p><p>死锁检测方法如下：</p><ul><li>在资源分配图中，找到不会阻塞又不独立的进程结点，使该进程获得其所需资源并运行，运行完毕后，再释放其所占有的全部资源。也就是消去该进程结点的请求边和分配边。</li><li>使用上面的算法进行一系列简化，若能消去所有边，则表示不会出现死锁，否则会出现死锁。</li></ul><p>在检测死锁时，可以采用两种方法：</p><ul><li>抢占资源。从一个或多个进程中抢占资源分配给死锁进程。</li><li>终止进程。可以终止所有的死锁进程；也可以按照某种顺序，逐个终止进程，释放其占有资源，直到死锁解除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;死锁概念&quot;&gt;&lt;a href=&quot;#死锁概念&quot; class=&quot;headerlink&quot; title=&quot;死锁概念&quot;&gt;&lt;/a&gt;死锁概念&lt;/h2&gt;&lt;p&gt;在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。&lt;/p&gt;
&lt;p&gt;死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。&lt;/p&gt;
&lt;p&gt;出现死锁的四个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥。在任何时刻一个资源只能被一个进程使用。&lt;/li&gt;
&lt;li&gt;拥有和请求。已经得到某个资源的进程可以再请求新的资源；&lt;/li&gt;
&lt;li&gt;不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放；&lt;/li&gt;
&lt;li&gt;循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(3)--进程的同步和通信方式</title>
    <link href="https://blog.timberliu.com/2019/01/08/%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1/"/>
    <id>https://blog.timberliu.com/2019/01/08/进程的同步与通信/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2019-01-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。</p><p>对于同步机制，需要遵循以下四个规则：</p><ul><li>空闲则入：没有进程在临界区时，任何进程可以进入；</li><li>忙则等待：有进程在临界区时，其他进程均不能进入临界区；</li><li>有限等待：等待进入临界区的进程不能无限期等待；</li><li>让权等待（可选）：不能进入临界区的进程，应该释放 <code>CPU</code>，如转换到阻塞态；<a id="more"></a>  </li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量机制（<code>semaphore</code>）是一种协调共享资源访问的方法。信号量由一个变量 <code>semaphore</code> 和两个原子操作组成，信号量只能通过 <code>P</code> 和 <code>V</code> 操作来完成，而且 <code>P</code><br>和 <code>V</code> 操作都是原子操作。</p><p>将信号量表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct process_control_block *list;</span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><p>相应的 <code>P(wait)</code> 操作和 <code>V(signal)</code> 操作如下实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value &lt; 0) &#123;</span><br><span class="line">        block(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    if(S-&gt;value &lt;= 0) &#123;</span><br><span class="line">        wakeup(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号量可分为两类：互斥信号量，信号量大小为为 <code>0</code> 或 <code>1</code>，用来实现进程的互斥访问；资源信号量，信号量大小为资源数，用来表示系统资源数目。</p><p><strong>资源信号量</strong></p><p>代表资源信号量时，<code>S-&gt;value</code> 初值表示系统资源的数目，<code>P</code> 操作意味着进程请求一个资源，于是系统中可分配的资源数减一，如果 <code>S-&gt;value &lt; 0</code>，表示该类资源已分配完毕，因此阻塞该进程，并插入信号量链表 <code>S-&gt;list</code> 中。小于 <code>0</code> 时，<code>S-&gt;value</code> 的绝对值表示该信号量链表中阻塞的进程数。</p><p><code>V</code> 操作表示进程释放一个资源，于是系统中可分配的资源数加一，如果增加一后仍然 <code>S-&gt;value &lt;= 0</code>，表示该信号量链表中仍然有阻塞的进程，因此调用 <code>wakeup</code>，将 <code>S-&gt;list</code> 中的第一个进程唤醒。</p><p><strong>互斥信号量</strong></p><p>代表互斥信号量时，<code>S-&gt;value</code> 初值为 <code>1</code>，表示只允许一个进程访问该资源。</p><p>利用信号量实现两个进程互斥描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">P() &#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    临界区；</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>mutex = 1</code> 时，表示两个进程都没有进入临界区，当 <code>mutex = 0</code> 时，表示一个进程进入临界区运行；当 <code>mutex = -1</code> 时，表示一个进程进入临界区运行，另一个进程被阻塞在信号量队列中。</p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程采用面向对象思想，将表示共享资源的数据结构及相关的操作，包括同步机制，都集中并封装到一起。所有进程都只能通过管程间接访问临界资源，而管程只允许一个进程进入并执行操作，从而实现进程互斥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor_name &#123;</span><br><span class="line">    share variable declarations;</span><br><span class="line">    condition declarations;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    void P1(···) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        initialization code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管程中设置了多个条件变量，表示多个进程被阻塞或挂起的条件，条件变量的形式为 <code>condition x, y;</code>，它也是一种抽象数据类型，每个变量保存了一条链表，记录因该条件而阻塞的进程，与条件变量相关的两个操作：<code>condition.cwait</code> 和 <code>condition.csignal</code>。</p><ul><li><code>condition.cwait</code>：正在调用管程的进程因 <code>condition</code> 条件需要被阻塞，则调用 <code>condition.cwait</code> 将自己插入到 <code>condition</code> 的等待队列中，并释放管程。此时其他进程可以使用该管程。</li><li><code>condition.csignal</code>：正在调用管程的进程发现 <code>condition</code> 条件发生变化，则调用 <code>condition.csignal</code> 唤醒一个因 <code>condition</code> 条件而阻塞的进程。如果没有阻塞的进程，则不产生任何结果。</li></ul><h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>生产者-消费者问题描述的是：生产者和消费者两个线程共享一个公共的固定大小的缓冲区，生产者在生成产品后将产品放入缓冲区；而消费者从缓冲区取出产品进行处理。</p><p>它需要保证以下三个问题：</p><ul><li>在任何时刻只能有一个生产者或消费者访问缓冲区（互斥访问）；</li><li>当缓冲区已满时，生产者不能再放入数据，必须等待消费者取出一个数据（条件同步）；</li><li>而当缓冲区为空时，消费者不能读数据，必须等待生产者放入一个数据（条件同步）。</li></ul><p><strong>利用信号量解决</strong></p><p>用信号量解决生产者-消费者问题，使用了三个信号量：</p><ul><li>互斥信号量 <code>mutex</code>：用来保证生产者和消费者对缓冲区的互斥访问；</li><li>资源信号量 <code>full</code>：记录已填充的缓冲槽数目；</li><li>资源信号量 <code>empty</code>：记录空的缓冲槽数目。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define N 10</span><br><span class="line">int in = 0, out = 0;</span><br><span class="line">item buffer[N];</span><br><span class="line">semaphere mutex = 1, full = 0, empty = N;</span><br><span class="line"></span><br><span class="line">void producer(void) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        item nextp = produce_item();</span><br><span class="line">        wait(empty);          </span><br><span class="line">        wait(mutex);                 </span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % N;</span><br><span class="line">        signal(mutex);              </span><br><span class="line">        signal(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer(void) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        item nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % N;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">        consume_item(nextc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是进程中的多个 <code>wait</code> 操作顺序不能颠倒，否则可能造成死锁。例如在生产者中，当系统中没有空的缓冲槽时，生产者进程的 <code>wait(mutex)</code> 获取了缓冲区的访问权，但 <code>wait(empty)</code> 会阻塞，这样消费者也无法执行。</p><p><strong>利用管程解决</strong></p><p>利用管程解决时，需要为它们建立一个管程，其中 <code>count</code> 表示缓冲区中已有的产品数目，条件变量 <code>full</code> 和 <code>empty</code> 有 <code>cwait</code> 和 <code>csignal</code> 两个操作，另外还包括两个过程：</p><ul><li><code>put(x)</code>：生产者将自己生产的产品放入到缓冲区中，而如果 <code>count &gt;= N</code>，表示缓冲区已满，生产者需要等待；</li><li><code>get(x)</code>：消费者从缓冲区中取出一个产品，如果 <code>count &lt;= 0</code>，表示缓冲区为空，消费者应该等待；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Monitor producerconsumer &#123;</span><br><span class="line">    item buffer[N];</span><br><span class="line">    int in, out;</span><br><span class="line">    condition full, emtpy;</span><br><span class="line">    int count;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    void put(item x) &#123;</span><br><span class="line">        if(count &gt;= N) &#123; </span><br><span class="line">            cwait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[in] = x;</span><br><span class="line">        in = (in + 1) % N;</span><br><span class="line">        count++;</span><br><span class="line">        csignal(emtpy);</span><br><span class="line">    &#125;</span><br><span class="line">    item get() &#123;</span><br><span class="line">        if(count &lt;= 0) &#123;</span><br><span class="line">            cwait(emtpy);</span><br><span class="line">        &#125;</span><br><span class="line">        x = buffer[out];</span><br><span class="line">        out = (out + 1) % N;</span><br><span class="line">        count--;</span><br><span class="line">        csignal(full);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123; in = 0; out = 0; count = 0; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是生产者和消费者可描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void producer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        item nextp = produce_item();</span><br><span class="line">        producerconsumer.put(nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        item nextc = producerconsumer.get();</span><br><span class="line">        consume_item(nextc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>哲学家就餐问题描述的是：有五个哲学家共用一个圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们交替地进行思考和进餐。哲学家在平时进行思考，在饥饿时试图获取左右两只筷子，拿到两只筷子才能进餐，进餐完后放下筷子继续思考。</p><p>为实现筷子的互斥使用，可以用一个信号量表示一只筷子，五个信号量构成信号量数组，也都被初始化为 <code>1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br></pre></td></tr></table></figure><p>第 <code>i</code> 位哲学家的活动可描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + 1) % 5]);</span><br><span class="line">        // eat</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + 1) % 5]);</span><br><span class="line">        // think</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述解法中，如果五位哲学家同时饥饿而都拿起左边的筷子，再试图去拿右边的筷子时，会出现无限期等待而引起死锁。</p><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>读者-写者问题描绘的是：一个文件可以被多个进程共享，允许多个 <code>Reader</code> 进程同时读这个文件，但不允许 <code>Wirter</code> 进程和其他 <code>Reader</code> 进程或 <code>Writer</code> 进程同时访问这个文件。所以读者-写者需要保证一个 <code>Writer</code> 进程必须与其他进程互斥地访问共享对象。</p><p>解决这个问题需要设置两个互斥信号量和一个整形变量：</p><ul><li>互斥信号量 <code>wmutext</code>：实现 <code>Reader</code> 进程和 <code>Writer</code> 进程在读或写时的互斥；</li><li>整形变量 <code>readcount</code>：正在读的进程数目；</li><li>互斥信号量 <code>rmutext</code>：实现多个 <code>Reader</code> 进程对 <code>readcount</code> 变量的互斥访问；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = 1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void Reader() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        if(readcount == 0) &#123;</span><br><span class="line">            wait(wmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">        // perform read opertaion</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        if(readcount == 0) &#123;</span><br><span class="line">            signal(wmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Writer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        // perform wirte opertaion</span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有一个 <code>Reader</code> 进程在读，便不允许 <code>Writer</code> 进程去写。所以，仅当 <code>readcount = 0</code>，表示没有 <code>Reader</code> 进程在读时，<code>Reader</code> 进程才需要执行 <code>wait(wmutex)</code> 操作，而 <code>readcount != 0</code> 时，表示有其他 <code>Reader</code> 进程在读，也就肯定没有 <code>Writer</code> 在写。同理，仅当 <code>readcount = 0</code> 时，才执行 <code>signal(wmutex)</code> 类似。</p><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程通信是指进程之间的信息交换。在进程间要传送大量数据时，应利用高级通信方法。</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>在共享内存系统中，多个通信的进程共享某些数据结构或存储区，进程之间能够通过这些空间进行通信。</p><p>可分为两种类型：</p><ul><li>基于共享数据结构的通信方式。多个进程共用某些数据结构，实现进程之间的信息交换，例如生产者-消费者问题中的缓冲区。这种方式仅适用于少量的数据，通信效率低下。</li><li>基于共享存储区的通信方式。在内存中分配一块共享存储区，多个进程可通过对该共享区域的读或写交换信息。通信的进程在通信前，需要先向系统申请共享存储区的一个分区，以便对其中的数据进行读写。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（<code>Pipe</code>）是指用于连接一个读进程和一个写进程以实现进程间通信的一个共享文件。发送进程以字符形式将数据送入管道，而接收进程则从管道中接收数据。</p><p>管道机制提供了三方面的协调能力：</p><ul><li>互斥：当一个进程对管道执行读或写操作时，其他进程必须等待；</li><li>同步：当写进程把一定数量的数据写入管道，便睡眠等待，直到读进程取走数据后再把它唤醒；</li><li>确定对方是否存在，只有确定对方存在才能通信。</li></ul><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>消息传递机制中，进程以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的原语，在进程之间进行消息传递，完成进程间数据交换。</p><p>按照实现方式，可分为两类：</p><ul><li>直接通信方式：发送进程利用操作系统提供的发送原语，直接把消息发送给进程，接收进程则利用接收原语来接收消息；</li><li>间接通信方式：发送和接收进程，通过共享中间实体方式进行消息的发送和接收，完成进程间的通信。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程间同步&quot;&gt;&lt;a href=&quot;#进程间同步&quot; class=&quot;headerlink&quot; title=&quot;进程间同步&quot;&gt;&lt;/a&gt;进程间同步&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。&lt;/p&gt;
&lt;p&gt;对于同步机制，需要遵循以下四个规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲则入：没有进程在临界区时，任何进程可以进入；&lt;/li&gt;
&lt;li&gt;忙则等待：有进程在临界区时，其他进程均不能进入临界区；&lt;/li&gt;
&lt;li&gt;有限等待：等待进入临界区的进程不能无限期等待；&lt;/li&gt;
&lt;li&gt;让权等待（可选）：不能进入临界区的进程，应该释放 &lt;code&gt;CPU&lt;/code&gt;，如转换到阻塞态；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(2)--进程和线程</title>
    <link href="https://blog.timberliu.com/2019/01/07/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.timberliu.com/2019/01/07/进程和线程/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程（<code>process</code>）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 <code>OS</code> 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。</p><p>在某一瞬间，一个 <code>CPU</code> 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。<br><a id="more"></a><br>进程和程序间的联系和区别如下：</p><ul><li>程序是一段静态的代码；进程是一个动态运行的过程；</li><li>程序是产生进程的基础；进程是程序功能的体现；</li><li>程序的每次执行都构成了不同的进程，通过多次运行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序；</li></ul><h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>为了实现进程，操作系统维护了一张进程表（结构数组），每个进程占用一个进程表项（进程控制块 <code>PCB</code>），它是进程存在的唯一标志。该表项包含了进程状态的重要信息，包括进程标识符、状态、优先级、程序计数器、堆栈指针、寄存器等；</p><p>对进程的管理就是对通过 <code>PCB</code> 的组织管理来实现的。由于保存了在进程的状态变化时的必要信息，在中断一个正在执行的进程，并在后来恢复时，就好像进程从未中断过。它是支持多进程和提供多处理的关键。</p><h2 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h2><p>如下图是进程的三种状态的状态图。一个进程的三种状态是：</p><ul><li>运行态：进程正在占用 <code>CPU</code> 执行；</li><li>就绪态：进程处于准备运行状态，已经获得除 <code>CPU</code> 外的所有资源；</li><li>阻塞态：进程由于等待某种外部事件而暂停运行，即使获得 <code>CPU</code>，也不能运行。</li></ul><p><img src="https://note.youdao.com/yws/public/resource/9bce5a7b445fc99c2cd7358f25bd4c1d/xmlnote/CE2E283B6F144294859EA68C058832B2/75804" width="60%"></p><p>进程之间主要有四种转换关系：</p><ul><li>由运行态转换为就绪态：在时间片用完后，不得不让出 <code>CPU</code>；</li><li>由就绪态转换为运行态：进程被调度，获得处理机资源；</li><li>由阻塞态转换为就绪态：进程的 <code>I/O</code> 请求完成；</li><li>由运行态转换为阻塞态：进程发出 <code>I/O</code> 请求；</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程（<code>thread</code>）是进程中的一条执行流程。在引入线程的操作系统中，进程是拥有资源的基本单位；而线程是 <code>CPU</code> 调度和分派的基本单位。</p><p>一个进程中可以有多个线程，多个线程可以并发执行，它们之间共享相同的地址空间。但如果一个线程崩溃，可能会导致其所属进程的所有线程崩溃。</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>调度性：传统 OS 中，进程是调度和分派的基本单位，但在引入线程后，线程是调度和分派的基本单位；</li><li>并发性：在引入线程后，多个进程可以并发执行，一个进程中的多个线程也可以并发执行；</li><li>拥有资源：进程是拥有资源的基本单位，而线程本身并不拥有资源；</li><li>系统开销：进程切换付出的系统开销明显大于线程；</li></ul><h2 id="线程实现的三种方式"><a href="#线程实现的三种方式" class="headerlink" title="线程实现的三种方式"></a>线程实现的三种方式</h2><p>有三种线程的实现方式：</p><ul><li>用户线程：用户空间实现，由用户线程库管理；</li><li>内核线程：内核中实现，由操作系统管理；</li><li>轻量级进程：内核中实现，支持用户线程；</li></ul><p><strong>用户线程</strong></p><p>用户线程是把整个线程包放在用户空间中，不依赖于操作系统的内核，所以它可以在不支持线程的操作系统上实现。可以用一组用户级的线程函数库来实现线程。</p><p><img src="https://note.youdao.com/yws/public/resource/9bce5a7b445fc99c2cd7358f25bd4c1d/xmlnote/2CD68ECA7B1C401FABAE9CD82860590C/70250" width="60%"></p><p>每个进程都需要私有的线程表，用来跟踪记录该进程中线程的状态信息，不过仅记录每个线程的程序计数器、堆栈指针、寄存器和状态等，该线程表由运行时系统管理。而且用户线程的切换由线程库函数来完成，不需要用户态、核心态切换，所以线程调度速度特别快。另外，也允许每个进程都拥有自定义的线程调度算法。</p><p>但如果一个线程发起系统调用而阻塞，尽管其他线程可以运行，但整个进程都会阻塞。当一个线程开始运行后，除非它主动较交出 <code>CPU</code>，否则它所在的进程中的其他线程将无法运行。</p><p><strong>内核线程</strong></p><p>内核线程在操作系统的内核中实现，由内核来完成对线程的创建、终止和管理。</p><p><img src="https://note.youdao.com/yws/public/resource/9bce5a7b445fc99c2cd7358f25bd4c1d/xmlnote/C9CBECFDE0E84441B4714E85049A20A7/70252" width="60%"></p><p>由于线程的创建、终止和切换通过系统调用执行，由内核完成的，其系统开销比较大；</p><p>但在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他使用内核线程的运行；</p><p><strong>轻量级进程</strong></p><p>轻量级进程是内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。而轻量级进程内部可以对应多个用户线程。</p><h1 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h1><h2 id="调度概念"><a href="#调度概念" class="headerlink" title="调度概念"></a>调度概念</h2><p>处理机调度是当有多个进程（线程）竞争 <code>CPU</code> 时，调度程序需要从从就绪队列中挑选下一个占用 <code>CPU</code> 运行的进程。</p><p>调度算法是为了解决通过什么样的准则来挑选就绪对列中的哪一个进程来执行。在每次调度时需要决定在下一个 <code>CPU</code> 计算时将哪个进程交给 <code>CPU</code>。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><strong>先来先服务算法FCFS</strong></p><p>根据进程进入就绪态的先后顺序排列。当进程进入阻塞态或结束时，就绪队列中的下一个进程占用 <code>CPU</code>。</p><p>实现简单，但可能短进程排在长进程后面，导致平均等待时间波动较大。</p><p><strong>短进程优先算法SJF</strong></p><p>选择就绪队列中执行时间最短的进程占用 <code>CPU</code> 运行。</p><ul><li>可抢占系统改进：短剩余时间优先算法，即选择剩余运行时间最短的进程运行。</li></ul><p>短进程优先算法有最优的平均周转时间，但连续的短进程可能会使长进程无法获得 <code>CPU</code> 资源，导致饥饿；运行时间不可预估，并不可靠。</p><p><strong>最高响应比优先算法HRN</strong></p><p>选择就绪队列中响应比最高的进程。它是基于短进程优先算法的改进，它不允许抢占，另外等待时间越长，响应比越高，可以避免长时间地等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = (w+s)/s     // 其中 w 为等待时间，s 为执行时间。</span><br></pre></td></tr></table></figure><p><strong>时间片轮转算法RR</strong></p><p>按时间片分配给进程运行。在轮转中，每个进程分到执行 <code>1/n</code> 的时间，时间片结束时，按先来先服务算法切换到下一个就绪进程，每隔 <code>n-1</code> 个时间片进程会再次执行。</p><p>如果时间片过大，进程等待时间过长，极限情况下会退化为先来先服务算法；如果时间片过小，虽然反应迅速，但上下文切换开销较大，会影响系统吞吐量。</p><p><strong>多级反馈队列算法</strong></p><p>就绪队列被划分为多个独立的子队列，而且每个队列可以有自己的调度策略，在队列之间可以设置优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短。</p><p>在执行时，进程在不同队列间移动，如果进程在当前优先级的时间片下没有完成，则下降到低一优先级的队列，以此类推。只有当一个队列为空时才会去执行下一个队列中的进程。</p><p>这种算法对于 <code>CPU</code> 密集型进程的优先级下降很快，而 <code>I/O</code> 密集型进程停留在高优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;进程（&lt;code&gt;process&lt;/code&gt;）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 &lt;code&gt;OS&lt;/code&gt; 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。&lt;/p&gt;
&lt;p&gt;在某一瞬间，一个 &lt;code&gt;CPU&lt;/code&gt; 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(1)--操作系统概述</title>
    <link href="https://blog.timberliu.com/2019/01/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://blog.timberliu.com/2019/01/06/操作系统概述/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。</p></blockquote><p>参考学习：</p><ul><li>书籍：《现代操作系统》、《深入理解计算机系统》</li><li>视频：学堂在线 - <a href="https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">操作系统（自主模式）</a><a id="more"></a><h2 id="操作系统知识点"><a href="#操作系统知识点" class="headerlink" title="操作系统知识点"></a>操作系统知识点</h2></li></ul><p><img src="https://note.youdao.com/yws/public/resource/7d90079e62501fa244a7166b342cc723/xmlnote/D445C1EA0B1443518C811D4DDD4DD598/75546" width="80%"></p><ul><li>操作系统概述：<ul><li>操作系统的定义以及功能；</li><li>计算机系统体系结构；</li><li>操作系统的四个特性：并发、共享、虚拟、异步；</li><li>用户态和核心态的区别；</li></ul></li><li>进程和线程：<ul><li>进程的几种状态及其转换；</li><li>进程与线程的区别；</li><li>进程调度的算法；</li><li>进程同步的方式；</li><li>进程通信的方式；</li></ul></li><li>死锁：<ul><li>死锁的概念、导致死锁的原因；</li><li>导致死锁的四个必要条件；</li><li>处理死锁的四种方式：预防、避免、检测、解除；</li></ul></li><li>存储器：<ul><li>内存连续分配方式采用的算法及优缺点；</li><li>分页存储管理方式；</li><li>分段存储管理方式；</li><li>段页式存储管理方法；</li><li>几种存储方式的比较及各自优缺点；</li><li>从逻辑地址到物理地址的转换过程；</li></ul></li><li>虚拟存储器：<ul><li>虚拟存储器的定义与实现方式；</li><li>页面置换算法，计算所需换页数；</li></ul></li><li>文件系统：<ul><li>文件系统基本概念；</li><li>文件分配方式；</li></ul></li></ul><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p>计算机系统一般由一个或多个处理器、内存、<code>I/O</code> 设备等组成，而操作系统就是这些硬件之上的一种软件，它为应用程序提供了一个抽象，并管理这些计算机资源。具体可以从功能上来认识操作系统。</p><p>作为扩展机器，它隐藏硬件底层实现细节，对硬件提供抽象，方便程序或用户的使用：</p><ul><li>进程是对 <code>CPU</code>、主存及 <code>I/O</code> 设备的抽象；</li><li>虚拟内存（虚拟地址空间）是对主存和 <code>I/O</code> 设备的抽象；</li><li>文件是对 <code>I/O</code> 设备的抽象；</li></ul><p>作为资源管理器，它在多个竞争程序之间合理地控制对处理器、存储器及 <code>I/O</code> 设备的分配，避免资源使用冲突。有两种共享资源的方式：</p><ul><li>时间复用：不同程序或用户轮流使用；</li><li>空间复用：每个程序或用户得到资源的一部分；</li></ul><h2 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h2><p>如下图是一般计算机系统的简化图。多数计算机有两种运行模式：内核态和运行态。</p><p><img src="https://note.youdao.com/yws/public/resource/7d90079e62501fa244a7166b342cc723/xmlnote/425E7051004C4FD78C847BBB67477125/75565" width="60%"></p><p>操作系统运行在内核态，它对所有硬件具有访问权，可以执行任何指令。用户接口程序和其余软件运行在用户态，<br>它只能执行机器指令中的一个子集。</p><h2 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h2><p>操作系统主要有四大特性，分别为：</p><ul><li>并发：在宏观上有多个程序在同时运行，需要 <code>OS</code> 管理和调度，而在微观上是分时交替运行；<blockquote><p>注意并发和并行的区别：</p><ul><li>并发指的是在<strong>一段时间内</strong>有多个应用程序可以运行；</li><li>并行指的是在<strong>一个时间点</strong>有多个应用程序可以执行，并行需要计算机有多个 <code>CPU</code>；</li></ul></blockquote></li><li>共享：资源可以供内存中多个并发执行的进程共同使用，在宏观上是同时访问该资源，而在微观上是采用互斥共享。</li><li>虚拟：利用多道程序设计，让每个应用程序都觉得有一个计算机专门为它服务。</li><li>异步：程序的执行不是连贯的，而是间断性的，其速度也不可知，但只要运行环境相同，其运行结果需要保证相同。</li></ul><h2 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h2><p>计算机系统主要由处理器、主存、<code>I/O</code> 设备及系统总线组成。</p><p><strong>处理器</strong></p><p>也称中央处理单元（<code>CPU</code>），是用来解释或执行主存中的指令的引擎。在任何时候，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，指向下一条指令。</p><p><strong>主存</strong></p><p>主存，是一个临时存储设备，用来存放程序和程序要处理的数据。存储系统大多采用分层次的存储结构。如下图：</p><p><img src="https://note.youdao.com/yws/public/resource/7d90079e62501fa244a7166b342cc723/xmlnote/C1BFECBD70544A8C917FE9B1C41F2448/75693" width="60%"></p><p>存储层次最顶层是寄存器。下一层是两层高速缓存 <code>L1、L2</code>。再下一层是主存，所有不能再高速缓存行命中的访问请求会转到内存。如果内存中还没有，可能还会到虚拟内存中查找。</p><p>在层次结构中，较高层次的存储设备可以作为较低层次设备的高速缓存。更高层次的存储设备比底层的更快，但价格也更昂贵。</p><p><strong>I/O 设备</strong></p><p><code>I/O</code> 设备是系统与外界联系的通道。主要包括磁盘、显示器、键盘等。每个 <code>I/O</code> 设备都通过一个控制器或适配器与 <code>I/O</code> 总线相连，来传递信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书籍：《现代操作系统》、《深入理解计算机系统》&lt;/li&gt;
&lt;li&gt;视频：学堂在线 - &lt;a href=&quot;https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统（自主模式）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常</title>
    <link href="https://blog.timberliu.com/2018/11/08/Java%E5%BC%82%E5%B8%B8/"/>
    <id>https://blog.timberliu.com/2018/11/08/Java异常/</id>
    <published>2018-11-07T16:00:00.000Z</published>
    <updated>2018-11-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-标准异常"><a href="#Java-标准异常" class="headerlink" title="Java 标准异常"></a>Java 标准异常</h2><p><code>Throwable</code> 是 <code>Java</code> 中最顶级的异常类，继承自 <code>Object</code>，实现了序列化接口，它有两个重要的子类：<code>Exception</code> 和 <code>Error</code>，二者都是 <code>Java</code> 异常处理的重要子类，它们之间的区别和联系如下：</p><ul><li><code>Error</code>：表示系统级的错误，是 <code>Java</code> 运行环境内部或硬件问题，一般与虚拟机相关，例如：栈溢出、内存溢出等。这种异常抛出后不能指望程序来进行处理。</li><li><code>Exception</code>：表示需要程序捕获并处理的异常，是由程序设计的不完善而出现的问题，包括运行时异常（<code>RuntimeException</code>）和其他异常，例如 <code>IOException</code> 等。<a id="more"></a></li></ul><p>异常体系图如下：</p><p><img src="http://media.timberliu.com/image/2019/1/29/Java%E5%BC%82%E5%B8%B8.png" width="80%"></p><h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><p><code>Java</code> 中的异常可分为两类：非受检异常（<code>Unchecked Exception</code>）和受检异常（<code>Checked Exception</code>）。</p><p>其中 <code>Error</code> 和 <code>RuntimeExcpetion</code> 表示属于非受检异常。这种异常不需要显式地捕获，也不需要在异常说明中声明，但是如果发生异常就会中断程序的执行。这种异常一般是由于代码原因导致的，例如空指针、数组越界、转型异常等。所以，只要代码没问题，这些异常就可以避免，也就不需要显式处理。</p><p>而其他的异常都属于受检异常。这种异常需要使用 <code>try-catch</code> 捕获处理或者在异常说明中进行声明，<br>如果一个方法调用了有受检异常抛出的方法那么就需要对该异常进行处理，否则编译就不能通过。例如 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 异常捕获</span></span><br><span class="line">        Class.forName(<span class="string">"timberliu.exception.User"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常说明中进行声明</span></span><br><span class="line"><span class="comment">// throws 用来声明方法可能抛出的所有异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受检异常在 <code>IO</code> 操作中使用较多。例如 <code>FileNotFoundException</code>，它表示的是：告诉方法调用者，不保证这个寻找文件的操作一定成功，取决于外部因素，所以需要明确地对调用失败的情况进行特殊处理。</p><h2 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h2><p>在异常被捕获后，有两种处理方式：1. 自己进行处理；2. 向上抛出，交给调用者处理。具体处理时，如果不知道如何处理那就向上抛出；如果知道如何处理，那么有以下处理方式：</p><ul><li>打印记录日志</li><li>封装异常后重新抛出</li><li>返回失败通用对象 <code>Response.Failed()</code></li><li>更改程序结果后正常返回</li><li>忽略或 <code>e.printStackTrace()</code>，一般禁止这样使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 明确抛出一个异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭 IO、网络连接等资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将捕获的异常重新封装到一个新的异常里重新抛出，这称为异常链。大多用于将受检异常封装成非受检异常。另外，抛出的新异常必须包含原有异常，这样在处理程序时才可以通过 <code>getCause()</code> 和 <code>initCause()</code> 方法访问异常的根源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 将 e 封装到新创建的异常里</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="意外情况"><a href="#意外情况" class="headerlink" title="意外情况"></a>意外情况</h2><p><strong style="color:#000000;font-size:16px">1.在 return 中使用 finally</strong></p><p>在 <code>try</code> 语句中有 <code>return</code> 语句时，<code>finally</code> 中的代码会在 <code>try</code> 或 <code>catch</code> 块中的 <code>return</code> 语句执行之后，返回之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">return</span> i = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"before finally: "</span> + i);</span><br><span class="line">        i = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">"after finally: "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return: "</span> + test());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try</span></span><br><span class="line"><span class="comment">// before finally: 2</span></span><br><span class="line"><span class="comment">// after finally: 3</span></span><br><span class="line"><span class="comment">// return: 2</span></span><br></pre></td></tr></table></figure><p>可以看到，这里的执行顺序是先执行 <code>i = 2</code>；然后执行 <code>finally</code> 块中的语句；最后 <code>return</code>。但是在 <code>finally</code> 语句中修改 <code>a</code> 的值，对结果不会造成影响。</p><p>如果 <code>finally</code> 语句中也有 <code>return</code> 语句，还会覆盖 <code>try</code> 或 <code>catch</code> 中的 <code>return</code> 语句的返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return: "</span> + test());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return 3</span></span><br></pre></td></tr></table></figure><p><strong style="color:#000000;font-size:16px">2.异常丢失</strong></p><p>如果在 <code>try/catch</code> 块中，执行 <code>System.exit(0);</code> 后，进程会被杀死，<code>finally</code> 中的代码就不会执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"try"</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try</span></span><br></pre></td></tr></table></figure><h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><ul><li><code>IndexOutOfBoundsException</code>：数组下标越界异常</li><li><code>ArrayStoreException</code>：向数组中存放与声明类型不兼容的对象异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal[] a = <span class="keyword">new</span> Dog[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.ArrayStoreException: timberliu.exception.Cat</span></span><br></pre></td></tr></table></figure><ul><li><code>ArithmeticException</code>：算术运算异常，例如除 <code>0</code> 运算</li><li><code>ClassCastException</code>：类型强制转换异常</li><li><code>DateTimeException</code>：时间运算异常</li><li><code>IllegalArgumentException</code>：非法参数异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">Cat cat = (Cat)animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.ClassCastException: timberliu.exception.Dog cannot be cast to timberliu.exception.Cat</span></span><br></pre></td></tr></table></figure><ul><li><code>NegativeArraySizeException</code>：创建一个大小为负数的数组错误</li><li><code>NullPointerException</code>：空指针异常</li><li><code>NumberFormatException</code>：数字格式异常，例如在字符串转换为数字时：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.NumberFormatException: For input string: "abc"</span></span><br></pre></td></tr></table></figure><ul><li><code>SecurityException</code>：安全异常</li><li><code>UnSupportedOperationException</code>：不支持的操作异常</li></ul><p>更多的异常可见官方的 <code>doc</code>：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html" target="_blank" rel="noopener">RuntimeExcpetion（Java Platform SE 8）</a></p><h2 id="Java7-新特性"><a href="#Java7-新特性" class="headerlink" title="Java7 新特性"></a>Java7 新特性</h2><p><strong style="color:#000000;font-size:16px">try-with-resources</strong></p><p>在 <code>Java7</code> 之前，对于 <code>IO</code> 操作、网络连接等，用完之后必须在 <code>finally</code> 块中调用 <code>close</code> 方法进行关闭，否则可能会导致内存泄露等问题。而从 <code>Java7</code> 中，可以使用 <code>try-with-resources</code> 语句，不需要再显式地关闭资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"e:\\file.txt"</span>));) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译一下，看它背后的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"e:\\file.txt"</span>));</span><br><span class="line">        Throwable var2 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">                var2 = var12;</span><br><span class="line">                <span class="keyword">throw</span> var12;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bufferedReader.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">                        var2.addSuppressed(var11);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，编译器自动生成了关闭资源的操作。而且，以前在关闭资源时有可能也会抛出异常，在 <code>Java7</code> 中可以使用 <code>Throwable.addSuppressed</code> 方法来抑制可能抛出的异常，这也是 <code>Java7</code> 增加的方法。</p><p><strong style="color:#000000;font-size:16px">Multi-Catch Exceptions</strong></p><p>它表示 <code>catch</code> 语句能同时捕获多个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"e:\\file.txt"</span>));</span><br><span class="line">        String line = bufferedReader.readLine();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Date date = format.parse(line);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException | IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以用同样的异常处理程序，来处理多个异常。</p><p><strong style="color:#000000;font-size:16px">Rethrowing Exceptions</strong></p><p>能够直接再次抛出已捕获的异常。注意：<code>throw new Exception(e)</code> 抛出的是重新包装之后的异常；而 <code>throw e</code> 抛出的是原始的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"IOException"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IOException</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Java-标准异常&quot;&gt;&lt;a href=&quot;#Java-标准异常&quot; class=&quot;headerlink&quot; title=&quot;Java 标准异常&quot;&gt;&lt;/a&gt;Java 标准异常&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Throwable&lt;/code&gt; 是 &lt;code&gt;Java&lt;/code&gt; 中最顶级的异常类，继承自 &lt;code&gt;Object&lt;/code&gt;，实现了序列化接口，它有两个重要的子类：&lt;code&gt;Exception&lt;/code&gt; 和 &lt;code&gt;Error&lt;/code&gt;，二者都是 &lt;code&gt;Java&lt;/code&gt; 异常处理的重要子类，它们之间的区别和联系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Error&lt;/code&gt;：表示系统级的错误，是 &lt;code&gt;Java&lt;/code&gt; 运行环境内部或硬件问题，一般与虚拟机相关，例如：栈溢出、内存溢出等。这种异常抛出后不能指望程序来进行处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exception&lt;/code&gt;：表示需要程序捕获并处理的异常，是由程序设计的不完善而出现的问题，包括运行时异常（&lt;code&gt;RuntimeException&lt;/code&gt;）和其他异常，例如 &lt;code&gt;IOException&lt;/code&gt; 等。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>接口与内部类</title>
    <link href="https://blog.timberliu.com/2018/11/06/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://blog.timberliu.com/2018/11/06/接口与内部类/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2018-11-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>抽象方法指的是仅有声明而没有方法体的方法。使用 <code>abstract</code> 关键字进行声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>而包含一个或多个抽象方法的类，就叫抽象类，用 <code>abstract</code>关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。<br><a id="more"></a><br>抽象类的主要目的是代码重用。大多用于抽象相关 <code>Java</code> 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 <code>java.util.AbstractList</code>。</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 <code>static</code> 和 <code>final</code> 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 <code>enum</code> 枚举类。</p><p>接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 <code>Cloneable</code>、<code>Serializable</code>，表示这个类可以克隆或者可以序列化。</p><p><code>Java</code> 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Play</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Class Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Study</span>, <span class="title">Play</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"student doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"study"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Diner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sleeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以继承接口（支持多继承）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Diner</span>, <span class="title">Sleeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类可以实现接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Undergraduate</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象类与接口比较"><a href="#抽象类与接口比较" class="headerlink" title="抽象类与接口比较"></a>抽象类与接口比较</h2><ul><li>一个类只能继承一个抽象类，但可以实现多个接口；</li><li>接口中的字段只能是 <code>static</code> 和 <code>final</code> 的，而抽象类的字段没有限制；</li><li>接口中的方法只能是 <code>public</code> 的，而抽象类的方法则没有限制。</li></ul><p>一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 <code>Java8</code> 开始也增加了默认方法，使得修改接口的成本也降低很多。</p><p>如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。</p><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><p>在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。</p><p>所以从 <code>Java8</code> 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，Java 8 中 List 接口的 sort 方法就是默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="inline-toc">1.</span><strong>可选方法</strong></p><p>默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。</p><p>例如，在 <code>Java8</code> 中，<code>Iterator</code> 接口为 <code>remove</code> 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 <code>Iterator</code> 接口的每一个类都声明一个空的 <code>remove</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnSupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="inline-toc">2.</span><strong>行为的多继承</strong></p><p>默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveHorizontally</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setX(getX() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">resizeWidth</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setWidth(getWidth() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">Moveable</span>, <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Change c = <span class="keyword">new</span> Change();</span><br><span class="line">        c.moveHorizontally(<span class="number">10</span>);</span><br><span class="line">        c.resizeWidth(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p><code>Java</code> 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。</p><p><strong>第一条规则</strong></p><p>在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello form B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。</p><p><strong>第二条规则</strong></p><p>如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello form B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello form B</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。</p><p><strong>第三条规则</strong></p><p>如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello from A</span></span><br></pre></td></tr></table></figure><p>上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 <code>hello</code> 方法，并且在调用时，使用 <code>X.super.f()</code> 这种语法，显式地指定使用哪一个接口中的方法。</p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>从外部类对象的非静态方法之外的任意位置创建某个内部类的对象，那么必须指明这个对象的类型：<code>OuterClassName.InnerClassName</code>。而且当生成一个内部类对象时，内部类对象会拥有一个指向外部类对象的引用，也就拥有了外围类所有成员的访问权。</p><p>要想创建内部类对象，必须使用外部类的对象来创建，这需要使用 .new 语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在内部类中如果想要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outer <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Outer.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.new Inner();</span><br><span class="line">        inner.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outer.f()</span></span><br></pre></td></tr></table></figure><p><strong style="color:#000000;font-size:16px">匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"inner class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"inner subclass: "</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Inner inner = outer.inner(<span class="string">"Inner"</span>);</span><br><span class="line">        inner.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inner subclass: Inner</span></span><br></pre></td></tr></table></figure><p>上面就是一个匿名内部类的例子，表示创建一个继承自 Inner 的匿名类的对象。在匿名内部类中，一般使用默认的构造器来生成内部类。另外，如果在匿名内部类希望使用一个在外部定义的对象，那么必须将其声明为 final。</p><p>但是匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但两者不能兼备。它只能扩展一个类或者只实现一个接口。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>接口一般用来实现多重继承，而生成遵循某个接口的对象可以使用工厂设计模式。一般在工厂对象上调用的是创建方法，而该工厂对象会生成接口的某个实现的对象。</p><p>工厂模式的实现在使用匿名内部类时会更加优雅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Checkers</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Checkers move "</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameFactory factory = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">(GameFactory factory)</span> </span>&#123;</span><br><span class="line">        Game g = factory.getGame();</span><br><span class="line">        <span class="keyword">while</span>(s.move()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        playGame(Checkers.factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Checkers move 0</span></span><br><span class="line"><span class="comment">// Checkers move 1</span></span><br><span class="line"><span class="comment">// Checkers move 2</span></span><br></pre></td></tr></table></figure><p>可以看到，在使用匿名内部类时，构造器都是 private 的，并且没有任何必须去创建一个额外的工厂类。另外，对于经常只需要单一的工厂对象，也被创建为 static。</p><h2 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h2><p>嵌套类，也就是静态内部类，要创建嵌套类对象，不需要外部类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"static inner class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static inner class</span></span><br></pre></td></tr></table></figure><p>与内部类相比，区别如下：</p><ul><li>创建内部类需要外部类的对象；嵌套类不需要外围类的对象</li><li>内部类不可以定义静态成员变量；嵌套类可以定义静态成员变量</li><li>内部类可以访问外部类的成员变量；嵌套类不可以访问非静态的外部类的成员变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h2&gt;&lt;p&gt;抽象方法指的是仅有声明而没有方法体的方法。使用 &lt;code&gt;abstract&lt;/code&gt; 关键字进行声明：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而包含一个或多个抽象方法的类，就叫抽象类，用 &lt;code&gt;abstract&lt;/code&gt;关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>数据类型与运算</title>
    <link href="https://blog.timberliu.com/2018/11/03/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97/"/>
    <id>https://blog.timberliu.com/2018/11/03/数据类型与运算/</id>
    <published>2018-11-02T16:00:00.000Z</published>
    <updated>2018-11-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p><code>Java</code> 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下：</p><p><img src="http://media.timberliu.com/image/2018/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png" width="80%"><br><a id="more"></a><br><code>Java</code> 中的 <code>char</code> 使用 <code>Unicode</code> 编码，占两个字节。所以在 <code>Unicode</code> 编码中存在的中文，都可以用 <code>char</code> 存储。</p><p>在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：<a href="https://blog.csdn.net/qq_23418393/article/details/57421688" target="_blank" rel="noopener">Java中，为什么 <code>byte</code> 类型的取值范围为-128~127?</a>。</p><p>浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。<code>Java</code> 中使用 <code>IEEE754</code>表示法，分为单精度和双精度两种，也就是 <code>float</code> 和 <code>double</code>，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。</p><h2 id="包装类型"><a href="#包装类型" class="headerlink" title="包装类型"></a>包装类型</h2><p>每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别：</p><ul><li>默认值不同。基本类型的默认值为 0、<code>false</code> 等；而包装类默认为 <code>null</code></li><li>初始化不同。基本类型不需要初始化；而包装类需要 <code>new</code>。</li><li>存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中</li><li>元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法</li></ul><p>基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 <code>Java5</code> 提供的一个语法糖。自动装箱就是 <code>Java</code>自动将原始类型值转换为对应的对象；自动拆箱就是 <code>Java</code> 自动将对象转换为对应的基本类型。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Integer n = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译后，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    Integer n = Integer.valueOf(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，自动装箱就是调用 <code>Integer</code> 的 <code>valueOf()</code> 方法实现的；而自动拆箱是调用 <code>Integer</code> 的 <code>xxxValue()</code> 方法实现的。</p><h2 id="整型的缓存机制"><a href="#整型的缓存机制" class="headerlink" title="整型的缓存机制"></a>整型的缓存机制</h2><p><code>Java5</code> 中，<code>Integer</code> 引入了一个新功能来节省内存和提高性能。在使用 <code>Integer.valueOf()</code>方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。</p><p><code>valueOf()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 <code>Integer</code> 对象。</p><p><code>IntegerCache</code> 是 <code>Integer</code> 的一个内部类，缓存池的大小默认为 <code>-128~127</code>。最大值可通过 <code>-XX:AutoBoxCacheMax=xxx</code> 修改。这个缓存在 <code>Integer</code> 类第一次被使用时，通过一个 <code>for</code> 循环存储在一个整数数组中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于编译器在自动装箱时会调用 <code>valueOf</code> 方法，所以创建多个相同的值时，会引用相同的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer i = <span class="number">123</span>;</span><br><span class="line">    Integer j = <span class="number">123</span>;</span><br><span class="line">    System.out.println(i == j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>所有的包装类都有类似的缓存机制：</p><ul><li><code>ByteCache</code> 可以缓存 <code>Byte</code> 对象</li><li><code>ShortCache</code> 可以缓存 <code>Short</code> 对象</li><li><code>LongCache</code> 可以缓存 <code>Long</code> 对象</li><li><code>CharacterCache</code> 可以缓存 <code>Character</code> 对象</li></ul><p><code>Byte</code>、<code>Short</code>、<code>Long</code> 的缓存范围都是固定的，为 <code>-128~127</code>。而 <code>CharacterCache</code> 的范围为 <code>0~127</code>。除了 <code>Integer</code>，这个范围都不能改变。</p><h2 id="高精度类型"><a href="#高精度类型" class="headerlink" title="高精度类型"></a>高精度类型</h2><p>Java 还提供了两个用于高精度计算的类：<code>BigInteger</code> 和 <code>BigDecimal</code>。</p><ul><li><code>BigInteger</code> 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。</li><li><code>BigDecimal</code> 支持任意精度的定点数。可以用它进行精确的货币运算。</li></ul><p>在 <code>Java</code> 中，对于金额的运算和在数据库中的存储，一般有两种方式：</p><ul><li>以元为单位。Java 中存储类型为 <code>BigDecimal</code>，在数据库中的存储类型为 <code>number(10, 2)</code>，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。</li><li>以分为单位。<code>Java</code> 中存储类型为 <code>Long</code>，在数据库中存储类型为 <code>big int</code>。取整和保留方式如前面一样。</li></ul><p>看一下下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">    BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">    BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">    <span class="comment">// 保留两位小数，使用四舍五入模式</span></span><br><span class="line">    <span class="keyword">return</span> b1.divide(b2, <span class="number">2</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行金额运算时，使用 <code>BigDecimal</code> 类，并且将 <code>double</code> 转为 <code>String</code> 类型进行运算。在使用 <code>divide</code> 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。</p><h2 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h2><p>先来看一下值传递与引用传递的概念：</p><ul><li>值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。</li><li>引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。<!-- more -->那么 <code>Java</code> 中到底是值传递还是引用传递？先来看下面的例子：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    j = <span class="number">2</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: j = "</span> + j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    change(i);</span><br><span class="line">    System.out.println(<span class="string">"main: i = "</span> + i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: j = 2</span></span><br><span class="line"><span class="comment">// main: i = 1</span></span><br></pre></td></tr></table></figure><p>可以看到，<code>change</code> 方法内部并没有改变实际参数的值，那么 <code>Java</code> 就是值传递吗？再来看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    user.setAge(<span class="number">21</span>);</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">"Timber"</span>);</span><br><span class="line">    user.setAge(<span class="number">20</span>);</span><br><span class="line">    change(user);</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: User&#123;name='Timber', age=21&#125;</span></span><br><span class="line"><span class="comment">// main: User&#123;name='Timber', age=21&#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，实际参数的值被改变了，那么 <code>Java</code> 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String name2)</span> </span>&#123;</span><br><span class="line">    name2 = <span class="string">"TimberLiu"</span>;</span><br><span class="line">    System.out.println(<span class="string">"change: "</span> + name2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String name1 = <span class="string">"Timber"</span>;</span><br><span class="line">    change(name1);</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + name1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: TimberLiu</span></span><br><span class="line"><span class="comment">// main: Timber</span></span><br></pre></td></tr></table></figure><p>可以看到，实际参数的值又被改变了，这又作何解释呢？</p><h2 id="Java-的值传递"><a href="#Java-的值传递" class="headerlink" title="Java 的值传递"></a>Java 的值传递</h2><p>其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 <strong>传递参数时是否会进行拷贝，创建一个副本</strong>。</p><p>再来看一下上面的第二个例子，是如何传递的呢？</p><p><img src="http://phra9vo17.bkt.clouddn.com/image/2018/11/%E5%80%BC%E4%BC%A0%E9%80%921.png" width="80%"></p><p>可以看到，当把 <code>user</code> 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(User user2)</span> </span>&#123;</span><br><span class="line">    user2 = <span class="keyword">new</span> User();</span><br><span class="line">    user2.setName(<span class="string">"TimberLiu"</span>);</span><br><span class="line">    user2.setAge(<span class="number">21</span>);</span><br><span class="line">    System.out.println(<span class="string">"change:"</span> + user2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    User user1 = <span class="keyword">new</span> User();</span><br><span class="line">    user1.setName(<span class="string">"Timber"</span>);</span><br><span class="line">    user1.setAge(<span class="number">20</span>);</span><br><span class="line">    change(user1);</span><br><span class="line">    System.out.println(<span class="string">"main: "</span> + user1);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// change: User&#123;name='TimberLiu', age=21&#125;</span></span><br><span class="line"><span class="comment">// main: User&#123;name='Timber', age=20&#125;</span></span><br></pre></td></tr></table></figure><p>这个过程发生了什么呢？看下图：</p><p><img src="http://media.timberliu.com/image/2018/11/%E5%80%BC%E4%BC%A0%E9%80%922.png" width="80%"></p><p>可以看到，这里把 <code>user1</code> 传递给 <code>change</code> 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 <code>change</code> 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 <code>user2</code> 的修改并不会影响到 <code>user1</code> 中的内容。</p><p>所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。</p><p>那么，为什么上面在传递 <code>String</code> 对象和 <code>User</code> 对象结果不一样呢？这是因为 <code>String</code> 类型是不可变的，在赋值 <code>name2 = &quot;TimberLiu&quot;</code> 时，会重新创建一个 <code>String</code>，而并没有修改实际参数的值。</p><p><img src="http://media.timberliu.com/image/2018/11/%E5%80%BC%E4%BC%A0%E9%80%923.png" width="80%"></p><p>所以，<strong>Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用</strong>。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p><code>Java</code> 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下：</p><p><img src="http://media.timberliu.com/image/2018/11/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" width="80%"></p><p>在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。</p><p>另外，在对基本数据进行运算时，所有 <code>byte</code>、<code>short</code>、<code>char</code> 类型的值都会自动被提升为 <code>int</code>。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。</p><p>在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overflow</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> big = Integer.MAX_VALUE;</span><br><span class="line">        System.out.println(<span class="string">"big = "</span> + big);</span><br><span class="line">        System.out.println(<span class="string">"bigger = "</span> + (big + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// big = 2147483647</span></span><br><span class="line"><span class="comment">// bigger = -2147483648</span></span><br></pre></td></tr></table></figure><h2 id="switch-对-String-的支持"><a href="#switch-对-String-的支持" class="headerlink" title="switch 对 String 的支持"></a>switch 对 String 的支持</h2><p><code>switch</code> 原本只支持整型，而 <code>byte</code>、<code>short</code>、<code>char</code> 可以转换为 <code>int</code> 型，所以也可以使用。但从 <code>Java7</code> 开始，在 <code>switch</code> 条件判断语句中也可以使用 <code>String</code> 类型了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decompile</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(str) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"aaa"</span>:</span><br><span class="line">            System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"bbb"</span>:</span><br><span class="line">            System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            System.out.println(<span class="string">"other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在反编译后，可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decompile</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> var3 = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">96321</span>:</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">"aaa"</span>)) &#123;</span><br><span class="line">            var3 = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">97314</span>:</span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">"bbb"</span>)) &#123;</span><br><span class="line">            var3 = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(var3) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">"bbb"</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        System.out.println(<span class="string">"other"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>String</code> 的 <code>switch</code> 还是比较的 <code>byte</code> 类型。先声明了一个 <code>byte</code> 类型，然后通过 <code>hashCode</code> 和 <code>equals</code> 两个方法先后进行比较来赋予 <code>byte</code> 变量不同的值，最后 <code>switch</code> 来执行不同的代码。这里在 <code>hash</code> 之后再进行 <code>equals</code> 判断是有必要的，因为 <code>hash</code> 可能发生碰撞。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>Hollis：<a href="https://www.hollischuang.com/archives/1174" target="_blank" rel="noopener">[译]Java中整型的缓存机制</a></li><li>Hollis：<a href="https://mp.weixin.qq.com/s/F7Niaa7nD1tLApCEGKAj4A" target="_blank" rel="noopener">为什么说Java中只有值传递</a></li><li>SEU_Calvin：<a href="https://blog.csdn.net/seu_calvin/article/details/70089977" target="_blank" rel="noopener">Java技术——Java中的参数传值方式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://media.timberliu.com/image/2018/11/%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png&quot; width=&quot;80%&quot;&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象中的一些概念</title>
    <link href="https://blog.timberliu.com/2018/11/01/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5/"/>
    <id>https://blog.timberliu.com/2018/11/01/面向对象概念/</id>
    <published>2018-10-31T16:00:00.000Z</published>
    <updated>2018-10-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this、super"><a href="#this、super" class="headerlink" title="this、super"></a>this、super</h2><p><code>this</code> 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 <code>this</code> 调用构造器，但必须将构造器置于最起始处。<a id="more"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name);</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>super</code> 关键字表示如果子类重写了父类的某个方法，可以通过 <code>super</code> 关键字来调用父类的方法实现，也可以用来调用父类的构造器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">":"</span> + age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age);</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.say();</span><br><span class="line">        System.out.println(name + <span class="string">":"</span> + age + <span class="string">","</span> + score);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student(<span class="string">"Timber"</span>, <span class="number">20</span>, <span class="number">80</span>);</span><br><span class="line">        student.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Timber:20</span></span><br><span class="line"><span class="comment">// Timber:20,80</span></span><br></pre></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><code>final</code> 关键字可用于三种情况：变量、方法和类。</p><p><span id="inline-toc">1.</span><strong>变量</strong></p><p>对于基本类型时，<code>final</code> 使数值恒定不变；对于引用类型时，<code>final</code> 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。</p><p>另外，在参数列表中还可以将参数声明为 <code>final</code>，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。</p><p><span id="inline-toc">2.</span><strong>方法</strong></p><p>final 方法不可以被重写。</p><p>类中所有的 <code>private</code> 方法都隐式地指定为 <code>final</code>，所以 <code>private</code> 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。</p><p><span id="inline-toc">3.</span><strong>类</strong></p><p><code>final</code> 类不能被继承，而且 <code>final</code> 类中的所有方法都隐式地被指定为 <code>final</code>，无法覆盖它们。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 <code>static</code> 方法或访问其 <code>static</code> 域。</p><p><span id="inline-toc">1.</span><strong>变量</strong></p><p>当 <code>static</code> 作用于某个字段时，会改变数据的创建方式，因为 <code>static</code> 字段对每个类只有一份存储空间，存放在方法区中；而非 <code>static</code> 字段则对每个对象都有一个存储空间，存放在堆中。</p><p><span id="inline-toc">2.</span><strong>方法</strong></p><p>对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 <code>this</code> 关键字。而 <code>static</code> 方法就是没有 <code>this</code> 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 <code>static</code> 方法，实际上这正是 <code>static</code> 方法的主要用途。</p><p><span id="inline-toc">3.</span><strong>静态块</strong></p><p><code>Java</code> 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class User &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        name = <span class="string">"Timber"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。</p><h2 id="重写与重载"><a href="#重写与重载" class="headerlink" title="重写与重载"></a>重写与重载</h2><p><span id="inline-toc">1.</span><strong>重写</strong></p><p>重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do something"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"studying"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person = <span class="keyword">new</span> Student();</span><br><span class="line">        person.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// studying</span></span><br></pre></td></tr></table></figure><p>上面就是一个重写的例子。重写一般需要注意以下几点：</p><ul><li>子类方法的方法签名必须和父类方法相同；</li><li>子类方法的返回类型必须小于等于父类的方法；</li><li>子类中的访问权限必须大于等于父类的方法；</li><li>子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常</li><li>不能重写被标识为 final 的方法</li></ul><p>重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"person"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    String s = <span class="string">"student"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person a1 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"a1.s: "</span> + a1.s);</span><br><span class="line">        Student a2 = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"a2.s: "</span> + a2.s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a1.s: person</span></span><br><span class="line"><span class="comment">// a2.s: student</span></span><br></pre></td></tr></table></figure><p><span id="inline-toc">2.</span><strong>重载</strong></p><p>重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"studying"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(String thing)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"studying "</span> + thing);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个重载的例子。重载一般需要注意几点：</p><ul><li>被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。</li><li>根据方法的返回值不能区分重载</li><li>重载涉及到基本类型的自动提升时可能会造成混淆。</li></ul><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><p>构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 <code>new</code> 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。</p><p>一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 <code>new Person()</code> 创建对象时就会报错。</p><p>对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 <code>int</code> 初始化为 <code>0</code>，引用类型初始化为 <code>null</code>等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。</p><p>对象的创建过程如下：</p><ul><li>当首次创建类对象，或者类的静态方法/静态域被首次访问时，<code>Java</code> 解释器查找类文件；</li><li>然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。</li><li>如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 <code>null</code>；</li><li>然后执行出现于成员变量定义处的初始化动作；</li><li>然后再执行构造器。</li></ul><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件：</p><ul><li>有类继承或接口实现</li><li>子类要重写父类的方法</li><li>父类的引用指向子类的对象</li></ul><p>根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;this、super&quot;&gt;&lt;a href=&quot;#this、super&quot; class=&quot;headerlink&quot; title=&quot;this、super&quot;&gt;&lt;/a&gt;this、super&lt;/h2&gt;&lt;p&gt;&lt;code&gt;this&lt;/code&gt; 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 &lt;code&gt;this&lt;/code&gt; 调用构造器，但必须将构造器置于最起始处。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象思想与 Java 平台</title>
    <link href="https://blog.timberliu.com/2018/10/28/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E4%B8%8EJava%E5%B9%B3%E5%8F%B0/"/>
    <id>https://blog.timberliu.com/2018/10/28/面向对象思想与Java平台/</id>
    <published>2018-10-27T16:00:00.000Z</published>
    <updated>2018-10-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习 <code>Java</code> 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。</p></blockquote><p><code>Java</code> 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 <code>Java</code> 平台又该如何理解？今天就来学习一下。<a id="more"></a></p><h2 id="面向对象思想"><a href="#面向对象思想" class="headerlink" title="面向对象思想"></a>面向对象思想</h2><p>所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。</p><p>而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。</p><p>在面向对象程序设计中会创建抽象数据类型，也就是类 <code>class</code>，它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。</p><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><p><span id="inline-toc">1.</span><strong>封装</strong></p><p>封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。</p><p>Java 用三个关键字在类内设定边界：<code>public</code>、<code>protected</code>、<code>private</code>，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。</p><p><span id="inline-toc">2.</span><strong>继承</strong></p><p>代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 <code>private</code>，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。</p><p>另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写 <code>overriding</code>。</p><p>那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。</p><p><span id="inline-toc">3.</span><strong>多态</strong></p><p>在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。</p><p>在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。</p><h2 id="五大设计原则"><a href="#五大设计原则" class="headerlink" title="五大设计原则"></a>五大设计原则</h2><p>面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。</p><ul><li><p>单一职责（<code>Single Responsibility</code>）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。  </p></li><li><p>开关封闭（<code>Open-Closed</code>）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。</p></li><li><p>里氏替换（<code>Liskov Substitution</code>）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。</p></li><li><p>接口隔离（<code>Interface-Segregation</code>）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。</p></li><li><p>依赖倒置（<code>Dependency Inversion</code>）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。</p></li></ul><p>对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。</p><h2 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h2><p>先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：<code>C/C++</code> 等。</p><p>解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：<code>Java</code>、<code>python</code> 等。</p><p>严格来说，传统的 <code>Java</code> 是解释型语言，但加入了 <code>JIT</code>、<code>AOT</code> 编译器后，让 <code>Java</code> 也拥有了编译型语言的特性。它总共有三种执行的方式：</p><ul><li><code>Java</code> 源代码首先经过 <code>Javac</code> 编译成 <code>.class</code> 文件，然后：<ul><li>解释执行：<code>.class</code> 文件经过 JVM 内嵌的解释器解释执行。  </li><li>编译执行：即时编译器（<code>Just In Time</code> 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热）</li></ul></li><li>编译执行: <code>Java</code> 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成）</li></ul><h2 id="Java-与-C-的区别"><a href="#Java-与-C-的区别" class="headerlink" title="Java 与 C++ 的区别"></a>Java 与 C++ 的区别</h2><p><code>Java</code> 和 <code>C++</code> 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：<code>C++</code> 是编译型语言，<code>Java</code> 是解释型语言。</p><p>二者主要区别如下：</p><table><thead><tr><th>-</th><th>Java</th><th>C++</th></tr></thead><tbody><tr><td>语言类型</td><td>解释型</td><td>编译型 </td></tr><tr><td>平台相关性</td><td>跨平台</td><td>平台相关的</td></tr><tr><td>语言</td><td>纯粹的面向对象语言</td><td>既支持面向对象也支持面向过程</td></tr><tr><td>数字类型</td><td>在所有平台上基本类型<br>有标准的范围限制和字节长度</td><td>对数字类型有标准的范围限制<br>但字节长度跟具体实现有关</td></tr><tr><td>参数传递</td><td>只有值传递<br>它的引用可以理解为安全指针</td><td>有值传递和引用传递</td></tr><tr><td>内存管理</td><td>自动垃圾回收</td><td>需要显示的内存管理，支持析构函数</td></tr><tr><td>继承与实现</td><td>支持多重继承</td><td>只允许单继承，但可以多实现</td></tr><tr><td>操作符</td><td>不支持操作符重载<br>仅对 String 有两个内置的加法运算</td><td>支持操作符重载</td></tr></tbody></table><h2 id="JDK、JRE、JVM"><a href="#JDK、JRE、JVM" class="headerlink" title="JDK、JRE、JVM"></a>JDK、JRE、JVM</h2><p>下图是 <code>Oracle</code> 官方文档中的 <code>JDK</code>、<code>JRE</code>、<code>JVM</code> 三者间的关系：</p><p><img src="http://media.timberliu.com/image/blog/2018/11/jdk_jre_jvm.png" width="80%"></p><p>三者详细：</p><ul><li>JDK：<code>Java Development Kit</code>（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。</li><li>JRE: <code>Java Runtime Enviroment</code>（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。</li><li>JVM：<code>Java Virtual Machine</code>（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。</li></ul><h2 id="跨平台特性"><a href="#跨平台特性" class="headerlink" title="跨平台特性"></a>跨平台特性</h2><p><code>Java</code> 的跨平台特性与 <code>Java</code> 虚拟机的存在密不可分。其实 <code>Java</code> 语言本身与其他编程语言没有特别大的差异，并不是说 <code>Java</code> 语言可以跨平台，而是在不同的平台都有可以让 <code>Java</code> 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 <code>JDK</code>，安装 <code>JDK</code> 也就有了 <code>Java</code> 的运行环境。</p><p>简单来说，<code>Java</code> 首先通过 <code>javac</code> 编译器将源码编译为字节码 <code>.class</code> 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 <code>JVM</code> 会可以根据不同的平台，使用不同的 <code>JVM</code> 映射规则，生成对应的机器码，让其与操作系统无关。所以 <code>Java</code> 才有了“编译一次，到处运行”的效果。</p><h2 id="Java-平台"><a href="#Java-平台" class="headerlink" title="Java 平台"></a>Java 平台</h2><p><code>Java</code> 是一种面向对象的语言，最显著的特性有两个方面：   </p><ol><li>跨平台特性。也就是“编译一次，到处运行”（<code>Compile once, run anywhere</code>)，能够非常容易地获得跨平台能力；</li><li>垃圾回收机制。<code>Java</code> 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。<!-- more -->  </li></ol><p>对于 <code>Java</code> 平台，有很多个方面可以谈：</p><ul><li><code>Java</code> 语言特性：面向对象特性、泛型、<code>Lamdba</code> 等</li><li>基础类库：集合、<code>IO/NIO</code>、网络、并发等基础类库</li><li><code>JVM</code>：类加载机制、垃圾回收、常用工具</li><li><code>Java</code> 生态：<code>JavaEE</code>、<code>Spring</code>、<code>Maven</code>、<code>Hadoop</code> 等</li></ul><p>下图是总结的一个蓝图：</p><p><img src="http://media.timberliu.com/image/2018/11/Java%E5%B9%B3%E5%8F%B0.png" width="90%"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li>《Java 编程思想》</li><li>Hollis：<a href="https://www.hollischuang.com/archives/220" target="_blank" rel="noopener">牢记面向对象五个基本原则</a></li><li>十四期_李光：<a href="https://blog.csdn.net/jerry11112/article/details/79027834" target="_blank" rel="noopener">面向对象与面向过程的本质的区别</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;学习 &lt;code&gt;Java&lt;/code&gt; 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 &lt;code&gt;Java&lt;/code&gt; 平台又该如何理解？今天就来学习一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="面向对象" scheme="https://blog.timberliu.com/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
</feed>
