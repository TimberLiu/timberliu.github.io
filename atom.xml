<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimberLiu&#39;s Blog</title>
  
  <subtitle>Easy coding, easy life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.timberliu.com/"/>
  <updated>2019-04-16T16:00:00.000Z</updated>
  <id>https://blog.timberliu.com/</id>
  
  <author>
    <name>TimberLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>剑指 offer (2) —— 链表篇</title>
    <link href="https://blog.timberliu.com/2019/04/17/042_%E5%89%91%E6%8C%87offer%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.timberliu.com/2019/04/17/042_剑指offer之链表/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中对剑指 <code>offer</code> 中数组相关的题目进行了归纳，这一篇文章是链表篇。同样地，如果各位大佬发现程序有什么 <code>bug</code> 或其他更巧妙的思路，欢迎交流学习。<a id="more"></a></p><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a>6. 从尾到头打印链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个链表的头节点，从尾到头打印链表的每个节点的值。</p></blockquote><p>这里可以用显式栈，或者递归来实现，都比较简单，也就不多做解释了。</p><p><strong>递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = printListFromTailToHead(listNode.next);</span><br><span class="line">    list.add(listNode.val);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ListNode node = listNode;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h2><p><strong>题目一描述</strong></p><blockquote><p>在 O(1) 时间内删除链表指定节点。给定单链表的头节点引用和一个节点引用，要求在 O(1) 时间内删除该节点。</p></blockquote><p><strong>解题思路</strong></p><p>一般来说，要在单向链表中删除指定节点，需要得到被删除节点的前驱节点。但这需要从头节点开始顺序查找，时间复杂度肯定不是 <code>O(1)</code> 了，所以需要换一种思路。</p><p>我们可以将后继节点的值赋值给要删除的指定节点，再删除下一个节点，如此也同样实现了删除指定节点的功能。但是还需要注意两种特殊情况：</p><ul><li>第一种是要删除的节点是头节点，这时还需要对链表的头结点进行更新；</li><li>第二种是要删除的节点是尾节点，它没有下一个节点，这时就只能从头节点开始顺序查找要删除节点的前驱节点了。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteNode</span><span class="params">(Node head, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head == node) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点是头节点</span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点是尾节点</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != node) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点在链表中间</span></span><br><span class="line">        ListNode nextNode = node.next;</span><br><span class="line">        node.val = nextNode.val;</span><br><span class="line">        node.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里除了最后一个节点，其他节点都可以在 <code>O(1)</code> 时间内删除，只有要删除的节点是尾节点时，才需要对链表进行遍历，所以，总体的时间复杂度还是 <code>O(1)</code>。</p><p><strong>题目二描述</strong></p><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p></blockquote><p><strong>解题思路</strong></p><p>这里要删除排序链表中的重复节点，由于头节点也可能被删除，所以需要对头节点特殊处理，或者添加一个虚拟节点。这里选择使用虚拟节点。</p><p>由于这里需要判断当前节点和下一个节点的值，所以循环中条件就是要判断当前节点和下一个节点均不能为空。如果这两个值不相等，则继续遍历。</p><p>如果不相等，则循环判断跳过连续重复的数个节点，最后 <code>cur</code> 指向这些重复节点的最后一个。由于重复节点不保留，所以需要让 <code>pre.next</code> 指向 <code>cur.next</code>，再更新 <code>cur</code> 为下一个节点 <code>pre.next</code>，进而继续判断。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteDuplication</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node dummyHead = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">    Node pre = dummyHead;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.value != cur.next.value) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.value == cur.next.value) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里虽然有两层嵌套循环，但实际上只对链表遍历了一遍，所以其时间复杂度为 <code>O(n)</code>。另外只申请了一个虚拟节点，所以空间复杂度为 <code>O(1)</code>。</p><h2 id="22-链表中倒数第-k-个节点"><a href="#22-链表中倒数第-k-个节点" class="headerlink" title="22. 链表中倒数第 k 个节点"></a>22. 链表中倒数第 k 个节点</h2><p><strong>题目描述</strong></p><p>输入一个链表，输出该链表中倒数第 k 个结点。（k 从 1 开始）</p><p><strong>解题思路</strong></p><p>这里可以定义两个指针。第一个指针从链表头开始遍历，向前移动 <code>k - 1</code> 步。然后从 <code>k</code> 步开始，第二个指针也开始从链表头开始遍历。</p><p>由于两个指针的距离为 <code>k - 1</code>，所有当第一个指针移动到链表的尾节点时，第二个指针正好移动到倒数第 <code>k</code> 个节点。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23. 链表中环的入口节点"></a>23. 链表中环的入口节点</h2><p><strong>题目描述</strong></p><blockquote><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p></blockquote><p><strong>解题思路</strong></p><p>首先需要判断链表是否有环，可以使用两个指针，同时从链表的头部开始遍历，一个指针一次走一步，一个指针一次走两步。如果快指针能追上慢指针，则表示链表有环；否则如果快指针走到了链表的末尾，表示没有环。</p><p>在找到环之后，定义一个指针指向链表的头节点，再选择刚才的慢指针从快慢指针的相遇节点开始，两个指针同时以每次一步向前移动，它们相遇的节点就是链表的入口节点。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode slow = pHead.next;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode p = pHead;</span><br><span class="line">    <span class="keyword">while</span>(slow != p) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p><strong>循环解决</strong></p><p>思路如下图：</p><p><img src="http://media.timberliu.com/image/2019/4/17/%E9%93%BE%E8%A1%A8-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC2.jpg" width="80%"></p><p><strong>循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode nex;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nex = cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = newHead;</span><br><span class="line">        newHead = cur;</span><br><span class="line">        <span class="comment">// 记录</span></span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归解决</strong></p><p><img src="http://media.timberliu.com/image/2019/4/17/%E9%93%BE%E8%A1%A8-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC.jpg" width="80%"></p><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = reverseList2(head.next);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-合并两个有序的链表"><a href="#25-合并两个有序的链表" class="headerlink" title="25. 合并两个有序的链表"></a>25. 合并两个有序的链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><p><strong>循环解题</strong></p><p>在使用循环时，首先需要确定新链表的头节点，如果链表 <code>first</code> 的头节点的值小于链表 <code>second</code> 的头节点的值，那么链表 <code>first</code> 的头节点便是新链表的头节点。</p><p>然后循环处理两个链表中剩余的节点，如果链表 <code>first</code> 中的节点的值小于链表 <code>second</code> 中的节点的值，则将链表 <code>first</code> 中的节点添加到新链表的尾部，否则添加链表 <code>second</code> 中的节点。然后继续循环判断，直到某一条链表为空。</p><p>当其中一条链表为空后，只需要将另一条链表全部链接到新链表的尾部。</p><p>思路图如下：</p><p><img src="http://media.timberliu.com/image/2019/4/17/%E9%93%BE%E8%A1%A8-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6.jpg" width="80%"></p><p><strong>循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge1</span><span class="params">(ListNode first, ListNode second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (second == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p = first;</span><br><span class="line">    ListNode q = second;</span><br><span class="line">    ListNode newHead;</span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">        newHead = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = q;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode r = newHead;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">            r.next = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.next = q;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        r = r.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.next = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归解题</strong></p><p>使用递归解决，比较简单。首先判断两条链表是否为空，如果 <code>first</code> 为空，则直接返回 <code>second</code>；如果 <code>second</code> 为空，则直接返回 <code>first</code>。</p><p>接着判断链表 <code>first</code> 中节点的值和链表 <code>second</code> 中节点的值，如果 <code>first</code> 中节点的值较小，则递归地求 <code>first.next</code> 和 <code>second</code> 的合并链表，让 <code>first.next</code> 指向新的链表头节点，然后返回 <code>first</code> 即可。</p><p>另一种情况类似，这里就不再赘述了。</p><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge2</span><span class="params">(ListNode first, ListNode second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (second == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.val &lt; second.val) &#123;</span><br><span class="line">        first.next = merge2(first.next, second);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        second.next = merge2(first, second.next);</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p></blockquote><p><strong>解题思路</strong></p><p>这可以分为三步来解决。第一步是根据原始链表的所有节点，将每一节点的复制节点链接到它的后面。</p><p>第二步设置复制出来的节点的特殊指针。如果原始链表的节点 <code>p</code> 的特殊指针指向节点 <code>s</code>，则复制出来的节点 <code>cloned</code> 的特殊指针就指向节点 <code>s</code> 的下一个节点。</p><p>第三部是将长链表拆分成两个链表，把所有偶数位置的节点连接起来就是新的复制出来的链表。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    cloneNodes(head);</span><br><span class="line">    connectSiblingNode(head);</span><br><span class="line">    <span class="keyword">return</span> reconnectNodes(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cloneNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode newNode = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">        newNode.next = p.next;</span><br><span class="line">        p.next = newNode;</span><br><span class="line">        p = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSiblingNode</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode cloned = p.next;</span><br><span class="line">        <span class="keyword">if</span>(p.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cloned.random = p.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = cloned.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RandomListNode <span class="title">reconnectNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode p = head;</span><br><span class="line">    </span><br><span class="line">    RandomListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode tail = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail = newHead = p.next;</span><br><span class="line">        p.next = tail.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail.next = p.next;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        p.next = tail.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a>36. 二叉搜索树与双向链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p></blockquote><p><strong>解题思路</strong></p><p>这里将二叉搜索树转换为一个排序的双向链表，可以采用使用递归算法。</p><p>首先递归地转换左子树，返回其链表头节点，然后需要遍历该链表，找到链表的尾节点，这是为了和根节点相连接。需要让链表的尾节点的 <code>right</code> 指向根节点，让根节点的 <code>left</code> 指向链表的尾节点。</p><p>然后递归地转换右子树，返回其链表头节点，然后需要让根节点的 <code>right</code> 指向链表头节点，让链表的头节点指向根节点。</p><p>最后判断如果左子树转换的链表为空，则返回以 <code>root</code> 根节点为头节点的链表，否则返回以左子树最小值为头节点的链表。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode leftHead = Convert(root.left);</span><br><span class="line">    TreeNode leftEnd = leftHead;</span><br><span class="line">    <span class="keyword">while</span>(leftEnd != <span class="keyword">null</span> &amp;&amp; leftEnd.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftEnd = leftEnd.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftEnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftEnd.right = root;</span><br><span class="line">        root.left = leftEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode rightHead = Convert(root.right);</span><br><span class="line">    <span class="keyword">if</span>(rightHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.right = rightHead;</span><br><span class="line">        rightHead.left = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> leftHead == <span class="keyword">null</span> ? root : leftHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a>52. 两个链表的第一个公共节点</h2><p><strong>题目描述</strong></p><blockquote><p>输入两个链表，找出它们的第一个公共结点。</p></blockquote><p><strong>解题思路</strong></p><p>对于两个链表，如果有公共节点，要不它们就是同一条链表，要不它们的公共节点一定在公共链表的尾部。</p><p>可以遍历两个链表得到它们的长度，然后在较长的链表上，先走它们的长度差的步数，接着同时在两个链表上遍历，如此找到的第一个节点就是它们的第一个公共节点。</p><p><strong>代码实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public ListNode findFirstCommonNode(ListNode first, ListNode second) &#123;</span><br><span class="line">    int length1 = getListLength(first);</span><br><span class="line">    int length2 = getListLength(second);</span><br><span class="line"></span><br><span class="line">    ListNode headLongList = first;</span><br><span class="line">    ListNode headShortList = second;</span><br><span class="line">    int diff = length1 - length2;</span><br><span class="line"></span><br><span class="line">    if (length1 &lt; length2) &#123;</span><br><span class="line">        headLongList = second;</span><br><span class="line">        headShortList = first;</span><br><span class="line">        diff = length2 - length1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; diff; i++) &#123;</span><br><span class="line">        headLongList = headLongList.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (headLongList != null &amp;&amp; headShortList != null) &#123;</span><br><span class="line">        if (headLongList == headShortList) &#123;</span><br><span class="line">            return headLongList;</span><br><span class="line">        &#125;</span><br><span class="line">        headLongList = headLongList.next;</span><br><span class="line">        headShortList = headShortList.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getListLength(ListNode head) &#123;</span><br><span class="line">    int length = 0;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中对剑指 &lt;code&gt;offer&lt;/code&gt; 中数组相关的题目进行了归纳，这一篇文章是链表篇。同样地，如果各位大佬发现程序有什么 &lt;code&gt;bug&lt;/code&gt; 或其他更巧妙的思路，欢迎交流学习。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.timberliu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="https://blog.timberliu.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer (1) —— 数组篇</title>
    <link href="https://blog.timberliu.com/2019/04/16/041_%E5%89%91%E6%8C%87offer%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.timberliu.com/2019/04/16/041_剑指offer之数组/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>算法难，难如上青天，但是难也得静下心来慢慢学习，并总结归纳。所以将剑指 <code>offer</code> 中的题目按照类别进行了归纳，这是第一篇–数组篇。当然，如果各位大佬发现程序有什么 <code>bug</code> 或其他更巧妙的思路，欢迎交流学习。<a id="more"></a></p><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h2><p><strong>题目一描述</strong></p><blockquote><p>在一个长度为 n 的数组里的所有数字都在 0~n-1 的范围内。数组中存在有重复的数字，但不知道有几个数字重复，也不知道重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><p><strong>解题思路</strong></p><p>由于数组中所有数字都在 <code>0 ~ n-1</code> 范围内，那么如果数组中没有重复的数字，则排序后的数组中，数字 <code>i</code> 就一定出现在下标为 <code>i</code> 的位置。</p><p>所以，可以在遍历数组的时候，判断：</p><ol><li>如果当前位置元素 <code>arr[i]</code> 等于 <code>i</code>，则继续遍历；</li><li>否则，将 <code>arr[i]</code> 与 <code>arr[arr[i]]</code> 进行比较：<ul><li>如果相等，则表示找到了重复的数字；</li><li>否则，将它们两个进行交换，也就是将 <code>arr[i]</code> 放到下标为 <code>i</code> 的位置。然后继续重复步骤 <code>2</code> 进行比较。</li></ul></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[arr[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = arr[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[temp];</span><br><span class="line">            arr[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法，每一个数字最多只需要交换两次就可以归位：</p><ul><li>第一次和当前正在遍历的元素进行交换；</li><li>第二次就可以将它归位。</li></ul><p>因此时间复杂度是 <code>O(n)</code>。由于不需要额外空间，空间复杂度是 <code>O(1)</code>。</p><p><strong>题目二描述</strong></p><blockquote><p>在一个长度为 n+1 的数组中所有数字都在 1~n 范围内，所以数组中至少有一个数字重复。请找出任意一个重复的数字，但是不能修改原有的数组。  </p></blockquote><p><strong>解题思路</strong></p><p>由于数组中所有数字都在 <code>1 ~ n</code> 范围内，所以可以将 <code>1 ~ n</code> 的数组从中间值 <code>m</code> 分为 <code>1 ~ m</code> 和 <code>m+1 ~ n</code> 两部分。如果 <code>1 ~ m</code> 之间的数字超过了 <code>m</code> 个，表示重复数字在 <code>1 ~ m</code> 之间，否则在 <code>m+1 ~ n</code> 之间。</p><p>然后继续将包含重复数字的区间分为两部分，继续判断直到找到一个重复的数字。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">duplicateNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">        <span class="keyword">int</span> count = countRange(arr, start, mid);</span><br><span class="line">        <span class="keyword">if</span> (start == mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; (mid - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= start &amp;&amp; arr[i] &lt;= end) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照二分查找的思路，函数 <code>countRange</code> 会被调用 <code>log(n)</code> 次，每次需要 <code>O(n)</code> 的时间，所以总的时间复杂度是 <code>O(nlogn)</code>。</p><h2 id="4-二位数组中的查找"><a href="#4-二位数组中的查找" class="headerlink" title="4. 二位数组中的查找"></a>4. 二位数组中的查找</h2><p><strong>题目描述</strong></p><blockquote><p>在一个二维数组中，每一行按照从左到右递增的顺序排序，每一列按照从上到下递增的顺序排序。要求实现一个函数，输入一个二位数组和一个整数，判断该整数是否在数组中。</p></blockquote><p><strong>解题思路</strong></p><p>这里可以选取左下角或右上角的元素进行比较。这里，以右上角为例：</p><p>对于右上角的元素，如果该元素大于要查找的数字，则要查找的数字一定在它的左边，将 <code>col--</code>，如果该元素小于要查找的数字，则要查找的数字一定在它的下边，将 <code>row++</code>，否则，找到了该元素，查找结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span> || array[<span class="number">0</span>].length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[row][col] &gt; target) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &lt; target) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h2><p><strong>题目描述</strong></p><blockquote><p>将一个数组最开始的几个元素移动数组的末尾，称为旋转数组。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p></blockquote><p><strong>解题思路</strong></p><p>由于数组在一定程度上是有序的，所以可以采用类似二分查找的方法来解决。可以使用两个指针，start 指向数组的第一个元素，end 指向最后一个元素，接着让 mid 指向数组的中间元素。</p><p>这里需要考虑一类特殊情况，就是数组中存在重复元素，例如 <code>1 1 1 0 1</code> 或者 <code>1 0 1 1 1</code> 的情况，这时利用二分法已经不能解决，只能进行顺序遍历。</p><p>一般情况下，判断数组中间元素（<code>mid</code>）与数组最后一个元素（<code>end</code>）的大小，如果数组中间元素大于最后一个元素，则中间元素属于前半部分的非递减子数组，例如 <code>3 4 5 1 2</code>。此时最小的元素一定位于中间元素的后面，则将 <code>start</code> 变为 <code>mid + 1</code>。</p><p>否则的话，也就是数组中间元素（<code>mid</code>）小于等于最后一个元素（<code>end</code>），则中间元素属于后半部分的非递减子数组中，例如 <code>2 0 1 1 1</code>，或者 <code>4 5 1 2 3</code>。此时最小的元素可能就是中间元素，可能在中间元素的前面，所以将 <code>end</code> 变为 <code>mid</code>。</p><p>如此，直到 <code>start</code> 大于等于 <code>end</code> 退出循环时，<code>start</code> 指向的就是最小的元素。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组长度为 1 时，该元素必然是最小的元素，也就不需要再判断 start == end 的情况</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array[start] == array[end] &amp;&amp; array[start] == array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(array, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array[mid] &gt; array[end]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array[start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = array[start];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><p><strong>解题思路</strong></p><p>这里有两种解题思路：第一种是利用插入排序的思路（其实只要能保证稳定性的排序算法都可以），遍历数组，如果该元素是奇数，则对前面的元素进行，如果前面的元素是偶数则进行交换，直到找到一个奇数为止。</p><p>第二种是借助辅助数组，首先遍历一遍数组，将所有奇数元素保存到辅助数组中，并计算出奇数元素的个数；然后再遍历一遍辅助数组，将其中所有奇数元素放到原数组的前半部分，将所有偶数元素放到从 <code>count</code> 开始的后半部分。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderOddEven1</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((data[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; (data[j] &amp; <span class="number">1</span>) == <span class="number">0</span>; j--) &#123;</span><br><span class="line">                data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度 O(n) 空间复杂度 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderOddEven2</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((data[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        tempArr[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, k = count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tempArr[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            data[j++] = tempArr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[k++] = tempArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一种做法，和插入排序的时间复杂度一致，平均情况下时间复杂度为 <code>O(n^2)</code>，在最好情况下时间复杂度是 <code>O(n)</code>。</p><p>而第二种做法，由于只需要遍历两次数组，所以时间复杂度为 <code>O(n)</code>。但是需要借助辅助数组，所以空间复杂度是 <code>O(n)</code>。</p><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。如果输入如下 4 X 4 矩阵：<br> 1  2  3  4<br> 5  6  7  8<br> 9  10 11 12<br> 13 14 15 16<br> 则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。</p></blockquote><p><strong>解题思路</strong></p><p>在打印矩阵时，可以按照从外到内一圈一圈来打印，于是可以使用循环来打印矩阵，每次循环打印一圈。对于一个 <code>5 * 5</code> 的矩阵，循环结束条件是 <code>2 * 2 &lt; 5</code>，而对于一个 <code>6 * 6</code> 的矩阵，循环结束条件是 <code>2 * 3 &lt; 6</code>。所以可以得出循环结束的条件是 <code>2 * start &lt; rows &amp;&amp; 2 * start &lt; cols</code>。</p><p>在打印一圈时，可以分为从左到右打印第一行、从上到下打印最后一列、从右到左打印最后一行、从下到上打印第一列。但是这里需要考虑最后一圈退化为一行、一列的情况。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || (rows = matrix.length) &lt;= <span class="number">0</span> || (cols = matrix[<span class="number">0</span>].length) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * i &lt; rows &amp;&amp; <span class="number">2</span> * i &lt; cols) &#123;</span><br><span class="line">        printMatrixCore(matrix, i++, res);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatrixCore</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX = matrix.length - start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endY = matrix[<span class="number">0</span>].length - start - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一行总是存在的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endY; i++) &#123;</span><br><span class="line">        res.add(matrix[start][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少要有两行</span></span><br><span class="line">    <span class="keyword">if</span>(endX &gt; start) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start + <span class="number">1</span>; j &lt;= endX; j++) &#123;</span><br><span class="line">            res.add(matrix[j][endY]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少要有两行两列</span></span><br><span class="line">    <span class="keyword">if</span>(endX &gt; start &amp;&amp; endY &gt; start) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            res.add(matrix[endX][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少要有三行两列</span></span><br><span class="line">    <span class="keyword">if</span>(endX &gt; start + <span class="number">1</span> &amp;&amp; endY &gt; start) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = endX - <span class="number">1</span>; j &gt; start; j--) &#123;</span><br><span class="line">            res.add(matrix[j][start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h2><p><strong>题目描述</strong></p><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组 {1,2,3,2,2,2,5,4,2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。</p></blockquote><p><strong>解题思路1</strong></p><p>由于有一个数字出现次数超过了数组长度的一半，所以如果数组有序的话，那么数组的中位数必然是出现次数超过一半的数。</p><p>但是这里没有必要完全对数组排好序。可以利用快速排序的思想，使用 <code>partition</code> 函数，对数组进行切分，使得切分元素之前的元素都小于等于它，之后的元素都大于等于它。</p><p>一次切分之后可以将切分元素的下标 <code>index</code> 与数组中间的 <code>mid</code> 比较，如果 <code>index</code> 大于 <code>mid</code>，表示中间值在左半部分，将 <code>end = mid - 1</code>，继续进行切分；而如果 <code>index</code> 小于 <code>mid</code>，表示中间值在右半部分，将 <code>start = mid + 1</code>，继续进行切分；否则表示找到了出现次数超过一半的元素。</p><p><strong>代码实现1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = partition(array, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != mid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; mid) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(array, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(array, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(checkMoreThanHalf(array, array[index])) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[left];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; right &amp;&amp; array[++i] &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == right) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; left &amp;&amp; array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    array[left] = array[j];</span><br><span class="line">    array[j] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] == res) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count * <span class="number">2</span> &gt; array.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题思路2</strong></p><p>还有一种解题思路，它是利用数组的特点，使用一个 <code>times</code> 来记录某个数的出现的次数，然后遍历数组，如果 <code>times</code> 为 <code>0</code>，将当前元素赋给 <code>result</code>，并将 <code>times</code> 置为 <code>1</code>；否则如果当前元素等于 <code>result</code>，则将 <code>times</code> 加 <code>1</code>，否则将 <code>times</code> 减 <code>1</code>。</p><p>如此在遍历完数组，出现次数 <code>times</code> 大于等于 <code>1</code> 对应的那个数一定就是出现次数超过数组一半长度的数。</p><p><strong>代码实现2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span>[] number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="keyword">null</span> || number.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">            result = number[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == number[i]) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkMoreThanHalf(number, result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : number) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == result) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count * <span class="number">2</span> &gt; number.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法只需要遍历一遍数组，就可以找到找到数组中出现次数超过一半的数，所以时间复杂度是 <code>O(n)</code>。虽然与前一种方法的时间复杂度一致，但无疑简洁了不少。</p><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个整型数组。数组里有正数和负数。数组中一个或多个连续的整数组成一个子数组，求所有子数组和的最大值。</p></blockquote><p><strong>解题思路</strong></p><p>可以从头到尾遍历数组，如果前面数个元素之和 <code>lastSum</code> 小于 <code>0</code>，就将其舍弃，将 <code>curSum</code> 赋值为 <code>array[i]</code>。否则将前面数个元素之和 <code>lastSum</code> 加上当前元素 <code>array[i]</code>，得到新的和 <code>curSum</code>。然后判断这个和 <code>curSum</code> 与保存的最大和 <code>maxSum</code>，如果 <code>curSum</code> 大于 <code>maxSum</code>，则将其替换。然后更新 <code>lastSum</code>，继续遍历数组进行比较。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lastSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lastSum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum = array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curSum = lastSum + array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curSum &gt; maxSum) &#123;</span><br><span class="line">            maxSum = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSum = curSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h2><p><strong>题目描述</strong></p><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数 P，并将 P 对 1000000007 取模的结果输出，即输出 P%1000000007。</p></blockquote><p><strong>解题思路</strong></p><p>首先把数组分成两个子数组，然后递归地对子数组求逆序对，统计出子数组内部的逆序对的数目。</p><p>由于已经统计了子数组内部的逆序对的数目，所以需要这两个子数组进行排序，避免在后面重复统计。在排序的时候，还要统计两个子数组之间的逆序对的数目。</p><p>注意，这里如果 <code>aux[i] &gt; aux[j]</code>，应该是 <code>count += mid + 1 - i;</code>，也就是从下标为 <code>i ~ mid</code> 的元素与下标为 <code>j</code> 的元素都构成了逆序对。而如果是 <code>count += j - mid;</code> 的话，则成了下标为 <code>i</code> 的元素与下标为 <code>mid + 1 ~ j</code> 的元素构成了逆序对，后面会出现重复统计的情况。</p><p>最后对两个子数组内部的逆序对和两个子数组之间的逆序对相加，返回即可。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">return</span> inversePairs(array, aux, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> left = inversePairs(data, aux, start, mid);</span><br><span class="line">    <span class="keyword">int</span> right = inversePairs(data, aux, mid + <span class="number">1</span>, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        aux[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line">            data[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; end) &#123;</span><br><span class="line">            data[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            data[k] = aux[j++];</span><br><span class="line">            count += mid + <span class="number">1</span> - i;</span><br><span class="line">            count %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (left + right + count) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法与归并排序的时间、空间复杂度一致，每次排序的时间为 <code>O(n)</code>，总共需要 <code>O(logn)</code> 次，所以总的时间复杂度是 <code>O(nlogn)</code>。在归并时需要辅助数组，所以其空间复杂度为 <code>O(n)</code>。</p><h2 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53. 在排序数组中查找数字"></a>53. 在排序数组中查找数字</h2><p><strong>题目一描述</strong></p><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote><p><strong>解题思路</strong></p><p>对于排序数组，可以使用两次二分查找分别找到要查找的数字第一次和最后一次出现的数组下标。然后就可以计算出该数字出现的次数。</p><p>查找第一次出现的数组下标时，如果数组中间元素大于该数字 <code>k</code>，则在数组左半部分去查找，否则数组中间元素小于该数字 <code>k</code>，则在数组右半部分去查找。</p><p>当中间元素等于 <code>k</code> 时，则需要判断 <code>mid</code>，如果 <code>mid</code> 前面没有数字，或者前面的数字不等于 <code>k</code>，则找到了第一次出现的数组下标；否则继续在数组左半部分去查找。</p><p>查找最后一次出现的数组下标与查找第一次出现的思想类似，这里就不再赘述了。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = getFirstIndex(array, k);</span><br><span class="line">    <span class="keyword">int</span> right = getLastIndex(array, k);</span><br><span class="line">    <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == array[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || array[mid - <span class="number">1</span>] != k) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; array[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == array[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == end || array[mid + <span class="number">1</span>] != k) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; array[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二描述</strong></p><blockquote><p>一个长度为 n 的递增数组中的所有数字都是唯一的，并且每个数字都在 [0, n] 范围内，在 [0, n] 范围内的 n+1 个数字中有且只有一个数字不在数组中，请找出这个数字。</p></blockquote><p><strong>解题思路</strong></p><p>由于数组是有序的，所以数组开始的一部分数字与它们对应的下标是相等。如果不在数组中的数字为 <code>m</code>，则它前面的数字与它们的下标都相等，它后面的数字比它们的下标都要小。</p><p>可以使用二分查找，如果中间元素的值和下标相等，则在数组右半部分查找；如果不相等，则需要进一步判断，如果它前面没有元素，或者前面的数字和它的下标相等，则找到了 <code>m</code>；否则继续在左半部分查找。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] != mid) &#123;</span><br><span class="line">            <span class="comment">// 当前不相等，前一个相等，表示找到了</span></span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid - <span class="number">1</span>] == mid - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 左半边查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//右半边查找</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-数组中数字出现的次数"><a href="#56-数组中数字出现的次数" class="headerlink" title="56. 数组中数字出现的次数"></a>56. 数组中数字出现的次数</h2><p><strong>题目一描述</strong></p><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p><strong>解题思路</strong></p><p>这里解题思路有些巧妙，使用位元素来解决，由于两个相等的数字异或后结果为 <code>0</code>，所以遍历该数组，依次异或数组中的每一个元素，那么最终的结果就是那两个只出现一次的数字异或的结果。</p><p>由于这两个数字肯定不一样，异或的结果也肯定不为 <code>0</code>，也就是它的二进制表示中至少有一位是 <code>1</code>，将该位求出后记为 <code>n</code>。</p><p>可以将以第 <code>n</code> 位为标准将原数组分为两个数组，第一个数组中第 <code>n</code> 位是 <code>1</code>，而第二个数组中第 <code>n</code> 位是 <code>0</code>，而两个只出现一次的数字必然各出现在一个数组中，并且数组中的元素异或的结果就是只出现一次的那个数字。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        num ^= array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = bitOf1(num);</span><br><span class="line">    <span class="keyword">int</span> mark = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((array[i] &amp; mark) == <span class="number">0</span>) &#123;</span><br><span class="line">            num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitOf1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二描述</strong></p><blockquote><p>一个整型数组里除了一个数字只出现了一次之外，其他的数字都出现了三次。请找出那个只出现一次的数字。</p></blockquote><p><strong>解题思路</strong></p><p>这里由于出现了三次，虽然不能再使用异或运算，但同样可以使用位运算。可以从头到尾遍历数组，将数组中每一个元素的二进制表示的每一位都加起来，使用一个 <code>32</code> 位的辅助数组来存储二进制表示的每一位的和。</p><p>对于所有出现三次的元素，它们的二进制表示的每一位之和，肯定可以被 <code>3</code> 整除，所以最终辅助数组中如果某一位能被 <code>3</code> 整除，那么那个只出现一次的整数的二进制表示的那一位就是 <code>0</code>，否则就是 <code>1</code>。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNumberAppearOnce</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = arr[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span> (bit != <span class="number">0</span>) &#123;</span><br><span class="line">                bitSum[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            bitMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num[<span class="number">0</span>] = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h2><p><strong>题目描述</strong></p><blockquote><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]&times;A[1]&times;…&times;A[i-1]&times;A[i+1]&times;…&times;A[n-1]。不能使用除法。</p></blockquote><p><strong>解题思路</strong></p><p>这里要求 <code>B[i] = A[0] * A[1] * ... *  A[i-1] * A[i+1] * ... * A[n-1]</code>，可以将其分为分为两个部分的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">0</span>] * A[<span class="number">1</span>] * ... * A[i-<span class="number">2</span>] * A[i-<span class="number">1</span>]</span><br><span class="line">A[i+<span class="number">1</span>] * A[i+<span class="number">2</span>] * ... * A[n-<span class="number">2</span>] * A[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>可以使用两个循环，第一个循环采用自上而下的顺序，<code>res[i] = res[i - 1] * arr[i - 1]</code> 计算前半部分，第二循环采用自下而上的顺序，<code>res[i] *= (temp *= arr[i + 1])</code>。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// arr [2, 1, 3, 4, 5]</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        result[i] = arr[i - <span class="number">1</span>] * result[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// result [1, 2, 2, 6, 24]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = result.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = arr[i + <span class="number">1</span>] * temp;</span><br><span class="line">        result[i] = result[i] * temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp  60  60   20  5   1</span></span><br><span class="line">    <span class="comment">// result [60, 120, 40, 30, 24]</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法难，难如上青天，但是难也得静下心来慢慢学习，并总结归纳。所以将剑指 &lt;code&gt;offer&lt;/code&gt; 中的题目按照类别进行了归纳，这是第一篇–数组篇。当然，如果各位大佬发现程序有什么 &lt;code&gt;bug&lt;/code&gt; 或其他更巧妙的思路，欢迎交流学习。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://blog.timberliu.com/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="https://blog.timberliu.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 深入理解 Condition</title>
    <link href="https://blog.timberliu.com/2019/04/15/040_Condition/"/>
    <id>https://blog.timberliu.com/2019/04/15/040_Condition/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h1><p>在 <code>Java</code> 中，每一个对象都有 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 等方法，这些方法和 <code>synchronized</code> 关键字配合，可以实现等待/通知模式。而在 <code>Condition</code> 中同样提供了类似的方法，它们与 <code>Lock</code> 配合，也可以实现等待/通知模式。<a id="more"></a></p><p>在使用 <code>Condition</code> 时，需要通过 <code>Lock</code> 对象的 <code>newCondition</code> 方法进行创建，调用 <code>await</code> 方法和 <code>signal</code> 等方法时，也需要先获取锁。</p><p><code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法如下，其他方法稍后会详细介绍：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>await()</td><td>使当前线程等待，直到另一个线程调用 signal 或 signalAll 方法将其唤醒，或者其他线程调用 interrupt 方法将其中断</td></tr><tr><td>signal()</td><td>唤醒一个等待的线程，唤醒的线程从 await 方法返回前必须重新获取锁</td></tr></tbody></table><p>下面通过 <code>Condition</code> 和队列实现一个简单的生产者-消费者例子，来了解 <code>Condition</code> 的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放产品的队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; products = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 如果队列满了，则线程等待在该 condition 上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="comment">// 如果队列为空，则线程等待在该 condition 上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        producerConsumer.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果队列满了</span></span><br><span class="line">                    <span class="keyword">while</span>(products.size() == MAX) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"products is full, please wait"</span>);</span><br><span class="line">                        <span class="comment">// 线程等待，直到被唤醒</span></span><br><span class="line">                        full.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (products.offer(++val)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Producer put a object to product "</span> + val);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="comment">// 产出了产品，唤醒等待在 empty 上的线程</span></span><br><span class="line">                        empty.signal();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Integer value;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果队列为空</span></span><br><span class="line">                    <span class="keyword">while</span> (products.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"products is empty, please wait"</span>);</span><br><span class="line">                        <span class="comment">// 则线程等待在 empty 上</span></span><br><span class="line">                        empty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((value = products.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Consumer get a object from product "</span> + value);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="comment">// 消费了产品后，唤醒等待在 full 上的线程</span></span><br><span class="line">                        full.signal();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Condition-实现分析"><a href="#Condition-实现分析" class="headerlink" title="Condition 实现分析"></a>Condition 实现分析</h1><p>前面说了在使用 <code>Condition</code> 时，需要调用 <code>Lock</code> 的 <code>newCondition</code> 方法，而 <code>ReentrantLock</code> 或是 <code>ReentrantReadWriteLock</code> 内部又是调用的 <code>Sync</code> 的 <code>newCondition</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>ConditionObject</code> 就是实现等待/通知模式的具体类，它实现了 <code>Condition</code> 接口，是 <code>AQS</code> 的一个内部类，提供了 <code>await</code>、<code>signal</code>、<code>signalAll</code> 等方法。</p><p>下面从等待队列、<code>await</code> 方法、<code>signal</code> 方法三个方面来分析 <code>ConditionObject</code> 的实现：</p><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>每个 <code>ConditionObject</code> 对象内部维护着一个等待队列，队列中的节点都代表着一个在 <code>ConditionObject</code> 上等待的线程，等待队列的节点复用了 <code>AQS</code> 内部同步队列的节点，使用的都是同步器的 <code>Node</code> 对象。</p><p><code>ConditionObject</code> 中定义了两个 <code>Node</code> 引用，分别指向等待队列的首节点和尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待队列的第一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 等待队列的最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个线程调用了 <code>await</code> 方法，该线程就会释放锁、构成成节点加入到等待队列中，并进入等待状态。其中将线程构造成节点，并加入到等待队列中，这一步通过 <code>addConditionWaiter</code> 方法来实现，这里也并不需要使用 <code>CAS</code>，因为调用 <code>await</code> 的方法一定是获取了锁的线程，也就确保了线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果最后一个节点被取消了，则需要清理掉</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先会检查最后一个节点是否被取消了，如果是则会调用 <code>unlinkCancelledWaiters</code> 方法清理掉；否则将当前线程构造成节点，等待状态设为 <code>Node.CONDITION</code>，加入到等待队列的尾部。</p><p><code>unlinkCancelledWaiters</code> 方法会从等待队列头开始遍历，删除掉不是等待状态的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// 保存前一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h2><p><code>ConditionObject</code> 的 <code>await</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 将当前线程构造成节点加入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先调用 <code>addConditionWaiter</code> 方法将当前线程重新构造成一个节点，加入到等待队列中。然后会调用 <code>fullyRelease</code> 方法释放同步状态，唤醒同步队列中的后继节点。</p><p>然后循环判断如果当前线程是否在同步队列中，也就是当前线程是否被唤醒了，如果被唤醒会将当前线程加入到同步队列中。这里就会跳出 <code>while</code> 循环，然后调用 <code>acquireQueued</code> 方法开始尝试获取同步状态。</p><p>这里如果其他线程对当前线程进行中断，则会抛出 <code>InterruptedException</code>。</p><h2 id="signal-方法"><a href="#signal-方法" class="headerlink" title="signal 方法"></a>signal 方法</h2><p><code>ConditionObject</code> 的 <code>signal</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signal</code> 方法首先会调用 <code>isHeldExclusively</code> 方法判断当前线程是否获取了锁，接着如果等待队列不为空，会调用 <code>doSignal</code> 方法唤醒队列中的首节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会将 <code>first.nextWaiter</code> 置为 <code>null</code>，并调用 <code>transferForSignal</code> 方法将同步状态变为 <code>0</code>，并将其加入到同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态由等待变为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>enq</code> 方法将当前线程插入到同步队列中尾部，然后返回前一个节点。如果前一个节点被取消，或者设置前一个节点为 <code>SINGAL</code> 失败，则需要调用 <code>LockSupport.unpark</code> 唤醒当前线程。</p><h1 id="await-和-signal"><a href="#await-和-signal" class="headerlink" title="await 和 signal"></a>await 和 signal</h1><p>这里将 <code>await</code> 和 <code>signal</code> 整体的流程大概梳理一下：</p><ul><li>当一个线程 <code>A</code> 调用了 <code>await</code> 方法后，首先会将当前线程 <code>A</code> 重新构成一个节点加入到等待队列中（<code>addConditionWaiter</code>）；</li><li>然后当前线程 <code>A</code> 释放同步状态（<code>fullyRelease</code>），自循环判断是否处于同步队列中（<code>isOnSyncQueue</code>），即是否被唤醒。</li><li>当另一个线程 <code>B</code> 调用了 <code>signal</code> 方法后（假设上一个线程 <code>A</code> 已处于等待队列的头部），则会将线程 <code>A</code> 加入到同步队列中，并唤醒线程 <code>A</code>（<code>transferForSignal</code>）。</li><li>线程 <code>A</code> 被唤醒后，处于同步队列中，就会退出 <code>await</code> 的 <code>while</code> 循环，重新去尝试获取同步状态（<code>acquireQueued</code>）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Condition-接口&quot;&gt;&lt;a href=&quot;#Condition-接口&quot; class=&quot;headerlink&quot; title=&quot;Condition 接口&quot;&gt;&lt;/a&gt;Condition 接口&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中，每一个对象都有 &lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; 等方法，这些方法和 &lt;code&gt;synchronized&lt;/code&gt; 关键字配合，可以实现等待/通知模式。而在 &lt;code&gt;Condition&lt;/code&gt; 中同样提供了类似的方法，它们与 &lt;code&gt;Lock&lt;/code&gt; 配合，也可以实现等待/通知模式。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 深入理解 ReentrantReadWriteLock</title>
    <link href="https://blog.timberliu.com/2019/04/15/039_ReentrantReadWriteLock/"/>
    <id>https://blog.timberliu.com/2019/04/15/039_ReentrantReadWriteLock/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p><code>ReentrantLock</code> 是排它锁，它在同一时刻只允许一个线程进行访问。在很多场景中，读服务远多于写服务，而读服务之间不存在数据竞争问题，在一个线程读数据时禁止其他读线程访问，会导致性能降低。</p><p>所以就有了读写锁，它在同一时刻可以允许多个读线程访问，但在写线程访问时，则所有的读线程和其他写线程都会被阻塞。读写锁内部维护了一个读锁和一个写锁，如此将读写锁分离，可以很大地提升并发性和吞吐量。<a id="more"></a></p><p><strong>ReadWriteLock</strong></p><p><code>ReadWriteLock</code> 接口定义了读锁和写锁的两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>readLock()</code> 方法用于返回读操作的锁，<code>writeLock()</code> 用于返回写操作的锁。</p><p><strong>实现类</strong></p><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，它的几个重要属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类 ReadLock，读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">// 内部类 WriteLock 写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">// 同步器，读写和写锁依赖于它</span></span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>其中有两个构造方法，主要如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定公平性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>ReentrantReadWriteLock</code> 锁的主体依然是 <code>Sync</code>，读锁和写锁都依赖与 <code>Sync</code> 来实现，它们使用的是同一个锁，只是在获取锁和释放锁的方式不同。</p><h1 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h1><p>在 <code>ReentrantLock</code> 中使用一个 <code>int</code> 型变量 <code>state</code> 来表示同步状态，该值表示锁被一个线程重复获取的次数，而读写锁中需要一个 <code>int</code> 型变量上维护多个读线程和一个写线程的状态。</p><p>所以它将该变量分为两部分，高 <code>16</code> 位表示读，低 <code>16</code> 位表示写。分割之后通过位运算来计算读锁和写锁的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">// 写锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><h1 id="内部工作状态"><a href="#内部工作状态" class="headerlink" title="内部工作状态"></a>内部工作状态</h1><p>另外，<code>ReentrantReadWriteLock</code> 还提供了返回内部工作状态的方法。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>getReadLockCount</td><td>返回读锁被获取的次数（锁重入次数也会加 1）</td></tr><tr><td>isWriteLocked</td><td>返回写锁是否被获取</td></tr><tr><td>getWriteHoldCount</td><td>返回当前线程获取写锁的次数</td></tr><tr><td>getReadHoldCount</td><td>返回当前线程获取读锁的次数</td></tr></tbody></table><p>前面三个方法都比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedCount(getState()); <span class="comment">// c &gt;&gt;&gt; SHARED_SHIFT</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exclusiveCount(getState()) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于写锁只会被一个线程获取</span></span><br><span class="line"><span class="comment">// 所以，如果是当前线程，则通过 c &amp; EXCLUSIVE_MASK 直接计算即可</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isHeldExclusively() ? exclusiveCount(getState()) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个方法，首先来看一下 <code>Sync</code> 类的几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程持有的读锁数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HoldCounter 的一个缓存，减少 ThreadLocal.get 的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="comment">// 第一个获取到读锁的读线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 第一个读线程持有的读锁数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"><span class="comment">// 上面三个都是为了提高效率，如果读锁仅有一个或有缓存了，就不用去 ThreadLocalHoldCounter 获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程持有锁的计数器，需要与线程绑定</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 持有线程 id，在释放锁时，判断 cacheHoldCounter 缓存的是否是当前线程的读锁数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 ThreadLocal 将 HoldCounter 绑定到线程上</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync() &#123;</span><br><span class="line">    readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">    setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getReadHoldCount()</code> 方法用于获取当前线程获取读锁的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果读锁被获取的次数为 0，那么当前线程获取读锁的次数肯定也为 0</span></span><br><span class="line">    <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果当前线程是第一个获取读锁的线程，则直接返回 firstReaderHoldCount</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current)</span><br><span class="line">        <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存的 HoldCounter 绑定的线程是否是当前线程，如果是则直接返回读锁数量</span></span><br><span class="line">    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">        <span class="keyword">return</span> rh.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则从 ThreadLocalHoldCounter 中获取 HoldCounter，再获取读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove(); <span class="comment">// 防止内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>写锁是一个支持可重入的排它锁。</p><h2 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h2><p><code>WriteLock</code> 的 <code>lock()</code> 方法如下，可以看到，这里调用的是 <code>AQS</code> 的独占式获取锁方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取写锁时，调用 <code>AQS</code> 的 <code>acquire</code> 方法，其中又调用了 <code>Sync</code> 自定义组件实现的 <code>tryAcquire</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 写锁个数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c != 0 &amp;&amp; w == 0 表示有线程获取了读锁</span></span><br><span class="line">        <span class="comment">// 或者当前线程不是持有锁的线程，则失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写锁会超过范围，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 当前线程获取写锁，可重入</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有任何线程获取读锁和写锁，当前线程尝试获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果有线程获取了读锁，则当前线程不能再获取写锁。因为读写锁需要确保获取写锁的线程的操作对于读锁的线程是可见的，如果存在读锁时再允许获取写锁，则获取读锁的线程可能无法得知当前获取写锁的线程的操作。</p><p>判断获取写锁的线程是否应该被阻塞，公平锁和非公平中实现不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于非公平锁，直接返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于公平锁，则需要判断是否有前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h2><p><code>unlock()</code> 方法如下，其中调用了 <code>AQS</code> 的 <code>release</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>release()</code> 方法首先调用 <code>Sync</code> 中的 <code>tryRelease()</code> 方法，然后唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先减少写状态值，如果写状态为 <code>0</code>，则表示写锁已经被释放，将持有锁的线程设置为 <code>null</code>，并更改同步状态值。</p><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><p>读锁是一个支持可重入的共享锁，它能被多个线程同时获取。</p><h2 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h2><p><code>ReadLock</code> 的 <code>lock()</code> 方法如下，其中调用了 <code>AQS</code> 的共享式获取锁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>acquireShared</code> 方法中，又调用了 <code>Sync</code> 的 <code>tryAcquireShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 存在写锁，并且写锁被其他线程持有，则失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 获取读锁的线程是否需要阻塞</span></span><br><span class="line">    <span class="comment">// 读锁小于 MAX_COUNT(1 &lt;&lt; 16)</span></span><br><span class="line">    <span class="comment">// 使用 CAS 更新状态为 c + 1 &lt;&lt; 16</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有读锁</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 读锁仅有一个</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">//更新缓存</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 将 HoldCounter 设置到 ThreadLocal 中</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 读锁数量加 1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，如果满足上述三个条件，则获取读锁成功，会对 <code>firstReaderHoldCount</code> 等值进行设置，稍后详细介绍。如果不满足时，会调用 <code>fullTryAcquireShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果写锁不为 0</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是持有写锁的线程，返回</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 读锁是否需要被阻塞</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁超出最大范围</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 使用 CAS 更新状态值，尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断读锁是否应该被阻塞，公平锁和非公平锁实现不同，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于非公平锁，需要判断同步队列中第一个结点是否是独占式（写锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于公平锁，需要判断是否有前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h2><p><code>ReadLock</code> 的 <code>unlock</code> 方法如下，其中调用的是 <code>AQS</code> 的共享式释放锁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>releaseShared</code> 方法中又调用了 <code>Sync</code> 的 <code>tryReleaseShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果当前线程是第一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 仅获取了一次，将 firstReader 置为 null</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则将 firstReadHoldCount 减 1</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">// 缓存如果有效，直接使用；否则重新获取</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环使用 CAS 更新状态值</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p><code>ReentrantReadWriteLock</code> 允许锁降级，也就是写锁降级为读锁。它是指先获取写锁，再获取到读锁，最后释放写锁的过程。但锁升级是不允许的，也就是先获取读锁，再获取写锁，最后释放读锁的过程。</p><p>在获取读锁的 <code>tryAcquireShared</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 存在写锁，并且写锁被其他线程持有，则失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在写锁，并且写锁被其他线程持有时，才会失败。说明如果当前线程持有了写锁，也可以再获取读锁。最后释放写锁，这称为锁降级。</p><p>为何要这样做呢？试想如果一个线程获取了写锁，这个时候其他任何线程都是无法再获取读锁或写锁的，然后该线程再去获取读锁，也就不会产生任何的竞争。通过这种锁降级机制，就不会有释放写锁后，再去竞争获取读锁的情况，避免了锁的竞争和线程的上下文切换，也就提高了效率。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://cmsblogs.com/?p=2213" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之读写锁：ReentrantReadWriteLock</a></li><li><a href="http://ifeve.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E8%AF%BB%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8A%E5%85%B3%E4%BA%8E%E9%94%81%E9%99%8D%E7%BA%A7%E7%9A%84%E4%BA%89/" target="_blank" rel="noopener">并发编程之——读锁源码分析(解释关于锁降级的争议)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ReentrantReadWriteLock&quot;&gt;&lt;a href=&quot;#ReentrantReadWriteLock&quot; class=&quot;headerlink&quot; title=&quot;ReentrantReadWriteLock&quot;&gt;&lt;/a&gt;ReentrantReadWriteLock&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是排它锁，它在同一时刻只允许一个线程进行访问。在很多场景中，读服务远多于写服务，而读服务之间不存在数据竞争问题，在一个线程读数据时禁止其他读线程访问，会导致性能降低。&lt;/p&gt;
&lt;p&gt;所以就有了读写锁，它在同一时刻可以允许多个读线程访问，但在写线程访问时，则所有的读线程和其他写线程都会被阻塞。读写锁内部维护了一个读锁和一个写锁，如此将读写锁分离，可以很大地提升并发性和吞吐量。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 深入理解 ReentrantLock</title>
    <link href="https://blog.timberliu.com/2019/04/14/038_ReentrantLock/"/>
    <id>https://blog.timberliu.com/2019/04/14/038_ReentrantLock/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-04-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-ReentrantLock"><a href="#深入理解-ReentrantLock" class="headerlink" title="深入理解 ReentrantLock"></a>深入理解 ReentrantLock</h1><p><code>ReentrantLock</code> 是一种可重入锁，它指的是一个线程能够对资源重复加锁。<code>ReentrantLock</code> 与 <code>synchronized</code> 类似，能够保证解决线程安全问题，但是却提供了比 <code>synchronized</code> 更强大、灵活的机制，例如可中断式的获取锁、可定时的获取锁等。<a id="more"></a></p><p>另外，<code>ReentrantLock</code> 也提供了公平锁与非公平锁的选择，它们之间的区别主要就是看对锁的获取与获取锁的请求的顺序是否是一致的，选择公平锁时，等待时间最长的线程会最优先获取到锁，但是公平锁获取的效率通常比非公平锁要低。可以在构造方法中通过传参的方式来具体指定选择公平或非公平。</p><h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p>在 <code>ReentrantLock</code> 中，有一个抽象内部类 <code>Sync</code>，它继承自 <code>AQS</code>，<code>ReentrantLock</code> 的大部分功能都委托给 <code>Sync</code> 进行实现，其内部定义了 <code>lock()</code> 抽象方法，默认实现了 <code>nonfairTryAcquire()</code> 方法，它是非公平锁的默认实现。</p><p><code>Sync</code> 有两个子类：公平锁 <code>FairSync</code> 和 <code>NonFairSync</code>，实现了 <code>Sync</code> 中的 <code>lock()</code> 方法和 <code>AQS</code> 中的 <code>tryAcquire()</code> 方法。</p><h2 id="NonFairSync"><a href="#NonFairSync" class="headerlink" title="NonFairSync"></a>NonFairSync</h2><p><code>NonFairSync</code> 中 <code>lock()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，非公平锁可以立即尝试获取锁，如果失败的话，会调用 <code>AQS</code> 中的 <code>acquire</code> 方法，其中 <code>acquire</code> 方法又会调用由自定义组件实现的 <code>tryAcquire</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nonfairTryAcquire()</code> 方法在 <code>Sync</code> 中已经默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 CAS 设置同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 整数溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，首先会判断的当前线程的状态是否为 <code>0</code>，也就是该锁是否处于空闲状态，如果是的话则尝试获取锁，设置成功将当前线程设置为持有锁的线程。</p><p>否则的话，就判断当前线程是否为持有锁的线程，如果是的话，则增加同步状态值，获取到锁，这里也就验证了锁的可重入，再获取了锁之后，可以继续获取锁，只需增加同步状态值即可。</p><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h2><p><code>FairSync</code> 中 <code>lock()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁只能调用 <code>AQS</code> 的 <code>acquire()</code> 方法，再去调用由自定义组件实现的 <code>tryAcquire()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一与非公平锁不同的是在获取同步状态时，会调用 <code>hasQueuedPredecessors</code> 方法，这个方法用来判断同步队列中是否有前驱节点。也就是当前线程前面再没有其他线程时，它才可以尝试获取锁。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p><code>ReentrantLock</code> 的 <code>unlock</code> 方法内部调用 <code>AQS</code> 的 <code>release</code> 方法释放锁，而其中又调用了自定义组件实现的 <code>tryRelease</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 当前线程不是持有锁的线程，不能释放</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，判断当前线程是否是持有锁的线程，如果不是会抛出异常。如果是的话，再减去同步状态值，判断同步状态是否为 <code>0</code>，即锁被完全释放，其他线程可以获取同步状态了。</p><p>如果没有完全释放，则仅使用 <code>setState</code> 方法设置同步状态值。</p><h2 id="指定公平性"><a href="#指定公平性" class="headerlink" title="指定公平性"></a>指定公平性</h2><p>在 <code>ReentrantLock</code> 的构造函数中可以指定公平性：</p><ul><li>默认创建一个非公平的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个指定公平性的锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="synchronized-和-ReentrantLock-区别"><a href="#synchronized-和-ReentrantLock-区别" class="headerlink" title="synchronized 和 ReentrantLock 区别"></a>synchronized 和 ReentrantLock 区别</h1><p>这里总结一下 synchronized 和 ReentrantLock 的异同，它们之间的相同点如下：</p><ul><li>都可以用于实现线程间的同步访问；</li><li>两者都是可重入锁，即一个线程能够对资源重复加锁；</li></ul><p>其不同点如下：</p><ul><li>同步实现机制不同：<ul><li><code>synchronized</code> 通过 <code>Java</code> 对象关联的 <code>Monitor</code> 监视器实现（不考虑偏向锁、轻量级锁）；</li><li><code>ReentrantLock</code> 通过 <code>CAS</code>、<code>AQS</code> 和 <code>LockSupport</code> 等共同实现；</li></ul></li><li>可见性实现机制不同：<ul><li><code>synchronized</code> 依赖 <code>JVM</code> 内存模型保证包含共享变量的多线程内存可见性。</li><li><code>ReentrantLock</code> 通过 <code>ASQ</code> 中 <code>volatile</code> 类型的 <code>state</code> 同步状态值保证包含共享变量的多线程内存可见性。</li></ul></li><li>使用方式不同：<ul><li><code>synchronized</code> 可以用于修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、同步代码块（指定的锁对象）。</li><li><code>ReentrantLock</code> 需要显式地调用 <code>lock</code> 方法，并在 <code>finally</code> 块中释放。</li></ul></li><li>功能丰富程度不同：<ul><li><code>synchronized</code> 只提供最简单的加锁。</li><li><code>ReentrantLock</code> 提供定时获取锁、可中断获取锁、<code>Condition</code>（提供 <code>await</code>、<code>signal</code> 等方法）等特性。</li></ul></li><li>锁类型不同：<ul><li><code>synchronized</code> 只支持非公平锁。</li><li><code>ReentrantLock</code> 提供公平锁和非公平锁实现。但非公平锁相比于公平锁效率较高。</li></ul></li></ul><p>在 <code>synchronized</code> 优化以前，它比较重量级，其性能比 <code>ReentrantLock</code> 要差很多，但是自从 <code>synchronized</code> 引入了偏向锁、轻量级锁（自旋锁）、锁消除、锁粗化等技术后，两者的性能就相差不多了。</p><p>一般来说，仅当需要使用 <code>ReentrantLock</code> 提供的其他特性时，例如：可中断的、可定时的、可轮询的、公平地获取锁等，才考虑使用 <code>ReentrantLock</code>。否则应该使用 <code>synchronized</code>，简单方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解-ReentrantLock&quot;&gt;&lt;a href=&quot;#深入理解-ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;深入理解 ReentrantLock&quot;&gt;&lt;/a&gt;深入理解 ReentrantLock&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是一种可重入锁，它指的是一个线程能够对资源重复加锁。&lt;code&gt;ReentrantLock&lt;/code&gt; 与 &lt;code&gt;synchronized&lt;/code&gt; 类似，能够保证解决线程安全问题，但是却提供了比 &lt;code&gt;synchronized&lt;/code&gt; 更强大、灵活的机制，例如可中断式的获取锁、可定时的获取锁等。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Lock 与 AQS 同步器</title>
    <link href="https://blog.timberliu.com/2019/04/12/037_Lock%20%E4%B8%8E%20AQS%20%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/04/12/037_Lock 与 AQS 同步器/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>在 <code>Java5</code> 之前，只能使用 <code>synchronized</code> 关键字来实现锁。它使用起来比较简单，但是有一些局限性：</p><ul><li>无法中断一个正在等待获取锁的线程；</li><li>无法在请求获取一个锁时等待一段时间。<a id="more"></a></li></ul><p>而在 <code>Java5</code> 中，并发包中增加了 <code>Lock</code> 接口及其实现类，它的功能与 <code>synchronized</code> 类似，需要进行显示地获取和释放锁，但是却提供了很多 <code>synchronized</code> 不具有的特性。举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是获取锁的 <code>lock</code> 方法应该写在 <code>try</code> 块之外，因为如果写在 <code>try</code> 块中，获取锁时发生了异常，抛出异常的同时也会导致锁无故释放，而不是等到执行 <code>finally</code> 语句时才释放锁。</p><p>在 <code>Lock</code> 接口中，定义了锁获取和释放的基本操作，包括可中断的获取锁、超时获取锁等特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可中断地获取锁，即获取锁时，其他线程可以中断当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，调用后会立即返回，能获取就返回 true，否则返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在给定时间内可中断地尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个绑定到该 Lock 实例上的 Condition</span></span><br><span class="line">    <span class="comment">// 只有当前线程持有了锁，才能调用 await 方法，await 方法的调用将会自动释放锁</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code> 接口的主要实现就是 <code>ReentrantLock</code>。而 <code>Lock</code> 接口的实现基本都是通过内部实现了一个同步器 <code>AQS</code> 的子类来实现线程访问控制的。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>同步器 <code>AbstractQueuedSynchronizer</code>，是用来构建锁或其他同步组件的基础框架。它使用一个 <code>int</code> 成员变量表示同步状态，通过内置的 <code>FIFO</code> 同步队列来完成线程获取资源时的排队等待工作。</p><p>在自定义同步组件时，推荐定义一个静态内部类，使其继承自同步器 <code>AQS</code> 并实现它的抽象方法来管理同步状态，在实现抽象方法时，对同步状态的管理可以使用同步器提供的三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 CAS 设置当前状态，保证原子性</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步器是实现同步组件的关，它们二者的关系如下：</p><ul><li>同步组件是面向使用者的，定义了使用者与同步组件交互的接口，隐藏了实现细节；</li><li>同步器面向的是同步组件的实现者，它简化了同步组件的实现方式。</li></ul><h2 id="同步器的接口"><a href="#同步器的接口" class="headerlink" title="同步器的接口"></a>同步器的接口</h2><p>同步器是基于模板方法模式的。使用者需要继承同步器并重写指定的方法。而可重写的方法主要有：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>tryAcquire</td><td>独占式获取同步状态</td></tr><tr><td>tryRelease</td><td>独占式释放同步状态</td></tr><tr><td>tryAcquireShared</td><td>共享式获取同步状态</td></tr><tr><td>tryReleaseShared</td><td>共享式释放同步状态</td></tr><tr><td>isHeldExclusively</td><td>判断同步器是否被线程独占</td></tr></tbody></table><p>随后将同步器组合到自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法会调用使用者重写的方法。</p><p>可调用的模板方法主要有三类：独占式获取与释放同步状态、共享式获取与释放状态、以及查询同步队列中的等待线程情况。下文会介绍它们，并简单分析其实现原理。</p><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>同步器内部使用一个 <code>FIFO</code> 同步队列来管理同步状态，在线程获取同步状态失败时，同步器会将当前线程与等待状态等信息构造成一个节点，将其加入到同步队列中，同时会阻塞当前线程。当释放同步状态时，则会唤醒队列中首节点的线程，使其再次尝试获取同步状态。</p><p>同步队列中的节点的主要属性有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点，在入队时被赋值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点，</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入节点的线程，该线程获取到同步状态</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待状态 <code>waitStatus</code> 的取值主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步队列中等待的线程等待超时或被中断，需要取消等待，之后节点的状态将不会再改变</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后继节点的线程处于等待状态</span></span><br><span class="line"><span class="comment">// 当前节点的线程释放或取消同步状态时，会唤醒它的后继节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 节点目前在等待队列中</span></span><br><span class="line"><span class="comment">// 当节点被唤醒时，从等待队列转移到同步队列中，尝试获取同步状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享式同步状态被传播给其他节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 waitStatus 值为 0</span></span><br></pre></td></tr></table></figure><p>同步器中包含两个引用，分别指向同步队列的首节点和尾节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点，惰性初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾节点，惰性初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p>当线程无法获取同步状态，会将该线程构造成一个节点加入同步队列中，使用 <code>addWaiter</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果快速尝试添加尾节点失败，则调用 <code>enq</code> 方法通过死循环来保证节点的正确添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 如果未初始化，则会先初始化，再继续尝试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个过程可能会有多个线程同时执行，所以必须要保证线程安全，提供了基于 <code>CAS</code> 的设置尾节点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步队列中，首节点是获取同步状态成功的节点，线程在释放同步状态时，会唤醒后继节点，后继节点成功获取同步状态时将自己设置为首节点，由于只有一个线程能获取到同步状态，所以设置头节点的方法不需要 <code>CAS</code> 方法保证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占式获取与释放"><a href="#独占式获取与释放" class="headerlink" title="独占式获取与释放"></a>独占式获取与释放</h2><p>独占式获取与释放同步状态主要有四个模板方法，分别是：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>可响应中断的独占式获取同步状态</td></tr><tr><td>boolean tryAcquireNanos(int arg, long nanos)</td><td>可响应中断的独占式超时获取同步状态</td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr></tbody></table><h3 id="独占式获取"><a href="#独占式获取" class="headerlink" title="独占式获取"></a>独占式获取</h3><p><code>acquire</code> 方法可以获取同步状态，该方法为独占式获取，不可中断，也就是如果线程获取同步状态失败，加入到同步队列中，后续对线程进行中断操作，线程并不会被移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 方法中，首先调用 <code>tryAcquire</code> 方法尝试获取同步状态，该方法由自定义组件自己实现。如果获取失败，调用 <code>addWaiter</code> 方法将当前线程加入到同步队列末尾。最后调用 <code>acquiredQueued</code> 方法通过死循环的方式来获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，通过死循环的方式来获取同步状态，并且只有前驱节点是头节点时，才能够尝试获取同步状态，这样做就是为了保持 <code>FIFO</code> 同步队列原则，即先加入到同步队列中的线程先尝试获取同步状态。</p><p>另外，在自旋时首先会调用 <code>shouldParkAfterFailedAcquire</code> 方法判断是否应该被阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 前驱节点状态为 SIGNAL ，则当前节点可以被阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 前驱节点处于取消状态，也就是超时或被中断，需要从同步队列中删除</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将当前节点设置为 SIGNAL，不会阻塞</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是根据前驱节点的 <code>waitStatus</code> 来判断当前节点的线程，如果当前节点应该被阻塞，则会调用 <code>parkAndCheckInterrupt</code> 方法阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用 <code>LockSupport.park()</code> 方法阻塞当前线程，并返回当前线程的中断状态。</p><h3 id="可中断式获取"><a href="#可中断式获取" class="headerlink" title="可中断式获取"></a>可中断式获取</h3><p><code>acquireInterruptibly</code> 方法以可响应中断的方式获取同步状态，其中调用 <code>tryAcquire</code> 方法失败后，会调用 <code>doAcquireInterruptibly</code> 方法自旋式获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireInterruptibly</code> 方法与普通地独占式获取同步状态非常类似，只是不再使用 <code>interrupt</code> 标志，而是直接抛出 <code>InterruptedException</code> 异常。</p><h3 id="超时可中断式获取"><a href="#超时可中断式获取" class="headerlink" title="超时可中断式获取"></a>超时可中断式获取</h3><p><code>tryAcquireNanos</code> 方法可以超时获取同步状态，即在指定时间内可中断地获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先调用 <code>tryAcquire</code> 方法尝试获取同步状态，如果获取失败，则会调用 <code>doAcquireNanos</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算总的超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余的超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 如果超时时间大于 临界值，则会阻塞线程，否则快速自旋</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先计算出超时的最终时间，然后将当前节点加入到同步队列中。</p><p>然后自旋进行判断，如果当前节点为头节点，则会调用 <code>tryAcquire</code> 方法尝试获取同步状态；否则重新计算超时时间，如果 <code>nanosTimeout</code> 小于 <code>0</code>，则获取失败。否则继续判断超时时间是否大于 <code>spinForTimeoutThreshold</code> 临界值，如果大于表示时间较长，调用 <code>LockSupport.parkNanos</code> 使线程阻塞。</p><p>如果时间较短，则直接进入自旋过程，继续判断。另外，还会判断线程是否被中断。</p><h3 id="独占式释放"><a href="#独占式释放" class="headerlink" title="独占式释放"></a>独占式释放</h3><p><code>release</code> 方法用来释放同步状态，该方法释放了同步状态后，会唤醒后继节点，使其重新尝试获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先调用 <code>tryRelease</code> 方法尝试释放同步状态，该方法由自定义同步组件自己实现。然后调用 <code>unparkSuccessor</code> 方法来唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 节点状态设置为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后继节点超时或者被中断</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从 tail 向前，找最靠近 head 的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先找到一个可用的 <code>waitStatus</code> 值大于 <code>0</code> 的节点，然后调用 <code>LockSupport.unpark</code> 方法唤醒该线程。</p><h2 id="共享式获取与释放"><a href="#共享式获取与释放" class="headerlink" title="共享式获取与释放"></a>共享式获取与释放</h2><p>共享式与独占式最大的区别就是同一时刻有多个线程同时获取到同步状态。</p><p>共享式获取与释放同步状态主要有四个模板方法，分别是：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>acquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>acquireSharedInterruptibly(int arg)</td><td>可响应中断的共享式获取同步状态</td></tr><tr><td>tryAcquireSharedNanos(int arg, long anos)</td><td>可响应中断的共享式超时获取同步状态</td></tr><tr><td>releaseShared(int arg)</td><td>共享式释放同步状态</td></tr></tbody></table><h3 id="共享式获取"><a href="#共享式获取" class="headerlink" title="共享式获取"></a>共享式获取</h3><p><code>acquireShared</code> 方法可以共享式地获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先调用 <code>tryAcquireShared</code> 方法尝试获取同步状态，如果返回值大于等于 <code>0</code>，则表示获取成功。否则获取失败，则会调用 <code>doAcquireShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 大于等于 0，表示获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先以共享节点加入到等待队列中，然后以死循环的方式进行判断，如果当前节点的前驱节点为头节点，则调用 <code>doAcquireShared</code> 方法尝试获取同步状态，直到其返回值大于等于 <code>0</code>。</p><p>可响应中断、超时获取的共享式获取同步状态与之前类似，这里也就不多介绍。</p><h3 id="共享式释放"><a href="#共享式释放" class="headerlink" title="共享式释放"></a>共享式释放</h3><p><code>releaseShared</code> 方法用于共享式释放同步状态，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先调用 <code>tryReleaseShared</code> 尝试释放同步状态，如果释放失败，则会调用 <code>doReleaseShared</code> 方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中在释放同步状态时，由于有多个线程，需要保证线程安全。首先，如果后继节点的线程需要唤醒，则将当前节点的状态设置为 <code>0</code>，然后调用 <code>unparkSuccessor</code> 方法唤醒后继节点。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>方腾飞：《Java并发编程的艺术》</li><li><a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：AQS简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lock-接口&quot;&gt;&lt;a href=&quot;#Lock-接口&quot; class=&quot;headerlink&quot; title=&quot;Lock 接口&quot;&gt;&lt;/a&gt;Lock 接口&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;Java5&lt;/code&gt; 之前，只能使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字来实现锁。它使用起来比较简单，但是有一些局限性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法中断一个正在等待获取锁的线程；&lt;/li&gt;
&lt;li&gt;无法在请求获取一个锁时等待一段时间。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之深入分析 synchronized 关键字</title>
    <link href="https://blog.timberliu.com/2019/03/03/036_%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20synchronized%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.timberliu.com/2019/03/03/036_深入分析 synchronized 实现原理/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized-概述"><a href="#synchronized-概述" class="headerlink" title="synchronized 概述"></a>synchronized 概述</h1><p><code>synchronized</code> 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。<a id="more"></a></p><ul><li>互斥性：同一时刻只允许一个线程持有某个对象锁，一次实现对共享资源的互斥访问。</li><li>可见性：确保在锁释放前，对共享变量做的修改，对随后获得该锁的另一个线程是可见的。 </li></ul><p><code>synchronized</code> 的获取和释放锁由 <code>JVM</code> 实现，用户不需要显示的获取和释放锁，非常方便。但是当线程尝试获取锁的时候，如果获取不到锁该线程会一直阻塞。</p><p>在早期版本中，<code>synchronized</code> 是一个重量级锁，效率低下。但从 <code>JDK1.6</code> 开始，从 <code>JVM</code> 层面对 <code>synchronized</code> 引入了各种锁优化技术，例如：自旋锁、适应性自旋锁、锁消除、锁粗化、轻量级锁和偏向锁等，大大减少了锁操作的开销。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>使用 <code>synchronized</code> 实现同步有同步方法块、同步方两种方式。</p><h2 id="同步方法块"><a href="#同步方法块" class="headerlink" title="同步方法块"></a>同步方法块</h2><p>作用于代码块时，括号中可以是指定的对象，也可以是 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的是指定的对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁定是指定的类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>作用于方法时，锁的是当前的对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于静态方法，锁的是类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理基础"><a href="#原理基础" class="headerlink" title="原理基础"></a>原理基础</h1><p><strong>HotSpot 对象头</strong></p><p><code>HotSpot</code> 虚拟机的对象头分为两部分信息：</p><ul><li><code>Mark Word</code>：用于存放对象自身的运行时数据，如哈希码、<code>GC</code> 分代年龄、锁类型、锁标志位等信息，这部分数据在 <code>32</code> 位和 <code>64</code> 位虚拟机中分别为 <code>32</code> 和 <code>64 bit</code>。它是实现轻量级锁和偏向锁的关键。</li><li><code>Class Metadata Address</code>：用于存储指向方法区对象类型数据的指针，如果是数组，还会有一个额外的部分用于存放数组长度。</li></ul><p><code>Mark Word</code> 被设计为一个非固定的数据结构以便存储更多的信息，它会根据对象的状态复用自己的存储空间。例如，在 <code>32</code> 位的 <code>HotSpot</code> 虚拟机中,各种状态下对象的存储内容如下：</p><p><img src="http://media.timberliu.com/image/2019/3/3/ObjectHead.png" width="60%"></p><p><strong>Monitor</strong></p><p>每个 <code>Java</code> 对象都有一个 <code>Monitor</code> 对象与之关联，它被称为管程（监视器锁），前面的表格中，锁状态为重量级锁时，指针就指向 <code>Monitor</code> 对象的起始地址。当一个 <code>Monitor</code> 被某个线程持有后，便处于锁定状态。在 <code>HotSpot</code> 虚拟机的源码实现中，<code>ObjectMonitor</code> 对象相关属性有：</p><ul><li><code>_count</code>：计数器；</li><li><code>_owner</code>：指向持有 <code>ObjectMonitor</code> 对象的线程；</li><li><code>_WaitSet</code>：等待池；</li><li><code>_EntryList</code>：锁池；</li></ul><p>多个线程访问同步代码时，首先会进入 <code>_EntryList</code> 锁池中被阻塞，当线程获取到对象的 <code>Monitor</code> 后，就会把 <code>_owner</code> 指向当前线程，同时 <code>Monitor</code> 中的 <code>_count</code> 计数器加一。如果线程调用 <code>wait</code> 方法，<code>_owner</code> 就被恢复为 <code>null</code>，<code>_count</code> 计数器减一，同时该线程就会进入 <code>_WaitSet</code> 等待池中。</p><p>当线程执行完毕，将对应的变量复位，以便其他线程获取 Monitor 锁。</p><p><strong>四种状态</strong></p><p><code>synchronized</code> 有四种状态：无锁、偏向锁、轻量级锁和重量级锁。随着对锁的竞争逐渐激烈，锁的状态进行升级。</p><h1 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h1><h2 id="同步方法块-1"><a href="#同步方法块-1" class="headerlink" title="同步方法块"></a>同步方法块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ···</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -c -v</code> 对 <code>SynchronizedTest.class</code> 进行反汇编：</p><p><img src="http://media.timberliu.com/image/2019/2/27/synchronized%20%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%97.png" width="80%"></p><p>可以看到，在同步代码块的开始位置插入 <code>monitorenter</code> 指令，在结束位置插入 <code>monitorexit</code> 指令，而且必须保证每一个 <code>monitorenter</code> 都有一个 <code>monitorexit</code> 与之对应。</p><p><code>synchronized</code> 便是通过 <code>Monitor</code> 获取锁的。当线程执行到 <code>monitorenter</code> 指令时，将会尝试获取 <code>Monitor</code> 所有权。当计数器为 <code>0</code>，则成功获取；获取后将锁计数器置为 <code>1</code>。在执行 <code>monitorexit</code> 指令时，将锁计数器置为 <code>0</code>。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h2 id="同步方法-1"><a href="#同步方法-1" class="headerlink" title="同步方法"></a>同步方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -c -v</code> 对 <code>SynchronizedTest.class</code> 进行反汇编：</p><p><img src="http://media.timberliu.com/image/2019/2/27/synchronized%20%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" width="80%"></p><p>可以看到，被同步的方法也仅是被翻译成普通的方法调用和返回指令。在 <code>JVM</code> 字节码层面并没有任何特别的指令来实现 <code>synchronized</code> 修饰的方法。</p><p>但是在 <code>Class</code> 文件的方法表中将方法的 <code>flags</code> 字段中的 <code>ACC_SYNCHRONIZED</code> 标志位置为 <code>1</code>，表示该方法是同步方法。在执行方法时，线程就会持有 <code>Monitor</code> 对象。</p><h1 id="底层优化"><a href="#底层优化" class="headerlink" title="底层优化"></a>底层优化</h1><p><code>JDK1.6</code> 对锁引入了大量的优化，如自旋锁、自适应自旋锁、锁消除、锁粗化、轻量级锁、偏向锁等技术来减少锁操作的开销。</p><h2 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h2><p>在实现同步互斥时，如果获取锁失败，就会使当前线程阻塞，但线程的挂起和恢复都需要在内核态和用户态之间转换，对系统的性能影响很大。许多情况下共享数据的锁定状态持续时间不会很长，切换线程不值得。</p><p>自旋锁就是让线程在请求共享数据的锁时执行一个忙循环（自旋），如果能够很快获得锁，就避免其进入阻塞状态。</p><p>自旋等待虽然避免了线程切换的开销，但它要求多处理器，而且要占用处理器时间。如果锁占用时间过长，那么反而会消耗更多的资源。因此，对自旋等待的时间必须进行限制，另外自旋的次数也不能过多，默认为 <code>10</code> 次，可使用 <code>-XX:PreBlockSpin</code> 参数修改。</p><p><code>JDK1.6</code> 中引入了自适应的自旋锁，它的自旋时间由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机的即时编译器在运行时，如果代码要求同步，但检测发现不可能存在共享数据竞争时，那么就进行锁消除。</p><p>锁消除主要根据逃逸分析，如果判断在一段代码中，堆上的所有数据都不会逃逸出去，那就可以将它们认为是线程私有的，也就无须进行同步加锁。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁也是出现循环体中，那么即使没有数据竞争，频繁地加锁解锁也会导致不必须的性能消耗。</p><p>锁粗化指的就是如果虚拟机探测到这样的情况，那就将加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是在无竞争的情况下消除整个同步，也就是减少同一线程获取锁的代价。它的思想是这个锁会偏向于第一个获得它的线程，如果接下来该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>当锁对象第一次被线程获取时，锁进入偏向模式，同时 Mard Word 的结构也变为偏向锁结构。锁标志位为“01”，同时使用 <code>CAS</code> 操作把获取到这个锁的线程的 <code>ID</code> 记录在对象的 <code>Mark Word</code> 中，如果 <code>CAS</code> 操作成功，这个线程以后每次进入这个锁相关的同步块时，都可以不用再进行任何同步操作。</p><p>不适用于锁竞争比较激烈的多线程场合。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是相对于使用操作系统互斥量实现的传统锁而言的。偏向锁运行在一个线程进入同步块时，如果有第二个线程加入锁竞争，则偏向锁就会升级为轻量级锁。它适用于线程交替执行的场景。</p><p>在代码进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机将先在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前 <code>Mark Word</code> 的拷贝。如下图，左侧是一个线程的虚拟机栈，右侧是一个锁对象：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20CAS%20%E4%B9%8B%E5%89%8D%E5%A0%86%E6%A0%88%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" width="60%"></p><p>然后，虚拟机将使用 <code>CAS</code> 操作尝试将对象的 <code>Mark Word</code> 更新为指向 <code>Lock Record</code> 的指针，并将 <code>Lock Record</code> 里的 <code>owner</code> 指针指向对象的 <code>Mark Word</code>。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象的 <code>Mark Word</code> 的锁标志位转变为“00”，即表示对象处于轻量级锁定状态。多线程堆栈和对象头的状态如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20CAS%20%E5%90%8E%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E7%8A%B6%E6%80%81.png" width="60%"></p><p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果已指向则说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，如果没有指向则说明这个锁对象已经被其他对象抢占了。</p><p>如果有两条以上的线程争用同一个锁，那轻量级锁就要膨胀为重量级锁，锁标志变为“10”，<code>Mark Word</code> 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。</p><p>对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了重量级锁使用互斥量的开销，提升了程序同步的性能。</p><p>偏向锁、轻量级锁的状态转化及对象 <code>Mark Word</code> 的关系如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E5%81%8F%E5%90%91%E9%94%81.jpg" width="60%"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《深入理解 Java 虚拟机》</li><li>CyC2018：<a href="https://note.youdao.com/" target="_blank" rel="noopener">CS-Notes / Java 并发</a></li><li>Hollis：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized-概述&quot;&gt;&lt;a href=&quot;#synchronized-概述&quot; class=&quot;headerlink&quot; title=&quot;synchronized 概述&quot;&gt;&lt;/a&gt;synchronized 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Java 内存模型</title>
    <link href="https://blog.timberliu.com/2019/03/03/035_Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://blog.timberliu.com/2019/03/03/035_Java 内存模型/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h1><p>计算机的 <code>CPU</code> 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下：</p><ul><li><code>CPU</code> 增加了高速缓存，以均衡与内存的速度差异；</li><li>操作系统增加了进程、线程，以分时复用 <code>CPU</code>，均衡 <code>CPU</code> 与 <code>I/O</code> 设备的差异；</li><li>编译器优化指令执行次序，使得缓存能得到更加充分的利用。<a id="more"></a></li></ul><p>虽然高速缓存很好地解决了处理器与内存的速度矛盾，但是又出现了一个新的问题。在多核处理机中，每个处理器都有自己的高速缓存，它们共享同一主内存。当多个处理器的任务涉及到同一块主内存区域时，可能导致缓存的数据不一致的情况，这就是可见性问题，可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>操作系统基于线程来进行任务调度。高级语言的一条语句往往需要多条指令完成，但是任务切换可以发生在任何一条 <code>CPU</code> 指令后，在多线程环境下这就可能导致数据与预期的不一致，即原子性问题。原子性是指一个或多个操作在 <code>CPU</code> 执行过程中不被中断。</p><p>编译器的指令重排序优化同样不能保证最终的结果与预期的一致。这里的重排序会满足以下两个条件：</p><ul><li><code>as-if-serial</code>：在单线程环境下不管怎么重排序，不能改变程序运行的结果。</li><li>数据依赖性：存在数据依赖关系的不能重排序。</li></ul><p>需要注意的是：虽然重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。也就是有序性问题，有序性指的是程序按照代码的先后顺序（逻辑先后）执行。</p><p>所以，<code>JVM</code> 试图虚拟机定义了一种 <code>Java</code> 内存模型（<code>Java Memory Model</code>，<code>JMM</code>）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 <code>Java</code> 程序在各种平台下都能达到一致的内存访问效果，也就是解决以上三个问题。</p><h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p><code>Java</code> 内存模型主要是为了定义程序中各个变量的访问规则，此处的变量指的是实例字段、静态字段和构成数组对象的元素等共享变量。</p><p><code>Java</code> 内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，其中保存了该线程使用的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程之间的变量值传递需要通过主内存来完成。</p><p>线程、工作内存、主内存三者的关系如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" width="60%"></p><h1 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h1><p>对于主内存与工作内存之间交互的实现细节，<code>Java</code> 内存模型中定义了 <code>8</code> 种操作来实现，虚拟机实现时必须保证这些操作是原子性的。</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92.jpg" width="60%"></p><ul><li><code>read</code>（读取）：把一个变量的值从主内存传输到工作内存中；</li><li><code>load</code>（载入）：把 <code>read</code> 操作从主内存得到的变量放入工作内存的变量副本中；</li><li><code>use</code>（使用）；把工作内存中一个变量的值传递给执行引擎；</li><li><code>assign</code>（使用）：把一个从执行引擎接收到的值赋给工作内存的变量；</li><li><code>store</code>（存储）：把工作内存中一个变量的值传送到主内存中；</li><li><code>write</code>（写入）：把 <code>store</code> 操作从工作内存中得到的变量放入主内存的变量中。</li></ul><h1 id="volatile-型变量"><a href="#volatile-型变量" class="headerlink" title="volatile 型变量"></a>volatile 型变量</h1><p>关键字 <code>volatile</code> 是 <code>JVM</code> 提供的轻量级的同步机制。当一个变量被定义为 <code>volatile</code> 后，它可以保证内存的可见性。</p><p>使用 <code>volatile</code> 还可以禁止指令重排序优化。它是 <code>Java</code> 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>内存屏障（<code>Memory Barrier</code>）是一组处理器指令，用于实现对内存访问操作的顺序限制。在重排序时不能把后面的指令重排序到内存屏障之前的位置。</p><h1 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h1><p><code>Java</code> 内存模型保证了并发的三个特性：原子性、可见性、有序性，下面学习一下哪些操作实现了这三个特性：</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>Java</code> 内存模型保证了内存间交互的 <code>8</code> 个操作的原子性，但对于 <code>64</code> 位的数据类型（<code>long</code> 和 <code>double</code>），允许虚拟机的实现可以不保证 <code>64</code> 位数据类型的 <code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 这 <code>4</code> 个操作的原子性。但目前虚拟机几乎都把 <code>64</code> 位数据的读写操纵作为原子性来对待。也就是说可以认为基本类型的读写访问是具备原子性的。</p><p><code>JMM</code> 还提供了 <code>lock</code> 和 <code>unlock</code> 操作来保证更大范围的原子性，尽管虚拟机并未将其开放给用户，但可使用 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令来隐式地使用这两个操作，对应到 <code>Java</code> 代码中就是 <code>synchronized</code> 关键字，所以 <code>synchronized</code> 同步块也是原子性的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>主要有三种方式实现可见性：</p><ul><li><code>volatile</code>：<code>volatile</code> 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</li><li><code>synchronized</code>：对同步块加锁解锁，在执行 <code>unlock</code> 操作前必须把此变量值同步到主内存中。</li><li><code>final</code>：被 <code>final</code> 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 <code>this</code> 引用逃逸（其它线程可能通过引用访问到初始化了一半的对象），那么其它线程就能看见 <code>final</code> 字段的值。</li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p><code>Java</code> 中有两种方式保证线程之间操作的有序性；</p><ul><li><code>volatile</code> 关键字通过添加内存屏障的方式来禁止指令重排。</li><li>通过 <code>synchronized</code> 来保证有序性，它保证每个时刻只有一个线程执行同步代码，即让线程串行地执行同步代码。</li></ul><h1 id="Happends-Before-原则"><a href="#Happends-Before-原则" class="headerlink" title="Happends-Before 原则"></a>Happends-Before 原则</h1><p>前面说的保证并发安全的定义实践起来比较麻烦，有一个等效判断原则——<code>Happens-Before</code> 原则，来确定一个访问在并发环境下是否安全。</p><p><code>Happens-Before</code> 的含义就是前面一个操作的结果对后续操作是可见的。要想保证执行操作 <code>B</code> 的线程看到线程 <code>A</code> 的结果，那么 <code>A</code> 和 <code>B</code> 之间必须满足 <code>Happens-Before</code> 原则。如果两个操作之间缺乏 <code>Happens-Before</code> 原则，那么 <code>JVM</code> 就可以对它们任意地重排序，那么就会产生数据竞争问题。</p><p><code>Happens-Before</code> 原则包括：</p><ul><li>程序顺序规则：一个线程内按照控制流顺序，前面的操作 <code>Happens-Before</code> 于后面的操作。</li><li>管程锁定规则：一个 <code>unlock</code> 操作 <code>Happens-Before</code> 于后面对同一个锁的 <code>lock</code> 操作。</li><li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 变量的写操作 <code>Happens-Before</code> 于对该变量的读操作。</li><li>线程启动规则：<code>Thread</code> 对象的 <code>start</code> 方法 <code>Happens-Before</code> 于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都 <code>Happens-Before</code> 于对该线程的终止检测，可通过 <code>Thread.join</code> 方法结束，或 <code>Thread.isAlive</code> 方法的返回值，检测到线程已经终止执行。</li><li>线程中断规则：对线程 <code>interrupt</code> 方法的调用 <code>Happens-Before</code> 于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成 <code>Happens-Before</code> 于它的 <code>finalize</code> 方法的开始。</li><li>传递性：如果操作 <code>A</code>  <code>Happens-Before</code> 于操作 <code>B</code>，操作 <code>B</code>  <code>Happens-Before</code> 于操作 <code>C</code>，那么操作 <code>A</code> 就 <code>Happens-Before</code> 于操作 <code>C</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《深入理解 Java 虚拟机》</li><li>CyC2018：<a href="https://note.youdao.com/" target="_blank" rel="noopener">CS-Notes / Java 并发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要有内存模型&quot;&gt;&lt;a href=&quot;#为什么要有内存模型&quot; class=&quot;headerlink&quot; title=&quot;为什么要有内存模型&quot;&gt;&lt;/a&gt;为什么要有内存模型&lt;/h1&gt;&lt;p&gt;计算机的 &lt;code&gt;CPU&lt;/code&gt; 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; 增加了高速缓存，以均衡与内存的速度差异；&lt;/li&gt;
&lt;li&gt;操作系统增加了进程、线程，以分时复用 &lt;code&gt;CPU&lt;/code&gt;，均衡 &lt;code&gt;CPU&lt;/code&gt; 与 &lt;code&gt;I/O&lt;/code&gt; 设备的差异；&lt;/li&gt;
&lt;li&gt;编译器优化指令执行次序，使得缓存能得到更加充分的利用。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 类加载机制</title>
    <link href="https://blog.timberliu.com/2019/03/02/034_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.timberliu.com/2019/03/02/034_类加载机制/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code> 源程序经过编译器编译后，会生成 <code>Class</code> 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。<a id="more"></a></p><h1 id="类加载概述"><a href="#类加载概述" class="headerlink" title="类加载概述"></a>类加载概述</h1><p>类加载机制，就是 <code>JVM</code> 将描述类的数据从 <code>Class</code> 文件加载到内存中，并对数据进行校验、转换解析和初始化，最终会形成可以被 <code>JVM</code> 直接使用的 <code>Java</code> 类型。</p><p>类被从加载，到卸载会经历如下七个生命周期：</p><p><img src="http://media.timberliu.com/image/2019/2/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" width="80%"> </p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序的确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始。</p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类加载在何时开始，<code>Java</code> 虚拟机规范并没有明确规定。但是对初始化阶段，则是严格规定了有且只有五种情况必须立即对类进行初始化：</p><ul><li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 四条字节码指令时，如果类没有被初始化，则需要先进行初始化。它们对应的代码场景分别是：<ul><li><code>new</code>：使用 <code>new</code> 关键在实例化对象时；</li><li><code>getstatic</code>：读取一个类的静态字段；</li><li><code>putstatic</code>：设置一个类的静态字段；</li><li><code>invokestatic</code>：调用一个类的静态方法时；</li></ul></li><li>使用 <code>java.lang.reflect</code> 包中的方法对类进行反射调用时，如果类没有被初始化，则需要先进行初始化。</li><li>当初始化一个类时，如果其父类还没有被初始化，则需要先对其父类进行初始化。</li><li>当虚拟机启动时，需要指定一个要执行的主类（包含 <code>main</code> 方法的类），虚拟机会先初始化这个主类。</li><li>当使用 <code>JDK1.7</code> 的动态语言支持时，如果一个 <code>java.lang.invoke.MehodHandle</code> 实例最后的解析结果 <code>REF_getStatic</code>、<code>REF_getStatic</code>、<code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先进行初始化。</li></ul><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>下面详细学习一下类加载的全过程，也就是加载、验证、准备、解析和初始化五个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载阶段，<code>JVM</code> 需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时的数据结构。</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>加载完成后，二进制字节流按照 <code>JVM</code> 所需的格式存储在方法区之中，方法区中的数据存储格式由 <code>JVM</code> 具体的实现中定义。然后在内存中实例化一个 <code>java.lang.Class</code> 类的对象，这个对象将作为程序访问方法区中的数据的外部接口。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 <code>Class</code> 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证阶段大致会完成 <code>4</code> 个阶段的检验动作，其中第一个阶段是基于二进制字节流进行的，之后进入内存的方法区中存储；而后三个阶段是基于方法区的存储结构进行的：</p><ul><li>文件格式验证：验证字节流是否符合 <code>Class</code> 文件格式的规范，并且能被当前版本的虚拟机处理。例如：是否以魔数 <code>0xCAFEBABE</code> 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 <code>Java</code> 语言规范的要求。例如：这个类是否有父类，这个类的父类是否继承了不允许被继承的类( <code>final</code> 类)。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对方法体进行校验分析，保证被校验方法的安全性。</li><li>符号引用验证：在解析阶段发生。对类自身以外的信息进行匹配性校验，例如符号引用中通过字符串描述的全限定名是否能找到对应的类等。</li></ul><p>验证阶段非常重要，但不是必须的，因为它对程序运行期没有影响。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。该阶段有需要注意以下几点：</p><ul><li>这个阶段进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等）。</li><li>如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性，即同时被 <code>final</code> 和 <code>static</code> 修饰，那么在准备阶段变量就会被初始化为 <code>ConstValue</code> 属性所指定的值。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用与直接应用区别如下：</p><ul><li>符号引用：以一组符号来描述引用的目标，可以是任何形式的字面量。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><p>解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 <code>7</code> 类符号引用进行。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在准备阶段，变量已经被赋过一次系统要求的初始值。而在初始化阶段，则按照程序去初始化类变量，或者说，初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法。</p><p><code>&lt;clinit&gt;</code> 方法运行的特点和细节如下：</p><ul><li><code>&lt;clinit&gt;</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。收集的顺序是语句在源文件中出现的顺序决定，静态语句块只能访问定义在静态语句块之前的变量。定义在它之后的变量，在之前的静态语句块可以赋值，但不能访问。</li><li>虚拟机会保证子类的 <code>&lt;clinit&gt;</code> 方法执行之前，父类的 <code>clinit</code> 方法已执行完毕。</li><li>执行接口的 <code>&lt;clinit&gt;</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;</code> 方法。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>加载阶段的“通过一个类的全限定类名来获取此类的二进制字节流”这个动作放到 <code>JVM</code> 外部实现，以便让应用程序自己决定如何获取所需的类。这个模块称为“类加载器”。</p><p>类加载器除了用于实现类的加载动作，还用来比较两个类是否“相等”。这里的相等指的是：只有两个类是由同一个类加载器的前提下，两个类来源于同一 <code>Class</code> 文件，被同一个虚拟机加载，两个类才相等。</p><p>这里的“相等”，包括：</p><ul><li>代表类的 <code>Class</code> 对象的 <code>equals()</code> 方法；</li><li><code>isAssignableFrom()</code> 方法；</li><li><code>isInstance()</code> 方法；</li><li>使用 <code>instanceof</code> 关键字对对象所属关系判断；</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h2><p><code>Java</code> 程序一般会使用三种系统提供的类加载器：启动类加载器、扩展类加载器和应用程序加载器（<code>HotSpot</code> 虚拟机）。它们的层次关系如下图：</p><p><img src="http://media.timberliu.com/image/2019/2/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" width="80%"></p><p>这种层次关系，称为类加载器的双亲委派模型。其中除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。子类加载器和父类加载器不是以继承关系来实现，而是通过组合关系来复用父加载器的代码。</p><p>三种类加载器如下：</p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：使用 <code>C++</code> 语言实现，是虚拟机自身的一部分。这个类加载器负责加载 <code>JVM</code> 启动所需要的类（<code>&lt;JAVA_HOME&gt;\lib</code> 或 <code>-Xbootclasspath</code> 目录下的类库）。</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：除了启动类加载器外，其他类加载器都由 <code>Java</code> 实现，独立于虚拟机外部。它负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，或者被 <code>java.ext.dirs</code> 系统变量指定的路径中的类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（<code>Application ClassLoader</code>）：这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值。它负责加载用户类路径（<code>ClassPath</code>）上所指定的类库。开发者可以直接使用这个类加载器。</li></ul><p>使用双亲委派模型组织类加载器之间的关系，使得 <code>Java</code> 类随着它的类加载器一起具备了带有优先级的层次关系，而不会出现关系混乱的类加载器。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>双亲委派模型的工作过程如下：</p><ul><li>如果一个类加载器收到类加载的请求，它首先从自己的加载类缓存中，查询该类是否已经被加载，如果已经加载则直接返回原来已经加载的类。</li><li>如果没有加载，则会委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到顶层的启动类加载器。</li><li>只有当父加载器无法完成这个加载请求，即它的搜索范围中没有找到所需的类时，子加载器才会尝试自己去加载。</li><li>如果一个类加载器加载类后，会将其放入自己的缓存中，以便下次有加载请求的时候直接返回。</li></ul><h2 id="优先使用父-ClassLoader-加载类"><a href="#优先使用父-ClassLoader-加载类" class="headerlink" title="优先使用父 ClassLoader 加载类"></a>优先使用父 ClassLoader 加载类</h2><p>主要有以下两个好处：</p><ol><li>共享功能：可以避免重复加载，当父加载器已经加载了该类时，就不需要子类再次加载，一些顶层的类被 <code>ClassLoader</code> 加载过就会缓存在内存里，以后用到时都不需要重新加载。</li><li>隔离功能：为了安全性，避免用户自己编写的类替换 <code>Java</code> 的一些核心类，比如 <code>String</code> ，同时也避免了重复加载，因为 <code>JVM</code> 中区分不同类，不仅仅是根据类名，相同的 <code>class</code> 文件被不同的 <code>ClassLoader</code> 加载就是不同的两个类，如果相互转型的话会抛 <code>java.lang.ClassCastException</code>。</li></ol><h2 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h2><p>双亲委派模型的代码都集中在在 <code>java.lang.ClassLoader</code> 的 <code>loadClass</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                </span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>loadClass</code> 方法的加载过程如下：</p><ul><li>首先检查请求的类是否已经被加载。</li><li>如果没有调用，则调用父加载器的 <code>loadClass</code> 方法。</li><li>如果父加载器为空，则默认使用启动类加载器加载。</li><li>如果父加载器加载失败，抛出 <code>ClassNotFoundException</code> 异常，再调用自己的 <code>findClass</code> 方法进行加载。</li></ul><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型仅是 <code>Java</code> 推荐的类加载器实现方式。大部分的类加载器也都遵循这个模型，双亲委派模型主要出现过 <code>3</code> 次被破坏的情况。</p><p>第一次破坏是发生在双亲委派模型出现之前。为了向前兼容 <code>JDK1.0</code> 就存在的类加载器和抽象类 <code>java.lang.ClassLoader</code>，在 <code>JDK1.2</code> 后的 <code>java.lang.ClassLoader</code> 添加了一个新的 <code>protected</code> 方法 <code>findClass()</code>。</p><p>第二次破坏是由模型自身的缺陷导致的。用户代码总是调用基础类，但是上层类加载器加载的基础类不能调用回用户的代码。<code>Java</code> 中引入了线程上下文类加载器，可以使用这个线程上下文类加载器请求子类加载器去完成类加载的动作。</p><p>第三次破坏是由于用户对程序的动态性的追求导致的。例如 <code>OSGI</code> 实现模块化热部署，在 <code>OSGI</code> 环境下，类加载器不再是双亲委派模型中的树形结构，而是发展为网状结构。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>指 · 间：<a href="http://www.zhenchao.org/2016/12/04/jvm/class-load/" target="_blank" rel="noopener">探秘 JVM：类加载机制</a></li><li>芋道源码：《精尽 Java【虚拟机】面试题》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 源程序经过编译器编译后，会生成 &lt;code&gt;Class&lt;/code&gt; 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 垃圾收集器</title>
    <link href="https://blog.timberliu.com/2019/02/26/033_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/02/26/033_垃圾收集器/</id>
    <published>2019-02-25T16:00:00.000Z</published>
    <updated>2019-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中学习了 <code>JVM</code> 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 <code>HotSpot</code> 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><code>HotSpot</code> 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。<a id="more"></a></p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p><code>Serial</code> 收集器是一个单线程的收集器，它不仅只会使用一个 <code>CPU</code> 或一条收集线程去完成垃圾收集工作，而且在垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><code>Serial</code> 收集器是 <code>HotSpot</code> 虚拟机在运行 <code>Client</code> 模式下的默认新生代收集器。在垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。</p><p>但它也有优点，与其他收集器的单线程相比，由于没有现成交互的开销，专心做垃圾收集，所以其简单而高效；</p><p>可以使用 <code>-XX:UseSerialGC</code> 参数选择使用 <code>Serial</code> 收集器，此时年轻代采用 <code>Serail</code>，老年代采用 <code>Serial Old</code>。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><code>ParNew</code> 收集器是 <code>Serial</code> 收集器的多线程版本，除了使用多线程进行垃圾回收外，其他几乎一样。</p><p>它是许多运行在 <code>Server</code> 模式下的虚拟机首选的新生代收集器，一个很重要的原因是除了 <code>Serial</code> 收集器外，只有 <code>ParNew</code> 收集器与 <code>CMS</code> 收集器配合工作。垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。</p><p><code>ParNew</code> 收集器默认开启的线程数与 <code>CPU</code> 的数量相同，可以使用 <code>-XX:ParallelGCThreas</code> 参数来限制垃圾收集的线程数。使用 <code>-XX:UseParNewGC</code> 参数来使用 <code>ParNew</code> 收集器。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p><code>Parallel Scavenge</code> 收集器是新生代收集器，也是使用复制算法的多线程收集器。与其他收集器不同的是，它关注的是达到一个可控制的吞吐量，吞吐量 = 运行代码时间 / （运行代码时间 + 垃圾收集时间）。</p><p><code>Parallel Scanenge</code> 收集器提供了两个参数用于精确控制吞吐量。第一个是控制最大垃圾收停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数。它允许是一个大于 <code>0</code> 的毫秒数，收集器将尽可能保证内存回收时间不超过设定值。这个参数也不是越小越好，GC 停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</p><p>第二个是直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数。它允许是一个大于 <code>0</code> 且小于 <code>100</code> 的整数，就是垃圾收集时间占总时间的比率。</p><p>另外，<code>Parallel Scavenge</code> 收集器拥有自适应调节机制，它不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 与 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象大小 <code>-XX:PretenureSizeThreshold</code> 等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间及最大的吞吐量。可使用 <code>-XX:UseAdaptiveSizePolicy</code> 参数来开启。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><code>Serial Old</code> 是 <code>Serial</code> 收集器的老年代版本，是一个单线程收集器，使用“标记-整理算法”。</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p><code>Parallel Old</code> 是 <code>Parallel Scavenge</code> 收集器的老年代版本，使用多线程和“标记-整理”算法。如果新生代选择了 <code>Parallel Scavenge</code> 收集器，老年代只能选择 <code>Serial Old</code> 收集器。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p><code>CMS(Concurrent Mark Sweep)</code> 是一种以获取最短停顿时间为目标的收集器，使用“标记-清除”算法。如果应用重视响应速度，希望停顿时间最短，就可以选择 <code>CMS</code> 收集器。</p><p>它的运作过程可分为 <code>4</code> 个步骤：</p><ul><li>初始标记：仅仅标记 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要 <code>Stop the world</code>。</li><li>并发标记：进行 <code>GC Roots Tracing</code> 过程。 </li><li>重新标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。</li><li>并发清除。</li></ul><p><code>CMS</code> 的主要优点是并发收集、低停顿。但也有三个缺点：</p><ul><li>对 <code>CPU</code> 资源非常敏感。并发阶段虽不会导致用户线程停顿，但会因为占用资源而导致程序变慢，总吞吐量降低。</li><li>无法处理浮动垃圾，也就是在标记过程后，清除阶段产生但当次收集中不能处理的垃圾，可能出现 <code>Concurrent Mode Failure</code> 失败而导致另一次 <code>Full FC</code> 的产生。</li><li><code>CMS</code> 基于标记-清除算法，收集结束时会产生大量空间碎片。碎片过多时，无法找到足够的连续空间来分配大对象，不得不提前出发一次 <code>Full GC</code>。</li></ul><p>可以使用 <code>-XX:UseConcMarkSweepGC</code> 参数来选择 <code>CMS</code> 收集器。</p><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p><code>G1(Garbage-First)</code> 是一款面向服务端应用的垃圾收集器。它的特点如下：</p><ul><li>并行与并发：充分利用多 <code>CPU</code>、多核环境，使用多个 <code>CPU</code> 来缩短停顿的时间，部分需要其他收集器原本需要停顿 <code>Java</code> 线程执行的 <code>GC</code> 动作，<code>G1</code> 收集器可通过并发的方式让 <code>Java</code> 程序继续执行。</li><li>分代收集：<code>G1</code> 收集器能独立管理整个 <code>GC</code> 堆，并且能采用不同的方式处理不同时期的对象。</li><li>空间整合：<code>G1</code> 收集器从整体来看，基于“标记-整理”算法实现；从局部来看，基于“复制”算法实现。</li><li>可预测的停顿：<code>G1</code> 能明确指定垃圾收集的限制时间。</li></ul><p>使用 <code>G1</code> 收集器时，将 <code>Java</code> 堆划分为多个大小相等的区域 <code>Region</code>。<code>G1</code> 跟踪各个 <code>Region</code> 的回收价值和成本（回收获得空间及回收时间），后台会维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>。它通过使用 <code>Remembered Set</code> 来避免全堆扫描。</p><p><code>G1</code> 收集器的运行步骤可分为：</p><ul><li>初始标记：仅仅标记一下 <code>GC Roots</code> 直接能关联到的对象，需要停顿，但耗时很短。</li><li>并发标记：从 <code>GC Roots</code> 开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，但可并发执行。</li><li>最终标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。</li><li>筛选回收：对各个 <code>Region</code> 的回收价值和成本进行排序，根据指定的 <code>GC</code> 停顿时间制定回收计划。</li></ul><h1 id="常用收集器组合"><a href="#常用收集器组合" class="headerlink" title="常用收集器组合"></a>常用收集器组合</h1><p><code>HotSpot</code> 虚拟机中包含了七种垃圾收集器，如下图：</p><p><img src="http://media.timberliu.com/image/2019/2/23/GC%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.png" width="60%"></p><p>它们的组合说明如下：</p><table><thead><tr><th>新生代收集器</th><th>年老代收集器</th><th>说明</th></tr></thead><tbody><tr><td>Serial</td><td>Serial Old</td><td>都是单线程，GC 时会暂停所有应用线程。<br>使用 -XX:+UseSerialGC 选项来开启</td></tr><tr><td>Serial</td><td>CMS + Serial Old</td><td>CMS 是并发 GC，不需要暂停所有应用线程。<br>当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC<br>使用 -XX:+UseConcMarkSweepGC 选项来开启</td></tr><tr><td>ParNew</td><td>CMS</td><td>ParNew 是 Serial 的并行版本，可以指定 GC 线程数<br>默认 GC 线程数为 CPU 的数量</td></tr><tr><td>ParNew</td><td>Serial Old</td><td>使用 -XX:+UseParNewGC 选项来开启</td></tr><tr><td>Parallel Scavenge</td><td>Serial Old</td><td>Parallel Scavenge 策略关注吞吐量，适用于后台持久运行的应用程序<br>使用 -XX:+UseParallelGC 选项来开启</td></tr><tr><td>Parallel Scavenge</td><td>Parallel Old</td><td>Parallel Old 是 Serial Old 的并行版本<br>使用 -XX:+UseParallelOldGC 选项来开启</td></tr><tr><td>G1GC</td><td>G1GC</td><td>-XX:+UseG1GC #开启<br>-XX:MaxGCPauseMillis #暂停时间目标</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>雨点的名字：<a href="https://www.cnblogs.com/qdhxhz/p/9211269.html" target="_blank" rel="noopener">【JVM虚拟机】（3）—垃圾回收器</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中学习了 &lt;code&gt;JVM&lt;/code&gt; 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 &lt;code&gt;HotSpot&lt;/code&gt; 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。&lt;/p&gt;
&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;p&gt;&lt;code&gt;HotSpot&lt;/code&gt; 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 JVM 内存结构</title>
    <link href="https://blog.timberliu.com/2019/02/25/031_JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.timberliu.com/2019/02/25/031_JVM 内存结构/</id>
    <published>2019-02-24T16:00:00.000Z</published>
    <updated>2019-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code> 虚拟机在运行 <code>Java</code> 程序 时，把它所管理的内存划分为若干个不同的数据区域，主要包括以下五个部分：程序计数器、<code>Java</code> 堆、<code>Java</code> 虚拟机栈、方法区和本地方法栈。<a id="more"></a></p><p><img src="http://media.timberliu.com/image/2019/2/23/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" width="70%"></p><h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是当前线程所执行的字节码的行号指示器，它会指出下一条将要执行的指令的地址，字节码解释器就是通过改变计数器的值来选取程序接下来执行的操作。</p><p>程序计数器是线程私有的一小块内存，每条线程都要有一个独立的程序计数器，以使线程切换后恢复到正确的执行位置。</p><ul><li>如果线程正在执行 <code>Java</code> 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址</li><li>如果执行 <code>native</code> 方法，则计数器为空</li></ul><p>它也是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>与程序计数器一样，<code>Java</code> 虚拟机栈也是线程私有的，在线程创建时 <code>Java</code> 栈会被创建，每个方法在在执行的同时都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>一般所谓的“栈”，指的是虚拟机栈中局部变量表部分，其中存放了各种基本数据类型( <code>8</code> 种)，对象引用(<code>reference</code> 类型) 和 <code>returnAddress</code> 类型。局部变量表所需的空间在编译期就已经确定并完成分配，在方法运行期间不会被改变。</p><p><code>Java</code> 虚拟栈中可能出现两种异常：</p><ul><li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度</li><li><code>OutOfMemoryError</code>：虚拟机栈扩展时无法申请到足够的内存</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 <code>Java</code> 虚拟机栈的作用类似，区别是 <code>Java</code> 虚拟机栈为虚拟机执行 <code>Java</code> 方法服务，而本地方法栈为虚拟机执行 <code>Native</code> 方法服务。有的虚拟机（例如 <code>HotSpot</code> 虚拟机）直接把本地方法栈和 <code>Java</code> 虚拟机栈合并在一起。</p><p>本地方法栈也可能会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p><code>Java</code> 堆是是虚拟机中最主要的内存区域。它为线程共享，在虚拟机启动时创建，几乎所有的对象实例都存储在 <code>Java</code> 堆中。</p><p><code>Java</code> 堆也被称作 <code>&quot;GC&quot;</code> 堆。从内存回收角度看，可分为新生代和老年代。而新生代又可分为 <code>Eden</code> 区、<code>From Survivor</code> 区、<code>To Survivor</code> 区等。</p><p><code>Java</code> 堆的实现，既可以实现为固定的，也可以是扩展的。当前虚拟机都按照可扩展来实现，通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制堆大小。</p><p>如果堆中没有内存并且也无法再扩展时，会抛出 <code>OutOfMemeoryError</code> 异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与 <code>Java</code> 堆一样，为线程共享。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。也叫作 <code>Non-Heap</code>（非堆）。</p><p>如果方法区无法满足内存分配需求，会抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。<code>Class</code> 文件中的常量池用于编译期生成的各种字面量和符号引用，这部分内容在类加载后被存入运行时常量池。</p><p>动态性是运行时常量池相对于 <code>Class</code> 文件常量池的一个重要特征，即不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中。</p><p>运行时常量池受到方法区内存的限制，如果常量池无法再申请内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不由 <code>JVM</code> 管理，它是利用 <code>Native</code> 函数库在 <code>Java</code> 堆外申请分配的内存区域，可以避免在 <code>Java</code> 堆和 <code>Native</code> 堆中复制数据以提高性能。</p><p>例如 <code>NIO</code> 中的 <code>DirectByteBuffer</code> 就可以作为这块内存的引用进行操作直接内存。</p><h1 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h1><p>有时会看到方法区被称为永久代，其实两者有着本质的区别。方法区是 <code>JVM</code> 规范中的定义，而永久代是 <code>JVM</code> 规范的一种实现，并且只有在 <code>HotSpot</code> 虚拟机中如此，其他虚拟机中没有永久代的说法。</p><p>在 <code>JDK1.6</code> 之前，<code>HotSpot</code> 虚拟机把 <code>GC</code> 分代收集扩展至方法区，或者说使用永久代实现方法区。不过永久代有 <code>-XX:MaxPermSize</code> 的上限，很容易遇到内存溢出问题。</p><p>所以在 <code>JDK1.7</code> 中，将部分数据已经转移 <code>Java Heap</code> 或 <code>Native Heap</code> 中，例如：将原本放在永久代中的字符串池和类的静态变量移出到 <code>Java Heap</code> 中，将符号引用转移到 <code>Native Heap</code> 中。但永久代仍然存在，并没有移除。</p><p>在 <code>JDK1.8</code> 中，取消了永久代，代替为元空间实现，它也是 <code>JVM</code> 规范中方法区的一种实现。不过它与永久代最大的不同是：元空间并不在虚拟机中，而是将元空间放到本地内存中。所以默认情况下，它只受本地内存的限制，可以通过 <code>-XX:MetaspaceSize</code> 参数设置初始空间大小，默认没有最大空间限制。</p><h1 id="常见的-OOM-及原因"><a href="#常见的-OOM-及原因" class="headerlink" title="常见的 OOM 及原因"></a>常见的 OOM 及原因</h1><p><code>Java</code> 中的 <code>OOM</code> 指的就是 <code>java.lang.OutOfMemoryError</code> 异常。主要有以下几种：</p><p><strong>java.lang.OutOfMemoryError:Java heap space</strong></p><p><code>Java</code> 堆中主要用于存放各种对象实例。当堆中没有足够的空间分配给新对象时，或者说达到了堆空间设置的最大空间限制，则会抛出此异常。</p><p>引起内存溢出的原因主要有：</p><ul><li>流量访问量大，超过设置的堆空间大小；</li><li>内存泄露，不能被回收的对象消耗过多堆空间；</li></ul><p><strong>java.lang.OutOfMemoryError:Permgen space</strong></p><p>在 <code>JDK7</code> 中，<code>HotSpot</code> 虚拟机使用永久代实现方法区，永久代较小，而且回收效率较低，很容易出现内存溢出。</p><p>因此，<code>JDK8</code> 取消了永久代，使用元空间来实现方法区，存放在本地内存中。</p><p><strong>java.lang.OutOfMemoryError:Metaspace</strong></p><p>方法区主要存储类的元信息，<code>HotSpot</code> 元数据区。当元空间没有足够的空间分配给加载的类时，会抛出此异常。</p><p>引起元数据区空间不足的原因主要有：</p><ul><li>加载的类太多，常见于 <code>jsp</code> 页面过多时；</li><li>元空间被实现在堆外，主要受到进程本身的内存限制，一般很难出现溢出。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Hollis：<a href="https://www.hollischuang.com/archives/2509" target="_blank" rel="noopener">JVM内存结构 VS Java内存模型 VS Java对象模型</a></li><li>liuxiaopeng：<a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 虚拟机在运行 &lt;code&gt;Java&lt;/code&gt; 程序 时，把它所管理的内存划分为若干个不同的数据区域，主要包括以下五个部分：程序计数器、&lt;code&gt;Java&lt;/code&gt; 堆、&lt;code&gt;Java&lt;/code&gt; 虚拟机栈、方法区和本地方法栈。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 垃圾回收机制</title>
    <link href="https://blog.timberliu.com/2019/02/25/032_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.timberliu.com/2019/02/25/032_垃圾回收机制/</id>
    <published>2019-02-24T16:00:00.000Z</published>
    <updated>2019-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然内存的分配和回收技术已相当成熟，但如果需要排查内存溢出、内存泄露问题，或者要求高并发、高性能时，就需要对垃圾的回收进行监控和调节，以更好优化系统提高性能。<a id="more"></a></p><h1 id="对象存活判定"><a href="#对象存活判定" class="headerlink" title="对象存活判定"></a>对象存活判定</h1><p><code>Java</code> 内存结构中，程序计数器、虚拟机栈、本地方法栈等随着线程而生，随线程而灭，不需要考虑内存回收问题。而 <code>Java</code> 堆和方法区则不同，它们的内存分配是动态的，只有在运行期间才能知道会创建哪些对象，垃圾回收关注的就是这两部分。</p><p>垃圾回收首先需要判断哪些对象还存活着，主要有引用计数和可达性分析两种算法。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>它的原理如下：给对象添加一个引用计数器，每当有一个地方引用它时，计时器值就加 <code>1</code>；当引用失效时，计数器值就减 <code>1</code>；如果计数器为 0，对象就不可能再被使用。</p><p>引用计数算法虽然实现简单、判定效率较高。但它很难解决对象之间循环引用的问题。</p><p>例如两个对象相互引用，实际上两个对象都不会再访问，但因为相互引用着对方，导致它们的计数器值都不为 <code>0</code>，于是引用技术算法无法通过 <code>GC</code> 收集器回收它们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>它的原理如下：通过一系列称为 <code>GC Roots</code> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 <code>GC Roots</code> 没有任何引用链相连时，则证明对象是不可用的。</p><p><code>Java</code> 中，可作为 <code>GC Roots</code> 的对象包括如下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中 <code>JNI</code>( <code>Native</code> 方法) 引用的对象。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>可以看到，对象回收判定算法判断对象是否存活都与引用有关。从 <code>JDK1.2</code> 开始，引用分为四种类型，用来实现不同的功能，它们的引用强度也依次递减。</p><p><strong>强引用（Strong Reference）</strong></p><p>平时使用的引用就是强引用。只要强引用还存在，该对象永远不会被回收。</p><p>可以通过将对象设置为 <code>null</code>，使其被回收。</p><p><strong>软引用（Soft Reference）</strong></p><p>用于描述一些还有用但并非必需的对象。当系统内存空间不足时，会回收这些软引用指向的对象。它通过 <code>SoftReference</code> 类来实现软引用。</p><p>可以用来实现高速缓存。</p><p><strong>弱引用（Weak Reference）</strong></p><p>用来描绘非必需对象。被弱引用指向的对象只能生存到下一次垃圾回收之前。只要垃圾收集器运行，弱引用指向的对象就会被回收。它通过 <code>WeakReference</code> 类来实现弱引用。</p><p><strong>虚引用（Phantom Reference）</strong></p><p>虚引用和没有引用没有任何区别。一个对象是否有虚引用，不会影响其生存时间，也无法通过虚引用获取对象实例。它通过 <code>PhantomReference</code> 来实现虚引用。必须和引用队列 <code>ReferenceQueue</code> 联合使用。</p><p>为一个对象设置虚引用的唯一目的是该对象被垃圾收集器回收前会收到一条系统通知。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区，或者说 <code>HotSpot</code> 虚拟机中的永久代，进行垃圾回收的效率一般比较低。回收主要包括两部分内容：废弃常量和无用的类。</p><p>判断一个常量是否是废弃常量比较简单，与回收 <code>Java</code> 堆中的对象类似。而判定一个类是否是无用的类需要满足三个条件：</p><ul><li>该类所有的实例都已经被回收；</li><li>加载该类的 <code>ClassLoader</code> 已经被回收；</li><li>该类对象的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h2><p>标记-清除算法分为两个标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记过程也就是对象存活判定算法。</p><p><img src="http://media.timberliu.com/image/2019/2/23/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.png" width="60%"></p><p>它是最基础的收集算法，主要有两个缺点：</p><ul><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h2><p>复制算法将可用内存分为大小相等的两块，每次只使用其中的一块。在一块内存用完后，将仍存活的对象赋值到另一块上面，再把已使用过的内存一次清理掉。</p><p><img src="http://media.timberliu.com/image/2019/2/23/%E5%A4%8D%E5%88%B6.png" width="60%"></p><p>复制算法的优缺点如下：</p><ul><li>优点：每次对半个分区进行内存回收，内存分配时也不用考虑内存碎片等情况，实现简单，运行高效。</li><li>缺点：可使用的内存缩小为一半，代价较大。</li></ul><h2 id="标记-整理算法（Mark-compact）"><a href="#标记-整理算法（Mark-compact）" class="headerlink" title="标记-整理算法（Mark-compact）"></a>标记-整理算法（Mark-compact）</h2><p>标记-整理算法分为标记和整理两个阶段，标记阶段和“标记-清除算法”一样，但在整理阶段，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://media.timberliu.com/image/2019/2/23/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86.png" width="60%"></p><p>标记-整理算法的优缺点如下：</p><ul><li>避免了空间碎片，空间利用率较高。</li><li>效率不高，标记和清除过程的效率较低。</li></ul><h2 id="分代算法（Generational-Collection）"><a href="#分代算法（Generational-Collection）" class="headerlink" title="分代算法（Generational Collection）"></a>分代算法（Generational Collection）</h2><p>分代算法根据对象存活周期将内存划分为几块。一般是将 <code>Java</code> 对分为新生代和老年代，根据各个年代的特点采用适当的收集算法。</p><p>新生代中，每次垃圾收集时只有少量对象存活，选择复制算法；老年代中，对象存活率较高、没有额外空间进行分配，使用“标记-清理”或“标记-整理”算法。</p><p>为了对不同生命周期的对象采用不同的回收算法，所以垃圾收集器都采用分代收集算法，将堆分为新生代和老年代。</p><p>&emsp;&emsp;<img src="http://media.timberliu.com/image/2019/2/23/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.jpg" width="60%"></p><h1 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h1><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>新生代主要用来存放新创建的对象，一般占堆 <code>1/3</code> 的空间。由于很多对象生命周期很短，每次 <code>Minor GC</code> 后只有少量对象存活，所以选用复制算法。</p><p>新生代又被分为一块较大的 <code>Eden</code> 区和两块较小的大小相等的 <code>Survivor</code> 区，使用 <code>from</code> 和 <code>to</code> 来分别指代两个 <code>Survivor</code> 区。<code>HotSpot</code> 虚拟机默认 <code>Eden</code> 和两块 <code>Survivor</code> 的大小比例为 <code>8:1:1</code>。每次只会使用 <code>Eden</code> 和其中一块 <code>Survivor</code> 区为对象服务，所以总是有一块 <code>Survivor</code> 区是空闲的，新生代实际可用的内存空间也就为 <code>90%</code>。</p><p>通常，对象会分配在 <code>Eden</code> 区中，当 <code>Eden</code> 区无法在分配对象时，<code>JVM</code> 便会触发一次 <code>Minor GC</code>，将存活下来的对象复制到 <code>from</code> 指向的 <code>Survivor</code> 区中。</p><p>当 <code>from</code> 指向的 <code>Survivor</code> 区也无法分配时，对 <code>Eden</code> 和 <code>from</code> 指向的 <code>Survivor</code> 区执行 <code>Minor GC</code>，将存活下来的对象复制到 <code>to</code> 指向的 <code>Survivor</code> 区中，然后交换 <code>from</code> 和 <code>to</code> 指针，使 <code>to</code> 指向的 <code>Survivor</code> 区为空，以保证下次 <code>Minor GC</code> 有复制的空闲空间。</p><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>老年代用于存放大对象，或年龄超过一定程度的对象。一般占据堆 <code>2/3</code> 的空间。</p><p>如果对象需要大量连续的内存空间，例如很长的字符串及数组，这些对象会直接分配在老年代，以避免在 <code>Eden</code> 区及两个 <code>Survivor</code> 区之间发生大量的内存复制。</p><p>虚拟机为每个对象定义了一个对象年龄计数器，如果对象分配在 <code>Eden</code> 区，在经过一次 <code>Minor GC</code> 后仍然存活，之后移动到 <code>Survivor</code> 空间中，将其年龄设置为 <code>1</code>。对象在 <code>Survivor</code> 区中每经过一次 <code>Minor GC</code>，年龄就增加一次，当它的年龄增加到一定程度（默认为 <code>15</code>）时，也会被晋升到老年代中。</p><p>如果在 <code>Survivor</code> 区中相同年龄所有对象大小的总和大于 <code>Survivor</code> 区的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>老年代的对象一般都比较稳定，<code>Major GC</code> 不会频繁执行。<code>Major GC</code> 采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。<code>MajorGC</code> 的耗时较长，而且会产生内存碎片。</p><h2 id="三种清理方式"><a href="#三种清理方式" class="headerlink" title="三种清理方式"></a>三种清理方式</h2><p><strong>Minor GC(Young GC)</strong></p><p>指发生在新生代的垃圾收集动作。当 <code>Eden</code> 区没有足够的空间分配时，就会触发一次 <code>Minor GC</code>。由于 <code>Java</code> 对象大多生命周期较短，所以 <code>Minor GC</code> 非常频繁，一般回收速度也比较快。</p><p><strong>Major GC</strong></p><p>指发生在老年代的垃圾收集动作，在进行 <code>Major GC</code> 前，一般都会进行至少一次 <code>Minor GC</code>。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上。</p><p><strong>Full GC</strong></p><p>指回收整个新生代和老年代的垃圾收集动作。成本较高，对系统性能产生影响。<code>FULL GC</code> 的时候会 <code>STOP THE WORD</code>。</p><p>它的触发条件主要有：</p><ul><li>在执行 <code>Minor GC</code> 之前，如果老年代最大可用的连续空间小于历次晋升到老生代对象的平均大小，则触发一次 <code>Full GC</code> 。</li><li>大对象直接进入老年代，或从年轻代晋升上来的老对象，在老年代尝试分配内存，但老年代内存空间不够时。</li><li>显式调用 <code>System.gc()</code> 方法时。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>雨点的名字：<a href="https://www.cnblogs.com/qdhxhz/p/9211095.html" target="_blank" rel="noopener">【JVM虚拟机】（2）—GC 算法与种类</a></li><li>Nutty：<a href="https://www.cnblogs.com/ygj0930/p/6522828.html" target="_blank" rel="noopener">JVM的新生代、老年代、MinorGC、MajorGC</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然内存的分配和回收技术已相当成熟，但如果需要排查内存溢出、内存泄露问题，或者要求高并发、高性能时，就需要对垃圾的回收进行监控和调节，以更好优化系统提高性能。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(6)之 HashMap 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/24/030_Java%E9%9B%86%E5%90%88%E4%B9%8B%20HashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/24/030_Java集合之 HashMap 源码解析/</id>
    <published>2019-02-23T16:00:00.000Z</published>
    <updated>2019-02-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 在日常开发中非常常用，它基于哈希表实现，以 <code>key-value</code> 形式存储。本文通过 <code>JDK1.8</code> 的源码，分析一下 <code>HashMap</code> 的内部结构和实现原理。</p><h1 id="HashMap-概述"><a href="#HashMap-概述" class="headerlink" title="HashMap 概述"></a>HashMap 概述</h1><p>在 <code>JDK1.7</code> 之前，<code>HashMap</code> 底层由数组 + 链表实现，也就是链表散列。当向 <code>HashMap</code> 中添加一个键值对时，首先计算 <code>key</code> 的 <code>hash</code> 值，以此确定插入数组中的位置，但可能会碰撞冲突，将其转换为链表存储。</p><p>而从 <code>JDK1.8</code> 开始，增加了红黑树，由数组 + 链表 + 红黑树实现，当链表长度超过 <code>8</code> 时，链表转换为红黑树以提高性能。<a id="more"></a><br>它的存储方式如下：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%E7%BB%93%E6%9E%84.png" width="50%"></p><h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><h2 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h2><p><code>HashMap</code> 的几个静态常量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认初始容量为 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大容量为 2^30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认负载因子为 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认链表中元素大于 8 时转为红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;             </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容时，链表中元素小于这个值就会还原为链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的容量大于 64 时才允许被树形化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h2><p>下面是 <code>HashMap</code> 中几个重要的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 存储元素数组</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">// 缓存 entry 返回的 Set </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// 键值对个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 内部结构修改次数</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// 临界值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></span><br></pre></td></tr></table></figure><p><strong>Node&lt;K,V&gt;[] table</strong></p><p><code>Node&lt;K,V&gt;[] table</code> 数组用来存储具体的元素，是 <code>HashMap</code> 底层数组和链表的组成元素。在第一次使用时初始化(默认初始化容量为 <code>16</code>)，并在必要的时候进行扩容。</p><p>一般来说，由于素数导致冲突的概率较小，所以哈希表数组大小为素数。但 <code>Java</code> 的 <code>HashMap</code> 中采用非常规设计，数组的长度总是 <code>2</code> 的 <code>n</code> 次方，这样做可以在取模和扩容时做优化，同时也能减少碰撞冲突。</p><p><code>Node</code> 是 <code>HashMap</code> 的一个内部类，实现了 <code>Map.Entry</code> 接口，本质上就是一个映射（键值对）。它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;   <span class="comment">// 用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;      <span class="comment">// 键</span></span><br><span class="line">    V value;          <span class="comment">// 值</span></span><br><span class="line">    Node&lt;K,V&gt; next;   <span class="comment">// 指向链表的下一个结点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写了 hashCode 和 equals 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ··· &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet</strong></p><p><code>entrySet</code> 用于缓存 <code>entrySet()</code> 方法返回的 <code>Set</code>。后面会详细分析。</p><p><strong>size</strong></p><p><code>size</code> 是 <code>HashMap</code> 中键值对的数量。注意，键值对的数量 <code>size</code> 和哈希表数组的长度 <code>capacity</code>不同。</p><p><strong>modCount</strong></p><p><code>modCount</code> 用于记录 <code>HashMap</code> 内部结构发生变化的次数，用于使用迭代器遍历集合时修改内部结构，而快速失败。需要注意的是，这里指的是结构发生变化，例如增加或删除一个键值对或者扩容，但是修改键值对的值不属于结构变化。</p><p><strong>threshold 和 loadFactor</strong></p><p><code>threshold</code> 是 <code>HashMap</code> 能容纳的最大键值对个数，<code>loadFactor</code> 是负载因子，默认为 <code>0.75</code>。有如下等式(<code>capacity</code> 是数组容量)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">threshold = capacity * loadFactor;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以得出，在数组长度定义好之后，负载因子越大，所能容纳键值对越多。如果存储元素个数大于 `threshold`，就要进行扩容，扩容后的容量是之前的两倍。</span><br><span class="line"></span><br><span class="line">**TreeNode**</span><br><span class="line"></span><br><span class="line">当链表长度超过 `8`（阈值）时，将链表转换为红黑树存储，以提高查找的效率。下面是 `TreeNode` 的定义：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // 父节点</span><br><span class="line">    TreeNode&lt;K,V&gt; left;    //左子树</span><br><span class="line">    TreeNode&lt;K,V&gt; right;   //右子树</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;      //颜色属性</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回当前节点的根节点</span><br><span class="line">    final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p><code>HashMap</code> 主要提供了四种构造方法：</p><p>1). 构造一个默认初始容量 <code>16</code> 和默认加载因子 <code>0.75</code> 的空 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2). 构造一个指定的初始容量和默认加载因子 <code>0.75</code> 的空 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3). 构造一个指定的初始容量和加载因子的空 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4). 使用给定的 <code>map</code> 构造一个新 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># 基本方法</span><br><span class="line"></span><br><span class="line">`HashMap` 内部功能实现很多，这里主要从 `hash` 方法、`put` 方法、`get` 方法、`resize` 方法和 `entrySet` 方法进行分析。</span><br><span class="line"></span><br><span class="line">## hash 方法</span><br><span class="line"> </span><br><span class="line">`HashMap` 中，增删改查都需要用 `hash` 算法来计算元素在数组中的位置，所以 `hash` 算法是否均匀高效，对性能影响很大。看一下它的实现：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 优化了高位运算算法</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tab[i = (n - 1) &amp; hash] 取模</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hash</code> 算法计算对象的保存位置，分为三步：取 <code>key</code> 的 <code>hashCode</code> 值、高位运算、取模运算。</p><p>由于取模元素消耗较大，<code>HashMap</code> 中用了一个很巧妙的方法，利用的就是底层数组长度总是 <code>2</code><br>的 <code>n</code> 次方。通过 <code>hash &amp; (table.length - 1)</code> 就可以得到对象的保存位置，相较于对 <code>length</code> 取模效率更高。</p><p><code>JDK1.8</code> 中优化了高位运算的算法，通过 <code>hashCode</code> 的高 <code>16</code> 位异或低 <code>16</code> 位实现。下面举例说明，<code>n</code> 为 <code>table</code> 的长度：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%E9%AB%98%E4%BD%8D%E8%BF%90%E7%AE%97.png" width="60%"></p><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>来看一下 <code>HashMap</code> 的 <code>put</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 hash 计算 key 的哈希值</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 为空或长度为 0，则调用 resize 进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据 key 的 hash 计算数组索引值，如果当前位置为 null，则直接创建新节点插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// table[i] 不为空</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 table[i] 的首元素和传入的 key 相等（hashCode 和 equals），则直接覆盖，这里容许 key 和 value 为 null</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断 table[i] 是否为 treeNode，即 table[i] 是否为红黑树，如果是则在树中插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果 key 不存在</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 则新建一个结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果长度大于8，则转为红黑树处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 key 已经存在，则直接覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部结构发生变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>put</code> 方法的几个步骤：：  </p><ul><li>判断哈希表数组 <code>table[]</code> 为空或者长度为 <code>0</code>，如果是则调用 <code>resize()</code> 进行扩容；</li><li>通过 <code>hash &amp; (table.length - 1)</code> 计算插入的数组索引值，如果当前位置为 <code>null</code>，则直接创建节点插入</li><li>判断 <code>table[i]</code> 的首个元素是否和 <code>key</code> 相等（<code>hashCode</code> 和 <code>equals</code>），如果相等则直接覆盖 <code>value</code>；</li><li>判断 <code>table[i]</code> 是否为 <code>treeNode</code>，即 <code>table[i]</code> 是否是红黑树，如果是红黑树，则直接在树中插入键值对；</li><li>否则遍历链表，如果 <code>key</code> 不存在，则直接创建节点插入，并判断链表长度是否大于 <code>8</code>，如果是红黑树则转为红黑树处理；如果遍历中发现 <code>key</code> 已经存在，则直接覆盖即可；</li><li>插入成功后，判断实际存在键值对是否超过了最大容量，如果是则进行扩容；</li></ul><p><code>HashMap</code> 的 <code>put</code> 方法可以通过下图理解：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23put%E6%96%B9%E6%B3%95.png" width="80%"></p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>来看一下 <code>HashMap</code> 的 <code>get</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用 getNode 方法，如果通过 key 获取的 Node 为 null，则返回 null；否则返回 node.value</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果数组不为空，数组长度大于 0</span></span><br><span class="line">    <span class="comment">// 通过 hash &amp; (length - 1) 计算数组的索引值，并且对应的位置不为 null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果桶中第一个元素与 key 相等，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; </span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前桶是红黑树，则转换处理</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则，遍历链表处理</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h2><p>下面来分析一下 <code>resize</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 保存原先的数组、容量、临界值</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果扩容前容量 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组大小已经达到最大 2^30，则修改阈值为最大值 2^31-1，以后也就不会再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有超过最大值，就扩充为原来的 2 倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 如果扩容前容量 &lt;= 0，旧临界值 &gt; 0</span></span><br><span class="line">        <span class="comment">// 将数组的新容量设置为 旧数组扩容的临界值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 容量 &lt;= 0，旧临界值 &lt;= 0          </span></span><br><span class="line">        <span class="comment">// 否则设置为默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的临界值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的 table，容量为 newCap</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧哈希表的每个桶，将旧哈希表中的桶复制到新的哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果旧桶中只有一个 node</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 则将 oldTab[j] 放入新哈希表中 e.hash &amp; (newCap - 1) 的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果旧桶中为红黑树，则转换处理</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 将下标不变的节点组织成一条链表</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 将下标增加 oldCapaciry 的节点组织成另一条链表</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 原索引</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到新数组中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引 + oldCap 放到新数组中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize</code> 方法在扩容时，由于每次数组的长度变为原先的 <code>2</code> 倍，所以元素要么在原位置，要么在“原始位置 + 原数组长度”的位置。通过计算 <code>e.hash &amp; oldCap</code> 来判断是否需要移动。</p><p>看下图，<code>n</code> 为 <code>table</code> 的长度，图 <code>(a)</code> 为扩容前的 <code>key1</code> 和 <code>key2</code> 确定索引位置的示例，图 <code>(b)</code> 为扩容后的 <code>key1</code> 和 <code>key2</code> 确定索引位置的示例，其中 <code>key1(hash1)</code> 是 <code>key1</code> 对应的哈希与高位运算的结果：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23resize1.png" width="80%"></p><p>元素在重新计算 <code>hash</code> 后，因为 <code>n</code> 变为 <code>2</code> 倍，那么 <code>n - 1</code> 的 <code>mask</code> 的范围(红色)在高位多 <code>1bit</code>，因此新的 <code>index</code> 就会这样变化：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23resize2.png" width="80%"></p><p>因此，在扩容时，只需看看原来的 <code>hash</code> 值新增的 <code>bit</code> 位是 <code>1</code> 还是 <code>0</code>，如果是 <code>0</code>，索引不变，否则变成 “原索引 + <code>oldCapacity</code>“，可以看看下图 <code>16</code> 扩充为 <code>32</code> 的示意图：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23resize3.png" width="60%"></p><h2 id="entrySet-方法"><a href="#entrySet-方法" class="headerlink" title="entrySet 方法"></a>entrySet 方法</h2><p><code>HashMap</code> 的一种遍历方式就是使用 <code>entrySet</code> 方法返回的迭代器进行遍历。先来看一下 <code>entrySet</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果缓存 <code>map</code> 中键值对的 <code>Set</code> 不为 <code>null</code>，则直接返回，否则会创建一个 <code>EntrySet</code> 对象。</p><p><code>EntrySet</code> 类的 <code>iterator</code> 方法会返回一个 <code>EntryIterator</code> 迭代器对象，另外还有两个迭代器 <code>KeyIterator</code>、<code>ValueIterator</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们三个都继承自 <code>HashIterator</code>，分别用于键遍历、值遍历、键值对遍历，它们都重写了 <code>Iterator</code> 的 <code>next</code> 方法，其中调用了 <code>HashIterator</code> 的 <code>nextNode</code> 方法。</p><p>而 <code>HashIterator</code> 是一个抽象类，实现了迭代器的大部分方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>HashIterator</code> 迭代器的默认构造器中，将 <code>current</code> 设置为 <code>null</code>，然后循环在数组中查找不为 <code>null</code> 的桶， 让 <code>next</code> 指向第一个桶中的第一个节点 <code>Node</code>。</p><p>在遍历时，<code>next</code> 方法会调用 <code>nextNode()</code> 方法，这个方法首先把 <code>next</code> 赋给 <code>e</code> 以稍后返回，并把 <code>e</code> 赋给 <code>current</code>。然后判断 <code>next</code> 是否为空，如果不为空，返回 <code>e</code> 即可。</p><p>如果为空，就在数组中继续查找不为空的桶，找到后退出循环，最后返回 <code>e</code>。这样就能都遍历出来了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>HashMap</code> 的特点主要有：</p><ul><li><code>HashMap</code> 根据键的 <code>hashCode</code> 值来存储数据，大多数情况下可以直接定位它的值，因而访问速度很快。</li><li><code>HashMap</code> 不保证插入的顺序。</li><li>扩容是一个特别耗能的操作，在使用 <code>HashMap</code> 时，最好估算 <code>map</code> 的大小，初始化时给定一个大致的数值，避免进行频繁的扩容。</li><li><code>threshold = capacity * loadFactor;</code> 如果存储元素个数大于 <code>threshold</code>，就要进行扩容，扩容后的容量是之前的两倍。</li><li>默认的负载因子 <code>0.75</code> 是时间和空间之间的一个平衡，一般不建议修改。</li><li><code>HashMap</code> 中 <code>key</code> 和 <code>value</code> 允许为 <code>null</code>，最多允许一条记录的键为 <code>null</code>，允许多条记录的值为 <code>null</code>。</li><li>它是非线程安全的。如果需要线程安全，可以使用 <code>Collections</code> 的 <code>synchronizedMap</code> 方法使 <code>HashMap</code> 具有线程安全的能力，或使用 <code>ConcurrentHashMap</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>美团技术团队：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java8系列之重新认识HashMap</a></li><li>潘威威：<a href="https://blog.csdn.net/panweiwei1994/article/details/77244920" target="_blank" rel="noopener">Java8源码-HashMap</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 在日常开发中非常常用，它基于哈希表实现，以 &lt;code&gt;key-value&lt;/code&gt; 形式存储。本文通过 &lt;code&gt;JDK1.8&lt;/code&gt; 的源码，分析一下 &lt;code&gt;HashMap&lt;/code&gt; 的内部结构和实现原理。&lt;/p&gt;
&lt;h1 id=&quot;HashMap-概述&quot;&gt;&lt;a href=&quot;#HashMap-概述&quot; class=&quot;headerlink&quot; title=&quot;HashMap 概述&quot;&gt;&lt;/a&gt;HashMap 概述&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;JDK1.7&lt;/code&gt; 之前，&lt;code&gt;HashMap&lt;/code&gt; 底层由数组 + 链表实现，也就是链表散列。当向 &lt;code&gt;HashMap&lt;/code&gt; 中添加一个键值对时，首先计算 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;hash&lt;/code&gt; 值，以此确定插入数组中的位置，但可能会碰撞冲突，将其转换为链表存储。&lt;/p&gt;
&lt;p&gt;而从 &lt;code&gt;JDK1.8&lt;/code&gt; 开始，增加了红黑树，由数组 + 链表 + 红黑树实现，当链表长度超过 &lt;code&gt;8&lt;/code&gt; 时，链表转换为红黑树以提高性能。&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(5)之 List 总结</title>
    <link href="https://blog.timberliu.com/2019/02/23/029_Java%E9%9B%86%E5%90%88%E4%B9%8B%20List%20%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.timberliu.com/2019/02/23/029_Java集合之 List 总结/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-02-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章对 <code>ArrayList</code>、<code>LinkedList</code> 的源码进行了分析，这篇文章对 <code>List</code> 做个简单的总结。</p><h1 id="List-接口结构"><a href="#List-接口结构" class="headerlink" title="List 接口结构"></a>List 接口结构</h1><p><code>List</code> 以线性方式存储元素，其中允许存放重复元素，元素有序。主要有以下几个实现类：</p><ul><li><code>ArrayList</code>：随机访问元素效率较高，但增删元素较慢；</li><li><code>LinkedList</code>：增删元素效率较高，但随机访问效率较低；</li><li><code>Vector</code>：与 <code>ArrayList</code>，但它是线程安全的，同步通过 <code>synchronized</code> 实现，效率较低，一般不建议使用；</li><li><code>Stack</code>：是一个先进先出的栈，继承自 <code>Vector</code>；<a id="more"></a></li></ul><p>它的主要结构如下：</p><p><img src="http://media.timberliu.com/image/2019/2/22/List%20%E7%BB%93%E6%9E%84.jpg" width="60%"></p><h1 id="数组与-ArrayList-的区别"><a href="#数组与-ArrayList-的区别" class="headerlink" title="数组与 ArrayList 的区别"></a>数组与 ArrayList 的区别</h1><p>数组与 <code>ArrayList</code> 之间的区别如下：</p><ul><li>数组可以存储基本类型和对象；而 <code>ArrayList</code> 只能存储对象，需要进行拆装箱。所以如果特别关注性能，可以选用数组。</li><li>数组需要指定大小，且不能改变；而 <code>ArrayList</code> 可以指定或不指定初始化容量，且支持自动扩容。所以，如果数据大小已知，并且对数据的操作比较简单，可以使用数组。</li><li><code>ArrayList</code> 最大的优势就是封装了很多操作数组的方法。如果操作比较复杂，可以选用 <code>ArrayList</code>。</li><li>表示多维数组时，用数组更加直观。例如 <code>Object[][]</code>。</li></ul><p>其实一般来说，在普通业务开发中，直接使用 <code>ArrayList</code> 就可以了，相比于损耗一点点性能，换来使用上的方便简单，也是可以接受。</p><p>但如果做的是较底层的开发，如中间件，性能优化等，数组一般会比较好。</p><h1 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a>ArrayList 与 LinkedList 的区别</h1><p><strong>ArrayList</strong></p><p>优点：<code>ArrayList</code> 底层基于动态数组实现，由于地址连续，按照下标直接计算操作地址，随机访问效率较高。</p><p>缺点：但同样是因为地址连续，在插入和删除数据时，数组需要移动数据，所以插入和删除操作的效率较低。</p><p><strong>LinkedList</strong></p><p>优点：<code>LinkedList</code> 底层基于双向链表实现，由于地址是任意的，所以在创建节点时比较简单，增加和删除操作的效率比较高。另外，它也适用于队列、栈形式的场景。</p><p>缺点：由于 <code>LinkedList</code>  访问元素时需要一个一个地移动指针，所以随机访问的效率较低。</p><p><strong>适用场景</strong></p><p>可以按照如下要求进行选择：</p><ul><li>如果对数据随机访问的操作较多，则选用 <code>ArrayList</code>。</li><li>如果对数据的增加或删除操作较多，则选用 <code>LinkedList</code>。</li></ul><h1 id="ArrayList-与-Vector-的区别"><a href="#ArrayList-与-Vector-的区别" class="headerlink" title="ArrayList 与 Vector 的区别"></a>ArrayList 与 Vector 的区别</h1><p><code>ArrayList</code> 和 <code>Vector</code> 很相似，主要有以下三个区别：</p><ul><li><code>Vector</code> 是线程安全的，而 <code>ArrayList</code> 不是。<code>Vector</code> 中的方法被 <code>synchronized</code> 修饰，效率很低，一般不赞成使用。</li><li>两者都是基于动态数组实现，但是扩容时，两者的增加方式不同。<code>ArrayList</code> 每次扩至 <code>1.5</code> 倍，而 <code>Vector</code> 扩至 <code>2</code> 倍。</li><li><code>Vector</code> 可以设置扩容时的自增容量 <code>capacityIncrement</code>，而 <code>ArrayList</code> 不可以。</li><li><code>ArrayList</code> 支持 <code>Iterator</code> 和 <code>ListIterator</code> 迭代器；而 <code>Vector</code> 除此之外，还支持 <code>Enumeration</code>。</li></ul><p>它们的适用场景如下：</p><ul><li><code>Vector</code> 是线程安全的，而 <code>ArrayList</code> 是非线程安全的。如果在非多线程的情境下，一般采用 <code>ArrayList</code> 效率比较高。由于 <code>Vector</code> 效率较低，如果在多线程环境下，一般使用 <code>CopyOnWriteArrayList</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面两篇文章对 &lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;LinkedList&lt;/code&gt; 的源码进行了分析，这篇文章对 &lt;code&gt;List&lt;/code&gt; 做个简单的总结。&lt;/p&gt;
&lt;h1 id=&quot;List-接口结构&quot;&gt;&lt;a href=&quot;#List-接口结构&quot; class=&quot;headerlink&quot; title=&quot;List 接口结构&quot;&gt;&lt;/a&gt;List 接口结构&lt;/h1&gt;&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 以线性方式存储元素，其中允许存放重复元素，元素有序。主要有以下几个实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt;：随机访问元素效率较高，但增删元素较慢；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt;：增删元素效率较高，但随机访问效率较低；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt;：与 &lt;code&gt;ArrayList&lt;/code&gt;，但它是线程安全的，同步通过 &lt;code&gt;synchronized&lt;/code&gt; 实现，效率较低，一般不建议使用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;：是一个先进先出的栈，继承自 &lt;code&gt;Vector&lt;/code&gt;；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(4)之 LinkedList 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/22/028_Java%E9%9B%86%E5%90%88%E4%B9%8B%20LinkedList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/22/028_Java集合之 LinkedList 源码解析/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code> 与 <code>ArrayList</code> 同样实现了 <code>List</code> 接口，但它基于双向链表实现，插入和删除操作效率较高，而随机访问效率较低。本文通过源码来分析一下 <code>LinkedList</code> 的实现原理，注意事项，使用场景等，以便能更好地使用它（<code>JDK</code> 版本为 <code>1.8</code>）。</p><p><code>LinkedList</code> 的主要特点如下：</p><ul><li><code>LinkedList</code> 是 <code>List</code> 接口和 <code>Deque</code> 接口的双向链表实现；</li><li><code>LinkedList</code> 实现了列表的所有操作，允许添加 <code>null</code>；<a id="more"></a></li><li><code>LinkedList</code> 不是同步的；</li><li>由 <code>iterator()</code> 和 <code>listIterator()</code> 返回的迭代器是 <code>fail-fast</code> 的。</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>先来看一下 <code>LinkedList</code> 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到 <code>LinkedList</code> 继承或实现了以下类或接口：</p><ul><li><code>AbstractSequentialList</code>：<br><code>AbstractSequentialList</code> 继承自 <code>AbstractList</code>，但 <code>AbstractSequentialList</code> 只支持按次序访问，而不像 <code>AbstractList</code> 那样支持随机访问。</li><li><code>List</code>：：实现了 <code>List</code> 接口，提供了所有可选列表操作。</li><li><code>Deque</code>：代表双端队列，这是 <code>LinkedList</code> 可用作队列或双端队列的原因。</li><li><code>Cloneable</code>：表明其可以被克隆，重写了 <code>clone</code> 方法。</li><li><code>java.io.Serializable</code>：表明该类是可以序列化的。</li></ul><p>但 <code>LinkedList</code> 没有实现 <code>RandomAccess</code>，说明 <code>LinkedList</code> 不支持随机访问，这就是 <code>LinkedList</code> 随机访问效率低的原因之一。</p><p><img src="http://media.timberliu.com/image/2019/2/20/LinkedList%20%E6%A1%86%E6%9E%B6.png" width="60%"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>LinkedList</code> 的属性主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向头节点的指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向尾节点的指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p><code>LinkedList</code> 的内部类 <code>Node</code> 表示链表中的节点，包括一个数据域 <code>item</code>，一个后置指针 <code>next</code>，一个前置指针 <code>prev</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p><code>LinkedList</code> 中提供了两种构造方法：</p><p><strong>构造空链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用给定 collection 构造链表</strong></p><p>构造方法中，先构造一个空链表，再把指定集合 <code>collection</code> 中的所有元素都添加到 <code>LinkedList</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作链表的底层方法"><a href="#操作链表的底层方法" class="headerlink" title="操作链表的底层方法"></a>操作链表的底层方法</h1><p>下面是几个操作链表的底层方法：</p><h2 id="linkFirst-方法"><a href="#linkFirst-方法" class="headerlink" title="linkFirst 方法"></a>linkFirst 方法</h2><p>该方法用于在链表头添加元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使节点 f 指向原来的头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 新建节点 Node，前驱指针指向 null，后置指针指向原来的头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 头指针 first 指向新的头节点 newNode</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果原来的头节点为 null，则更新尾指针</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则使原来的头节点 f 的前驱指针指向新的头节点 newNode</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="linkLast-方法"><a href="#linkLast-方法" class="headerlink" title="linkLast 方法"></a>linkLast 方法</h2><p>该方法用于在链表尾部添加元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使节点 l 指向原来的尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 新建节点 Node，前驱指针指向 l，后置指针指向 null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 尾指针 last 指向新的尾节点 newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果原来的头节点为 null，则更新头指针</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则使原来的尾节点 l 的后置指针指向新的尾节点 newNode</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="linkBefore-方法"><a href="#linkBefore-方法" class="headerlink" title="linkBefore 方法"></a>linkBefore 方法</h2><p>该方法用于在指定节点 <code>succ</code> 之前添加元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得指定节点 succ 的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 新建节点 newNode，前置指针指向 pred，后置指针指向 succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// succ 的前置指针指向 newNode</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果指定节点的前驱节点为 null，则将 newNode 置为头节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则更新 pred 的后置节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlinkFirst-方法"><a href="#unlinkFirst-方法" class="headerlink" title="unlinkFirst 方法"></a>unlinkFirst 方法</h2><p>该方法用于删除头节点，并返回头节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存头节点的值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 保存头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 头节点的值置为 null</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点的后置指针置为 null</span></span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将头节点置为 next</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果 next 为 null，将尾节点置为 null</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则将 next 的前驱指针指向 null</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlinkLast-方法"><a href="#unlinkLast-方法" class="headerlink" title="unlinkLast 方法"></a>unlinkLast 方法</h2><p>该方法用于删除尾节点，并返回尾节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存尾节点的值</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 保存尾节点的前一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 尾节点的值置为 null</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 尾节点的前驱指针指向 null</span></span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 将尾节点置为 prev</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果 prev 为 null，将头节点置为 null</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则将 prev 的后置指针指向 null</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlink-方法"><a href="#unlink-方法" class="headerlink" title="unlink 方法"></a>unlink 方法</h2><p>该方法用于删除指定的节点 <code>x</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存指定节点的值、前驱节点、后置节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点为 null，表示删除的是头节点，则将 first 指向为 next</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将 prev 的后置指针指向 next，x 的前置指针指向 null</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果后置节点为 null，表示删除的是尾节点，则将 last 指向 prev</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将 next 的前置指针指向 prev，x 的后置指针指向 null</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x 的值置为 null</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本链表方法"><a href="#基本链表方法" class="headerlink" title="基本链表方法"></a>基本链表方法</h1><h2 id="add-E-方法"><a href="#add-E-方法" class="headerlink" title="add(E) 方法"></a>add(E) 方法</h2><p><code>add</code> 方法在链表的末尾添加指定的元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-Object-方法"><a href="#remove-Object-方法" class="headerlink" title="remove(Object) 方法"></a>remove(Object) 方法</h2><p><code>remove</code> 方法用于在删除链表中出现的第一个指定的元素 <code>o</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 o 为 null，遍历链表，删除第一个值为 null 的节点，返回 true</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则删除第一个值为 o 的节点。如果链表中存在 o，就返回 true。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addAll-int-Collection-lt-extends-E-gt-方法"><a href="#addAll-int-Collection-lt-extends-E-gt-方法" class="headerlink" title="addAll(int, Collection&lt;? extends E&gt;) 方法"></a>addAll(int, Collection&lt;? extends E&gt;) 方法</h2><p><code>addAll</code> 方法将给定的 <code>collection</code> 集合插入到从 <code>index</code> 位置开始的 <code>List</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查插入到位置是否合法</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 c 转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)   <span class="comment">// 如果 c 为空，那么就返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使 pred 指向插入点前面的节点，succ 指向插入点后面（pred 的下一个）节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，逐个将元素插入到插入点</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引为 index 位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果 index 小于链表的一半，则从表头开始遍历</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则从链表尾开始遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addAll</code> 方法在链表中间插入元素原理图如下：</p><p><img src="http://media.timberliu.com/image/2019/2/21/LinkedList%23addAll%28%29.jpg" width="60%"></p><h2 id="add-int-E-方法"><a href="#add-int-E-方法" class="headerlink" title="add(int, E) 方法"></a>add(int, E) 方法</h2><p>此 <code>add</code> 方法用于在 <code>List</code> 中索引为 <code>index</code> 位置插入元素 <code>element</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果 index 等于 size，则插入到链表尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，插入到索引为 index 位置之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-int-E-方法"><a href="#set-int-E-方法" class="headerlink" title="set(int, E) 方法"></a>set(int, E) 方法</h2><p><code>set</code> 方法用给定的元素 <code>element</code> 代替 <code>List</code> 中索引为 <code>index</code> 位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 返回索引为 index 位置的节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-int-方法"><a href="#get-int-方法" class="headerlink" title="get(int) 方法"></a>get(int) 方法</h2><p><code>get</code> 方法会返回 <code>List</code> 中指定位置 <code>index</code> 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="indexOf-Ojbect-方法"><a href="#indexOf-Ojbect-方法" class="headerlink" title="indexOf(Ojbect) 方法"></a>indexOf(Ojbect) 方法</h2><p><code>index</code> 方法返回 <code>List</code> 中指定元素第一次出现的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 o 为 null，遍历链表，查找第一个为 null 的元素，返回 index</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则查找第一个为 Object 的元素，返回 index</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getFirst-getLast-方法"><a href="#getFirst-getLast-方法" class="headerlink" title="getFirst/getLast 方法"></a>getFirst/getLast 方法</h2><p><code>getFirst</code> 方法返回链表中第一个元素，而 <code>getLast</code> 方法返回链表中最后一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeFirst-removeLast-方法"><a href="#removeFirst-removeLast-方法" class="headerlink" title="removeFirst/removeLast 方法"></a>removeFirst/removeLast 方法</h2><p><code>removeFirst</code> 方法从 <code>list</code> 中删除第一个元素，并返回它；而 <code>removeLast</code> 方法从 <code>list</code> 中删除最后一个元素，并返回它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addFirst-addLast-方法"><a href="#addFirst-addLast-方法" class="headerlink" title="addFirst/addLast 方法"></a>addFirst/addLast 方法</h2><p><code>addFirst</code> 方法在链表头插入指定元素；<code>addLast</code> 方法在链表尾插入指定元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><h2 id="peek-element-方法"><a href="#peek-element-方法" class="headerlink" title="peek/element 方法"></a>peek/element 方法</h2><p><code>peek/element</code> 方法都是返回队列的队首元素。但是，如果队列为空，<code>peek</code> 方法返回 <code>null</code>，而 <code>element</code> 方法会抛出 <code>NoSuchElementException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll-remove-方法"><a href="#poll-remove-方法" class="headerlink" title="poll/remove 方法"></a>poll/remove 方法</h2><p><code>poll/remvoe</code> 方法都是删除队列的队首元素，并返回。但是如果队列为空，<code>poll</code> 方法会返回空，而 <code>remove</code> 方法会抛出 <code>NoSuchElementException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="offer-方法"><a href="#offer-方法" class="headerlink" title="offer 方法"></a>offer 方法</h2><p><code>offer</code> 方法在队列的队尾处添加指定元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端队列方法"><a href="#双端队列方法" class="headerlink" title="双端队列方法"></a>双端队列方法</h1><h2 id="offerFirst-offerLast-方法"><a href="#offerFirst-offerLast-方法" class="headerlink" title="offerFirst/offerLast 方法"></a>offerFirst/offerLast 方法</h2><p><code>offerFirst</code> 方法在队列的队首添加元素；而 <code>offerLast</code> 方法在队列的队尾添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="peekFirst-peekLast-方法"><a href="#peekFirst-peekLast-方法" class="headerlink" title="peekFirst/peekLast 方法"></a>peekFirst/peekLast 方法</h2><p><code>peekFirst</code> 方法会返回队列的队首元素，但不删除。如果队列为空，会返回 <code>null</code>。</p><p><code>peekLast</code> 方法会返回队列的队尾元素，但不删除。如果队列为空，会返回 <code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pollFirst-pollLast-方法"><a href="#pollFirst-pollLast-方法" class="headerlink" title="pollFirst/pollLast 方法"></a>pollFirst/pollLast 方法</h2><p><code>pollFirst</code> 方法会删除队列的队首元素，并返回。如果队列为空，则返回 <code>null</code>。</p><p><code>pollLast</code> 方法会删除队列的队尾元素，并返回。如果队列为空，则返回 <code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h1><p><code>push</code> 方法将指定元素压入到栈顶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 方法从栈顶弹出元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 与 &lt;code&gt;ArrayList&lt;/code&gt; 同样实现了 &lt;code&gt;List&lt;/code&gt; 接口，但它基于双向链表实现，插入和删除操作效率较高，而随机访问效率较低。本文通过源码来分析一下 &lt;code&gt;LinkedList&lt;/code&gt; 的实现原理，注意事项，使用场景等，以便能更好地使用它（&lt;code&gt;JDK&lt;/code&gt; 版本为 &lt;code&gt;1.8&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 的主要特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 是 &lt;code&gt;List&lt;/code&gt; 接口和 &lt;code&gt;Deque&lt;/code&gt; 接口的双向链表实现；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 实现了列表的所有操作，允许添加 &lt;code&gt;null&lt;/code&gt;；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(3)之 ArrayList 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/21/027_Java%E9%9B%86%E5%90%88%E4%B9%8B%20ArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/21/027_Java集合之 ArrayList 源码解析/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-02-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>ArrayList</code> 在日常开发中非常常用，它是 <code>List</code> 接口的可变长数组的实现，提供了添加、修改、删除、遍历等功能。本文通过源码来分析一下 <code>ArrayList</code> 的实现原理，注意事项，使用场景等（<code>JDK</code> 版本为 <code>1.8</code>）。</p><p><code>ArrayList</code> 的特点如下：</p><ul><li><code>ArrayList</code> 基于数组方式实现，可以自动扩容；但由于扩容比较耗时，所以在初始化 <code>ArrayList</code> 时最好预判一下初始化容量；</li><li><code>ArrayList</code> 中允许插入 <code>null</code> 元素；<a id="more"></a></li><li>由于实现了 <code>Serializable</code> 接口，重写了 <code>writeObject</code> 和 <code>readObject</code> 方法，所以 <code>ArrayList</code> 支持序列化和反序列化；</li><li><code>ArrayList</code> 不是同步的；</li><li><code>ArrayList</code>的 <code>iterator</code> 和 <code>listIterator</code>方法返回的迭代器是 <code>fail-fast</code> 的。</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先，来看一下 <code>ArrayList</code> 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到 <code>ArrayList</code> 继承或实现了以下类或接口：</p><ul><li><code>AbstractList</code> ：继承了 <code>AbstractList</code>。<code>AbstractList</code> 提供了 <code>List</code> 接口的骨干实现，以最大限度地减少（如 <code>ArrayList</code>）实现 <code>List</code> 所需的工作。</li><li><code>List</code>：实现了 <code>List</code> 接口。提供了所有可选列表操作。</li><li><code>RandomAccess</code>：表明 <code>ArrayList</code> 支持随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。</li><li><code>Cloneable</code>：表明其可以被克隆，重写了 <code>clone</code> 方法。</li><li><code>java.io.Serializable</code>：表明该类支持序列化。</li></ul><p>下面是 <code>ArrayList</code> 的类结构层次图：</p><p><img src="http://media.timberliu.com/image/2019/2/20/ArrayList%20%E6%A1%86%E6%9E%B6.png" width="60%"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>ArrayList</code> 的属性主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化 id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 ArrayList 的容量为 0 时，返回该空数组 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用默认构造器（无参构造方法），则返回该空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储当前元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList 的大小（包含的元素数目）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配给数组的最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>除此之外，还有一个从 <code>AbstarctList</code> 继承的 <code>modCount</code> 属性，它代表 <code>ArrayList</code> 集合的修改次数。在遍历集合时，如果 <code>modCount</code> 被更改，就会抛出 <code>ConcurrentModificationExceptioin</code> 异常。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在 <code>ArrayList</code> 中，提供了三种构造方法：</p><p><strong>默认构造方法</strong></p><p>不传入参数的默认构造方法会构造一个初始容量为 <code>10</code> 的空列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定容量</strong></p><p>这个构造方法会构造一个指定初始化容量为 <code>initialCapacity</code> 的空 <code>ArrayList</code>。如果指定初始化容量为负，则会抛出 <code>IllegalArgumentException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用给定 collection 构造数组</strong></p><p>这个方法会构造一个包含指定 <code>collection</code> 的元素的列表，这些元素是按照该 <code>collection</code> 的迭代器返回它们的顺序排列的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断 elementData 是否为 Object[] 类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用空数组代替</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会将传入的 <code>elementData</code> 转换为数组，然后使用 <code>Arrays.copyOf</code> 方法将元素拷贝到 <code>elementData</code> 数组中。</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><p><code>ArrayList</code> 的主要方法如下：</p><h2 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index) 方法"></a>get(int index) 方法</h2><p><code>get</code> 方法用于返回 <code>list</code> 中索引为 <code>index</code> 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中首先检查索引，如果索引超过数组的长度，则会抛出 <code>IndexOutOfBoundsException</code> 异常。</p><p>然后使用 <code>elementData</code> 方法获取元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>ArrayList</code> 底层由数组实现，通过数组下标获取元素，它的时间复杂度为 <code>O(1)</code>。</p><h2 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e) 方法"></a>add(E e) 方法</h2><p><code>add</code> 方法用于在 <code>list</code> 的末尾添加指定的元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先是 <code>ensureCapacityInternal(size + 1)</code> 方法，这个方法对数组容量进行检查，如果不够则进行扩容，只供内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法 <code>grow</code>，会保证至少能存储 <code>minCapacity</code> 个元素。实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，扩容后的容量按照如下方式计算：</p><ul><li>第一次扩容，使用 <code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> 公式，将容量增加一半；</li><li>如果容量还是小于 <code>minCapacity</code>，就将容量扩充为 <code>minCapacity</code>；</li><li>如果容量大于 <code>MAX_ARRAY_SIZE</code>，就将容量扩充为 <code>Integer.MAX_VALUE</code>。</li></ul><p>最后，使用 <code>Arrays.copyOf</code> 方法将元素拷贝到新数组中即可。</p><h2 id="add-index-element-方法"><a href="#add-index-element-方法" class="headerlink" title="add(index, element) 方法"></a>add(index, element) 方法</h2><p>这个 <code>add</code> 方法用于在 <code>list</code> 中指定的位置插入元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先会对指定的位置 <code>index</code> 进行检查，如果越界，就会抛出 <code>IndexOutOfBoundsException</code> 异常。然后使用 <code>ensureCapacityInternal</code> 方法判断容量并进行扩容。</p><p>然后，使用 <code>System.arraycopy()</code> 方法将索引为 <code>index</code> 位置之后的元素向后移动一位，再将 <code>index</code> 位置赋值为 <code>element</code>。</p><h2 id="remove-index-方法"><a href="#remove-index-方法" class="headerlink" title="remove(index) 方法"></a>remove(index) 方法</h2><p><code>remove</code> 方法用于删除 <code>list</code> 中指定索引 <code>index</code> 位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用 <code>rangeCheck</code> 方法检查 <code>index</code> 是否越界，然后修改 <code>modCount</code>，表示修改次数加一。再使用 <code>elementData</code> 方法获取 <code>index</code> 位置的元素，方便稍后返回。</p><p>使用 <code>size-index-1</code> 计算左移的位数，再使用 <code>System.arraycopy()</code> 方法向左移动一位，也就表示删除了该元素。最后将 <code>--size</code> 位置的元素置为 <code>null</code>，避免对象游离，使 <code>JVM</code> 回收。</p><h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h1><p>迭代器提供了一种方法来访问集合中的元素。<code>Array</code> 类中的 <code>iterator()</code> 方法用来从容器对象中返回一个指向 <code>list</code> 开始处的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Itr</code> 类实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回的元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个被返回的元素的索引，如果没有返回 -1</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Itr</code> 类的主要方法如下：</p><ul><li><code>next()</code>：获取序列中的下个元素；</li><li><code>hasNext()</code>：检查序列中是否还有下一个元素；</li><li><code>remove()</code>：将迭代器最近返回的一个元素删除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 在日常开发中非常常用，它是 &lt;code&gt;List&lt;/code&gt; 接口的可变长数组的实现，提供了添加、修改、删除、遍历等功能。本文通过源码来分析一下 &lt;code&gt;ArrayList&lt;/code&gt; 的实现原理，注意事项，使用场景等（&lt;code&gt;JDK&lt;/code&gt; 版本为 &lt;code&gt;1.8&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 的特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 基于数组方式实现，可以自动扩容；但由于扩容比较耗时，所以在初始化 &lt;code&gt;ArrayList&lt;/code&gt; 时最好预判一下初始化容量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 中允许插入 &lt;code&gt;null&lt;/code&gt; 元素；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(2)之 Iterator 迭代器</title>
    <link href="https://blog.timberliu.com/2019/02/20/025_Java%E9%9B%86%E5%90%88%E4%B9%8B%20Iterator%20%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/02/20/025_Java集合之 Iterator 迭代器/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iterator-与-ListIterator"><a href="#Iterator-与-ListIterator" class="headerlink" title="Iterator 与 ListIterator"></a>Iterator 与 ListIterator</h1><p>凡是实现 <code>Collection</code> 接口的集合类都有一个 <code>iterator</code> 方法，会返回一个实现了 <code>Iterator</code> 接口的对象，用于遍历集合。<code>Iterator</code> 接口主要有三个方法，分别是 <code>hasNext</code>、<code>next</code>、<code>remove</code> 方法。</p><p><code>ListIterator</code> 继承自 <code>Iterator</code>，专门用于实现 <code>List</code> 接口对象，除了 <code>Iterator</code> 接口的方法外，还有其他几个方法。</p><p>基于顺序存储集合的 <code>Iterator</code> 可以直接按位置访问数据。基于链式存储集合的 <code>Iterator</code>，一般都是需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。<a id="more"></a></p><p><code>Iterator</code> 与 <code>ListIterator</code> 的区别：</p><ul><li><code>Iterator</code> 可用于遍历 <code>Set</code>、<code>List</code>；<code>ListIterator</code> 只可用于遍历 <code>List</code>。</li><li><code>Iterator</code> 只能向后遍历；<code>ListIterator</code> 可向前或向后遍历。</li><li><code>ListIterator</code> 实现了 <code>Iterator</code> 的接口，并增加了<br><code>add</code>、<code>set</code>、<code>hasPrevious</code>、<code>previous</code>、<code>previousIndex</code>、<code>nextIndex</code> 方法。</li></ul><h1 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h1><p>快速失败机制（<code>fail—fast</code>）就是在使用迭代器遍历一个集合对象时，如果遍历过程中对集合进行修改（增删改），则会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>例如以下代码，就会抛出 <code>ConcurrentModificationException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"abc"</span>);</span><br><span class="line">stringList.add(<span class="string">"def"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = stringList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    stringList.add(<span class="string">"ghi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>ArrayList</code> 源码，就可以知道为什么会抛出异常。原因是在 <code>ArrayList</code> 类的内部类迭代器 <code>Itr</code> 中有一个 <code>expectedModCount</code> 变量。在 <code>AbstracList</code> 抽象类有一个 <code>modCount</code> 变量，集合在被遍历期间如果内容发生变化，就会改变 <code>modCount</code> 的值。每当迭代器使用 <code>next()</code> 遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否等于 <code>expectedmodCount</code> ，如果相等就继续遍历；否则就会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里异常的抛出条件是检测到 <code>modCount != expectedmodCount</code>。如果集合发生变化时将 <code>modCount</code> 的值又刚好设置为 <code>expectedmodCount</code>，那么就不会抛出异常。因此，不能依赖于这个异常是否抛出而进行并发操作，这个异常只建议使用于检测并发修改的 <code>bug</code>。</p><p>在 <code>java.util</code> 包下的集合类都采用快速失败机制，所以在多线程下，不能发生并发修改，也就是在迭代过程中不能被修改。</p><h1 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h1><p>采用安全失败机制（<code>fail—safe</code>）的集合类，在遍历集合时不是直接访问原有集合，而是先将原有集合的内容复制一份，然后在拷贝的集合上进行遍历。</p><p>由于是对拷贝的集合进行遍历，所以在遍历过程中对原集合的修改并不会被迭代器检测到，所以不会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>虽然基于拷贝内容的安全失败机制避免了 <code>ConcurrentModificationException</code>，但是迭代器并不能访问到修改后的内容，而仍然是开始遍历那一刻拿到的集合拷贝。</p><p>在 <code>java.util.concurrent</code> 包下的集合都采用安全失败机制，所以可以在多线程场景下进行并发使用和修改操作。</p><h1 id="如何在遍历集合的同时删除元素"><a href="#如何在遍历集合的同时删除元素" class="headerlink" title="如何在遍历集合的同时删除元素"></a>如何在遍历集合的同时删除元素</h1><p>在遍历集合时，正确的删除方式有以下几种：</p><p><strong>普通 for 循环从后往前遍历</strong></p><p>使用普通 <code>for</code> 循环，如果从后往前遍历，则可以避免元素移动的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"abc"</span>);</span><br><span class="line">stringList.add(<span class="string">"def"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stringList.size(); i++) &#123;</span><br><span class="line">    String str = stringList.get(i);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"abc"</span>.equals(str)) &#123;</span><br><span class="line">        stringList.remove(str);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>foreach 删除后跳出循环</strong></p><p>在使用 <code>foreach</code> 迭代器遍历集合时，在删除元素后使用 break 跳出循环，则不会触发 <code>fail-fast</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : stringList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"abc"</span>.equals(str)) &#123;</span><br><span class="line">        stringList.remove(str);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器自带的 remove 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = stringList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String str = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"abc"</span>.equals(str)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 这里是 iterator，而不是 stringList</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h1><p><code>Enumeration</code> 是 <code>JDK1.0</code> 引入的接口，为集合提供遍历的接口，使用它的集合包括 <code>Vector</code>、<code>HashTable</code> 等。<code>Enumeration</code> 迭代器不支持 <code>fail-fast</code> 机制。</p><p>它只有两个接口方法：<code>hasMoreElements</code>、<code>nextElement</code> 用来判断是否有元素和获取元素，但不能对数据进行修改。</p><p>但需要注意的是 <code>Enumeration</code> 迭代器只能遍历 <code>Vector</code>、<code>HashTable</code> 这种古老的集合，因此通常情况下不要使用。</p><h1 id="Java中遍历-Map-的几种方式"><a href="#Java中遍历-Map-的几种方式" class="headerlink" title="Java中遍历 Map 的几种方式"></a>Java中遍历 Map 的几种方式</h1><p><strong>方法一 在 for-each 循环中使用 entries 来遍历</strong></p><p>这是最常见的，并且在大多数情况下也是最可取的遍历方式，在键和值都需要时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果遍历一个空 <code>map</code> 对象，<code>for-each</code> 循环将抛出 <code>NullPointerException</code>，因此在遍历前应该检查是否为空引用。</p><p><strong>方法二 在 for-each 循环中遍历 keys 或 values</strong></p><p>如果只需要 <code>map</code> 中的键或者值，可以通过 <code>keySet</code> 或 <code>values</code> 来实现遍历，而不是用 <code>entrySet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 map 中的键  </span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + key);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 map 中的值  </span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">"Value = "</span> + value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比 <code>entrySet</code> 遍历在性能上稍好，而且代码更加干净。</p><p><strong>方法三 使用 Iterator 遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();  </span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;  </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();  </span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看起来冗余却有其优点所在，可以在遍历时调用 <code>iterator.remove()</code> 来删除 <code>entries</code>，另两个方法则不能。</p><p>从性能方面看，该方法类同于 <code>for-each</code> 遍历（即方法二）的性能。</p><p><strong>总结</strong></p><ul><li>如果仅需要键（<code>keys</code>）或值（<code>values</code>），则使用方法二；</li><li>如果需要在遍历时删除 <code>entries</code>，则使用方法三；</li><li>如果键值都需要，则使用方法一。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Iterator-与-ListIterator&quot;&gt;&lt;a href=&quot;#Iterator-与-ListIterator&quot; class=&quot;headerlink&quot; title=&quot;Iterator 与 ListIterator&quot;&gt;&lt;/a&gt;Iterator 与 ListIterator&lt;/h1&gt;&lt;p&gt;凡是实现 &lt;code&gt;Collection&lt;/code&gt; 接口的集合类都有一个 &lt;code&gt;iterator&lt;/code&gt; 方法，会返回一个实现了 &lt;code&gt;Iterator&lt;/code&gt; 接口的对象，用于遍历集合。&lt;code&gt;Iterator&lt;/code&gt; 接口主要有三个方法，分别是 &lt;code&gt;hasNext&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ListIterator&lt;/code&gt; 继承自 &lt;code&gt;Iterator&lt;/code&gt;，专门用于实现 &lt;code&gt;List&lt;/code&gt; 接口对象，除了 &lt;code&gt;Iterator&lt;/code&gt; 接口的方法外，还有其他几个方法。&lt;/p&gt;
&lt;p&gt;基于顺序存储集合的 &lt;code&gt;Iterator&lt;/code&gt; 可以直接按位置访问数据。基于链式存储集合的 &lt;code&gt;Iterator&lt;/code&gt;，一般都是需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合之 Collections 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/20/026_Java%E9%9B%86%E5%90%88%E4%B9%8B%20Collections%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/20/026_Java集合之 Collections 源码解析/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Java</code> 集合框架中，有两个经常使用的工具类：<code>Collections</code> 和 <code>Arrays</code>。<code>Collections</code> 用来操作集合，而 <code>Arrays</code> 用来操作数组。这篇文章就来分析一个 <code>Collections</code> 类。<a id="more"></a></p><p>网上查了一下，有两篇文章写得很好，本篇文章基本就是对它们的整理。</p><ul><li><a href="https://blog.csdn.net/u011240877/article/details/78348578#" target="_blank" rel="noopener">Java 常用工具类 Collections 源码分析</a></li><li><a href="https://www.jianshu.com/p/51ce612db017" target="_blank" rel="noopener">Java1.8-Collections源码解析</a></li></ul><h1 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort 方法"></a>sort 方法</h1><p><code>Collections</code> 有两个 <code>sort</code> 方法，第一个方法要求 <code>List</code> 中的对象必须要实现 <code>Comparable</code> 接口；而第二个方法则不要求实现 <code>Comparable</code> 接口，但可以使用自定义的比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但两者底层实现都是通过 <code>List</code> 接口的默认方法 <code>sort</code>。首先将 <code>List</code> 对象转换成数组，然后使用 <code>Arrays.sort</code> 方法排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>Arrays.sort</code> 方法稍后进行详细分析。</p><h1 id="binarySearach-方法"><a href="#binarySearach-方法" class="headerlink" title="binarySearach 方法"></a>binarySearach 方法</h1><p>二分查找需要集合已经有序，如果没有排序那也就没有意义。同样地，<code>Collections</code> 也有两个 <code>binarySearach</code> 方法，这里只看一下实现了 <code>Comparable</code> 接口的对象的二分查找方法。对于指定比较器的算法其实是一样的，区别在于比较的标准不同。</p><p><code>binarySearach</code> 方法中，如果 <code>List</code> 支持随机访问，或者小于二分查找的阈值 <code>BINARYSEARCH_THRESHOLD(5000)</code>，则调用 <code>indexedBinarySearch</code>，否则调用 <code>iteratorBinarySearch</code>，借助迭代器来访问.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看一下 <code>indexedBinarySearch</code> 方法，由于支持随机访问，所以查找的平均时间复杂度为 <code>O(logn)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 无符号右移，相当于除 2</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = list.get(mid); <span class="comment">// get 时间复杂度为 O(1)</span></span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>iteratorBinarySearch</code> 方法，不能支持随机访问，就需要使用迭代器保存之前访问的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;</span><br><span class="line">    ListIterator&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = get(i, mid);</span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(ListIterator&lt;? extends T&gt; i, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    T obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = i.nextIndex();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= index) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            obj = i.next();</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos++ &lt; index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            obj = i.previous();</span><br><span class="line">        &#125; <span class="keyword">while</span> (--pos &gt; index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Collections.get()</code> 方法，每次查找中间点都需要移动指针。所以时间复杂度会达到 <code>O(n)</code>。</p><h1 id="reverse-方法"><a href="#reverse-方法" class="headerlink" title="reverse 方法"></a>reverse 方法</h1><p>下面来看一下 <code>reverse</code> 反转列表的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">            swap(list, i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator fwd = list.listIterator();</span><br><span class="line">        ListIterator rev = list.listIterator(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">            Object tmp = fwd.next();</span><br><span class="line">            fwd.set(rev.previous());</span><br><span class="line">            rev.set(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，同样的这里判断是否支持随机访问，或 <code>list</code> 小于反转的阈值 <code>REVERSE_THRESHOLD</code>。</p><p>如果支持随机访问，则先交换第一个和最后一个元素，然后第二个和倒数第二个元素，一直到中间位置。这里的 <code>swap</code> 交换很巧妙：</p><ol><li>使用 <code>l.get(i)</code> 得到 <code>i</code> 位置的元素；</li><li>使用 <code>l.set(j, l.get(i))</code> 将 <code>i</code> 位置的元素设置到 <code>j</code> 位置；</li><li>由于 set 方法会返回设置之前的元素，所以整体的 <code>l.set(···)</code> 会将 <code>j</code> 位置的元素设置到 <code>i</code> 位置；</li></ol><p>如果不支持随机访问，就是用两个迭代器，一个从头开始，一个从尾开始，交换元素，一直到中间位置。</p><p><code>Collections</code> 中的 <code>reverse</code> 方法在反转列表时，是交换对象中的值。对于链表，还有另外一种实现，是直接交换链表中的结点。</p><h1 id="shuffle-方法"><a href="#shuffle-方法" class="headerlink" title="shuffle 方法"></a>shuffle 方法</h1><p>下面来看一下 <code>shuffle</code> 打乱列表中元素的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shuffle array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line"></span><br><span class="line">        ListIterator it = list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，这里判断是否 <code>list</code> 支持随机访问，或者 <code>list</code> 小于 <code>SHUFFLE_THRESHOLD</code>。</p><p>如果支持随机访问，就使用 <code>random</code> 生成一个小于 <code>i</code> 的值，使用 <code>swap</code> 方法随机交换元素。</p><p>如果不支持，首先将 <code>list</code> 转换成数组，然后遍历数组随机交换元素，最后又遍历把打乱的元素写回列表。</p><h1 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate 方法"></a>rotate 方法</h1><p>下面来看一下 <code>rotate</code> 旋转方法，也就是对集合中的元素进行右移，可以指定移动的距离 <code>distance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class="line">        rotate1(list, distance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rotate2(list, distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，这里判断 <code>list</code> 支持随机访问，或者 <code>list</code> 小于 <code>ROTATE_THRESHOLD</code>。如果支持随机访问，就调用 <code>rotate1</code>，否则就调用 <code>rotate2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">rotate1</span><span class="params">(List&lt;T&gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    distance = distance % size;</span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">        distance += size;</span><br><span class="line">    <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cycleStart = <span class="number">0</span>, nMoved = <span class="number">0</span>; nMoved != size; cycleStart++) &#123;</span><br><span class="line">        T displaced = list.get(cycleStart);</span><br><span class="line">        <span class="keyword">int</span> i = cycleStart;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += distance;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                i -= size;</span><br><span class="line">            displaced = list.set(i, displaced);</span><br><span class="line">            nMoved ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != cycleStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>rotate2</code> 方法，则借助于反转方法 <code>reverse</code> 来进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate2</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =  -distance % size;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; <span class="number">0</span>)</span><br><span class="line">        mid += size;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">    reverse(list.subList(mid, size));</span><br><span class="line">    reverse(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里三个 <code>reverse</code> 方法非常巧妙，比如要对 <code>[1,2,3,4,5,6,7,8,9]</code> 进行 <code>3</code> 位旋转，则我们旋转的方式可以是：先对前 <code>size-3</code> 位进行反转，然后再对后 <code>3</code> 位进行反转，最后整体再进行反转就可以实现旋转的操作了。</p><p>其中，<code>mid</code> 的值就是确定要前后反转的中间值。我们用一张图来看一下就明白了：</p><p><img src="http://media.timberliu.com/image/2019/2/20/Collections%23reverse%20%E5%8F%8D%E8%BD%AC.jpg" width="50%"></p><h1 id="unmodifiable-方法"><a href="#unmodifiable-方法" class="headerlink" title="unmodifiable 方法"></a>unmodifiable 方法</h1><p><code>Collections</code> 提供了一系列以 <code>unmodifiable</code> 开头的方法，用来在原集合基础上生成一个不可变的集合。例如 <code>unmodifiableCollection</code>、<code>unmodifiableList</code>、<code>unmodifiableMap</code> 等。</p><p>看一下 <code>Collections.unmodifiableCollection(c)</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableCollection&lt;&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以返回一个容器的包装类，这个包装类的添加、替换、删除等修改操作都会抛出异常 <code>UnsupportedOperationException</code>。例如 <code>UnmodifiableCollection</code> 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h1 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a>synchronized 方法</h1><p><code>Collections</code> 也提供了一系列以 <code>synchronized</code> 开头的方法，用来将原集合转成一个线程安全的集合。例如 <code>synchronizedList</code>，<code>synchronizedMap</code> 等。</p><p>看一下 <code>synchronizedList</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以返回一个容器的包装类 <code>SynchronizedRandomAccessList</code> 或 <code>SynchronizedList</code>，这个包装类的添加、替换、删除等操作都使用了 <code>synchronized</code> 关键字。例如 <code>SynchronizedList</code> 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>几乎所有方法都使用了 <code>synchronized</code> 关键字，这样得到的集合在并发环境下效率不是很高。</p><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><p>当然，<code>Collections</code> 类中还有很多方法：</p><ul><li>以 <code>checked</code> 开头的方法：获取动态类型检查的集合；</li><li><code>frequency</code> 方法：用于获取某一个元素在集合中出现的次数，并且可以统计 <code>null</code>；</li><li><code>fill()</code> 方法：用于使用指定的元素替换列表中的所有元素；</li><li><code>min()/max()</code> 方法：求集合中的最大最小值；</li><li><code>indexOfSubList</code>、<code>lastIndexOfSubList</code> 方法：查找子列表最早出现或最后出现的索引；</li><li><code>replaceAll</code> 方法：替换集合中的某一个元素为新的元素，可以替换 <code>null</code> 元素；</li><li><code>copy</code> 方法：将原集合中元素拷贝到另一个集合中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 集合框架中，有两个经常使用的工具类：&lt;code&gt;Collections&lt;/code&gt; 和 &lt;code&gt;Arrays&lt;/code&gt;。&lt;code&gt;Collections&lt;/code&gt; 用来操作集合，而 &lt;code&gt;Arrays&lt;/code&gt; 用来操作数组。这篇文章就来分析一个 &lt;code&gt;Collections&lt;/code&gt; 类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(1)之 总体架构</title>
    <link href="https://blog.timberliu.com/2019/02/19/024_Java%E9%9B%86%E5%90%88%E4%B9%8B%20%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://blog.timberliu.com/2019/02/19/024_Java集合之 总体架构/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p><code>Java</code> 提供了一个丰富的集合类，包含了常用的数据结构和算法等。使用 <code>Java</code> 集合的优点部分如下：</p><ul><li>降低开发的成本：通过提供的核心集合类，使程序员更专注地实现程序的核心功能，而不用自己去实现自己的集合类；</li><li>提高代码的质量：集合框架提供了许多经过严格测试的、高性能、高质量的数据结构和算法，大大提高了程序的质量；</li><li>促进软件的复用性：只要符合标准集合接口的新数据结构和算法本质上都是可以复用的。<a id="more"></a></li></ul><p>在集合的接口和实现中大量使用了泛型，它为集合提供了一个可以容纳的对象类型，如果添加其他类型的元素，在编译时就会出错，这避免了在运行时出现类型转换异常。泛型也使得代码更加整洁，因为不需要显式地编写类型转换操作，编译器会帮我们实现。</p><p><code>Java</code> 整个集合框架图如下：</p><p><img src="http://media.timberliu.com/image/2019/2/19/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg" width="90%"></p><p>可以看到，这个框图主要有两个主干：<code>Collection</code> 和 <code>Map</code>。</p><ul><li><code>Collection</code>：它是一个接口，提供了对集合对象进行基本操作的通用接口方法，有很多具体的实现和继承，它被分为三大分支：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li><li><code>Map</code>：它是由一系列键值对组成的集合，提供了 <code>key</code> 到 <code>Value</code> 的映射。</li></ul><p>除此之外，还有 <code>Iterator</code> 迭代器，<code>Collections</code> 和 <code>Arrays</code> 工具类，<code>Comparator</code> 比较器等。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><code>List</code> 是一个有序列表，用特定的插入顺序来维护元素顺序。可以对列表中元素的插入位置进行控制，同时可以根据元素的索引访问元素。实现 <code>List</code> 接口的主要有 <code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code> 等。</p><p><strong>ArrayList</strong></p><p><code>ArrayList</code> 是一个动态数组，在随机访问元素时性能较高，但插入和删除元素效率较低。<code>ArrayList</code> 都有一个初始容量，代表了数组的大小，在 <code>ArrayList</code> 快满时，会进行扩容操作，每次增长 <code>1.5</code> 倍大小。但 <code>ArrayList</code> 是非同步的，在多线程场景下不要使用。</p><p><strong>LinkedList</strong></p><p><code>LinkedList</code> 是一个双向链表，由于实现方式不同，它不支持随机访问，但很容易在列表中间进行插入和删除操作。与 <code>ArrayList</code> 一样，<code>LinkedList</code> 也是非同步的。</p><p><strong>Vector</strong></p><p><code>Vector</code> 与 <code>ArrayList</code> 类似，基于动态数组实现，但 <code>Vector</code> 是同步的。它的操作与 <code>ArrayList</code> 几乎一样。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>Map</code> 是由一系列键值对组成的集合，提供了 <code>key</code> 到 <code>Value</code> 的映射。实现 <code>Map</code> 接口的有：<code>HashMap</code>、<code>TreeMap</code>、<code>HashTable</code>、<code>EnumMap</code> 等。</p><p><strong>HashMap</strong></p><p><code>HashMap</code> 以哈希表数据结构实现，查询对象时通过哈希函数将元素的哈希地址转换成数组索引，在出现碰撞冲突时，则使用链表的形式存储哈希地址相同的元素，在 <code>JDK8</code> 后，链表过长后会转换为红黑树。<code>HashMap</code> 存储和查询效率较高，但需要考虑哈希函数、碰撞冲突等问题。</p><p><strong>TreeMap</strong></p><p><code>TreeMap</code> 实现了 <code>SortedMap</code> 接口，内部以红黑树数据结构实现，其中键以某种排序规则排序，排序规则也可以通过 <code>Comparator</code> 比较器指定。</p><p><strong>HashTable</strong></p><p><code>HashTable</code> 也是以哈希表数据结构实现，遇到冲突时采用链表的形式。类似于 <code>HashMap</code>，但它的同步的。</p><p><strong>EnumMap</strong></p><p><code>EnumMap</code> 是将枚举类型作为键值的 <code>Map</code>。由于键的数量相对固定，所以在内部用一个数组存储对应值。通常来说，效率高于 <code>HashMap</code>。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>Set</code> 是一个不包括重复元素的集合，存入的元素没有顺序。内部通过 <code>Map</code> 实现，<code>Set</code> 里存储的值对应的是 <code>Map</code> 中的键，键对应的值是不变的，指向一个常量。实现 <code>Set</code> 接口的集合有：<code>HashSet</code>、<code>TreeSet</code>、<code>EnumSet</code> 等。</p><p><strong>HashSet</strong></p><p><code>HashSet</code> 底层基于 <code>HashMap</code> 实现，它内部元素的顺序是由哈希码来决定的，所以它不保证 <code>Set</code> 的迭代顺序。可以放入 <code>null</code>，但只能放入一个。</p><p><strong>TreeSet</strong></p><p>与 <code>HashSet</code> 类似，它是基于 <code>TreeMap</code> 实现，以某种排序规则排序。它是使用元素的自然顺序排序，或根据创建 <code>Set</code> 时提供的 <code>Comparator</code> 进行排序。但不允许存入 <code>null</code> 值。</p><p><strong>EnumSet</strong></p><p><code>EnumSet</code> 基于 <code>EnumMap</code> 实现，是枚举专用的 <code>Set</code>，其中所有元素都是枚举类型。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><code>Queue</code> 通常是指先进先出的队列，也不允许随机访问队列中的元素。而 <code>Deque</code> 接口是 <code>Queue</code> 的子接口，它代表一个双端队列。</p><p><strong>ArrayDeque</strong></p><p><code>ArrayDeque</code> 是基于有首尾指针的数组（环形缓冲区）实现的双端队列，它只能从首尾取出或插入元素。底层由数组实现，可以指定容量，默认容量为 <code>16</code>，并根据添加元素个数，动态扩展。</p><p><strong>PriorityQueue</strong></p><p><code>PriorityQueue</code> 是一个优先级队列，它使用自然顺序或者制定的比较器来排序。队列的头是按指定排序方式的最小元素。</p><h1 id="Comparator-和-Comparable"><a href="#Comparator-和-Comparable" class="headerlink" title="Comparator 和 Comparable"></a>Comparator 和 Comparable</h1><p><code>Comparator</code> 和 <code>Comparable</code> 是两个接口，都可以用来对对象进行比较。</p><ul><li><code>Comparable</code> 接口用于当前对象和其他对象进行比较。它有一个 <code>compareTo</code> 方法，该方法只有一个参数。返回值为 <code>int</code>，大于 <code>0</code> 表示当前对象大于参数对象；小于 <code>0</code> 表示当前对象小于参数对象；等于 <code>0</code> 表示两者相等。</li><li><code>Comparator</code> 是一个比较器接口，用于对传入的两个对象进行比较。它有一个 <code>compare</code> 方法，该方法有两个参数。</li></ul><p>例如，对一组 <code>Student</code> 对象进行排序，分别使用 <code>Comparable</code> 和 <code>Comparator</code> 接口实现功能。</p><p><strong>Comparable</strong></p><p><code>Comparable</code> 接口实现在对象类的内部，之后对象就变成了一个可以比较大小的对象，也就可以用来排序了。</p><p>首先 <code>Student</code> 类需要实现 <code>Comparable</code> 接口，重写其 <code>compareTo</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter、getter、toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="keyword">this</span>.name.compareTo(another.name);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">this</span>.age - another.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后利用 <code>List</code> 接口的 <code>sort(Comparator&lt;? super E&gt; c)</code> 默认方法，或者 <code>Collections</code> 工具类的 <code>sort(List&lt;T&gt; list)</code> 方法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"a"</span>, <span class="number">4</span>));</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"d"</span>, <span class="number">2</span>));</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"c"</span>, <span class="number">5</span>));</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"c"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    students.sort(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Collections.sort(students);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparator</strong></p><p><code>Comparator</code> 实现在对象类的外部，此时对象类的结构不需要有任何变化。</p><p>然后另外定义一个比较器类，实现 <code>Comparator</code> 接口并重写其 <code>compare</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = o1.getName().compareTo(o2.getName());</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后利用 <code>List</code> 接口的 <code>sort(Comparator&lt;? super E&gt; c)</code> 方法，或者 <code>Collections</code> 工具类的 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 方法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>, <span class="number">4</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>, <span class="number">2</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>, <span class="number">5</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    persons.sort(<span class="keyword">new</span> PersonComparator());</span><br><span class="line">    <span class="comment">// Collections.sort(persons, new PersonComparator());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集合框架&quot;&gt;&lt;a href=&quot;#集合框架&quot; class=&quot;headerlink&quot; title=&quot;集合框架&quot;&gt;&lt;/a&gt;集合框架&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 提供了一个丰富的集合类，包含了常用的数据结构和算法等。使用 &lt;code&gt;Java&lt;/code&gt; 集合的优点部分如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低开发的成本：通过提供的核心集合类，使程序员更专注地实现程序的核心功能，而不用自己去实现自己的集合类；&lt;/li&gt;
&lt;li&gt;提高代码的质量：集合框架提供了许多经过严格测试的、高性能、高质量的数据结构和算法，大大提高了程序的质量；&lt;/li&gt;
&lt;li&gt;促进软件的复用性：只要符合标准集合接口的新数据结构和算法本质上都是可以复用的。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射与动态代理</title>
    <link href="https://blog.timberliu.com/2019/02/18/023_Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://blog.timberliu.com/2019/02/18/023_Java 反射与动态代理/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。</p><p>一般来说，<code>Java</code> 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。<a id="more"></a></p><h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>反射机制指的是程序在运行时自省（<code>introspect</code>，即能够获取自身信息）的能力。在 <code>Java</code> 中，只要给定类的完全限定名，就可以通过反射直接操作类或对象。它主要有以下几个作用：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时判断任意一个类具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>在运行时构造任意一个类的对象；</li></ul><p>可以看到，反射提高了程序的灵活性和扩展性。但同时降低了代码的可读性和维护性；又因为反射涉及到动态类型，无法执行某些虚拟机优化，所以代码的执行性能也降低；另外，可以访问任意成员变量和方法，也破坏了封装性。一般来说，在业务代码中应尽量避免使用反射，但必须能理解中间件或框架中的反射代码。</p><p>反射的应用场景非常多。例如，对象序列化，动态代理，<code>JDBC</code> 的 <code>Class.forName()</code>，<code>RPC</code> 框架，<code>Spring</code> 的 <code>IOC/DI</code>。</p><h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p><code>Java</code> 的 <code>Class</code> 类是反射机制的基础，包含了被装入到 JVM 中的类（包括类和接口）的信息。每个类（型）都有一个 <code>Class</code> 对象，也就是说每当编写并编译了一个新类，就会产生一个 <code>Class</code> 对象，被保存在一个同名的 <code>.class</code> 文件中。</p><p>所有的类都是在对其第一次使用时，动态加载到 <code>JVM</code> 中的。当运行程序时，类加载器会首先检查这个类的 <code>class</code> 对象是否已经加载，如果没有加载，类加载器就会根据类名查找 <code>.class</code> 文件，并将其 <code>Class</code> 对象载入。</p><p>获取某一个类所对应的 <code>Class</code> 对象有三种方法：</p><p>1). 根据对象的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Class c = user.getClass();</span><br></pre></td></tr></table></figure><p>2). 根据 <code>Class</code> 的静态方法 <code>forName()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"com.timber.User"</span>);</span><br></pre></td></tr></table></figure><p>3). 根据类名 <code>.class</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class;</span><br></pre></td></tr></table></figure><p>对于基本类型来说，它们的包装类型拥有一个名为 <code>TYPE</code> 的 <code>final</code> 静态字段，指向该基本类型对应的 <code>Class</code> 对象。例如，<code>Integer.TYPE</code> 指向 <code>int.class</code>。</p><p>对于数组类型来说，可以使用 <code>类名 + [].class</code> 来访问 <code>Class</code> 对象。例如，<code>int[].class</code>。</p><h1 id="使用反射创建对象"><a href="#使用反射创建对象" class="headerlink" title="使用反射创建对象"></a>使用反射创建对象</h1><p>在 <code>Java</code> 中创建对象主要有四种方式：</p><ul><li>通过 <code>new</code> 关键字创建；</li><li>使用反射；</li><li>使用 <code>clone</code> 方法；</li><li>使用反序列化；</li></ul><p><strong>使用反射</strong></p><p><code>Java</code> 中使用反射创建对象主要有两种方法：</p><p>1). 使用 <code>Class</code> 类的 <code>newInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">Class&lt;?&gt; userClass = Class.forName(<span class="string">"com.timber.User"</span>);  <span class="comment">// 给定类的完全限定名</span></span><br><span class="line">User user = (User) userClass.newInstance();</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">User user = User.class.newInstance();</span><br></pre></td></tr></table></figure><p>2). 使用 <code>Constructor</code> 类的 <code>newInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = (User) constructor.newInstance();</span><br></pre></td></tr></table></figure><p>事实上，<code>Class</code> 的 <code>newInstance</code> 方法内部就是调用 <code>Constructor</code> 的 <code>newInstance</code> 方法。如下为 <code>Class</code> 类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Unsafe.getUnsafe().throwException(e.getTargetException());</span><br><span class="line">        <span class="comment">// Not reached</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用反射功能"><a href="#使用反射功能" class="headerlink" title="使用反射功能"></a>使用反射功能</h1><p>在得到 <code>Class</code> 对象后，可以正式使用反射功能了。除了使用 <code>newInstance()</code> 生成类的实例，还有以下几项： </p><p>1). 使用 <code>isInstance(Object o)</code> 来判断一个对象是否该类的实例，等同于 <code>instanceof</code> 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class.newInstance();</span><br><span class="line"><span class="keyword">boolean</span> b = c.isInstance(user);</span><br></pre></td></tr></table></figure><p>2). 使用 <code>Array.newInstance(Class c, int size)</code> 来构造该类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = Array.newInstance(<span class="keyword">int</span>[].class, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>3). 使用 <code>getFields()/getConstructors()/getMethods()</code> 来访问该类的成员。需要注意，方法名中带 <code>Declared</code> 的不会返回父类的成员，但是会返回私有成员；而不带 <code>Declared</code> 的则相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = c.getMethods();</span><br><span class="line">Method[] methods = c.getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>当获得类成员之后，可以进一步做如下操作：</p><ul><li>使用 <code>Constructor/Field/Method.setAccessible()</code> 来修改访问限制</li><li>使用 <code>Constructor.newInstance(Object[])</code> 来生成该类的实例</li><li>使用 <code>Field.set/get(Object)</code> 来访问字段值</li><li>使用 <code>Method.invoke(Object, Object[])</code> 来调用方法</li></ul><p>实例：在泛型为 <code>Integer</code> 的 <code>ArrayList</code> 中存放一个 <code>String</code> 类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; listClass = list.getClass();</span><br><span class="line">        Method method = listClass.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(list, <span class="string">"test"</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h1><p>在前面的方法中，<code>Class.forName</code> 会调用本地方法，<code>Class.getMethod()</code> 会遍历该类的共有方法，如果找不到，还会遍历父类的私有方法，所以它们的操作都很费时。另外，<code>Method.getMethods()</code> 等方法还会返回查找结果的一份拷贝。</p><p>在实践中，应该避免在热点代码中使用 <code>Method.getMethods()</code> 和 <code>Method.getDeclaredMethods()</code> 方法。并且往往会缓存 <code>Class.forName()</code> 和 <code>Method.getMethod()</code> 的结果。</p><p>在反射调用时会带来不少性能开销，主要原因有三个：</p><ul><li>由于 <code>Method.invoke</code> 是一个变长参数方法，在调用时会生成一个 <code>Object</code> 数组</li><li>由于 <code>Object</code> 数组不能存储基本类型，所以会对基本类型进行自动装箱、拆箱</li><li>如果拥有多个不同的反射调用，就会对应多个 <code>GeneratedMethodAccessor</code>，可能由于 <code>JVM</code> 调用点的类型 <code>profile</code> 无法同时记住多个类，而没有被内联</li></ul><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>代理是基本的设计模式之一。它可以通过访问代理对象来完成对目标对象的访问，在不修改原对象的情况下扩充其功能。可以分为静态代理和动态代理两种。</p><p>静态代理，就是代理类由程序员自己编写，代理模式中的所有对象在编译期就已经确定。下面是一个简单的例子，首先定义一个接口和其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"目标对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是代理模式中的目标对象和目标对象的接口，接下来定义代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用目标对象之前"</span>);</span><br><span class="line">        target.say();</span><br><span class="line">        System.out.println(<span class="string">"调用目标对象之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个代理类，它同样实现了目标对象的接口，并重写了 say 方法。下面是一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(target);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用目标对象之前</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 调用目标对象之后</span></span><br></pre></td></tr></table></figure><p>静态代理也存在一些局限，例如，需要程序员手写很多代码，并且当需要代理的类中方法比较多，或者同时需要代理多个对象时，实现会很复杂。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理中的代理类是在运行期动态生成的。在 <code>Java</code> 中，动态代理有两种方式：</p><p>1). <code>JDK</code> 接口 + 反射方式</p><p>这种方式主要通过 <code>java.lang.reflect</code> 包中的 <code>Proxy</code> 类和 <code>InvocationHandler</code> 接口实现。由于是 <code>JDK</code> 本身支持，可能比 <code>cglib</code> 更加可靠，代码实现也比较简单。<br>但是它有一个限制，就是代理对象必须实现一个或多个接口。</p><p>2). <code>cglib</code> 继承 + <code>asm</code> 方式</p><p><code>cglib</code> 是一个第三方代码生成类库，通过在运行时动态生成一个子类对象来实现，它底层通过一个小而快字节码处理框架 <code>asm</code>，转换字节码来生成新的类。这种方式无需实现接口，达到了代理类无侵入。但是无法代理 <code>final</code> 类和父类的 <code>static/final</code> 方法。</p><p><code>cglib</code> 虽然性能较高，但是它需要对 <code>JVM</code> 内部结构包括 <code>Class</code> 文件格式和指令集很熟悉，所以不鼓励使用。</p><p><code>Java</code> 的动态代理最主要的用途就是应用在各种框架中。例如，<code>RPC</code> 框架，<code>Spring</code> 中的 <code>AOP</code>，<code>Servlet</code> 的过滤器、拦截器。像 <code>Mybatis</code> 的分页插件，<code>Spring AOP</code> 中类似日志、事务、权限、性能监控等都用到了动态代理，以在不同模块的特定阶段实现某些功能。</p><h1 id="两种实现方法"><a href="#两种实现方法" class="headerlink" title="两种实现方法"></a>两种实现方法</h1><p>1). <code>JDK</code> 动态代理</p><p>目标对象的接口和实现和静态代理中一样，下面定义调用处理器类，它需要实现 <code>IovacationHandler</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前:"</span> + method.getName());</span><br><span class="line">        <span class="comment">// 将请求转发给目标对象，并传入相应的参数</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"调用后:"</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入类加载器、希望该代理类实现的接口类数组、调用处理器，构造代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        JDKInvocationHandler handler = <span class="keyword">new</span> JDKInvocationHandler(target);</span><br><span class="line">        UserService proxy = (UserService) handler.getProxy();</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用前:say</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 调用后:say</span></span><br></pre></td></tr></table></figure><p>2). <code>Cglib</code> 动态代理</p><p>目标对象和之前的一致，下面定义代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class c)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(c);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开事务"</span>);</span><br><span class="line">        Object retVal = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"关闭事务"</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserServiceImpl proxyImpl = (UserServiceImpl) proxy.getProxy(UserServiceImpl.class);</span><br><span class="line">        proxyImpl.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开事务</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 关闭事务</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;code&gt;Java&lt;/code&gt; 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
