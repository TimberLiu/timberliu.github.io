<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimberLiu&#39;s Blog</title>
  
  <subtitle>Easy coding, easy life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.timberliu.com/"/>
  <updated>2019-05-15T16:00:00.000Z</updated>
  <id>https://blog.timberliu.com/</id>
  
  <author>
    <name>TimberLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>观察者模式真的很简单</title>
    <link href="https://blog.timberliu.com/2019/05/16/052_%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%9C%9F%E7%9A%84%E5%BE%88%E7%AE%80%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/05/16/052_观察者模式真的很简单/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2019-05-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章学习了责任链模式，它主要是定义了一对多的依赖，当主题的状态时，所有依赖于它的观察者都会受到通知，并更新状态。<a id="more"></a></p><p>这篇文章我们来学习一下观察者模式，同样地从一个例子开始。</p><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><p>现在很多平台都提供知识付费服务，例如极客时间、得到等，我在极客时间也订阅了数据结构与算法、趣谈网络协议等。现在我们就模仿一下算法专栏的订阅系统。</p><h2 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h2><p>一般专栏都会提供文章和音频两种格式，可以如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Article</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String articleName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Article</span><span class="params">(String articleName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.articleName = articleName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Article: "</span> + articleName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Audio</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String audioName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Audio</span><span class="params">(String audioName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.audioName = audioName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Audio: "</span> + audioName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于算法专栏，我们可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmColumn</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储文章和音频的容器</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Article, Audio&gt; course = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在算法中添加不同的订阅者</span></span><br><span class="line">    <span class="keyword">private</span> WebDeveloper webDeveloper;</span><br><span class="line">    <span class="keyword">private</span> BackgroundDeveloper backgroundDeveloper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWebDeveloper</span><span class="params">(WebDeveloper webDeveloper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.webDeveloper = webDeveloper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBackgroundDeveloper</span><span class="params">(BackgroundDeveloper backgroundDeveloper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.backgroundDeveloper = backgroundDeveloper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在更新课程时，将文章和音频添加到容器中</span></span><br><span class="line">    <span class="comment">// 通知订阅者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">courseUpdated</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        course.put(article, audio);</span><br><span class="line">        webDeveloper.updateCourse(article, audio);</span><br><span class="line">        backgroundDeveloper.updateCourse(article, audio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果订阅者包括前端开发工程师和后台开发工程师，可以这样定义（这里不太恰当，其实是想说明订阅者可以是不同的对象）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebDeveloper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Article, Audio&gt; course = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Article lastArticle;</span><br><span class="line">    <span class="keyword">private</span> Audio lastAudio;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCourse</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        lastArticle = article;</span><br><span class="line">        listAudio = audio;</span><br><span class="line">        course.put(lastArticle, listAudio);</span><br><span class="line">        showNews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WebDeveloper：更新了 "</span> + lastArticle.toString() + <span class="string">" + "</span> + lastAudio.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundDeveloper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Article, Audio&gt; course = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Article lastArticle;</span><br><span class="line">    <span class="keyword">private</span> Audio lastAudio;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateCourse</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        lastArticle = article;</span><br><span class="line">        listAudio = audio;</span><br><span class="line">        course.put(lastArticle, listAudio);</span><br><span class="line">        showNews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showNews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BackgroundDeveloper：更新了 "</span> + lastArticle.toString() + <span class="string">" + "</span> + lastAudio.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面写段代码来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AlgorithmColumn algorithmColumn = <span class="keyword">new</span> AlgorithmColumn();</span><br><span class="line"></span><br><span class="line">        WebDeveloper webDeveloper = <span class="keyword">new</span> WebDeveloper();</span><br><span class="line">        algorithmColumn.setWebDeveloper(webDeveloper);</span><br><span class="line"></span><br><span class="line">        BackgroundDeveloper backgroundDeveloper = <span class="keyword">new</span> BackgroundDeveloper();</span><br><span class="line">        algorithmColumn.setBackgroundDeveloper(backgroundDeveloper);</span><br><span class="line"></span><br><span class="line">        Article article1 = <span class="keyword">new</span> Article(<span class="string">"01.数组文章"</span>);</span><br><span class="line">        Audio audio1 = <span class="keyword">new</span> Audio(<span class="string">"01.数组音频"</span>);</span><br><span class="line">        algorithmColumn.courseUpdated(article1, audio1);</span><br><span class="line"></span><br><span class="line">        Article article2 = <span class="keyword">new</span> Article(<span class="string">"02. 链表文章"</span>);</span><br><span class="line">        Audio audio2 = <span class="keyword">new</span> Audio(<span class="string">"02. 链表音频"</span>);</span><br><span class="line">        algorithmColumn.courseUpdated(article2, audio2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果还有其他人订阅专栏，例如运维工程师，测试工程师，我们创建相应的类后，就需要修改 AlgorithmColumn，这明显不符合开闭原则。</p><p>另外，如果这些人也想订阅其他专栏，我们还需要重新创建一个独立的 AlgorithmColumn。很明显，刚才的设计并不是很好。</p><h2 id="改进后"><a href="#改进后" class="headerlink" title="改进后"></a>改进后</h2><p>对于多个专栏，我们可以提取出一个接口，提供注册和取消课程的方法，另外还有通知订阅专栏的人课程更新的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Article article, Audio audio)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的算法专栏可以如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmColumn</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Article, Audio&gt; course = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目前专栏订阅不可退订</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</span><br><span class="line">            <span class="comment">// 通知所有订阅专栏的人</span></span><br><span class="line">            observer.updateCourse(article, audio);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">courseUpdated</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        course.put(article, audio);</span><br><span class="line">        notifyObservers(article, audio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于不同的工程师，我们依旧可以提取出一个接口，其中 updateCourse 方法用于在课程更新后，由 AlgorithmColumn 调用通知课程更新了。</p><p>还有 subscribeColumn 和 unsubscribeColumn 方法，用于由工程师来决定订阅或者是取消专栏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">courseUpdated</span><span class="params">(Article article, Audio audio)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">subscribeColumn</span><span class="params">(Subject column)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribeColumn</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后对 WebDeveloper 和 BackgroundDeveloper 进行修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebDeveloper</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject subscriberColumn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">courseUpdated</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WebDeveloper：更新了 "</span> + article.toString() + <span class="string">" + "</span> + audio.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeColumn</span><span class="params">(Subject column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscriberColumn = column;</span><br><span class="line">        column.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribeColumn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subscriberColumn.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundDeveloper</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Subject subscriberColumn;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">courseUpdated</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"BackgroundDeveloper：更新了 "</span> + article.toString() + <span class="string">" + "</span> + audio.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribeColumn</span><span class="params">(Subject column)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subscriberColumn = column;</span><br><span class="line">        column.registerObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unsubscribeColumn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        subscriberColumn.removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面写段代码来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Subject algorithmColumn = <span class="keyword">new</span> AlgorithmColumn();</span><br><span class="line"></span><br><span class="line">        Observer webDeveloper = <span class="keyword">new</span> WebDeveloper();</span><br><span class="line">        webDeveloper.subscribeColumn(algorithmColumn);</span><br><span class="line">        Observer backgroundDeveloper = <span class="keyword">new</span> BackgroundDeveloper();</span><br><span class="line">        backgroundDeveloper.subscribeColumn(algorithmColumn);</span><br><span class="line"></span><br><span class="line">        Article article = <span class="keyword">new</span> Article(<span class="string">"01.数组文章"</span>);</span><br><span class="line">        Audio audio = <span class="keyword">new</span> Audio(<span class="string">"01.数组音频"</span>);</span><br><span class="line">        ((AlgorithmColumn) algorithmColumn).updateCourse(article, audio);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是观察者模式，它定义了对象之间的一对多依赖，如此当一个对象的状态改变时，它的所有依赖这都会收到通知并自动更新。</p><p>它的 UML 图如下：</p><p><img src="http://media.timberliu.com/image/2019/5/14/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" width="80%"></p><p>下面来总结一下观察者模式的优点：</p><ul><li>由于主题唯一依赖于实现 Observer 接口的对象，所以可以随时增加观察者。在新添加观察者时，实现观察者接口，然后向对应的主题注册即可。</li><li>由于主题和观察者是松耦合的，所以改变主题或观察者中的一方，并不会影响另一方。</li></ul><p>缺点：</p><ul><li>观察者之间依赖过多，增加了程序的复杂度。</li></ul><h1 id="Java-内置的观察者模式"><a href="#Java-内置的观察者模式" class="headerlink" title="Java 内置的观察者模式"></a>Java 内置的观察者模式</h1><p>Java 内置的观察者模式，与前面所说的类似。我们使用它对上面的例子进行改写。</p><p>主题需要扩展自 Observable 类，可以继承它的一些增加、通知观察者模式的方法等。我们先来看一下 Observable 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> Vector&lt;Observer&gt; obs;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obs = <span class="keyword">new</span> Vector&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">if</span> (!obs.contains(o)) &#123;</span><br><span class="line">            obs.addElement(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        Object[] arrLocal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!changed) <span class="comment">// 判断主题是否更新了</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            arrLocal = obs.toArray();</span><br><span class="line">            clearChanged(); <span class="comment">// 清除更新</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = arrLocal.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)</span><br><span class="line">            ((Observer)arrLocal[i]).update(<span class="keyword">this</span>, arg); <span class="comment">// 循环通知所有观察者</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里增加了一个 changed 变量，表示主题是否更新，在更新观察者时，可以有更多的弹性，更适当地通知观察者。</p><p>我们让 AlgorithmColumn 继承自 Observable 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmColumn</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Article, Audio&gt; course = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">courseUpdated</span><span class="params">(Article article, Audio audio)</span> </span>&#123;</span><br><span class="line">        course.put(article, audio);</span><br><span class="line">        setChanged(); <span class="comment">// 设置主题已更新</span></span><br><span class="line">        notifyObservers(<span class="keyword">new</span> Pair&lt;&gt;(article, audio)); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;Article, Audio&gt; <span class="title">getCourse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> course;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于观察者，则需要实现自 Observer 接口，该接口的定义比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebDeveloper 和 BackgroundDeveloper 两种定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebDeveloper</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Observable observable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WebDeveloper</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observable = observable;</span><br><span class="line">        observable.addObserver(<span class="keyword">this</span>); <span class="comment">// 向主题注册观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (observable <span class="keyword">instanceof</span> AlgorithmColumn) &#123;</span><br><span class="line">            Pair pair = (Pair) arg;</span><br><span class="line">            System.out.println(<span class="string">"WebDeveloper：更新了 "</span> + pair.getKey() + <span class="string">" + "</span> + pair.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackgroundDeveloper</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Observable observable;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BackgroundDeveloper</span><span class="params">(Observable observable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observable = observable;</span><br><span class="line">        observable.addObserver(<span class="keyword">this</span>); <span class="comment">// 向主题注册观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (observable <span class="keyword">instanceof</span> AlgorithmColumn) &#123;</span><br><span class="line">            Pair pair = (Pair) arg;</span><br><span class="line">            System.out.println(<span class="string">"BackgroundDeveloper：更新了 "</span> + pair.getKey() + <span class="string">" + "</span> + pair.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种内置的方式有一个很大的缺点，可观察者 Observale 是一个类而不是一个接口，如此就有些限制了它的复用性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First 设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章学习了责任链模式，它主要是定义了一对多的依赖，当主题的状态时，所有依赖于它的观察者都会受到通知，并更新状态。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>责任链模式就是如此简单</title>
    <link href="https://blog.timberliu.com/2019/05/16/051_%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/05/16/051_责任链模式就是如此简单/</id>
    <published>2019-05-15T16:00:00.000Z</published>
    <updated>2019-05-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们学习了模板方法模式，它在一个方法中定义了一个算法的骨架，其中包含多个步骤，可以将一个或多个步骤交由子类去提供实现。<a id="more"></a></p><p>这篇文章来学习一下责任链模式，同样地，我们从一个例子开始——技术面试。</p><h1 id="责任链"><a href="#责任链" class="headerlink" title="责任链"></a>责任链</h1><p>一般来说，普通的技术面试的时候会有三轮面试，分别为技术组长，技术主管和 HR 面，而且一般是通过技术组长面，才进行技术主管面；通过了技术主管面，才进行 HR 面。我们现在就来模拟设计一个这样的系统。</p><h2 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h2><p>面试者一般需要语言基础，算法，项目三个方面的知识，这个类可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Interviewee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 假设大于 5 为过关，否则不过关</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> basicKnowledge;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> project;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> character;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Interviewee</span><span class="params">(<span class="keyword">int</span> basicKnowledge, <span class="keyword">int</span> project, <span class="keyword">int</span> character)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.basicKnowledge = basicKnowledge;</span><br><span class="line">        <span class="keyword">this</span>.project = project;</span><br><span class="line">        <span class="keyword">this</span>.character = character;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// setter/getter   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于三轮技术面的面试官，我们可以抽象出一个面试管的接口，提供了对面试者的能力进行考察的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Interviewer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 考察相应的能力</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里假设三轮面试中，一面技术组长考察基础知识，而面技术主管考察项目经验，三面 HR 考察性格等能力，如此三个面试官可以如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderInterviewer</span> <span class="keyword">implements</span> <span class="title">Interviewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interviewee.getBasicKnowledge() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"基础能力为："</span> + interviewee.getBasicKnowledge() + <span class="string">"，过关，进入二面"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"基础能力为："</span> + interviewee.getBasicKnowledge() + <span class="string">"，不过关，不能进入二面"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupervisorInterviewer</span> <span class="keyword">implements</span> <span class="title">Interviewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interviewee.getProject() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"项目能力："</span> + interviewee.getProject() + <span class="string">"，过关，进入三面"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"能力能力："</span> + interviewee.getProject() + <span class="string">"，不过关，不能进入三面"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HRInterviewer</span> <span class="keyword">implements</span> <span class="title">Interviewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interviewee.getCharacter() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"性格："</span> + interviewee.getCharacter() + <span class="string">"，过关，拿到 offer"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"性格："</span> + interviewee.getCharacter() + <span class="string">"，不过关，没有通过面试"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在定义好面试者和面试官后，我们还需要定义一个技术面试类，一次面试中，需要传入技术组长、技术主管和 HR：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TechnicalInterview</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Interviewer leaderInterviewer;</span><br><span class="line">    <span class="keyword">private</span> Interviewer supervisorInterviewer;</span><br><span class="line">    <span class="keyword">private</span> Interviewer hrInterviewer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TechnicalInterview</span><span class="params">(Interviewer leaderInterview, Interviewer supervisorInterview, Interviewer hrInterview)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.leaderInterviewer = leaderInterview;</span><br><span class="line">        <span class="keyword">this</span>.supervisorInterviewer = supervisorInterview;</span><br><span class="line">        <span class="keyword">this</span>.hrInterviewer = hrInterview;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (leaderInterviewer.inspect(interviewee)) &#123;</span><br><span class="line">            <span class="comment">// 通过技术组长，才进入二面</span></span><br><span class="line">            <span class="keyword">if</span> (supervisorInterviewer.inspect(interviewee)) &#123;</span><br><span class="line">                <span class="comment">// 通过技术主管，才进入三面</span></span><br><span class="line">                <span class="keyword">if</span> (hrInterviewer.inspect(interviewee)) &#123;</span><br><span class="line">                    <span class="comment">// 通过 HR，拿到 offer</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们写段代码来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Interviewer leaderInterview = <span class="keyword">new</span> LeaderInterviewer();</span><br><span class="line">        Interviewer supervisorInterview = <span class="keyword">new</span> SupervisorInterviewer();</span><br><span class="line">        Interviewer hrInterview = <span class="keyword">new</span> HRInterviewer();</span><br><span class="line">        TechnicalInterview technicalInterview = <span class="keyword">new</span> TechnicalInterview(leaderInterview, supervisorInterview, hrInterview);</span><br><span class="line"></span><br><span class="line">        Interviewee interviewee1 = <span class="keyword">new</span> Interviewee(<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        technicalInterview.inspect(interviewee1);</span><br><span class="line"></span><br><span class="line">        Interviewee interviewee2 = <span class="keyword">new</span> Interviewee(<span class="number">8</span>, <span class="number">4</span>, <span class="number">7</span>);</span><br><span class="line">        technicalInterview.inspect(interviewee2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有两个面试者，它们的测试结果如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">基础能力为：<span class="number">8</span>，过关，进入二面</span><br><span class="line">项目能力：<span class="number">6</span>，过关，进入三面</span><br><span class="line">性格：<span class="number">7</span>，过关，拿到 offer</span><br><span class="line"></span><br><span class="line">基础能力为：<span class="number">8</span>，过关，进入二面</span><br><span class="line">能力能力：<span class="number">4</span>，不过关，不能进入三面</span><br></pre></td></tr></table></figure><p>可以看到，这里对于一次技术面试，需要单独创建一个技术面试类，并且在 inspect 方法中，由于有多轮面试，所以需要写很多的 if 语句。</p><p>如果我们想增加一次或多次面试，就需要修改该类的实例变量，及其方法的实现，这明显不符合开闭原则。</p><p>而且如果我们想修改面试的顺序，例如一面技术主管考察基础，二面技术组长考察基础，这也需要修改 inspect 方法。可见我们刚才的设计并不是很好。</p><h2 id="改进后"><a href="#改进后" class="headerlink" title="改进后"></a>改进后</h2><p>其实，我们可以将面试官的接口改为抽象类，其中存放了下一个面试官的实例变量。其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Interviewer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Interviewer nextInterviewer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextInterviewer</span><span class="params">(Interviewer nextInterviewer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextInterviewer = nextInterviewer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们修改之前说的三个面试官。在 inspect 方法中，当前面试官考察通过后，就判断是否有下一个面试官，如果有，则调用下一个面试官的 inspect 方法继续考察：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeaderInterviewer</span> <span class="keyword">extends</span> <span class="title">Interviewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interviewee.getCharacter() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"基础能力为："</span> + interviewee.getBasicKnowledge());</span><br><span class="line">            <span class="keyword">if</span> (nextInterviewer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"，过关，进入下一面"</span>);</span><br><span class="line">                nextInterviewer.inspect(interviewee);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"，拿到 offer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"基础能力为："</span> + interviewee.getBasicKnowledge() + <span class="string">"，不过关，不能进入下一面"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SupervisorInterviewer</span> <span class="keyword">extends</span> <span class="title">Interviewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interviewee.getCharacter() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"项目能力为："</span> + interviewee.getProject());</span><br><span class="line">            <span class="keyword">if</span> (nextInterviewer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"，过关，进入下一面"</span>);</span><br><span class="line">                nextInterviewer.inspect(interviewee);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"，拿到 offer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"项目能力为："</span> + interviewee.getProject() + <span class="string">"，不过关，不能进入下一面"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HRInterviewer</span> <span class="keyword">extends</span> <span class="title">Interviewer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">inspect</span><span class="params">(Interviewee interviewee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (interviewee.getCharacter() &gt; <span class="number">5</span>) &#123;</span><br><span class="line">            System.out.print(<span class="string">"性格能力为："</span> + interviewee.getCharacter());</span><br><span class="line">            <span class="keyword">if</span> (nextInterviewer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"，过关，进入下一面"</span>);</span><br><span class="line">                nextInterviewer.inspect(interviewee);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"，拿到 offer"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"性格能力为："</span> + interviewee.getCharacter() + <span class="string">"，不过关，不能进入下一面"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们写段代码来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Interviewer leaderInterviewer = <span class="keyword">new</span> LeaderInterviewer();</span><br><span class="line">        Interviewer supervisorInterviewer = <span class="keyword">new</span> SupervisorInterviewer();</span><br><span class="line">        Interviewer hrInterviewer = <span class="keyword">new</span> HRInterviewer();</span><br><span class="line">        leaderInterviewer.setNextInterviewer(supervisorInterviewer);</span><br><span class="line">        supervisorInterviewer.setNextInterviewer(hrInterviewer);</span><br><span class="line"></span><br><span class="line">        Interviewee interviewee = <span class="keyword">new</span> Interviewee(<span class="number">8</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">        leaderInterviewer.inspect(interviewee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面这种方式，如果我们想增加一个面试官，只需要新建一个继承自 Interviewer 的面试官类，将其设置为之前面试链的下一个面试官即可。另外，对于多个面试官考察的顺序，也可以交由我们自己决定。</p><p>这就是责任链模式，它允许我们为某个请求创建一个对象链。每个对象依次检查该请求，并且对其进行处理，或者将其传给链中的下一个对象。</p><p>它的 UML 类图如下：</p><p><img src="http://media.timberliu.com/image/2019/5/15/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F.jpg" width="80%"></p><p>下面来总结一下责任链模式的优点：</p><ul><li>对请求的发送者和接收者进行解耦；</li><li>责任链可以动态地进行调整。例如调动链内成员的次序，增加或删除责任；</li></ul><p>缺点：</p><ul><li>责任链有可能过长，增加了程序的复杂度。</li></ul><h1 id="责任链模式的具体实践"><a href="#责任链模式的具体实践" class="headerlink" title="责任链模式的具体实践"></a>责任链模式的具体实践</h1><h2 id="Filter-和-FilterChain"><a href="#Filter-和-FilterChain" class="headerlink" title="Filter 和 FilterChain"></a>Filter 和 FilterChain</h2><p>Java 中定义了 Filter 接口和 FilterChain 接口，两者配合可以实现过滤器链。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">            FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilterChain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, ServletException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，在 SpringSecurity 中就使用核心过滤器链，其中配置了很多过滤器，用来对 HTTP 请求进行授权认证。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们学习了模板方法模式，它在一个方法中定义了一个算法的骨架，其中包含多个步骤，可以将一个或多个步骤交由子类去提供实现。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>我学会了策略模式</title>
    <link href="https://blog.timberliu.com/2019/05/15/049_%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BD%A0%E4%BC%9A%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B9%88/"/>
    <id>https://blog.timberliu.com/2019/05/15/049_策略模式你会使用了么/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面几篇文章我们学习了适配器模式、门面模式、装饰者模式，它们都是结构型模式，主要是为了解决如何组合类或对象，也就是它们之间的结构的问题。<a id="more"></a></p><p>从这篇文章开始，我们来学习行为型模式，它描述的主要是类或对象之间怎样交互，及如何分配职责的问题。今天是第一篇文章——策略模式，同样地从一个例子开始。</p><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><p>现在很多电商都会有促销活动，并且会有不同的促销策略。那我们该如何设计这个系统呢？</p><h2 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h2><p>我们先来定义促销活动的抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"促销活动"</span>);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">giveGift</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reducePrice</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有一个满赠满减促销活动。我们可以继承 PromotionActivity 抽象类，覆盖其 promotion 方法，实现具体的促销策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyoffPromotionActivity</span>  <span class="keyword">extends</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"满赠满减促销活动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赠送 xxx 礼物"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reducePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"减 xxx 元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此在结算时，对于这个促销活动，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PromotionActivity activity = <span class="keyword">new</span> MoneyoffPromotionActivity();</span><br><span class="line">        activity.getPromotionDetail();</span><br><span class="line">        activity.giveGift();</span><br><span class="line">        activity.reducePrice();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果现在还有打折活动，或者只赠送礼物的活动，我们可以如下这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftPromotionActivity</span> <span class="keyword">extends</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赠送礼物促销活动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赠送 xxx 礼物"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reducePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 覆盖，但什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalePromotionActivity</span> <span class="keyword">extends</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"限时打折促销活动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">giveGift</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 覆盖，但什么也不做</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reducePrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打 xxx 折"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们很难确定促销活动具体会有哪些促销策略，并且如果有新的策略，例如返现，那就会使得其他促销活动也要进行修改。所以这样的设计并不是很好，我们该如何进行改进呢?</p><h2 id="改进了"><a href="#改进了" class="headerlink" title="改进了"></a>改进了</h2><p>我们可以对促销策略单独实现，先定义一个促销策略接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后实现不同的促销策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GiftPromotionStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赠送 xxx 礼物"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赠送礼物促销活动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SalePromotionStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打 xxx 折"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"限时打折促销活动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoneyOffPromotionStrategy</span> <span class="keyword">implements</span> <span class="title">PromotionStrategy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"赠送 xxx 礼物，减 xxx 元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"满赠满减促销活动"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，促销活动可以这样定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PromotionStrategy promotionStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PromotionActivity</span><span class="params">(PromotionStrategy promotionStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.promotionStrategy = promotionStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPromotion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        promotionStrategy.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getPromotionDetail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        promotionStrategy.getPromotionDetail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此在结算时，例如限时打折促销活动，我们可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PromotionStrategy promotionStrategy = <span class="keyword">new</span> SalePromotionStrategy();</span><br><span class="line">        PromotionActivity activity = <span class="keyword">new</span> PromotionActivity(promotionStrategy);</span><br><span class="line">        </span><br><span class="line">        activity.doPromotion();</span><br><span class="line">        activity.getPromotionDetail();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是策略模式，它定义了一系列的策略，然后将每个策略封装起来，并且让他们之间可以相互转换。另外该模式，让策略的变化不会影响到使用策略的客户。</p><p>另外，策略模式仅仅是封装策略，并且它不会决定在何时使用何种算法。在什么时候使用什么算法是由客户端所决定的。</p><p>它的 UML 图如下：</p><p><img src="http://media.timberliu.com/image/2019/5/13/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpg" width="80%"></p><p>下面来总结一下策略模式的优点：</p><ul><li>该模式将策略与使用策略的客户分离开来，使策略之间可以互相转换；</li><li>符合开闭原则，在添加新的策略时，增加一个策略类即可。</li></ul><p>缺点：</p><ul><li>客户端必须自行决定使用哪一个策略类；</li><li>策略类可能会比较多，增加系统复杂性。</li></ul><h1 id="策略模式与其他模式的结合"><a href="#策略模式与其他模式的结合" class="headerlink" title="策略模式与其他模式的结合"></a>策略模式与其他模式的结合</h1><p>可以将策略模式与单例模式进行结合，例如改进上面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PromotionStrategyFactory</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, PromotionStrategy&gt; strategyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        strategyMap.put(PromotionKey.Gift.getPromotionKey(), <span class="keyword">new</span> GiftPromotionStrategy());</span><br><span class="line">        strategyMap.put(PromotionKey.Sale.getPromotionKey(), <span class="keyword">new</span> SalePromotionStrategy());</span><br><span class="line">        strategyMap.put(PromotionKey.MoneyOff.getPromotionKey(), <span class="keyword">new</span> MoneyOffPromotionStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PromotionStrategyFactory</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PromotionStrategy <span class="title">getPromotionStrategy</span><span class="params">(String strategyKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategyMap.getOrDefault(strategyKey, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> PromotionKey &#123;</span><br><span class="line">    Gift(<span class="string">"gift"</span>),</span><br><span class="line">    Sale(<span class="string">"sale"</span>),</span><br><span class="line">    MoneyOff(<span class="string">"moneyOff"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String promotionKey;</span><br><span class="line">    </span><br><span class="line">    PromotionKey(String promotionKey) &#123;</span><br><span class="line">        <span class="keyword">this</span>.promotionKey = promotionKey;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPromotionKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> promotionKey;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cashier</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PromotionStrategy promotionStrategy = PromotionStrategyFactory.getPromotionStrategy(PromotionKey.MoneyOff.getPromotionKey());</span><br><span class="line">        PromotionActivity promotionActivity = <span class="keyword">new</span> PromotionActivity(promotionStrategy);</span><br><span class="line">        </span><br><span class="line">        promotionActivity.getPromotionDetail();</span><br><span class="line">        promotionActivity.doPromotion();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="策略模式的具体实践"><a href="#策略模式的具体实践" class="headerlink" title="策略模式的具体实践"></a>策略模式的具体实践</h1><h2 id="JDK-ThreadPoolExecutor"><a href="#JDK-ThreadPoolExecutor" class="headerlink" title="JDK#ThreadPoolExecutor"></a>JDK#ThreadPoolExecutor</h2><p>在 ThreadPoolExecutor 中，如果线程池中的线程数达到了 maximumPoolSize，则会使用拒绝策略处理之后的请求。</p><p>如下图，主要有四种拒绝策略：</p><p><img src="http://media.timberliu.com/image/2019/5/13/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94ThreadPoolExecutor%23%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5.jpg" width="80%"></p><ul><li>AbortPolicy：直接抛出异常。</li><li>CallerRunsPolicy：调用请求所在线程来运行任务- DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面几篇文章我们学习了适配器模式、门面模式、装饰者模式，它们都是结构型模式，主要是为了解决如何组合类或对象，也就是它们之间的结构的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>模板方法模式，你会使用了么</title>
    <link href="https://blog.timberliu.com/2019/05/15/050_%E6%88%91%E5%AD%A6%E4%BC%9A%E4%BA%86%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.timberliu.com/2019/05/15/050_我学会了模板方法模式/</id>
    <published>2019-05-14T16:00:00.000Z</published>
    <updated>2019-05-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们学习了策略模式，它主要是定义一系列的策略，然后将每个策略封装起来，并且让他们之间可以相互转换。<a id="more"></a></p><p>这篇文章我们来学习模板方法模式，同样的，从一个例子开始。</p><h1 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h1><p>相信很多人都喜欢喝星巴克，它的制作过程大概可分为：把水煮沸、用沸水冲泡咖啡、把咖啡倒进杯子、最后加糖和牛奶。</p><p><strong>改进前</strong></p><p>用代码可以如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brewCoffee();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addSugarAndMilk();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">brewCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水冲泡咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSugarAndMilk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加糖和牛奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而有些人喜欢喝茶，它的制作过程与和咖啡也有类似之处，制作过程可分为：把水煮沸、用沸水浸泡茶叶、把茶倒进杯子、加柠檬。</p><p>它的代码可以这样实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createTea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brewTea();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addLemon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">brewTea</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水浸泡茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLemon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加柠檬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，boilWater 和 pourInCup 方法是重复的，既然它们如此相似，我们可以将共同的部分提取出来，放进一个基类中。</p><p><strong>改进后</strong></p><p>对于咖啡和茶，我们可以定义一个饮品的抽象类，将冲泡过程抽象为 brewBeverage 方法，将添加调料过程抽象为 addCondiment 方法，具体交给子类去实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brewBeverage();</span><br><span class="line">        pourInCup();</span><br><span class="line">        addCondiment();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brewBeverage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Coffee 和 Tea 两个类可以修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractBeverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brewBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水冲泡咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加糖和牛奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tea</span> <span class="keyword">extends</span> <span class="title">AbstractBeverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brewBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水浸泡茶叶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加柠檬"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们写段代码来测试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Customer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractBeverage beverage = <span class="keyword">new</span> Coffee();</span><br><span class="line">        beverage.createCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的实现就是模板方法模式，它在一个方法中定义了一个算法的骨架，其中包含多个步骤，可以将一个或多个步骤交由子类去提供实现。</p><p>例如，上述 AbstractBeverage 类中的 createBeverage 就是一个模板方法，定义了制作饮品的四个步骤，其中有两个步骤定义为抽象方法，需要由 Coffee 和 Tea 子类进行实现。</p><p>下面来总结一下模板方法模式的优点：</p><ul><li>模板方法模式定义了算法的骨架，可以更大程度地提高代码的复用性；</li><li>算法只存在于抽象类中，修改其步骤只需要继承抽象类，并重写其步骤即可，提高了代码的扩展性。</li></ul><p>缺点：</p><ul><li>由于是继承关系，所以如果父类添加了抽象方法，那么所有的子类都需要去实现；</li></ul><h1 id="模板方法模式结合钩子使用"><a href="#模板方法模式结合钩子使用" class="headerlink" title="模板方法模式结合钩子使用"></a>模板方法模式结合钩子使用</h1><p>对于上面的例子，可能有些顾客不想要加调料，我们可以对算法步骤进行判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeverageWithHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        boilWater();</span><br><span class="line">        brewBeverage();</span><br><span class="line">        pourInCup();</span><br><span class="line">        <span class="keyword">if</span> (customerWantsCondiment()) &#123;</span><br><span class="line">            addCondiment();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">brewBeverage</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供默认实现</span></span><br><span class="line">    <span class="comment">// 这就是一个钩子，子类可以覆盖实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">boilWater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"把水煮沸"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pourInCup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"倒进杯子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们就可得知顾客是否想要调料：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> <span class="keyword">extends</span> <span class="title">AbstractBeverageWithHook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">brewBeverage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用沸水冲泡咖啡"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">addCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"加糖和牛奶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 覆盖这个钩子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">customerWantsCondiment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getUserInput().toLowerCase().startsWith(<span class="string">"y"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断用户是否想要加糖或牛奶</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getUserInput</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模板方法模式的具体实践"><a href="#模板方法模式的具体实践" class="headerlink" title="模板方法模式的具体实践"></a>模板方法模式的具体实践</h1><h2 id="JDK-AbstractQueuedSynchronizer"><a href="#JDK-AbstractQueuedSynchronizer" class="headerlink" title="JDK#AbstractQueuedSynchronizer"></a>JDK#AbstractQueuedSynchronizer</h2><p>在 Lock 接口的框架中，使用 AbstractQueuedSynchronizer 对同步状态进行管理，它是构建锁或其他同步组件的基础。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractOwnableSynchronizer</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中 acquire 方法就是一个模板方法，其中包含了 tryAcquire、acquireQueued 等步骤。其中 tryAcquire 步骤就延迟到子类中实现。</p><p>例如在 ReentrantLock 类的内部类 NonfairSync，也就是非公平锁的实现，它的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 NonfairSync 中覆盖了 tryAcquire 方法，其中又调用了 Sync 的默认获取非公平锁实现。</p><h1 id="ThreadPoolExecutor-runWorker"><a href="#ThreadPoolExecutor-runWorker" class="headerlink" title="ThreadPoolExecutor#runWorker"></a>ThreadPoolExecutor#runWorker</h1><p>在 ThreadPoolExecutor 类中，runWorker 方法就是一个模板方法，它主要是会循环从队列获取任务，并进行执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            w.lock();</span><br><span class="line">            ···</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                beforeExecute(wt, task); <span class="comment">// 1</span></span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    ···</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterExecute(task, thrown); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在执行 task.run 时，前后会执行 beforeExecute 和 afterExecute 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果子类想要在任务执行前后，做一些其他的初始化或释放资源的操作。我们可以继承 ThreadPoolExecutor，并重写其 beforeExecute 和 afterExecute 方法。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First 设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们学习了策略模式，它主要是定义一系列的策略，然后将每个策略封装起来，并且让他们之间可以相互转换。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>装饰者模式好像也不难</title>
    <link href="https://blog.timberliu.com/2019/05/14/048_%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%A5%BD%E5%83%8F%E4%B9%9F%E4%B8%8D%E9%9A%BE/"/>
    <id>https://blog.timberliu.com/2019/05/14/048_装饰者模式好像也不难/</id>
    <published>2019-05-13T16:00:00.000Z</published>
    <updated>2019-05-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了适配器模式和门面模式，它们看起来很类似，但它们的目的不同，适配器模式是将一个不兼容的接口转换为另一个接口，以符合用户的期望；而门面模式是提供一个统一的接口，来访问子系统的多个接口，更简单地使用子系统。<a id="more"></a></p><p>这篇文章来学习一下装饰者模式，同样地，从一个例子开始。</p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><p>相信很多小伙伴早上都喜欢吃一个煎饼，它可以如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"煎饼"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但觉得吃不够，有时会加个鸡蛋，可以如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PancakeWithEgg</span> <span class="keyword">extends</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">"加鸡蛋"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有时可能想土豪一会，就再加个香肠，可以如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PancakeWithEggSausage</span> <span class="keyword">extends</span> <span class="title">PancakeWithEgg</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc() + <span class="string">"加香肠"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们买三种煎饼的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pancake pancake = <span class="keyword">new</span> Pancake();</span><br><span class="line">        System.out.println(pancake.getDesc() + <span class="string">":"</span> + pancake.cost());</span><br><span class="line"></span><br><span class="line">        PancakeWithEgg pancakeWithEgg = <span class="keyword">new</span> PancakeWithEgg();</span><br><span class="line">        System.out.println(pancakeWithEgg.getDesc() + <span class="string">":"</span> + pancakeWithEgg.cost());</span><br><span class="line"></span><br><span class="line">        PancakeWithEggSausage pancakeWithEggSausage = <span class="keyword">new</span> PancakeWithEggSausage();</span><br><span class="line">        System.out.println(pancakeWithEggSausage.getDesc() + <span class="string">":"</span> + pancakeWithEggSausage.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是如果有人想加两个鸡蛋，有人可能还想要不同口味的煎饼，上面的定义就不能满足要求了。</p><p>其实，我们可以使用装饰者模式来解决这个问题，我们需要先定义抽象的煎饼类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPancake</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getDesc</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候，煎饼类继承于上面的抽象煎饼类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pancake</span> <span class="keyword">extends</span> <span class="title">AbstractPancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"煎饼"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们可以创建一个抽象的装饰者，使其继承自抽象的煎饼类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractDecorator</span> <span class="keyword">extends</span> <span class="title">Pancake</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDesc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>煎饼添加鸡蛋的装饰者类，继承自抽象的装饰者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EggDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractPancake pancake;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EggDecorator</span><span class="params">(AbstractPancake pancake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pancake = pancake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pancake.getDesc() + <span class="string">"加一个鸡蛋"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pancake.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>煎饼添加香肠的装饰者类，也继承自抽象的装饰者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SausageDecorator</span> <span class="keyword">extends</span> <span class="title">AbstractDecorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractPancake pancake;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SausageDecorator</span><span class="params">(AbstractPancake pancake)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pancake = pancake;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pancake.getDesc() + <span class="string">"加一根香肠"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pancake.cost() + <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此我们就可以随意地加鸡蛋，或者香肠。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractPancake pancake = <span class="keyword">new</span> Pancake();</span><br><span class="line">        pancake = <span class="keyword">new</span> EggDecorator(pancake);</span><br><span class="line">        pancake = <span class="keyword">new</span> EggDecorator(pancake);</span><br><span class="line">        pancake = <span class="keyword">new</span> SausageDecorator(pancake);</span><br><span class="line"></span><br><span class="line">        System.out.println(pancake.getDesc() + <span class="string">":"</span> + pancake.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是装饰者模式，它主要用于动态地将责任添加到对象上，相比于继承，它提供了更有弹性的替代方案。</p><p>它的 UML 图如下：</p><p><img src="http://media.timberliu.com/image/2019/5/13/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F.png" width="80%"></p><p>可以看到，它主要有以下几个特点：</p><ul><li>装饰者和被装饰者拥有相同的超类型；</li><li>可以用多个装饰者来包装一个对象；</li><li>装饰者可以在被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的；</li><li>每个装饰者都有一个组件，也就是说，装饰者有一个实例变量以保存某个组件的引用。</li></ul><p>下面来总结一下装饰者模式的优点：</p><ul><li>它可以在不改变原有对象的情况下，扩展对象的功能。比继承提供了更有弹性的替代方案；</li><li>通过不同的装饰者类，及不同的排列组合，实现不同的效果。</li></ul><p>缺点：</p><ul><li>装饰者模式下会出现更多的类，增加了程序的复杂性。</li></ul><h1 id="装饰者模式的具体实践"><a href="#装饰者模式的具体实践" class="headerlink" title="装饰者模式的具体实践"></a>装饰者模式的具体实践</h1><p>最典型的集合便是 Java IO 相关的类，我们来看一下其结构：</p><p><img src="http://media.timberliu.com/image/2019/5/13/IO%23InputStream.png" width="80%"></p><p>InputStream 抽象类定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ObjectInputStream 类的定义如下，它主要用于反序列化之前由 ObjectOutputStream 写的基本数据和对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectInputStream</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">ObjectInput</span>, <span class="title">ObjectStreamConstants</span></span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">final</span> <span class="title">BlockDataInputStream</span> <span class="title">bin</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bin.read();</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FilterInputStream 是一个装饰者类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read();</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BufferedInputStream 则是一个继承自 FilterInputStream 的具体的装饰者，可以缓存输入，并支持 mark、reset 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> <span class="keyword">byte</span> buf[];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        ···</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ···</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>其实，我们可以看到，使用了装饰者模式，使得设计中有大量的类，造成了程序的复杂性。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First 设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面学习了适配器模式和门面模式，它们看起来很类似，但它们的目的不同，适配器模式是将一个不兼容的接口转换为另一个接口，以符合用户的期望；而门面模式是提供一个统一的接口，来访问子系统的多个接口，更简单地使用子系统。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>门面模式就是这么简单</title>
    <link href="https://blog.timberliu.com/2019/05/13/047_%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/05/13/047_门面模式就是这么简单/</id>
    <published>2019-05-12T16:00:00.000Z</published>
    <updated>2019-05-12T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上篇文章我们学习了适配器模式，我们知道它是将一个接口转换成另一个符合用户期望的接口，它的主要目的是为了兼容，将一个不兼容接口的对象包装起来，变成兼容的对象。<a id="more"></a></p><p>这篇文章我们来学习一下门面模式，它又称为外观模式，与适配器模式看起来很类似，但它主要是为了简化接口，下面就来具体看一下。</p><h1 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h1><p>不知道大家平时是否有这样的经历。每天开启电脑后，要打开各种软件、IDE、工具，就需要一个一个地点击桌面图标；到了晚上又要一个个地关闭，感觉非常麻烦。</p><p>这里举几个例子，首先是 Intellj IDEA：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IDEA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开 IDEA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭 IDEA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是 Google：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Google</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Tab&gt; tabs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开 google"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭 google"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTabs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开 ProcessOn、七牛云等 Tab"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有有道云笔记：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YouDaoNote</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开 YouDaoNote"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭 YouDaoNote"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可能还会有 Weixin：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeiXin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开 WeiXin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">off</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭 WeiXin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，可能还会有 Shell、CloudMusic 等。我们开启软件时，可以如下写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IDEA idea = <span class="keyword">new</span> IDEA();</span><br><span class="line">        Google google = <span class="keyword">new</span> Google();</span><br><span class="line">        YouDaoNote youDaoNote = <span class="keyword">new</span> YouDaoNote();</span><br><span class="line">        WeiXin weiXin = <span class="keyword">new</span> WeiXin();</span><br><span class="line"></span><br><span class="line">        idea.on();</span><br><span class="line">        google.on();</span><br><span class="line">        google.onTabs();</span><br><span class="line">        youDaoNote.on();</span><br><span class="line">        weiXin.on();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在关闭时，又将这些步骤反过来执行一遍，那也太麻烦了。其实，我们可以写一个 bat 脚本，每次只需要执行这个脚本，就可以开启多个软件。</p><p>这个脚本就是所谓的门面，现在我们来创建一个门面，它将不同的软件组合成一个统一的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DevelopmentEnvironment</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IDEA idea;</span><br><span class="line">    <span class="keyword">private</span> Google google;</span><br><span class="line">    <span class="keyword">private</span> YouDaoNote youDaoNote;</span><br><span class="line">    <span class="keyword">private</span> WeiXin weiXin;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DevelopmentEnvironment</span><span class="params">(IDEA idea, Google google, YouDaoNote youDaoNote, WeiXin weiXin)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.idea = idea;</span><br><span class="line">        <span class="keyword">this</span>.google = google;</span><br><span class="line">        <span class="keyword">this</span>.youDaoNote = youDaoNote;</span><br><span class="line">        <span class="keyword">this</span>.weiXin = weiXin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idea.on();</span><br><span class="line">        google.on();</span><br><span class="line">        google.onTabs();</span><br><span class="line">        youDaoNote.on();</span><br><span class="line">        weiXin.on();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutEnvironment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        idea.off();</span><br><span class="line">        google.off();</span><br><span class="line">        youDaoNote.off();</span><br><span class="line">        weiXin.off();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它对外只暴露了几个方法，于是我们建立开发环境可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IDEA idea = <span class="keyword">new</span> IDEA();</span><br><span class="line">        Google google = <span class="keyword">new</span> Google();</span><br><span class="line">        YouDaoNote youDaoNote = <span class="keyword">new</span> YouDaoNote();</span><br><span class="line">        WeiXin weiXin = <span class="keyword">new</span> WeiXin();</span><br><span class="line"></span><br><span class="line">        DevelopmentEnvironment environment = <span class="keyword">new</span> DevelopmentEnvironment(idea, google, youDaoNote, weiXin);</span><br><span class="line">        environment.buildEnvironment();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是门面模式，它提供了一个统一的接口，来访问子系统的多个接口，使得子系统更容易使用。</p><p>它的 UML 图如下：</p><p><img src="http://media.timberliu.com/image/2019/5/13/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.jpg" width="80%"></p><p>下面来总结一下门面模式的优点：</p><ul><li>通过统一的接口，来访问子系统的多个接口。如此就无需了解子系统的实现，简化了调用的过程。</li><li>减少了客户和子系统之间的系统依赖，耦合度更低。</li><li>门面模式很好得符合了最少知道原则。</li></ul><p>缺点：</p><ul><li>如果增加子系统，或者扩展子系统的行为，可能会引入风险；</li><li>系统设计不当时，增加子系统可能需要修改门面类，这违背了开闭原则。</li></ul><h1 id="最少知道原则"><a href="#最少知道原则" class="headerlink" title="最少知道原则"></a>最少知道原则</h1><p>其实门面模式很好地符合了最少知道原则，它指的是尽量减少对象之间的交互。在设计中，我们应该减少类之间的耦合度，以免修改系统中一部分，而影响到其他部分。</p><p>为满足该原则，我们应该只调用属于以下范围的方法：</p><ol><li>该对象本身；</li><li>被当作方法的参数而传递进来的对象；</li><li>此方法所创建或实例化的任何对象；</li><li>对象的任何组件；</li></ol><p>例如下面的例子就符合最少知识原则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">    Engine engine; <span class="comment">// 对象的组件</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// key 为作为方法参数传递进来的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Key key)</span> </span>&#123;</span><br><span class="line">        Door door = <span class="keyword">new</span> Door(); <span class="comment">// 该方法中创建的对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">boolean</span> authorized = key.turn(); <span class="comment">// 调用作为方法参数传递进来的对象的方法，2</span></span><br><span class="line">        <span class="keyword">if</span>(authorized) &#123;</span><br><span class="line">            engine.start(); <span class="comment">// 调用组件的方法 // 4</span></span><br><span class="line">            updateDashboardDisplay(); <span class="comment">// 调用对象本身的方法 // 1</span></span><br><span class="line">            door.lock(); <span class="comment">// 调用该方法中创建的对象的方法 // 2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对象本身的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateDasnboardDisplay</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="门面模式的具体实践"><a href="#门面模式的具体实践" class="headerlink" title="门面模式的具体实践"></a>门面模式的具体实践</h1><p>在实际项目中，我们都会记录应用的执行日志，常用的日志框架有许多，而不同的中间件会集成不同的日志框架，当集成这些中间件时，我们的系统不得不维护去多种日志框架。</p><p>于是，我们可以引入一个中间层，由这个中间层来决定使用哪一个具体的日志实现。这个中间层就是日志门面，我们在打印日志时，只需要调用日志门面的 API，而不需要关心日志具体的实现。</p><p>日志门面和日志实现主要有：</p><ul><li>日志门面（日志的抽象层）：slf4j、jcl（commons-logging）；</li><li>日志实现：jul（java.util.logging）、logback、log4j、log4j2；</li></ul><p>具体它们的原理，这里就不说了。</p><p>在实际使用时，例如 SpringBoot 中默认使用 Slfj + Logback 组合来打印日志。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First 设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇文章我们学习了适配器模式，我们知道它是将一个接口转换成另一个符合用户期望的接口，它的主要目的是为了兼容，将一个不兼容接口的对象包装起来，变成兼容的对象。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>适配器模式：我真的不难</title>
    <link href="https://blog.timberliu.com/2019/05/12/046_%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%EF%BC%9A%E6%88%91%E7%9C%9F%E7%9A%84%E4%B8%8D%E9%9A%BE/"/>
    <id>https://blog.timberliu.com/2019/05/12/046_适配器模式：我真的不难/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面三篇文章分别学习了单例模式、三种工厂模式和建造者模式，它们都是比较常用的创建型模式，顾名思义就是创建对象的。从这篇文章开始来学习结构型设计模式，今天是第一篇——适配器模式。<a id="more"></a></p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>首先拿我使用的小米手机为例，它撤销了原来的 Audio 接口，要使用耳机听歌呢，就必须使用 Type-C to Audio 转接线（如下图），一头接上手机，一头接上耳机线。（ps：话说，每次听歌和充电都要换来换去的，好麻烦）</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aaf4b9643c6e23?w=815&h=524&f=png&s=88042" width="60%"></p><p>其实，这就是一个实际的适配器，和设计模式中的适配器扮演着同样的角色，将一个接口转换为另一个接口，以符合用户的期望。</p><h2 id="改进前"><a href="#改进前" class="headerlink" title="改进前"></a>改进前</h2><p>下面我们就将这个例子转换为代码，看它是如何实现的。以前的手机呢，有两个接口，使用 TypeC 接口充电：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TypeCInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 充电</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chargeWithTypeC</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeCInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">TypeCInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">chargeWithTypeC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用 Type-C 接口充电"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Audio 接口听歌：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AudioInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 听歌</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listenWithAudio</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AudioInterfaceImpl</span> <span class="keyword">implements</span> <span class="title">AudioInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWithAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用 Audio 接口听歌"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们的手机，同时有这两个接口，用来充电和听歌：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AudioInterface audioInterface;</span><br><span class="line">    <span class="keyword">private</span> TypeCInterface typeCInterface;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaomiPhone</span><span class="params">(AudioInterface audioInterface, TypeCInterface typeCInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.audioInterface = audioInterface;</span><br><span class="line">        <span class="keyword">this</span>.typeCInterface = typeCInterface;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        typeCInterface.chargeWithTypeC();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioInterface.listenWithAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们就可以用手机来边充电，边听歌了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AudioInterface audioInterface = <span class="keyword">new</span> AudioInterfaceImpl();</span><br><span class="line">        TypeCInterface typeCInterface = <span class="keyword">new</span> TypeCInterfaceImpl();</span><br><span class="line">        </span><br><span class="line">        XiaomiPhone xiaomiPhone = <span class="keyword">new</span> XiaomiPhone(audioInterface, typeCInterface);</span><br><span class="line">        xiaomiPhone.charge();</span><br><span class="line">        xiaomiPhone.listen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进了"><a href="#改进了" class="headerlink" title="改进了"></a>改进了</h2><p>本来这一切都好好的，可是小米手机把 Audio 接口取消了，我们没法直接使用来听歌了。于是，我们只好使用转接线，将 Type-C 接口转为 Audio 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需将其转换为 Audio 接口，所以实现了 AudioInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeCToAudioTieline</span> <span class="keyword">implements</span> <span class="title">AudioInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TypeCInterface typeCInterface;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 另一头是 TypeC，所以传入 TypeCInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TypeCToAudioTieline</span><span class="params">(TypeCInterface typeCInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.typeCInterface = typeCInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWithAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">        typeCInterface.chargeWithTypeC();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后呢，把转接线插入到手机上（把手机和转接线看作一个整体，它只有 Audio 接口了）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XiaomiPhone</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AudioInterface audioInterface;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XiaomiPhone</span><span class="params">(AudioInterface audioInterface)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.audioInterface = audioInterface;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenWithAudio</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        audioInterface.listenWithAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是，现在我们就通过转接线，将 Type-C 接口转换成了 Audio 接口。然后将耳机插在转接线上，就可以听歌了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TypeCInterface typeCInterface = <span class="keyword">new</span> TypeCInterfaceImpl();</span><br><span class="line">        TypeCToAudioTieline tieline = <span class="keyword">new</span> TypeCToAudioTieline(typeCInterface);</span><br><span class="line"></span><br><span class="line">        XiaomiPhone xiaomiPhone = <span class="keyword">new</span> XiaomiPhone(tieline);</span><br><span class="line">        xiaomiPhone.listenWithAudio();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是适配器模式，它将一个类的接口转换成用户所需要的另一个接口，使得原本接口不兼容的类可以一起工作。</p><p>它的 UML 图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/13/16aaf4b964373534?w=845&h=386&f=png&s=19913" width="80%"></p><p>下面我们来总结适配器模式的优点：</p><ul><li>它可以通过适配器进行接口的转换，让原本不兼容的类协同工作；</li><li>这可以使客户从实现的接口解耦，如果被适配者改变了接口，适配器可以将其封装起来，客户不必跟随其修改；</li></ul><p>缺点：</p><ul><li>增加一个适配器，可能会增加系统的复杂度。</li></ul><h1 id="适配器模式的具体实践"><a href="#适配器模式的具体实践" class="headerlink" title="适配器模式的具体实践"></a>适配器模式的具体实践</h1><h2 id="JDK-InputStreamReader"><a href="#JDK-InputStreamReader" class="headerlink" title="JDK#InputStreamReader"></a>JDK#InputStreamReader</h2><p>通过 InputStreamReader，可以将 InputStream 字节流转换为字符流进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamReader</span> <span class="keyword">extends</span> <span class="title">Reader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> StreamDecoder sd;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将 inputStream 转换为 InputStreamReader</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InputStreamReader</span><span class="params">(InputStream in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sd = StreamDecoder.forInputStreamReader(in, <span class="keyword">this</span>, (String)<span class="keyword">null</span>); <span class="comment">// ## check lock object</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sd.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Spring-AOP-MVC"><a href="#Spring-AOP-MVC" class="headerlink" title="Spring#AOP/MVC"></a>Spring#AOP/MVC</h2><p>另外，比如在 Spring AOP 中，将 Advice 封装成对应的拦截器类型。或是在 Spring MVC 中，通过适配器模式，用于执行目标 Controller 中的请求处理方法。</p><p>由于对其源码不太熟悉，这里也就不详细说了。感兴趣的小伙伴可以看看这篇文章。</p><ul><li>小旋锋：<a href="https://juejin.im/post/5ba28986f265da0abc2b6084#heading-12" target="_blank" rel="noopener">设计模式 | 适配器模式及典型应用</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面三篇文章分别学习了单例模式、三种工厂模式和建造者模式，它们都是比较常用的创建型模式，顾名思义就是创建对象的。从这篇文章开始来学习结构型设计模式，今天是第一篇——适配器模式。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式就是这么简单</title>
    <link href="https://blog.timberliu.com/2019/05/12/045_%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/05/12/045_建造者模式就是这么简单/</id>
    <published>2019-05-11T16:00:00.000Z</published>
    <updated>2019-05-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中学习了三种工厂模式，这篇文章来学习一下另一种应用比较多的创建型模式，它适合用来创建拥有非常多的属性的对象。同样地，也是先从一个例子开始。<a id="more"></a></p><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><p>相信小伙伴们在假期出去游玩时，都会制定一套度假计划。一般来说，需要包括如下几个部分，VacationPlanner 类可以如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VacationPlanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day; <span class="comment">// 天数</span></span><br><span class="line">    <span class="keyword">private</span> String city; <span class="comment">// 旅游城市</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket; <span class="comment">// 车票</span></span><br><span class="line">    <span class="keyword">private</span> String hotel; <span class="comment">// 住宿旅馆</span></span><br><span class="line">    <span class="keyword">private</span> String tourist; <span class="comment">// 旅游景点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> personNum; <span class="comment">// 人数</span></span><br><span class="line">    <span class="keyword">private</span> String other; <span class="comment">// 其他</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter/getter/toString   </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此，我们创建计划的方法 createPlanner 可以按照如下写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vacation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> VacationPlanner <span class="title">createPlanner</span><span class="params">(<span class="keyword">int</span> day, String city, String hotel, <span class="keyword">int</span> personNum, </span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> ticket, String tourist, String other)</span> </span>&#123;</span><br><span class="line">        VacationPlanner planner = <span class="keyword">new</span> VacationPlanner();</span><br><span class="line">        planner.setDay(day);</span><br><span class="line">        planner.setCity(city);</span><br><span class="line">        planner.setHotel(hotel);</span><br><span class="line">        planner.setPersonNum(personNum);</span><br><span class="line">        planner.setTicket(ticket);</span><br><span class="line">        planner.setTourist(tourist);</span><br><span class="line">        planner.setOther(other);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> planner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单吧。但是如果很多人都想要制作一个度假计划，而每个人的计划又不太一样，所以，创建的度假计划及其创建步骤也就不同。例如，有的人就是本地人，不需要旅馆；有的人需要其他活动。</p><p>另外，其实我们并不需要知道度假计划的内部实现。那我们该如何做一个有弹性的设计，去适应各种变化呢?其实，我们可以创建一个单独的创建者，将度假计划的表示和创建计划的步骤分开来。</p><p>但在这之前，我们应该定义一个抽象建造者，也就是要符合之前我们所说的针对接口编程，而不是具体的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractVacationPlannerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildDay</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTicket</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildHotel</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildTourist</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPersonNum</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildOther</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> VacationPlanner <span class="title">getVacationPlanner</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再来创建一个具体的建造者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VacationPlannerBuilder</span> <span class="keyword">extends</span> <span class="title">AbstractVacationPlannerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> VacationPlanner vacationPlanner = <span class="keyword">new</span> VacationPlanner();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">        vacationPlanner.setDay(day);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTicket</span><span class="params">(<span class="keyword">int</span> ticket)</span> </span>&#123;</span><br><span class="line">        vacationPlanner.setTicket(ticket);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildHotel</span><span class="params">(String hotel)</span> </span>&#123;</span><br><span class="line">        vacationPlanner.setHotel(hotel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildTourist</span><span class="params">(String tourist)</span> </span>&#123;</span><br><span class="line">        vacationPlanner.setTourist(tourist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPersonNum</span><span class="params">(<span class="keyword">int</span> personNum)</span> </span>&#123;</span><br><span class="line">        vacationPlanner.setPersonNum(personNum);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOther</span><span class="params">(String other)</span> </span>&#123;</span><br><span class="line">        vacationPlanner.setOther(other);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> VacationPlanner <span class="title">getVacationPlanner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vacationPlanner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在 Vacation 就可以按照如下的方式写了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vacation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> AbstractVacationPlannerBuilder builder;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setVacationPlannerBuilder</span><span class="params">(AbstractVacationPlannerBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractVacationPlannerBuilder <span class="title">createPlanner</span><span class="params">(<span class="keyword">int</span> day, String city, String hotel, <span class="keyword">int</span> personNum,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         <span class="keyword">int</span> ticket, String tourist, String meal, String other)</span> </span>&#123;</span><br><span class="line">        builder.buildDay(day);</span><br><span class="line">        builder.buildCity(city);</span><br><span class="line">        builder.buildHotel(hotel);</span><br><span class="line">        builder.buildPersonNum(personNum);</span><br><span class="line">        builder.buildTicket(ticket);</span><br><span class="line">        builder.buildTourist(tourist);</span><br><span class="line">        builder.buildOther(other);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> builder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是建造者模式，它是将一个复杂对象的表示和创建分离开来，允许通过多个步骤来创建对象，并且可以改变其过程。</p><p>它的 UML 图如下：</p><p><img src="http://media.timberliu.com/image/2019/5/12/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.jpg" width="80%"></p><p>下面来总结一下建造者模式的优点：</p><ul><li>建造者模式将一个复杂对象的创建过程封装起来；</li><li>向客户端隐藏了产品内部的实现，将产品本身与产品的创建过程分离开来；</li><li>可以更加精确地控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中；</li></ul><p>缺点：</p><ul><li>在建造者模式中，如果产品之间的差异性太大，则不适合使用建造者模式。</li><li>如果产品的内部变化复杂，可能需要定义很多建造者类来实现这些变化，导致系统变得很庞大。</li></ul><h1 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h1><p>另外，建造者模式也可以使用静态内部类的形式，它是将实体类对应的 Builder 放置到实体类的内部，看一下它的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VacationPlanner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> day; <span class="comment">// 天数</span></span><br><span class="line">    <span class="keyword">private</span> String city; <span class="comment">// 旅游城市</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> ticket; <span class="comment">// 车票</span></span><br><span class="line">    <span class="keyword">private</span> String hotel; <span class="comment">// 住宿旅馆</span></span><br><span class="line">    <span class="keyword">private</span> String tourist; <span class="comment">// 旅游景点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> personNum; <span class="comment">// 人数</span></span><br><span class="line">    <span class="keyword">private</span> String other; <span class="comment">// 其他</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 全属性的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VacationPlanner</span><span class="params">(VacationPlannerBuilder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.day = builder.day;</span><br><span class="line">        <span class="keyword">this</span>.city = builder.city;</span><br><span class="line">        <span class="keyword">this</span>.ticket = builder.ticket;</span><br><span class="line">        <span class="keyword">this</span>.hotel = builder.hotel;</span><br><span class="line">        <span class="keyword">this</span>.tourist = builder.tourist;</span><br><span class="line">        <span class="keyword">this</span>.personNum = builder.personNum;</span><br><span class="line">        <span class="keyword">this</span>.other = builder.other;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VacationPlannerBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> day; <span class="comment">// 天数</span></span><br><span class="line">        <span class="keyword">private</span> String city; <span class="comment">// 旅游城市</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> ticket; <span class="comment">// 车票</span></span><br><span class="line">        <span class="keyword">private</span> String hotel; <span class="comment">// 住宿旅馆</span></span><br><span class="line">        <span class="keyword">private</span> String tourist; <span class="comment">// 旅游景点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> personNum; <span class="comment">// 人数</span></span><br><span class="line">        <span class="keyword">private</span> String other; <span class="comment">// 其他</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 与之前不同，这里返回 VacationPlannerBuilder</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildDay</span><span class="params">(<span class="keyword">int</span> day)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.day = day;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildCity</span><span class="params">(String city)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.city = city;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildTicket</span><span class="params">(<span class="keyword">int</span> ticket)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ticket = ticket;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildHotel</span><span class="params">(String hotel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.hotel = hotel;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildTourist</span><span class="params">(String tourist)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.tourist = tourist;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildPersonNum</span><span class="params">(<span class="keyword">int</span> personNum)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.personNum = personNum;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlannerBuilder <span class="title">buildOther</span><span class="params">(String other)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.other = other;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> VacationPlanner <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> VacationPlanner(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面来写个测试类进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        VacationPlanner planner = <span class="keyword">new</span> VacationPlanner.VacationPlannerBuilder()</span><br><span class="line">                .buildDay(<span class="number">3</span>)</span><br><span class="line">                .buildCity(<span class="string">"北京"</span>)</span><br><span class="line">                .buildHotel(<span class="string">"7天"</span>)</span><br><span class="line">                .buildPersonNum(<span class="number">2</span>)</span><br><span class="line">                .buildTicket(<span class="number">999</span>)</span><br><span class="line">                .buildTourist(<span class="string">"故宫"</span>)</span><br><span class="line">                .buildOther(<span class="string">"其他"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        System.out.println(planner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="建造者模式的具体实践"><a href="#建造者模式的具体实践" class="headerlink" title="建造者模式的具体实践"></a>建造者模式的具体实践</h1><h2 id="JDK-StringBuilder"><a href="#JDK-StringBuilder" class="headerlink" title="JDK#StringBuilder"></a>JDK#StringBuilder</h2><p><strong>AbstractStringBuilder</strong></p><p>可以将 StringBuilder 看成 String 的建造者，而 AbstractStringBuilder 是建造者的抽象类。它的部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存储 char 字符的数组</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (str == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> appendNull();</span><br><span class="line">        <span class="keyword">int</span> len = str.length();</span><br><span class="line">        ensureCapacityInternal(count + len); <span class="comment">// 确保容量</span></span><br><span class="line">        str.getChars(<span class="number">0</span>, len, value, count);</span><br><span class="line">        count += len;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == Integer.MIN_VALUE) &#123;</span><br><span class="line">            append(<span class="string">"-2147483648"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> appendedLength = (i &lt; <span class="number">0</span>) ? Integer.stringSize(-i) + <span class="number">1</span></span><br><span class="line">                                     : Integer.stringSize(i);</span><br><span class="line">        <span class="keyword">int</span> spaceNeeded = count + appendedLength;</span><br><span class="line">        ensureCapacityInternal(spaceNeeded);</span><br><span class="line">        Integer.getChars(i, spaceNeeded, value);</span><br><span class="line">        count = spaceNeeded;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringBuilder</strong></p><p>StringBuilder 的部分源码如下，这里使用的建造者模式是我们之前看到的第一种模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBuilder</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractStringBuilder</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(str);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.append(i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建了一个新的 String</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Guava-ImmutableSet"><a href="#Guava-ImmutableSet" class="headerlink" title="Guava#ImmutableSet"></a>Guava#ImmutableSet</h2><p>ImmutableSet 的建造者使用的是静态内部类方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ImmutableCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Builder&lt;E&gt; <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder&lt;E&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">ImmutableCollection</span>.<span class="title">ArrayBasedBuilder</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder&lt;E&gt; <span class="title">add</span><span class="params">(E element)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.add(element);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder&lt;E&gt; <span class="title">addAll</span><span class="params">(Iterable&lt;? extends E&gt; elements)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">super</span>.addAll(elements);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ImmutableSet&lt;E&gt; <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ImmutableSet&lt;E&gt; result = construct(size, contents);</span><br><span class="line">            size = result.size();</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">ImmutableSet&lt;E&gt; <span class="title">construct</span><span class="params">(<span class="keyword">int</span> n, Object... elements)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 返回不同的 ImmutableSet 实现</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般它有两种创建方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ImmutableSet&lt;Object&gt; set1 = <span class="keyword">new</span> ImmutableSet.Builder&lt;&gt;().build();</span><br><span class="line"></span><br><span class="line">ImmutableSet&lt;Object&gt; set2 = ImmutableSet.builder().build();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中学习了三种工厂模式，这篇文章来学习一下另一种应用比较多的创建型模式，它适合用来创建拥有非常多的属性的对象。同样地，也是先从一个例子开始。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>一文搞懂三种工厂模式</title>
    <link href="https://blog.timberliu.com/2019/05/10/044_%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%E4%B8%89%E7%A7%8D%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>https://blog.timberliu.com/2019/05/10/044_一文搞懂三种工厂模式/</id>
    <published>2019-05-09T16:00:00.000Z</published>
    <updated>2019-05-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章详细学习了单例模式的多种写法，今天来学习一下如下三种模式：简单工厂、工厂方法、抽象工厂模式，其实简单工厂模式不属于 GOF 23 种设计模式，不过它实现简单，在有些场景下它也比较适用，所以就首先来看一下它。<a id="more"></a></p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>通常我们使用 new 关键字就可以创建对象，为什么还要使用工厂模式呢？我们以下面这个例子来看一下。</p><p>如果有一个手机店，出售 IPhone、Samsung、Huawei 品牌的手机。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Samsung</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huawei</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾客在购买手机的代码可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">buyPhone</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Iphone"</span>.equals(type)) &#123;</span><br><span class="line">            phone = <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Samsung"</span>.equals(type)) &#123;</span><br><span class="line">            phone = <span class="keyword">new</span> Samsung();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Huawei "</span>.equals(type)) &#123;</span><br><span class="line">            phone = <span class="keyword">new</span> Huawei();</span><br><span class="line">        &#125;</span><br><span class="line">        phone.pay();</span><br><span class="line">        phone.box();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果店铺想要增加竞争力，又添加了几种手机品牌，就需要去修改 buyPhone 方法，在其中继续添加 if-else 语句。</p><p>也就是说，如果代码有变化或扩展，就必须重新修改该方法，这就违反了对扩展开放、对修改关闭的原则。而且这样修改对于系统来说，将难以维护和更新。</p><p>其实，我们可以将创建对象的代码移到另一个对象，封装成一个工厂类，在添加或改变手机的品牌时，只需要修改该工厂类即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimplePhoneFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Phone <span class="title">createPhone</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"Iphone"</span>.equals(type)) &#123;</span><br><span class="line">            phone = <span class="keyword">new</span> IPhone();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Samsung"</span>.equals(type)) &#123;</span><br><span class="line">            phone = <span class="keyword">new</span> Samsung();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"Huawei "</span>.equals(type)) &#123;</span><br><span class="line">            phone = <span class="keyword">new</span> Huawei();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 PhoneStore 的代码就可以修改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">buyPhone</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        Phone phone = SimplePhoneFactory.createPhone(type);</span><br><span class="line">        phone.pay();</span><br><span class="line">        phone.box();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述模式就是简单工厂模式，也可以利用静态方法来定义工厂，这称为静态工厂。</p><p>我们来看一下它的 UML 图：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16a9fa38fe80f45e?w=702&h=506&f=png&s=17058" width="80%"></p><p>下面来总结一下，简单工厂模式有哪些优缺点。</p><p>优点：</p><ul><li>如果一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>如果想增加一个产品，只要实现一个新的扩展自工厂类的子类就可以了。</li><li>它屏蔽了产品的具体实现，调用者只需要关心产品的接口。</li></ul><p>但它也有一些缺点：</p><ul><li>每次增加产品时，都需要增加一个产品类，使得系统中的类太多，增加了系统的复杂度。</li></ul><h1 id="简单工厂模式具体实践"><a href="#简单工厂模式具体实践" class="headerlink" title="简单工厂模式具体实践"></a>简单工厂模式具体实践</h1><p><strong>Calendar#createCalendar</strong></p><p>该方法部分源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       Locale aLocale)</span></span></span><br><span class="line"><span class="function">    ···</span></span><br><span class="line"><span class="function">    <span class="title">if</span> <span class="params">(aLocale.getLanguage()</span> </span>== <span class="string">"th"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"TH"</span>) &#123;</span><br><span class="line">        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">"JP"</span> &amp;&amp; aLocale.getLanguage() == <span class="string">"ja"</span></span><br><span class="line">               &amp;&amp; aLocale.getCountry() == <span class="string">"JP"</span>) &#123;</span><br><span class="line">        cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会根据传入的语言和国家来决定生成什么 Calendar。</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>如果手机店规模比较大，希望开设 IPhone、Samsung、Huawei 专卖分店（假设分店自己制作手机），这应该如何扩展呢？</p><p>由于购买手机的过程类似，都需要付款、打包；而分店则需要生产其相应品牌的手机。我们可以将 PhoneStore 修改为抽象类 ，将 SimplePhoneFactory 的 createPhone 方法改为抽象方法，放置到  AbstractPhoneStore 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">buyPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Phone phone = createPhone();</span><br><span class="line">        phone.pay();</span><br><span class="line">        phone.box();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IPhone、Samsung、Huawei 三种产品分别如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Samsung</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Huawei</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种产品对应的 IPhone、Samsung、Huawei 三家分店，它们的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneStore</span> <span class="keyword">extends</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SamsungStore</span> <span class="keyword">extends</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Samsung();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiStore</span> <span class="keyword">extends</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Huawei();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要 IPhone 手机，代码可以如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneStore phoneStore = <span class="keyword">new</span> IPhoneStore();</span><br><span class="line">        Phone phone = phoneStore.buyPhone();</span><br><span class="line">        <span class="comment">// phone 为 IPhone</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这种模式就是工厂方法模式，它会定义一个创建对象的接口，但让实现这个接口的类来决定实例化哪个类。例如这里创建了一个 PhoneStore 抽象类，但实际上由 IPhoneStore 来决定实例化哪个 Phone 的实现类。</p><p>我们可以看到工厂方法模式包括了四个角色：</p><ul><li>Product：抽象产品，对应上面的 Phone；</li><li>ConcreteProduct：具体产品，对应 IPhone、Samsung、Huawei 等；</li><li>Factory：抽象工厂，对应 PhoneStore；</li><li>ConcreteFactory：具体工厂，对应 IPhoneStore、SamsungStore、HuaweiStore。</li></ul><p>它的 UML 图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16a9fa38f6a83347?w=1003&h=356&f=png&s=18614" width="80%"></p><p>下面总结一下工厂方法模式的优点：</p><ul><li>用户只需要关心所需产品对应的工厂，而无需关心创建产品的细节；</li><li>在系统中加入新产品时，无需修改抽象工厂和抽象产品的接口，也无需修改其他的具体工厂和具体产品，只需要添加一个具体的工厂和具体产品就可以了。</li></ul><p>缺点：</p><ul><li>每添加一个新产品就要添加对应的工厂和产品，造成系统中类的个数太多，增加了系统的复杂度。</li><li>考虑系统的扩展性，需要引入抽象层，增加了系统的抽象性，系统实现的难度也加大。</li></ul><p>简单工厂模式与工厂方法模式之间的区别如下：</p><ul><li>在简单工厂中，是将对象的创建封装在另一个类中；</li><li>而在工厂方法中，它创建了一个框架，由子类来决定创建哪个对象。</li></ul><h1 id="工厂方法模式具体实践"><a href="#工厂方法模式具体实践" class="headerlink" title="工厂方法模式具体实践"></a>工厂方法模式具体实践</h1><p>Java 集合的 iterator 方法就是一个工厂方法。部分集合的 UML 图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16a9fa38f0727686?w=880&h=405&f=png&s=18371" width="80%"></p><p><strong>抽象工厂</strong></p><p>该实例中抽象工厂就是 Iterable 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">Iterator&lt;T&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体工厂</strong></p><p>具体工厂在 Java 集合中非常多，这里举两个例子，例如在 ArrayList 中的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; <span class="title">iterator</span>() </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 HashMap 中的实现中，entrySet 方法返回一个 EntrySet 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象产品</strong></p><p>抽象产品就是 Iterator 接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体产品</strong></p><p>这里的具体产品，以上面说的 ArrayList 中的 Itr 和 EntrySet 中的 EntryIterator 为例。</p><p>Itr 对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EntryIterator 对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>如果想要改变商业模式，三家专卖店内不仅可以卖 IPhone、Sansung、Huawei 三种品牌的手机，也可以卖相应品牌的电脑（假设分店自己生产手机、电脑），这应该如何设计呢？（这个例子不太符合实际情况，不过能说明抽象工厂模式的含义，凑合看吧）</p><p>店铺可以如下设计：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Phone <span class="title">buyPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Phone phone = createPhone();</span><br><span class="line">        phone.pay();</span><br><span class="line">        phone.box();</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Computer <span class="title">buyComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Computer computer = createComputer();</span><br><span class="line">        computer.pay();</span><br><span class="line">        computer.pack();</span><br><span class="line">        <span class="keyword">return</span> computer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Phone <span class="title">createPhone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> Computer <span class="title">createComputer</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种品牌的手机类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">box</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamsungPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种品牌的电脑类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pack</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SamsungComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HuaweiComputer</span> <span class="keyword">extends</span> <span class="title">Computer</span> </span>&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于三家相应品牌的专卖店，它们的具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IPhoneStore</span> <span class="keyword">extends</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MacComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SamsungStore</span> <span class="keyword">extends</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SamsungPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SamsungComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaweiStore</span> <span class="keyword">extends</span> <span class="title">PhoneStore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Phone <span class="title">createPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiPhone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Computer <span class="title">createComputer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HuaweiComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们要在 IPhone 专卖店购买手机和电脑，代码可以如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PhoneStore phoneStore = <span class="keyword">new</span> IPhoneStore();</span><br><span class="line">        Phone phone = phoneStore.buyPhone();</span><br><span class="line">        Computer computer = phoneStore.buyComputer();</span><br><span class="line">        <span class="comment">// phone 为 IPhone</span></span><br><span class="line">        <span class="comment">// computer 为 Mac</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述的模式就是抽象工工厂模式，它提供了一个接口，用于创建一个产品的家族，而不需要指定具体类。每个具体工厂会创建某个产品家族。</p><p>在上述例子，IPhoneStore、SamsungStore、HuaweiStore 就是一个个具体的工厂，它们可以生产对应品牌的手机和电脑。其中 IPhoneStore 这个工厂就是创建 IPhone、MacComputer 这个产品家族。</p><p>它的 UML 图如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16a9fa38f5739a61?w=1546&h=621&f=png&s=38727" width="90%"></p><p>下面总结一下抽象工厂模式的优缺点。</p><p>优点：</p><ul><li>同样地，将用户代码和实际的具体产品解耦，使其无需关心产品的创建细节；</li><li>使用某个工厂，可以创建一系列相关的产品。如果想要增加一条个产品线，例如上面想要增加一个新的品牌店和其相应的产品，只需要扩展 PhoneStore 工厂，并创建相应的 Phone、Computer 类即可，非常简单。</li></ul><p>缺点：</p><ul><li>限制了所能创建的产品集合，例如上面的 Phone 和 Computer，如果想要增加新的产品，增加 camera，就会比较困难，需要修改抽象工厂的接口，会增加很大的工作量；</li><li>另外，工厂类和产品类较多，增加了系统的抽象性和复杂度。</li></ul><p>抽象工厂模式与工厂方法模式很类似，它们之间的区别如下：</p><ul><li>在工厂方法模式中，每个具体工厂负责创建一个具体产品。所以，在增加一个具体产品时，也要增加其相应的工厂，需要创建一个继承自抽象工厂的类，并覆盖它的工厂方法。也就是所说的工厂方法使用继承创建对象。</li><li>而在抽象工厂模式中，每个具体工厂负责创建一个系列的具体产品。所以，只有在新增加一个类型的具体产品时，才需要增加相应的工厂。它可以用来创建一系列具体产品，将这些相关的产品组合起来，也就是所说的使用组合创建对象。</li></ul><p>它们之间也有一些关联，就是抽象工厂的方法以工厂方法的方法来实现。在抽象工厂的接口中，每个方法都负责创建一个具体产品，而具体工厂来提供具体的实现。</p><p>例如，PhoneStore 中的 createPhone、createComputer 方法由子类实现，这两个方法单独来看都是在创建一个对象，其实也就是一个工厂方法。</p><h1 id="抽象工厂模式的实践"><a href="#抽象工厂模式的实践" class="headerlink" title="抽象工厂模式的实践"></a>抽象工厂模式的实践</h1><p>JDBC 中的 Connection 就是一个抽象工厂模式，在不同的连接池中有不同的实现，例如 druid 和 dbcp：</p><p><img src="https://user-gold-cdn.xitu.io/2019/5/10/16a9fa38f66f1454?w=1553&h=583&f=png&s=40771" width="90%"></p><p>由于本人对于 druid 和 dbcp 的实现也不太熟悉，这里就不多解释了，有兴趣的小伙伴可以自己研究一下。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《Head First 设计模式》</li><li>CyC2018/CS-Notes：<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#%E4%B8%80%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">设计模式</a></li><li>越努力越幸运-致自己：<a href="https://blog.csdn.net/weixin_37778801/article/details/84203415" target="_blank" rel="noopener">java设计模式精讲 Debug 方式+内存分析 第4章 简单工厂模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章详细学习了单例模式的多种写法，今天来学习一下如下三种模式：简单工厂、工厂方法、抽象工厂模式，其实简单工厂模式不属于 GOF 23 种设计模式，不过它实现简单，在有些场景下它也比较适用，所以就首先来看一下它。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>单例模式就是如此简单</title>
    <link href="https://blog.timberliu.com/2019/05/08/043_%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E5%B0%B1%E6%98%AF%E5%A6%82%E6%AD%A4%E7%AE%80%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/05/08/043_单例模式就是如此简单/</id>
    <published>2019-05-07T16:00:00.000Z</published>
    <updated>2019-05-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在面试中相信很多人会被问到：说说你最了解的三个设计模式，日常开发中使用过哪些设计模式等等。最近几篇文章就来学习一下，这是第一篇文章，也是最常见的模式——单例模式。<a id="more"></a></p><h1 id="什么是单例"><a href="#什么是单例" class="headerlink" title="什么是单例"></a>什么是单例</h1><p>单例模式（<code>Singleton Pattern</code>），顾名思义，即保证一个类仅有一个实例，并在全局中提供一个访问点。</p><p>在实现单例时，要保证一个类仅有一个实例，就不能提供公有的构造方法，任由其他类创建实例，对应变量也需要为 <code>static</code>，只在加载时初始化一次。另外呢，要在全局中都能访问到，还需要提供一个静态的公有方法来进行访问。</p><p>具体实现方式比较多，对于不同的场景，也应该选择不同的方式，例如是否需要保证线程安全，是否需要延迟加载。下面具体来看一下。</p><h2 id="饿汉式-线程安全"><a href="#饿汉式-线程安全" class="headerlink" title="饿汉式(线程安全)"></a>饿汉式(线程安全)</h2><p>根据上面对单例模式实现的说明，可以很容易地想到如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton1 instance = <span class="keyword">new</span> Singleton1();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton1</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在该类第一次被加载时，就会创建好该实例。这就是所谓的饿汉式，也就是，在想要使用实例时，立刻就能拿到，而不需要进行等待。</p><p>另外这种方式，由 <code>JVM</code> 保证其线程安全。但是这种方式可能会造成资源消耗，因为有可能这个实例根本就用不到，而进行不必要的加载。</p><h2 id="懒汉式-非线程安全"><a href="#懒汉式-非线程安全" class="headerlink" title="懒汉式(非线程安全)"></a>懒汉式(非线程安全)</h2><p>上述方式在类加载时就进行实例化，可能会造成不必要的加载。那么我们可以在其真正被访问的时候，再进行实例化，于是可以写出如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>getInstance</code> 方法中，第一次访问时，由于没有初始化，才去进行进行初始化，在后续访问时，直接返回该实例即可。这就是所谓的懒汉式，也就是，它不会提前把实例创建出来，而是将其延迟到第一次被访问的时候。</p><p>但是懒汉式存在线程安全问题，如下图：</p><p><img src="http://media.timberliu.com/image/2019/5/8/%E6%87%92%E6%B1%89%E5%BC%8F-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.jpg" width="60%"></p><p>在多线程场景下，如果有两个线程同时进入 <code>if</code> 语句中，则这两个线程分别创建了一个对象，在两个线程从 <code>if</code> 中退出时，就创建了两个不一样的对象。</p><h2 id="懒汉式-线程安全"><a href="#懒汉式-线程安全" class="headerlink" title="懒汉式(线程安全)"></a>懒汉式(线程安全)</h2><p>既然普通的懒汉式会出现线程安全问题，那么给创建对象的方法加锁即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述这种做法虽然在多线程场景下也能正常工作，也具备延迟加载。但由于 <code>synchronized</code> 方法锁住了整个方法，效率比较低。于是，聪明的小伙伴，可以很容易想到，使用同步方法块，来减小加锁的粒度。</p><p>看下面两种做法，加锁粒度确实减小了，但是它们却并不能保证线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于指定重排序出现问题，后面介绍双重校验锁时会详细说。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton4.class) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>synchronized</code> 加在 <code>if</code> 语句外面，这和普通的懒汉式做法一样，没有区别。如果有两个线程分别进入 <code>if</code> 语句，虽然也有加锁操作，但是两个线程都会执行实例化，也就是会进行两次实例化。</p><h2 id="双重校验锁-线程安全"><a href="#双重校验锁-线程安全" class="headerlink" title="双重校验锁(线程安全)"></a>双重校验锁(线程安全)</h2><p>于是引出了双重校验锁方式，可以先判断对象是否实例化，如果没有再进行加锁，再加锁之后，再次判断是否实例化，如果仍然没有实例化，才实例化对象。</p><p>这种做法的完整代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果已经实例化，则直接返回，不用加锁，提升性能</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="comment">// 再次检查，保证线程安全</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 <code>synchronized</code> 语句前后，有两个 <code>if</code> 判断，这就是所谓的双重校验锁。</p><p><strong>使用 volatile</strong></p><p>其实，如果仅仅是双重校验的话，仍然不能保证线程安全问题。这就要分析 <code>instance = new Singleton5();</code> 这段代码。</p><p>虽然代码只有一句，但在 <code>JVM</code> 中它其实被分为三步执行：</p><ol><li>为 <code>instance</code> 分配内存空间；</li><li>对 <code>instance</code> 进行初始化；</li><li>将 <code>instance</code> 指向分配的内存地址；</li></ol><p>但由于编译器或处理器可能会对指令重排序，执行的顺序就有可能变成 <code>1-&gt;3-&gt;2</code>。这在单线程环境下不会出现问题，但是在多线程环境下可能会导致一个线程获得还没有初始化的实例。</p><p><img src="http://media.timberliu.com/image/2019/5/8/%E5%8F%8C%E9%87%8D%E6%A0%A1%E9%AA%8C%E9%94%81-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98.jpg" width="60%"></p><p>例如，线程 <code>A</code> 执行了第 <code>1</code>、<code>3</code> 步后，此时线程 <code>B</code> 调用 <code>getInstance()</code> 方法，判断 <code>instance</code> 不为空，因此返回 <code>instance</code>。但此时 <code>instance</code> 还未被初始化。</p><p>所以，就需要使用 <code>volatile</code> 关键字来修饰 <code>instance</code>，禁止编译器的指令重排序，保证在多线程环境下也能正常运行。</p><h2 id="静态内部类式-线程安全"><a href="#静态内部类式-线程安全" class="headerlink" title="静态内部类式(线程安全)"></a>静态内部类式(线程安全)</h2><p>目前双重校验锁的做法看起来不错，使用延迟加载，在保证线程安全的同时，加锁粒度也比较小，效率还不错。那还有没有其他方法呢？</p><p>那就是使用静态内部类来实现，来看一下它的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerSingleton</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton6 INSTANCE = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerSingleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种实现中，当外部类 <code>Singleton6</code> 类被加载时，静态内部类 <code>InnerSingleton</code> 并没有被加载。</p><p>而是只有当调用 <code>getInstance</code> 方法，从而访问类的静态变量时，才会加载内部类，从而实例化 <code>INSTANCE</code>。并且 <code>JVM</code> 能确保 <code>INSTANCE</code> 只能被实例化一次，即它也是线程安全的。</p><h2 id="枚举式-线程安全"><a href="#枚举式-线程安全" class="headerlink" title="枚举式(线程安全)"></a>枚举式(线程安全)</h2><p>另外，使用枚举实现单例也是一种不错的方式，代码非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton6 &#123;</span><br><span class="line">    INSTANCE();</span><br><span class="line"></span><br><span class="line">    Singleton6() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举的实现中，类被定义为 <code>final</code>，其枚举值被定义为 <code>static</code> <code>final</code>，对枚举值的初始化放在静态语句块中。所以，对象在该类第一次被加载时实例化，这不仅避免了线程安全问题，而且也避免了下面提到的反序列化对单例的破坏。</p><h1 id="单例与序列化"><a href="#单例与序列化" class="headerlink" title="单例与序列化"></a>单例与序列化</h1><p>现在来看一下，对象在序列化和反序列化时，是否还能够保证单例。</p><p>这里使用双重校验锁实现的单例类，对 <code>Singleton5</code> 类添加 <code>Serializable</code> 接口，然后进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton5 instance1 = Singleton5.getInstance();</span><br><span class="line">        <span class="keyword">try</span> ( ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>)) )&#123;</span><br><span class="line">            oos.writeObject(instance1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Singleton5 instance2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"tempFile"</span>))) )&#123;</span><br><span class="line">            instance2 = (Singleton5) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(instance1 == instance2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>可以看到，对 <code>Singleton5</code> 进行反序列得到的是一个新的对象，如此就破坏了 <code>Singleton5</code><br>的单例性。</p><p>我们可以在 <code>Singleton5</code> 类中添加一个 <code>readResolve()</code> 方法，并在该方法中指定要返回的对象的生成策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton5 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton5.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加 readResolve 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>debug</code> 方法查看源码，在 <code>readObject</code> 方法的调用栈中，可以看到 <code>ObejctStreamClass</code> 类的 <code>invokeReadResolve</code> 方法：</p><p><img src="http://media.timberliu.com/image/2019/5/8/%E5%BA%8F%E5%88%97%E5%8C%96-readResolve%E6%96%B9%E6%B3%95.png" width="80%"></p><p>如果定义了 <code>readResolve</code> 方法，会通过反射进行调用，根据指定的策略来生成对象。</p><h1 id="有哪些好的单例模式实践"><a href="#有哪些好的单例模式实践" class="headerlink" title="有哪些好的单例模式实践"></a>有哪些好的单例模式实践</h1><p><strong>JDK#Runtime</strong></p><p>该类用于获取应用运行时的环境。可以看到这是一个饿汉式的单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Spring#Singleton</strong></p><p>在 <code>Spring</code> 中定义 <code>Bean</code> 时，可以指定是单例还是多例（默认为单例）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scope</span>(<span class="string">"singleton"</span>)</span><br></pre></td></tr></table></figure><p>查看其源码，单例模式实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryBean</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt;, <span class="title">BeanClassLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">InitializingBean</span>, <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T singletonInstance;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// 扫描配置时，单例模式</span></span><br><span class="line">    <span class="comment">// 就会将 initialized 置为 true</span></span><br><span class="line"><span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line"><span class="keyword">this</span>.initialized = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 调用子类方法创建对象</span></span><br><span class="line"><span class="keyword">this</span>.singletonInstance = createInstance();</span><br><span class="line"><span class="keyword">this</span>.earlySingletonInstance = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isSingleton()) &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.initialized ? <span class="keyword">this</span>.singletonInstance : getEarlySingletonInstance());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> createInstance();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Hollis：<a href="https://www.hollischuang.com/archives/1373" target="_blank" rel="noopener">设计模式（二）——单例模式</a></li><li>CyC2018/CS-Notes：<a href="https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md#%E4%B8%80%E6%A6%82%E8%BF%B0" target="_blank" rel="noopener">设计模式</a></li><li>越努力越幸运-致自己：<a href="https://blog.csdn.net/weixin_37778801/article/details/84349407" target="_blank" rel="noopener">java设计模式精讲 Debug 方式+内存分析 第8章 单例模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在面试中相信很多人会被问到：说说你最了解的三个设计模式，日常开发中使用过哪些设计模式等等。最近几篇文章就来学习一下，这是第一篇文章，也是最常见的模式——单例模式。&lt;/p&gt;
    
    </summary>
    
      <category term="2.5 设计模式" scheme="https://blog.timberliu.com/categories/2-5-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://blog.timberliu.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer (2) —— 链表篇</title>
    <link href="https://blog.timberliu.com/2019/04/17/042_%E5%89%91%E6%8C%87offer%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://blog.timberliu.com/2019/04/17/042_剑指offer之链表/</id>
    <published>2019-04-16T16:00:00.000Z</published>
    <updated>2019-04-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中对剑指 <code>offer</code> 中数组相关的题目进行了归纳，这一篇文章是链表篇。同样地，如果各位大佬发现程序有什么 <code>bug</code> 或其他更巧妙的思路，欢迎交流学习。<a id="more"></a></p><h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6. 从尾到头打印链表"></a>6. 从尾到头打印链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个链表的头节点，从尾到头打印链表的每个节点的值。</p></blockquote><p>这里可以用显式栈，或者递归来实现，都比较简单，也就不多做解释了。</p><p><strong>递归实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = printListFromTailToHead(listNode.next);</span><br><span class="line">    list.add(listNode.val);</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>栈实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printListFromTailToHead</span><span class="params">(ListNode listNode)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span>(listNode == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    ListNode node = listNode;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="keyword">null</span>) &#123;</span><br><span class="line">        stack.push(node.val);</span><br><span class="line">        node = node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty()) &#123;</span><br><span class="line">        list.add(stack.pop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18. 删除链表的节点"></a>18. 删除链表的节点</h2><p><strong>题目一描述</strong></p><blockquote><p>在 O(1) 时间内删除链表指定节点。给定单链表的头节点引用和一个节点引用，要求在 O(1) 时间内删除该节点。</p></blockquote><p><strong>解题思路</strong></p><p>一般来说，要在单向链表中删除指定节点，需要得到被删除节点的前驱节点。但这需要从头节点开始顺序查找，时间复杂度肯定不是 <code>O(1)</code> 了，所以需要换一种思路。</p><p>我们可以将后继节点的值赋值给要删除的指定节点，再删除下一个节点，如此也同样实现了删除指定节点的功能。但是还需要注意两种特殊情况：</p><ul><li>第一种是要删除的节点是头节点，这时还需要对链表的头结点进行更新；</li><li>第二种是要删除的节点是尾节点，它没有下一个节点，这时就只能从头节点开始顺序查找要删除节点的前驱节点了。</li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteNode</span><span class="params">(Node head, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || node == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head == node) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点是头节点</span></span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点是尾节点</span></span><br><span class="line">        Node cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur.next != node) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 要删除的节点在链表中间</span></span><br><span class="line">        ListNode nextNode = node.next;</span><br><span class="line">        node.val = nextNode.val;</span><br><span class="line">        node.next = nextNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里除了最后一个节点，其他节点都可以在 <code>O(1)</code> 时间内删除，只有要删除的节点是尾节点时，才需要对链表进行遍历，所以，总体的时间复杂度还是 <code>O(1)</code>。</p><p><strong>题目二描述</strong></p><blockquote><p>在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 例如，链表1-&gt;2-&gt;3-&gt;3-&gt;4-&gt;4-&gt;5 处理后为 1-&gt;2-&gt;5。</p></blockquote><p><strong>解题思路</strong></p><p>这里要删除排序链表中的重复节点，由于头节点也可能被删除，所以需要对头节点特殊处理，或者添加一个虚拟节点。这里选择使用虚拟节点。</p><p>由于这里需要判断当前节点和下一个节点的值，所以循环中条件就是要判断当前节点和下一个节点均不能为空。如果这两个值不相等，则继续遍历。</p><p>如果不相等，则循环判断跳过连续重复的数个节点，最后 <code>cur</code> 指向这些重复节点的最后一个。由于重复节点不保留，所以需要让 <code>pre.next</code> 指向 <code>cur.next</code>，再更新 <code>cur</code> 为下一个节点 <code>pre.next</code>，进而继续判断。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">deleteDuplication</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    Node dummyHead = <span class="keyword">new</span> Node(-<span class="number">1</span>);</span><br><span class="line">    dummyHead.next = head;</span><br><span class="line"></span><br><span class="line">    Node pre = dummyHead;</span><br><span class="line">    Node cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.value != cur.next.value) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (cur.next != <span class="keyword">null</span> &amp;&amp; cur.value == cur.next.value) &#123;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dummyHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里虽然有两层嵌套循环，但实际上只对链表遍历了一遍，所以其时间复杂度为 <code>O(n)</code>。另外只申请了一个虚拟节点，所以空间复杂度为 <code>O(1)</code>。</p><h2 id="22-链表中倒数第-k-个节点"><a href="#22-链表中倒数第-k-个节点" class="headerlink" title="22. 链表中倒数第 k 个节点"></a>22. 链表中倒数第 k 个节点</h2><p><strong>题目描述</strong></p><p>输入一个链表，输出该链表中倒数第 k 个结点。（k 从 1 开始）</p><p><strong>解题思路</strong></p><p>这里可以定义两个指针。第一个指针从链表头开始遍历，向前移动 <code>k - 1</code> 步。然后从 <code>k</code> 步开始，第二个指针也开始从链表头开始遍历。</p><p>由于两个指针的距离为 <code>k - 1</code>，所有当第一个指针移动到链表的尾节点时，第二个指针正好移动到倒数第 <code>k</code> 个节点。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ListNode <span class="title">findKthToTail</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || k &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode fast = head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ListNode slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-链表中环的入口节点"><a href="#23-链表中环的入口节点" class="headerlink" title="23. 链表中环的入口节点"></a>23. 链表中环的入口节点</h2><p><strong>题目描述</strong></p><blockquote><p>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。</p></blockquote><p><strong>解题思路</strong></p><p>首先需要判断链表是否有环，可以使用两个指针，同时从链表的头部开始遍历，一个指针一次走一步，一个指针一次走两步。如果快指针能追上慢指针，则表示链表有环；否则如果快指针走到了链表的末尾，表示没有环。</p><p>在找到环之后，定义一个指针指向链表的头节点，再选择刚才的慢指针从快慢指针的相遇节点开始，两个指针同时以每次一步向前移动，它们相遇的节点就是链表的入口节点。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pHead == <span class="keyword">null</span> || pHead.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode slow = pHead.next;</span><br><span class="line">    ListNode fast = slow.next;</span><br><span class="line">    <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ListNode p = pHead;</span><br><span class="line">    <span class="keyword">while</span>(slow != p) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24. 反转链表"></a>24. 反转链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个链表，反转链表后，输出新链表的表头。</p></blockquote><p><strong>循环解决</strong></p><p>思路如下图：</p><p><img src="http://media.timberliu.com/image/2019/4/17/%E9%93%BE%E8%A1%A8-%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC2.jpg" width="80%"></p><p><strong>循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList1</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode nex;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        nex = cur.next;</span><br><span class="line">        </span><br><span class="line">        cur.next = newHead;</span><br><span class="line">        newHead = cur;</span><br><span class="line">        <span class="comment">// 记录</span></span><br><span class="line">        cur = nex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归解决</strong></p><p><img src="http://media.timberliu.com/image/2019/4/17/%E9%93%BE%E8%A1%A8-%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%92%E5%BD%92%E5%8F%8D%E8%BD%AC.jpg" width="80%"></p><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList2</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode newHead = reverseList2(head.next);</span><br><span class="line"></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="25-合并两个有序的链表"><a href="#25-合并两个有序的链表" class="headerlink" title="25. 合并两个有序的链表"></a>25. 合并两个有序的链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p></blockquote><p><strong>循环解题</strong></p><p>在使用循环时，首先需要确定新链表的头节点，如果链表 <code>first</code> 的头节点的值小于链表 <code>second</code> 的头节点的值，那么链表 <code>first</code> 的头节点便是新链表的头节点。</p><p>然后循环处理两个链表中剩余的节点，如果链表 <code>first</code> 中的节点的值小于链表 <code>second</code> 中的节点的值，则将链表 <code>first</code> 中的节点添加到新链表的尾部，否则添加链表 <code>second</code> 中的节点。然后继续循环判断，直到某一条链表为空。</p><p>当其中一条链表为空后，只需要将另一条链表全部链接到新链表的尾部。</p><p>思路图如下：</p><p><img src="http://media.timberliu.com/image/2019/4/17/%E9%93%BE%E8%A1%A8-%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6.jpg" width="80%"></p><p><strong>循环代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge1</span><span class="params">(ListNode first, ListNode second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (second == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p = first;</span><br><span class="line">    ListNode q = second;</span><br><span class="line">    ListNode newHead;</span><br><span class="line">    <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">        newHead = p;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newHead = q;</span><br><span class="line">        q = q.next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode r = newHead;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; q != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p.val &lt; q.val) &#123;</span><br><span class="line">            r.next = p;</span><br><span class="line">            p = p.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            r.next = q;</span><br><span class="line">            q = q.next;</span><br><span class="line">        &#125;</span><br><span class="line">        r = r.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.next = q;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.next = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归解题</strong></p><p>使用递归解决，比较简单。首先判断两条链表是否为空，如果 <code>first</code> 为空，则直接返回 <code>second</code>；如果 <code>second</code> 为空，则直接返回 <code>first</code>。</p><p>接着判断链表 <code>first</code> 中节点的值和链表 <code>second</code> 中节点的值，如果 <code>first</code> 中节点的值较小，则递归地求 <code>first.next</code> 和 <code>second</code> 的合并链表，让 <code>first.next</code> 指向新的链表头节点，然后返回 <code>first</code> 即可。</p><p>另一种情况类似，这里就不再赘述了。</p><p><strong>递归代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">merge2</span><span class="params">(ListNode first, ListNode second)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (second == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (first.val &lt; second.val) &#123;</span><br><span class="line">        first.next = merge2(first.next, second);</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        second.next = merge2(first, second.next);</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35. 复杂链表的复制"></a>35. 复杂链表的复制</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点），返回结果为复制后复杂链表的head。</p></blockquote><p><strong>解题思路</strong></p><p>这可以分为三步来解决。第一步是根据原始链表的所有节点，将每一节点的复制节点链接到它的后面。</p><p>第二步设置复制出来的节点的特殊指针。如果原始链表的节点 <code>p</code> 的特殊指针指向节点 <code>s</code>，则复制出来的节点 <code>cloned</code> 的特殊指针就指向节点 <code>s</code> 的下一个节点。</p><p>第三部是将长链表拆分成两个链表，把所有偶数位置的节点连接起来就是新的复制出来的链表。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RandomListNode <span class="title">Clone</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    cloneNodes(head);</span><br><span class="line">    connectSiblingNode(head);</span><br><span class="line">    <span class="keyword">return</span> reconnectNodes(head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cloneNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode newNode = <span class="keyword">new</span> RandomListNode(p.label);</span><br><span class="line">        newNode.next = p.next;</span><br><span class="line">        p.next = newNode;</span><br><span class="line">        p = newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connectSiblingNode</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        RandomListNode cloned = p.next;</span><br><span class="line">        <span class="keyword">if</span>(p.random != <span class="keyword">null</span>) &#123;</span><br><span class="line">            cloned.random = p.random.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p = cloned.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> RandomListNode <span class="title">reconnectNodes</span><span class="params">(RandomListNode head)</span> </span>&#123;</span><br><span class="line">    RandomListNode p = head;</span><br><span class="line">    </span><br><span class="line">    RandomListNode newHead = <span class="keyword">null</span>;</span><br><span class="line">    RandomListNode tail = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail = newHead = p.next;</span><br><span class="line">        p.next = tail.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        tail.next = p.next;</span><br><span class="line">        tail = tail.next;</span><br><span class="line">        p.next = tail.next;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36. 二叉搜索树与双向链表"></a>36. 二叉搜索树与双向链表</h2><p><strong>题目描述</strong></p><blockquote><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求不能创建任何新的结点，只能调整树中结点指针的指向。</p></blockquote><p><strong>解题思路</strong></p><p>这里将二叉搜索树转换为一个排序的双向链表，可以采用使用递归算法。</p><p>首先递归地转换左子树，返回其链表头节点，然后需要遍历该链表，找到链表的尾节点，这是为了和根节点相连接。需要让链表的尾节点的 <code>right</code> 指向根节点，让根节点的 <code>left</code> 指向链表的尾节点。</p><p>然后递归地转换右子树，返回其链表头节点，然后需要让根节点的 <code>right</code> 指向链表头节点，让链表的头节点指向根节点。</p><p>最后判断如果左子树转换的链表为空，则返回以 <code>root</code> 根节点为头节点的链表，否则返回以左子树最小值为头节点的链表。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode leftHead = Convert(root.left);</span><br><span class="line">    TreeNode leftEnd = leftHead;</span><br><span class="line">    <span class="keyword">while</span>(leftEnd != <span class="keyword">null</span> &amp;&amp; leftEnd.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftEnd = leftEnd.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(leftEnd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        leftEnd.right = root;</span><br><span class="line">        root.left = leftEnd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TreeNode rightHead = Convert(root.right);</span><br><span class="line">    <span class="keyword">if</span>(rightHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">        root.right = rightHead;</span><br><span class="line">        rightHead.left = root;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> leftHead == <span class="keyword">null</span> ? root : leftHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52. 两个链表的第一个公共节点"></a>52. 两个链表的第一个公共节点</h2><p><strong>题目描述</strong></p><blockquote><p>输入两个链表，找出它们的第一个公共结点。</p></blockquote><p><strong>解题思路</strong></p><p>对于两个链表，如果有公共节点，要不它们就是同一条链表，要不它们的公共节点一定在公共链表的尾部。</p><p>可以遍历两个链表得到它们的长度，然后在较长的链表上，先走它们的长度差的步数，接着同时在两个链表上遍历，如此找到的第一个节点就是它们的第一个公共节点。</p><p><strong>代码实现</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">public ListNode findFirstCommonNode(ListNode first, ListNode second) &#123;</span><br><span class="line">    int length1 = getListLength(first);</span><br><span class="line">    int length2 = getListLength(second);</span><br><span class="line"></span><br><span class="line">    ListNode headLongList = first;</span><br><span class="line">    ListNode headShortList = second;</span><br><span class="line">    int diff = length1 - length2;</span><br><span class="line"></span><br><span class="line">    if (length1 &lt; length2) &#123;</span><br><span class="line">        headLongList = second;</span><br><span class="line">        headShortList = first;</span><br><span class="line">        diff = length2 - length1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; diff; i++) &#123;</span><br><span class="line">        headLongList = headLongList.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (headLongList != null &amp;&amp; headShortList != null) &#123;</span><br><span class="line">        if (headLongList == headShortList) &#123;</span><br><span class="line">            return headLongList;</span><br><span class="line">        &#125;</span><br><span class="line">        headLongList = headLongList.next;</span><br><span class="line">        headShortList = headShortList.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int getListLength(ListNode head) &#123;</span><br><span class="line">    int length = 0;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    while (cur != null) &#123;</span><br><span class="line">        length++;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    return length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中对剑指 &lt;code&gt;offer&lt;/code&gt; 中数组相关的题目进行了归纳，这一篇文章是链表篇。同样地，如果各位大佬发现程序有什么 &lt;code&gt;bug&lt;/code&gt; 或其他更巧妙的思路，欢迎交流学习。&lt;/p&gt;
    
    </summary>
    
      <category term="1. 算法" scheme="https://blog.timberliu.com/categories/1-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="https://blog.timberliu.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指 offer (1) —— 数组篇</title>
    <link href="https://blog.timberliu.com/2019/04/16/041_%E5%89%91%E6%8C%87offer%E4%B9%8B%E6%95%B0%E7%BB%84/"/>
    <id>https://blog.timberliu.com/2019/04/16/041_剑指offer之数组/</id>
    <published>2019-04-15T16:00:00.000Z</published>
    <updated>2019-04-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>算法难，难如上青天，但是难也得静下心来慢慢学习，并总结归纳。所以将剑指 <code>offer</code> 中的题目按照类别进行了归纳，这是第一篇–数组篇。当然，如果各位大佬发现程序有什么 <code>bug</code> 或其他更巧妙的思路，欢迎交流学习。<a id="more"></a></p><h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3. 数组中重复的数字"></a>3. 数组中重复的数字</h2><p><strong>题目一描述</strong></p><blockquote><p>在一个长度为 n 的数组里的所有数字都在 0~n-1 的范围内。数组中存在有重复的数字，但不知道有几个数字重复，也不知道重复了几次。请找出数组中任意一个重复的数字。</p></blockquote><p><strong>解题思路</strong></p><p>由于数组中所有数字都在 <code>0 ~ n-1</code> 范围内，那么如果数组中没有重复的数字，则排序后的数组中，数字 <code>i</code> 就一定出现在下标为 <code>i</code> 的位置。</p><p>所以，可以在遍历数组的时候，判断：</p><ol><li>如果当前位置元素 <code>arr[i]</code> 等于 <code>i</code>，则继续遍历；</li><li>否则，将 <code>arr[i]</code> 与 <code>arr[arr[i]]</code> 进行比较：<ul><li>如果相等，则表示找到了重复的数字；</li><li>否则，将它们两个进行交换，也就是将 <code>arr[i]</code> 放到下标为 <code>i</code> 的位置。然后继续重复步骤 <code>2</code> 进行比较。</li></ul></li></ol><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] != i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[arr[i]]) &#123;</span><br><span class="line">                duplication[<span class="number">0</span>] = arr[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> temp = arr[i];</span><br><span class="line">            arr[i] = arr[temp];</span><br><span class="line">            arr[temp] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法，每一个数字最多只需要交换两次就可以归位：</p><ul><li>第一次和当前正在遍历的元素进行交换；</li><li>第二次就可以将它归位。</li></ul><p>因此时间复杂度是 <code>O(n)</code>。由于不需要额外空间，空间复杂度是 <code>O(1)</code>。</p><p><strong>题目二描述</strong></p><blockquote><p>在一个长度为 n+1 的数组中所有数字都在 1~n 范围内，所以数组中至少有一个数字重复。请找出任意一个重复的数字，但是不能修改原有的数组。  </p></blockquote><p><strong>解题思路</strong></p><p>由于数组中所有数字都在 <code>1 ~ n</code> 范围内，所以可以将 <code>1 ~ n</code> 的数组从中间值 <code>m</code> 分为 <code>1 ~ m</code> 和 <code>m+1 ~ n</code> 两部分。如果 <code>1 ~ m</code> 之间的数字超过了 <code>m</code> 个，表示重复数字在 <code>1 ~ m</code> 之间，否则在 <code>m+1 ~ n</code> 之间。</p><p>然后继续将包含重复数字的区间分为两部分，继续判断直到找到一个重复的数字。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">duplicateNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = ((end - start) &gt;&gt; <span class="number">1</span>) + start;</span><br><span class="line">        <span class="keyword">int</span> count = countRange(arr, start, mid);</span><br><span class="line">        <span class="keyword">if</span> (start == mid) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> start;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (count &gt; (mid - start + <span class="number">1</span>)) &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countRange</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= start &amp;&amp; arr[i] &lt;= end) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照二分查找的思路，函数 <code>countRange</code> 会被调用 <code>log(n)</code> 次，每次需要 <code>O(n)</code> 的时间，所以总的时间复杂度是 <code>O(nlogn)</code>。</p><h2 id="4-二位数组中的查找"><a href="#4-二位数组中的查找" class="headerlink" title="4. 二位数组中的查找"></a>4. 二位数组中的查找</h2><p><strong>题目描述</strong></p><blockquote><p>在一个二维数组中，每一行按照从左到右递增的顺序排序，每一列按照从上到下递增的顺序排序。要求实现一个函数，输入一个二位数组和一个整数，判断该整数是否在数组中。</p></blockquote><p><strong>解题思路</strong></p><p>这里可以选取左下角或右上角的元素进行比较。这里，以右上角为例：</p><p>对于右上角的元素，如果该元素大于要查找的数字，则要查找的数字一定在它的左边，将 <code>col--</code>，如果该元素小于要查找的数字，则要查找的数字一定在它的下边，将 <code>row++</code>，否则，找到了该元素，查找结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> target, <span class="keyword">int</span> [][] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span> || array[<span class="number">0</span>].length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> row = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> col = array[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(row &lt; array.length &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(array[row][col] &gt; target) &#123;</span><br><span class="line">            col--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[row][col] &lt; target) &#123;</span><br><span class="line">            row++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11. 旋转数组的最小数字"></a>11. 旋转数组的最小数字</h2><p><strong>题目描述</strong></p><blockquote><p>将一个数组最开始的几个元素移动数组的末尾，称为旋转数组。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。</p></blockquote><p><strong>解题思路</strong></p><p>由于数组在一定程度上是有序的，所以可以采用类似二分查找的方法来解决。可以使用两个指针，start 指向数组的第一个元素，end 指向最后一个元素，接着让 mid 指向数组的中间元素。</p><p>这里需要考虑一类特殊情况，就是数组中存在重复元素，例如 <code>1 1 1 0 1</code> 或者 <code>1 0 1 1 1</code> 的情况，这时利用二分法已经不能解决，只能进行顺序遍历。</p><p>一般情况下，判断数组中间元素（<code>mid</code>）与数组最后一个元素（<code>end</code>）的大小，如果数组中间元素大于最后一个元素，则中间元素属于前半部分的非递减子数组，例如 <code>3 4 5 1 2</code>。此时最小的元素一定位于中间元素的后面，则将 <code>start</code> 变为 <code>mid + 1</code>。</p><p>否则的话，也就是数组中间元素（<code>mid</code>）小于等于最后一个元素（<code>end</code>），则中间元素属于后半部分的非递减子数组中，例如 <code>2 0 1 1 1</code>，或者 <code>4 5 1 2 3</code>。此时最小的元素可能就是中间元素，可能在中间元素的前面，所以将 <code>end</code> 变为 <code>mid</code>。</p><p>如此，直到 <code>start</code> 大于等于 <code>end</code> 退出循环时，<code>start</code> 指向的就是最小的元素。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组长度为 1 时，该元素必然是最小的元素，也就不需要再判断 start == end 的情况</span></span><br><span class="line">    <span class="keyword">while</span>(start &lt; end) &#123; </span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (array[start] == array[end] &amp;&amp; array[start] == array[mid]) &#123;</span><br><span class="line">            <span class="keyword">return</span> min(array, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(array[mid] &gt; array[end]) &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> array[start];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">min</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = array[start];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= end; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] &lt; min) &#123;</span><br><span class="line">            min = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21. 调整数组顺序使奇数位于偶数前面"></a>21. 调整数组顺序使奇数位于偶数前面</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有的奇数位于数组的前半部分，所有的偶数位于数组的后半部分，并保证奇数和奇数，偶数和偶数之间的相对位置不变。</p></blockquote><p><strong>解题思路</strong></p><p>这里有两种解题思路：第一种是利用插入排序的思路（其实只要能保证稳定性的排序算法都可以），遍历数组，如果该元素是奇数，则对前面的元素进行，如果前面的元素是偶数则进行交换，直到找到一个奇数为止。</p><p>第二种是借助辅助数组，首先遍历一遍数组，将所有奇数元素保存到辅助数组中，并计算出奇数元素的个数；然后再遍历一遍辅助数组，将其中所有奇数元素放到原数组的前半部分，将所有偶数元素放到从 <code>count</code> 开始的后半部分。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 时间复杂度 O(n^2)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderOddEven1</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((data[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = data[i];</span><br><span class="line">            <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (; j &gt;= <span class="number">0</span> &amp;&amp; (data[j] &amp; <span class="number">1</span>) == <span class="number">0</span>; j--) &#123;</span><br><span class="line">                data[j + <span class="number">1</span>] = data[j];</span><br><span class="line">            &#125;</span><br><span class="line">            data[j + <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度 O(n) 空间复杂度 O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reorderOddEven2</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span> || data.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] tempArr = <span class="keyword">new</span> <span class="keyword">int</span>[data.length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((data[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        tempArr[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>, k = count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; data.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((tempArr[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            data[j++] = tempArr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[k++] = tempArr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里第一种做法，和插入排序的时间复杂度一致，平均情况下时间复杂度为 <code>O(n^2)</code>，在最好情况下时间复杂度是 <code>O(n)</code>。</p><p>而第二种做法，由于只需要遍历两次数组，所以时间复杂度为 <code>O(n)</code>。但是需要借助辅助数组，所以空间复杂度是 <code>O(n)</code>。</p><h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29. 顺时针打印矩阵"></a>29. 顺时针打印矩阵</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。如果输入如下 4 X 4 矩阵：<br> 1  2  3  4<br> 5  6  7  8<br> 9  10 11 12<br> 13 14 15 16<br> 则依次打印出数字 1,2,3,4,8,12,16,15,14,13,9,5,6,7,11,10。</p></blockquote><p><strong>解题思路</strong></p><p>在打印矩阵时，可以按照从外到内一圈一圈来打印，于是可以使用循环来打印矩阵，每次循环打印一圈。对于一个 <code>5 * 5</code> 的矩阵，循环结束条件是 <code>2 * 2 &lt; 5</code>，而对于一个 <code>6 * 6</code> 的矩阵，循环结束条件是 <code>2 * 3 &lt; 6</code>。所以可以得出循环结束的条件是 <code>2 * start &lt; rows &amp;&amp; 2 * start &lt; cols</code>。</p><p>在打印一圈时，可以分为从左到右打印第一行、从上到下打印最后一列、从右到左打印最后一行、从下到上打印第一列。但是这里需要考虑最后一圈退化为一行、一列的情况。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">printMatrix</span><span class="params">(<span class="keyword">int</span> [][] matrix)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> rows, cols;</span><br><span class="line">    <span class="keyword">if</span>(matrix == <span class="keyword">null</span> || (rows = matrix.length) &lt;= <span class="number">0</span> || (cols = matrix[<span class="number">0</span>].length) &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">2</span> * i &lt; rows &amp;&amp; <span class="number">2</span> * i &lt; cols) &#123;</span><br><span class="line">        printMatrixCore(matrix, i++, res);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatrixCore</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> start, ArrayList&lt;Integer&gt; res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> endX = matrix.length - start - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> endY = matrix[<span class="number">0</span>].length - start - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一行总是存在的</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= endY; i++) &#123;</span><br><span class="line">        res.add(matrix[start][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少要有两行</span></span><br><span class="line">    <span class="keyword">if</span>(endX &gt; start) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = start + <span class="number">1</span>; j &lt;= endX; j++) &#123;</span><br><span class="line">            res.add(matrix[j][endY]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少要有两行两列</span></span><br><span class="line">    <span class="keyword">if</span>(endX &gt; start &amp;&amp; endY &gt; start) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = endY - <span class="number">1</span>; i &gt;= start; i--) &#123;</span><br><span class="line">            res.add(matrix[endX][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 至少要有三行两列</span></span><br><span class="line">    <span class="keyword">if</span>(endX &gt; start + <span class="number">1</span> &amp;&amp; endY &gt; start) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = endX - <span class="number">1</span>; j &gt; start; j--) &#123;</span><br><span class="line">            res.add(matrix[j][start]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="39-数组中出现次数超过一半的数字"><a href="#39-数组中出现次数超过一半的数字" class="headerlink" title="39. 数组中出现次数超过一半的数字"></a>39. 数组中出现次数超过一半的数字</h2><p><strong>题目描述</strong></p><blockquote><p>数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。例如输入一个长度为 9 的数组 {1,2,3,2,2,2,5,4,2}。由于数字 2 在数组中出现了 5 次，超过数组长度的一半，因此输出 2。如果不存在则输出 0。</p></blockquote><p><strong>解题思路1</strong></p><p>由于有一个数字出现次数超过了数组长度的一半，所以如果数组有序的话，那么数组的中位数必然是出现次数超过一半的数。</p><p>但是这里没有必要完全对数组排好序。可以利用快速排序的思想，使用 <code>partition</code> 函数，对数组进行切分，使得切分元素之前的元素都小于等于它，之后的元素都大于等于它。</p><p>一次切分之后可以将切分元素的下标 <code>index</code> 与数组中间的 <code>mid</code> 比较，如果 <code>index</code> 大于 <code>mid</code>，表示中间值在左半部分，将 <code>end = mid - 1</code>，继续进行切分；而如果 <code>index</code> 小于 <code>mid</code>，表示中间值在右半部分，将 <code>start = mid + 1</code>，继续进行切分；否则表示找到了出现次数超过一半的元素。</p><p><strong>代码实现1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MoreThanHalfNum_Solution</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (end - start) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = partition(array, start, end);</span><br><span class="line">    <span class="keyword">while</span>(index != mid) &#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; mid) &#123;</span><br><span class="line">            end = index - <span class="number">1</span>;</span><br><span class="line">            index = partition(array, start, end);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = index + <span class="number">1</span>;</span><br><span class="line">            index = partition(array, start, end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(checkMoreThanHalf(array, array[index])) &#123;</span><br><span class="line">        <span class="keyword">return</span> array[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = array[left];</span><br><span class="line">    <span class="keyword">int</span> i = left, j = right + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; right &amp;&amp; array[++i] &lt; pivot) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == right) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; left &amp;&amp; array[--j] &gt; pivot) &#123; &#125;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= j) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[j];</span><br><span class="line">        array[j] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    array[left] = array[j];</span><br><span class="line">    array[j] = pivot;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> res)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(array[i] == res) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count * <span class="number">2</span> &gt; array.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解题思路2</strong></p><p>还有一种解题思路，它是利用数组的特点，使用一个 <code>times</code> 来记录某个数的出现的次数，然后遍历数组，如果 <code>times</code> 为 <code>0</code>，将当前元素赋给 <code>result</code>，并将 <code>times</code> 置为 <code>1</code>；否则如果当前元素等于 <code>result</code>，则将 <code>times</code> 加 <code>1</code>，否则将 <code>times</code> 减 <code>1</code>。</p><p>如此在遍历完数组，出现次数 <code>times</code> 大于等于 <code>1</code> 对应的那个数一定就是出现次数超过数组一半长度的数。</p><p><strong>代码实现2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span>[] number)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (number == <span class="keyword">null</span> || number.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> times = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (times == <span class="number">0</span>) &#123;</span><br><span class="line">            result = number[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (result == number[i]) &#123;</span><br><span class="line">            times++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            times--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkMoreThanHalf(number, result)) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span>[] number, <span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a : number) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a == result) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> count * <span class="number">2</span> &gt; number.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法只需要遍历一遍数组，就可以找到找到数组中出现次数超过一半的数，所以时间复杂度是 <code>O(n)</code>。虽然与前一种方法的时间复杂度一致，但无疑简洁了不少。</p><h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42. 连续子数组的最大和"></a>42. 连续子数组的最大和</h2><p><strong>题目描述</strong></p><blockquote><p>输入一个整型数组。数组里有正数和负数。数组中一个或多个连续的整数组成一个子数组，求所有子数组和的最大值。</p></blockquote><p><strong>解题思路</strong></p><p>可以从头到尾遍历数组，如果前面数个元素之和 <code>lastSum</code> 小于 <code>0</code>，就将其舍弃，将 <code>curSum</code> 赋值为 <code>array[i]</code>。否则将前面数个元素之和 <code>lastSum</code> 加上当前元素 <code>array[i]</code>，得到新的和 <code>curSum</code>。然后判断这个和 <code>curSum</code> 与保存的最大和 <code>maxSum</code>，如果 <code>curSum</code> 大于 <code>maxSum</code>，则将其替换。然后更新 <code>lastSum</code>，继续遍历数组进行比较。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findGreatestSumOfSubArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> lastSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> curSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxSum = Integer.MIN_VALUE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(lastSum &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            curSum = array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curSum = lastSum + array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curSum &gt; maxSum) &#123;</span><br><span class="line">            maxSum = curSum;</span><br><span class="line">        &#125;</span><br><span class="line">        lastSum = curSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51. 数组中的逆序对"></a>51. 数组中的逆序对</h2><p><strong>题目描述</strong></p><blockquote><p>在数组中的两个数字，如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对。输入一个数组,求出这个数组中的逆序对的总数 P，并将 P 对 1000000007 取模的结果输出，即输出 P%1000000007。</p></blockquote><p><strong>解题思路</strong></p><p>首先把数组分成两个子数组，然后递归地对子数组求逆序对，统计出子数组内部的逆序对的数目。</p><p>由于已经统计了子数组内部的逆序对的数目，所以需要这两个子数组进行排序，避免在后面重复统计。在排序的时候，还要统计两个子数组之间的逆序对的数目。</p><p>注意，这里如果 <code>aux[i] &gt; aux[j]</code>，应该是 <code>count += mid + 1 - i;</code>，也就是从下标为 <code>i ~ mid</code> 的元素与下标为 <code>j</code> 的元素都构成了逆序对。而如果是 <code>count += j - mid;</code> 的话，则成了下标为 <code>i</code> 的元素与下标为 <code>mid + 1 ~ j</code> 的元素构成了逆序对，后面会出现重复统计的情况。</p><p>最后对两个子数组内部的逆序对和两个子数组之间的逆序对相加，返回即可。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] aux = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line">    <span class="keyword">return</span> inversePairs(array, aux, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">inversePairs</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span>[] aux, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(start &gt;= end) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> left = inversePairs(data, aux, start, mid);</span><br><span class="line">    <span class="keyword">int</span> right = inversePairs(data, aux, mid + <span class="number">1</span>, end);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">        aux[i] = data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = start;</span><br><span class="line">    <span class="keyword">int</span> j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = start; k &lt;= end; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt; mid) &#123;</span><br><span class="line">            data[k] = aux[j++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j &gt; end) &#123;</span><br><span class="line">            data[k] = aux[i++];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(aux[i] &gt; aux[j]) &#123;</span><br><span class="line">            data[k] = aux[j++];</span><br><span class="line">            count += mid + <span class="number">1</span> - i;</span><br><span class="line">            count %= <span class="number">1000000007</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            data[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (left + right + count) % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法与归并排序的时间、空间复杂度一致，每次排序的时间为 <code>O(n)</code>，总共需要 <code>O(logn)</code> 次，所以总的时间复杂度是 <code>O(nlogn)</code>。在归并时需要辅助数组，所以其空间复杂度为 <code>O(n)</code>。</p><h2 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53. 在排序数组中查找数字"></a>53. 在排序数组中查找数字</h2><p><strong>题目一描述</strong></p><blockquote><p>统计一个数字在排序数组中出现的次数。</p></blockquote><p><strong>解题思路</strong></p><p>对于排序数组，可以使用两次二分查找分别找到要查找的数字第一次和最后一次出现的数组下标。然后就可以计算出该数字出现的次数。</p><p>查找第一次出现的数组下标时，如果数组中间元素大于该数字 <code>k</code>，则在数组左半部分去查找，否则数组中间元素小于该数字 <code>k</code>，则在数组右半部分去查找。</p><p>当中间元素等于 <code>k</code> 时，则需要判断 <code>mid</code>，如果 <code>mid</code> 前面没有数字，或者前面的数字不等于 <code>k</code>，则找到了第一次出现的数组下标；否则继续在数组左半部分去查找。</p><p>查找最后一次出现的数组下标与查找第一次出现的思想类似，这里就不再赘述了。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">GetNumberOfK</span><span class="params">(<span class="keyword">int</span> [] array , <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = getFirstIndex(array, k);</span><br><span class="line">    <span class="keyword">int</span> right = getLastIndex(array, k);</span><br><span class="line">    <span class="keyword">if</span>(left != -<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> right - left + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getFirstIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == array[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == <span class="number">0</span> || array[mid - <span class="number">1</span>] != k) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; array[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLastIndex</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = array.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(k == array[mid]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid == end || array[mid + <span class="number">1</span>] != k) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                start = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(k &lt; array[mid]) &#123;</span><br><span class="line">            end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二描述</strong></p><blockquote><p>一个长度为 n 的递增数组中的所有数字都是唯一的，并且每个数字都在 [0, n] 范围内，在 [0, n] 范围内的 n+1 个数字中有且只有一个数字不在数组中，请找出这个数字。</p></blockquote><p><strong>解题思路</strong></p><p>由于数组是有序的，所以数组开始的一部分数字与它们对应的下标是相等。如果不在数组中的数字为 <code>m</code>，则它前面的数字与它们的下标都相等，它后面的数字比它们的下标都要小。</p><p>可以使用二分查找，如果中间元素的值和下标相等，则在数组右半部分查找；如果不相等，则需要进一步判断，如果它前面没有元素，或者前面的数字和它的下标相等，则找到了 <code>m</code>；否则继续在左半部分查找。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMissingNumber</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = arr.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] != mid) &#123;</span><br><span class="line">            <span class="comment">// 当前不相等，前一个相等，表示找到了</span></span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || arr[mid - <span class="number">1</span>] == mid - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="comment">// 左半边查找</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                end = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//右半边查找</span></span><br><span class="line">            start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start == arr.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.length;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="56-数组中数字出现的次数"><a href="#56-数组中数字出现的次数" class="headerlink" title="56. 数组中数字出现的次数"></a>56. 数组中数字出现的次数</h2><p><strong>题目一描述</strong></p><blockquote><p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p></blockquote><p><strong>解题思路</strong></p><p>这里解题思路有些巧妙，使用位元素来解决，由于两个相等的数字异或后结果为 <code>0</code>，所以遍历该数组，依次异或数组中的每一个元素，那么最终的结果就是那两个只出现一次的数字异或的结果。</p><p>由于这两个数字肯定不一样，异或的结果也肯定不为 <code>0</code>，也就是它的二进制表示中至少有一位是 <code>1</code>，将该位求出后记为 <code>n</code>。</p><p>可以将以第 <code>n</code> 位为标准将原数组分为两个数组，第一个数组中第 <code>n</code> 位是 <code>1</code>，而第二个数组中第 <code>n</code> 位是 <code>0</code>，而两个只出现一次的数字必然各出现在一个数组中，并且数组中的元素异或的结果就是只出现一次的那个数字。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">findNumsAppearOnce</span><span class="params">(<span class="keyword">int</span> [] array,<span class="keyword">int</span> num1[] , <span class="keyword">int</span> num2[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(array == <span class="keyword">null</span> || array.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        num ^= array[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> index = bitOf1(num);</span><br><span class="line">    <span class="keyword">int</span> mark = <span class="number">1</span> &lt;&lt; index;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>((array[i] &amp; mark) == <span class="number">0</span>) &#123;</span><br><span class="line">            num1[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            num2[<span class="number">0</span>] ^= array[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bitOf1</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((num &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>题目二描述</strong></p><blockquote><p>一个整型数组里除了一个数字只出现了一次之外，其他的数字都出现了三次。请找出那个只出现一次的数字。</p></blockquote><p><strong>解题思路</strong></p><p>这里由于出现了三次，虽然不能再使用异或运算，但同样可以使用位运算。可以从头到尾遍历数组，将数组中每一个元素的二进制表示的每一位都加起来，使用一个 <code>32</code> 位的辅助数组来存储二进制表示的每一位的和。</p><p>对于所有出现三次的元素，它们的二进制表示的每一位之和，肯定可以被 <code>3</code> 整除，所以最终辅助数组中如果某一位能被 <code>3</code> 整除，那么那个只出现一次的整数的二进制表示的那一位就是 <code>0</code>，否则就是 <code>1</code>。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findNumberAppearOnce</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span>[] num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] bitSum = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> bitMask = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">31</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> bit = arr[i] &amp; bitMask;</span><br><span class="line">            <span class="keyword">if</span> (bit != <span class="number">0</span>) &#123;</span><br><span class="line">                bitSum[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">            bitMask &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        result &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        result += bitSum[i] % <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    num[<span class="number">0</span>] = result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66. 构建乘积数组"></a>66. 构建乘积数组</h2><p><strong>题目描述</strong></p><blockquote><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B 中的元素 B[i]=A[0]&times;A[1]&times;…&times;A[i-1]&times;A[i+1]&times;…&times;A[n-1]。不能使用除法。</p></blockquote><p><strong>解题思路</strong></p><p>这里要求 <code>B[i] = A[0] * A[1] * ... *  A[i-1] * A[i+1] * ... * A[n-1]</code>，可以将其分为分为两个部分的乘积。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A[<span class="number">0</span>] * A[<span class="number">1</span>] * ... * A[i-<span class="number">2</span>] * A[i-<span class="number">1</span>]</span><br><span class="line">A[i+<span class="number">1</span>] * A[i+<span class="number">2</span>] * ... * A[n-<span class="number">2</span>] * A[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>可以使用两个循环，第一个循环采用自上而下的顺序，<code>res[i] = res[i - 1] * arr[i - 1]</code> 计算前半部分，第二循环采用自下而上的顺序，<code>res[i] *= (temp *= arr[i + 1])</code>。</p><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] multiply(<span class="keyword">int</span>[] arr) &#123;</span><br><span class="line">    <span class="comment">// arr [2, 1, 3, 4, 5]</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="keyword">null</span> || arr.length &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">    result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">        result[i] = arr[i - <span class="number">1</span>] * result[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// result [1, 2, 2, 6, 24]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = result.length - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        temp = arr[i + <span class="number">1</span>] * temp;</span><br><span class="line">        result[i] = result[i] * temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// temp  60  60   20  5   1</span></span><br><span class="line">    <span class="comment">// result [60, 120, 40, 30, 24]</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法难，难如上青天，但是难也得静下心来慢慢学习，并总结归纳。所以将剑指 &lt;code&gt;offer&lt;/code&gt; 中的题目按照类别进行了归纳，这是第一篇–数组篇。当然，如果各位大佬发现程序有什么 &lt;code&gt;bug&lt;/code&gt; 或其他更巧妙的思路，欢迎交流学习。&lt;/p&gt;
    
    </summary>
    
      <category term="1. 算法" scheme="https://blog.timberliu.com/categories/1-%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="剑指offer" scheme="https://blog.timberliu.com/tags/%E5%89%91%E6%8C%87offer/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 深入理解 ReentrantReadWriteLock</title>
    <link href="https://blog.timberliu.com/2019/04/15/039_ReentrantReadWriteLock/"/>
    <id>https://blog.timberliu.com/2019/04/15/039_ReentrantReadWriteLock/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h1><p><code>ReentrantLock</code> 是排它锁，它在同一时刻只允许一个线程进行访问。在很多场景中，读服务远多于写服务，而读服务之间不存在数据竞争问题，在一个线程读数据时禁止其他读线程访问，会导致性能降低。</p><p>所以就有了读写锁，它在同一时刻可以允许多个读线程访问，但在写线程访问时，则所有的读线程和其他写线程都会被阻塞。读写锁内部维护了一个读锁和一个写锁，如此将读写锁分离，可以很大地提升并发性和吞吐量。<a id="more"></a></p><p><strong>ReadWriteLock</strong></p><p><code>ReadWriteLock</code> 接口定义了读锁和写锁的两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>readLock()</code> 方法用于返回读操作的锁，<code>writeLock()</code> 用于返回写操作的锁。</p><p><strong>实现类</strong></p><p><code>ReentrantReadWriteLock</code> 实现了 <code>ReadWriteLock</code> 接口，它的几个重要属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部类 ReadLock，读锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.ReadLock readerLock;</span><br><span class="line"><span class="comment">// 内部类 WriteLock 写锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock.WriteLock writerLock;</span><br><span class="line"><span class="comment">// 同步器，读写和写锁依赖于它</span></span><br><span class="line"><span class="keyword">final</span> Sync sync;</span><br></pre></td></tr></table></figure><p>其中有两个构造方法，主要如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定公平性</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">ReadLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteLock</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">WriteLock</span><span class="params">(ReentrantReadWriteLock lock)</span> </span>&#123;</span><br><span class="line">        sync = lock.sync;</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>ReentrantReadWriteLock</code> 锁的主体依然是 <code>Sync</code>，读锁和写锁都依赖与 <code>Sync</code> 来实现，它们使用的是同一个锁，只是在获取锁和释放锁的方式不同。</p><h1 id="读写状态"><a href="#读写状态" class="headerlink" title="读写状态"></a>读写状态</h1><p>在 <code>ReentrantLock</code> 中使用一个 <code>int</code> 型变量 <code>state</code> 来表示同步状态，该值表示锁被一个线程重复获取的次数，而读写锁中需要一个 <code>int</code> 型变量上维护多个读线程和一个写线程的状态。</p><p>所以它将该变量分为两部分，高 <code>16</code> 位表示读，低 <code>16</code> 位表示写。分割之后通过位运算来计算读锁和写锁的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">// 写锁状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><h1 id="内部工作状态"><a href="#内部工作状态" class="headerlink" title="内部工作状态"></a>内部工作状态</h1><p>另外，<code>ReentrantReadWriteLock</code> 还提供了返回内部工作状态的方法。</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>getReadLockCount</td><td>返回读锁被获取的次数（锁重入次数也会加 1）</td></tr><tr><td>isWriteLocked</td><td>返回写锁是否被获取</td></tr><tr><td>getWriteHoldCount</td><td>返回当前线程获取写锁的次数</td></tr><tr><td>getReadHoldCount</td><td>返回当前线程获取读锁的次数</td></tr></tbody></table><p>前面三个方法都比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadLockCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sharedCount(getState()); <span class="comment">// c &gt;&gt;&gt; SHARED_SHIFT</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isWriteLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> exclusiveCount(getState()) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于写锁只会被一个线程获取</span></span><br><span class="line"><span class="comment">// 所以，如果是当前线程，则通过 c &amp; EXCLUSIVE_MASK 直接计算即可</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getWriteHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isHeldExclusively() ? exclusiveCount(getState()) : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个方法，首先来看一下 <code>Sync</code> 类的几个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前线程持有的读锁数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> ThreadLocalHoldCounter readHolds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HoldCounter 的一个缓存，减少 ThreadLocal.get 的次数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="comment">// 第一个获取到读锁的读线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="comment">// 第一个读线程持有的读锁数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"><span class="comment">// 上面三个都是为了提高效率，如果读锁仅有一个或有缓存了，就不用去 ThreadLocalHoldCounter 获取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读线程持有锁的计数器，需要与线程绑定</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 持有线程 id，在释放锁时，判断 cacheHoldCounter 缓存的是否是当前线程的读锁数量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过 ThreadLocal 将 HoldCounter 绑定到线程上</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalHoldCounter</span></span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">HoldCounter</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> HoldCounter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HoldCounter();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync() &#123;</span><br><span class="line">    readHolds = <span class="keyword">new</span> ThreadLocalHoldCounter();</span><br><span class="line">    setState(getState()); <span class="comment">// ensures visibility of readHolds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>getReadHoldCount()</code> 方法用于获取当前线程获取读锁的次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getReadHoldCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果读锁被获取的次数为 0，那么当前线程获取读锁的次数肯定也为 0</span></span><br><span class="line">    <span class="keyword">if</span> (getReadLockCount() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果当前线程是第一个获取读锁的线程，则直接返回 firstReaderHoldCount</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current)</span><br><span class="line">        <span class="keyword">return</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 缓存的 HoldCounter 绑定的线程是否是当前线程，如果是则直接返回读锁数量</span></span><br><span class="line">    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">    <span class="keyword">if</span> (rh != <span class="keyword">null</span> &amp;&amp; rh.tid == getThreadId(current))</span><br><span class="line">        <span class="keyword">return</span> rh.count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则从 ThreadLocalHoldCounter 中获取 HoldCounter，再获取读锁数量</span></span><br><span class="line">    <span class="keyword">int</span> count = readHolds.get().count;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) readHolds.remove(); <span class="comment">// 防止内存泄露</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h1><p>写锁是一个支持可重入的排它锁。</p><h2 id="写锁的获取"><a href="#写锁的获取" class="headerlink" title="写锁的获取"></a>写锁的获取</h2><p><code>WriteLock</code> 的 <code>lock()</code> 方法如下，可以看到，这里调用的是 <code>AQS</code> 的独占式获取锁方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">    selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在获取写锁时，调用 <code>AQS</code> 的 <code>acquire</code> 方法，其中又调用了 <code>Sync</code> 自定义组件实现的 <code>tryAcquire</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c); <span class="comment">// 写锁个数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c != 0 &amp;&amp; w == 0 表示有线程获取了读锁</span></span><br><span class="line">        <span class="comment">// 或者当前线程不是持有锁的线程，则失败</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 如果写锁会超过范围，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 当前线程获取写锁，可重入</span></span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有任何线程获取读锁和写锁，当前线程尝试获取写锁</span></span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">        !compareAndSetState(c, c + acquires))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里如果有线程获取了读锁，则当前线程不能再获取写锁。因为读写锁需要确保获取写锁的线程的操作对于读锁的线程是可见的，如果存在读锁时再允许获取写锁，则获取读锁的线程可能无法得知当前获取写锁的线程的操作。</p><p>判断获取写锁的线程是否应该被阻塞，公平锁和非公平中实现不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于非公平锁，直接返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于公平锁，则需要判断是否有前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = tail;</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="写锁的释放"><a href="#写锁的释放" class="headerlink" title="写锁的释放"></a>写锁的释放</h2><p><code>unlock()</code> 方法如下，其中调用了 <code>AQS</code> 的 <code>release</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继节点</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>release()</code> 方法首先调用 <code>Sync</code> 中的 <code>tryRelease()</code> 方法，然后唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">    <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (free)</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    setState(nextc);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先减少写状态值，如果写状态为 <code>0</code>，则表示写锁已经被释放，将持有锁的线程设置为 <code>null</code>，并更改同步状态值。</p><h1 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h1><p>读锁是一个支持可重入的共享锁，它能被多个线程同时获取。</p><h2 id="读锁的获取"><a href="#读锁的获取" class="headerlink" title="读锁的获取"></a>读锁的获取</h2><p><code>ReadLock</code> 的 <code>lock()</code> 方法如下，其中调用了 <code>AQS</code> 的共享式获取锁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>acquireShared</code> 方法中，又调用了 <code>Sync</code> 的 <code>tryAcquireShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 存在写锁，并且写锁被其他线程持有，则失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    <span class="comment">// 获取读锁的线程是否需要阻塞</span></span><br><span class="line">    <span class="comment">// 读锁小于 MAX_COUNT(1 &lt;&lt; 16)</span></span><br><span class="line">    <span class="comment">// 使用 CAS 更新状态为 c + 1 &lt;&lt; 16</span></span><br><span class="line">    <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">        r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">        compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 没有读锁</span></span><br><span class="line">            firstReader = current;</span><br><span class="line">            firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">            <span class="comment">// 读锁仅有一个</span></span><br><span class="line">            firstReaderHoldCount++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            HoldCounter rh = cachedHoldCounter;</span><br><span class="line">            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                <span class="comment">//更新缓存</span></span><br><span class="line">                cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 将 HoldCounter 设置到 ThreadLocal 中</span></span><br><span class="line">                readHolds.set(rh);</span><br><span class="line">            <span class="comment">// 读锁数量加 1</span></span><br><span class="line">            rh.count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，如果满足上述三个条件，则获取读锁成功，会对 <code>firstReaderHoldCount</code> 等值进行设置，稍后详细介绍。如果不满足时，会调用 <code>fullTryAcquireShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">    HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="comment">// 如果写锁不为 0</span></span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前线程不是持有写锁的线程，返回</span></span><br><span class="line">            <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 读锁是否需要被阻塞</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">            <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">            <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                        rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读锁超出最大范围</span></span><br><span class="line">        <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="comment">// 使用 CAS 更新状态值，尝试获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                firstReader = current;</span><br><span class="line">                firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                firstReaderHoldCount++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                    rh = cachedHoldCounter;</span><br><span class="line">                <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                    rh = readHolds.get();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                    readHolds.set(rh);</span><br><span class="line">                rh.count++;</span><br><span class="line">                cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断读锁是否应该被阻塞，公平锁和非公平锁实现不同，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">NonfairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于非公平锁，需要判断同步队列中第一个结点是否是独占式（写锁）</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node h, s;</span><br><span class="line">    <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">        !s.isShared()         &amp;&amp;</span><br><span class="line">        s.thread != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">FairSync</span> <span class="keyword">extends</span> <span class="title">Sync</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于公平锁，需要判断是否有前驱节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="读锁的释放"><a href="#读锁的释放" class="headerlink" title="读锁的释放"></a>读锁的释放</h2><p><code>ReadLock</code> 的 <code>unlock</code> 方法如下，其中调用的是 <code>AQS</code> 的共享式释放锁方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>releaseShared</code> 方法中又调用了 <code>Sync</code> 的 <code>tryReleaseShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 如果当前线程是第一个获取读锁的线程</span></span><br><span class="line">    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">        <span class="keyword">if</span> (firstReaderHoldCount == <span class="number">1</span>)</span><br><span class="line">            <span class="comment">// 仅获取了一次，将 firstReader 置为 null</span></span><br><span class="line">            firstReader = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// 否则将 firstReadHoldCount 减 1</span></span><br><span class="line">            firstReaderHoldCount--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        HoldCounter rh = cachedHoldCounter;</span><br><span class="line">        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">            <span class="comment">// 缓存如果有效，直接使用；否则重新获取</span></span><br><span class="line">            rh = readHolds.get();</span><br><span class="line">        <span class="keyword">int</span> count = rh.count;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            readHolds.remove();</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">throw</span> unmatchedUnlockException();</span><br><span class="line">        &#125;</span><br><span class="line">        --rh.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环使用 CAS 更新状态值</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="锁降级"><a href="#锁降级" class="headerlink" title="锁降级"></a>锁降级</h1><p><code>ReentrantReadWriteLock</code> 允许锁降级，也就是写锁降级为读锁。它是指先获取写锁，再获取到读锁，最后释放写锁的过程。但锁升级是不允许的，也就是先获取读锁，再获取写锁，最后释放读锁的过程。</p><p>在获取读锁的 <code>tryAcquireShared</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="comment">// 存在写锁，并且写锁被其他线程持有，则失败</span></span><br><span class="line">    <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">        getExclusiveOwnerThread() != current)</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果存在写锁，并且写锁被其他线程持有时，才会失败。说明如果当前线程持有了写锁，也可以再获取读锁。最后释放写锁，这称为锁降级。</p><p>为何要这样做呢？试想如果一个线程获取了写锁，这个时候其他任何线程都是无法再获取读锁或写锁的，然后该线程再去获取读锁，也就不会产生任何的竞争。通过这种锁降级机制，就不会有释放写锁后，再去竞争获取读锁的情况，避免了锁的竞争和线程的上下文切换，也就提高了效率。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://cmsblogs.com/?p=2213" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之读写锁：ReentrantReadWriteLock</a></li><li><a href="http://ifeve.com/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B-%E8%AF%BB%E9%94%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E8%A7%A3%E9%87%8A%E5%85%B3%E4%BA%8E%E9%94%81%E9%99%8D%E7%BA%A7%E7%9A%84%E4%BA%89/" target="_blank" rel="noopener">并发编程之——读锁源码分析(解释关于锁降级的争议)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ReentrantReadWriteLock&quot;&gt;&lt;a href=&quot;#ReentrantReadWriteLock&quot; class=&quot;headerlink&quot; title=&quot;ReentrantReadWriteLock&quot;&gt;&lt;/a&gt;ReentrantReadWriteLock&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是排它锁，它在同一时刻只允许一个线程进行访问。在很多场景中，读服务远多于写服务，而读服务之间不存在数据竞争问题，在一个线程读数据时禁止其他读线程访问，会导致性能降低。&lt;/p&gt;
&lt;p&gt;所以就有了读写锁，它在同一时刻可以允许多个读线程访问，但在写线程访问时，则所有的读线程和其他写线程都会被阻塞。读写锁内部维护了一个读锁和一个写锁，如此将读写锁分离，可以很大地提升并发性和吞吐量。&lt;/p&gt;
    
    </summary>
    
      <category term="2.4 Java 并发" scheme="https://blog.timberliu.com/categories/2-4-Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://blog.timberliu.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 深入理解 Condition</title>
    <link href="https://blog.timberliu.com/2019/04/15/040_Condition/"/>
    <id>https://blog.timberliu.com/2019/04/15/040_Condition/</id>
    <published>2019-04-14T16:00:00.000Z</published>
    <updated>2019-04-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Condition-接口"><a href="#Condition-接口" class="headerlink" title="Condition 接口"></a>Condition 接口</h1><p>在 <code>Java</code> 中，每一个对象都有 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 等方法，这些方法和 <code>synchronized</code> 关键字配合，可以实现等待/通知模式。而在 <code>Condition</code> 中同样提供了类似的方法，它们与 <code>Lock</code> 配合，也可以实现等待/通知模式。<a id="more"></a></p><p>在使用 <code>Condition</code> 时，需要通过 <code>Lock</code> 对象的 <code>newCondition</code> 方法进行创建，调用 <code>await</code> 方法和 <code>signal</code> 等方法时，也需要先获取锁。</p><p><code>Condition</code> 的 <code>await</code> 和 <code>signal</code> 方法如下，其他方法稍后会详细介绍：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>await()</td><td>使当前线程等待，直到另一个线程调用 signal 或 signalAll 方法将其唤醒，或者其他线程调用 interrupt 方法将其中断</td></tr><tr><td>signal()</td><td>唤醒一个等待的线程，唤醒的线程从 await 方法返回前必须重新获取锁</td></tr></tbody></table><p>下面通过 <code>Condition</code> 和队列实现一个简单的生产者-消费者例子，来了解 <code>Condition</code> 的使用方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProducerConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存放产品的队列</span></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; products = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">// 如果队列满了，则线程等待在该 condition 上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition full = lock.newCondition();</span><br><span class="line">    <span class="comment">// 如果队列为空，则线程等待在该 condition 上</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Condition empty = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Consumer()).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Producer()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProducerConsumer producerConsumer = <span class="keyword">new</span> ProducerConsumer();</span><br><span class="line">        producerConsumer.init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果队列满了</span></span><br><span class="line">                    <span class="keyword">while</span>(products.size() == MAX) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"products is full, please wait"</span>);</span><br><span class="line">                        <span class="comment">// 线程等待，直到被唤醒</span></span><br><span class="line">                        full.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (products.offer(++val)) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Producer put a object to product "</span> + val);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="comment">// 产出了产品，唤醒等待在 empty 上的线程</span></span><br><span class="line">                        empty.signal();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Integer value;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 如果队列为空</span></span><br><span class="line">                    <span class="keyword">while</span> (products.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"products is empty, please wait"</span>);</span><br><span class="line">                        <span class="comment">// 则线程等待在 empty 上</span></span><br><span class="line">                        empty.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> ((value = products.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Consumer get a object from product "</span> + value);</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                        <span class="comment">// 消费了产品后，唤醒等待在 full 上的线程</span></span><br><span class="line">                        full.signal();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    lock.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Condition-实现分析"><a href="#Condition-实现分析" class="headerlink" title="Condition 实现分析"></a>Condition 实现分析</h1><p>前面说了在使用 <code>Condition</code> 时，需要调用 <code>Lock</code> 的 <code>newCondition</code> 方法，而 <code>ReentrantLock</code> 或是 <code>ReentrantReadWriteLock</code> 内部又是调用的 <code>Sync</code> 的 <code>newCondition</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> ConditionObject <span class="title">newCondition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 <code>ConditionObject</code> 就是实现等待/通知模式的具体类，它实现了 <code>Condition</code> 接口，是 <code>AQS</code> 的一个内部类，提供了 <code>await</code>、<code>signal</code>、<code>signalAll</code> 等方法。</p><p>下面从等待队列、<code>await</code> 方法、<code>signal</code> 方法三个方面来分析 <code>ConditionObject</code> 的实现：</p><h2 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h2><p>每个 <code>ConditionObject</code> 对象内部维护着一个等待队列，队列中的节点都代表着一个在 <code>ConditionObject</code> 上等待的线程，等待队列的节点复用了 <code>AQS</code> 内部同步队列的节点，使用的都是同步器的 <code>Node</code> 对象。</p><p><code>ConditionObject</code> 中定义了两个 <code>Node</code> 引用，分别指向等待队列的首节点和尾节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConditionObject</span> <span class="keyword">implements</span> <span class="title">Condition</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待队列的第一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node firstWaiter;</span><br><span class="line">    <span class="comment">// 等待队列的最后一个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Node lastWaiter;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个线程调用了 <code>await</code> 方法，该线程就会释放锁、构成成节点加入到等待队列中，并进入等待状态。其中将线程构造成节点，并加入到等待队列中，这一步通过 <code>addConditionWaiter</code> 方法来实现，这里也并不需要使用 <code>CAS</code>，因为调用 <code>await</code> 的方法一定是获取了锁的线程，也就确保了线程安全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = lastWaiter;</span><br><span class="line">    <span class="comment">// 如果最后一个节点被取消了，则需要清理掉</span></span><br><span class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">        t = lastWaiter;</span><br><span class="line">    &#125;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">        firstWaiter = node;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        t.nextWaiter = node;</span><br><span class="line">    lastWaiter = node;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先会检查最后一个节点是否被取消了，如果是则会调用 <code>unlinkCancelledWaiters</code> 方法清理掉；否则将当前线程构造成节点，等待状态设为 <code>Node.CONDITION</code>，加入到等待队列的尾部。</p><p><code>unlinkCancelledWaiters</code> 方法会从等待队列头开始遍历，删除掉不是等待状态的节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unlinkCancelledWaiters</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node t = firstWaiter;</span><br><span class="line">    Node trail = <span class="keyword">null</span>; <span class="comment">// 保存前一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node next = t.nextWaiter;</span><br><span class="line">        <span class="keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">            t.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (trail == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                trail.nextWaiter = next;</span><br><span class="line">            <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">                lastWaiter = trail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            trail = t;</span><br><span class="line">        t = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="await-方法"><a href="#await-方法" class="headerlink" title="await 方法"></a>await 方法</h2><p><code>ConditionObject</code> 的 <code>await</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 将当前线程构造成节点加入到等待队列中</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先调用 <code>addConditionWaiter</code> 方法将当前线程重新构造成一个节点，加入到等待队列中。然后会调用 <code>fullyRelease</code> 方法释放同步状态，唤醒同步队列中的后继节点。</p><p>然后循环判断如果当前线程是否在同步队列中，也就是当前线程是否被唤醒了，如果被唤醒会将当前线程加入到同步队列中。这里就会跳出 <code>while</code> 循环，然后调用 <code>acquireQueued</code> 方法开始尝试获取同步状态。</p><p>这里如果其他线程对当前线程进行中断，则会抛出 <code>InterruptedException</code>。</p><h2 id="signal-方法"><a href="#signal-方法" class="headerlink" title="signal 方法"></a>signal 方法</h2><p><code>ConditionObject</code> 的 <code>signal</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    Node first = firstWaiter;</span><br><span class="line">    <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">        doSignal(first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>signal</code> 方法首先会调用 <code>isHeldExclusively</code> 方法判断当前线程是否获取了锁，接着如果等待队列不为空，会调用 <code>doSignal</code> 方法唤醒队列中的首节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">            lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">        first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!transferForSignal(first) &amp;&amp;</span><br><span class="line">             (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会将 <code>first.nextWaiter</code> 置为 <code>null</code>，并调用 <code>transferForSignal</code> 方法将同步状态变为 <code>0</code>，并将其加入到同步队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将状态由等待变为 0</span></span><br><span class="line">    <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    Node p = enq(node);</span><br><span class="line">    <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">        LockSupport.unpark(node.thread);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里会调用 <code>enq</code> 方法将当前线程插入到同步队列中尾部，然后返回前一个节点。如果前一个节点被取消，或者设置前一个节点为 <code>SINGAL</code> 失败，则需要调用 <code>LockSupport.unpark</code> 唤醒当前线程。</p><h1 id="await-和-signal"><a href="#await-和-signal" class="headerlink" title="await 和 signal"></a>await 和 signal</h1><p>这里将 <code>await</code> 和 <code>signal</code> 整体的流程大概梳理一下：</p><ul><li>当一个线程 <code>A</code> 调用了 <code>await</code> 方法后，首先会将当前线程 <code>A</code> 重新构成一个节点加入到等待队列中（<code>addConditionWaiter</code>）；</li><li>然后当前线程 <code>A</code> 释放同步状态（<code>fullyRelease</code>），自循环判断是否处于同步队列中（<code>isOnSyncQueue</code>），即是否被唤醒。</li><li>当另一个线程 <code>B</code> 调用了 <code>signal</code> 方法后（假设上一个线程 <code>A</code> 已处于等待队列的头部），则会将线程 <code>A</code> 加入到同步队列中，并唤醒线程 <code>A</code>（<code>transferForSignal</code>）。</li><li>线程 <code>A</code> 被唤醒后，处于同步队列中，就会退出 <code>await</code> 的 <code>while</code> 循环，重新去尝试获取同步状态（<code>acquireQueued</code>）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Condition-接口&quot;&gt;&lt;a href=&quot;#Condition-接口&quot; class=&quot;headerlink&quot; title=&quot;Condition 接口&quot;&gt;&lt;/a&gt;Condition 接口&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 中，每一个对象都有 &lt;code&gt;wait&lt;/code&gt;、&lt;code&gt;notify&lt;/code&gt;、&lt;code&gt;notifyAll&lt;/code&gt; 等方法，这些方法和 &lt;code&gt;synchronized&lt;/code&gt; 关键字配合，可以实现等待/通知模式。而在 &lt;code&gt;Condition&lt;/code&gt; 中同样提供了类似的方法，它们与 &lt;code&gt;Lock&lt;/code&gt; 配合，也可以实现等待/通知模式。&lt;/p&gt;
    
    </summary>
    
      <category term="2.4 Java 并发" scheme="https://blog.timberliu.com/categories/2-4-Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://blog.timberliu.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 深入理解 ReentrantLock</title>
    <link href="https://blog.timberliu.com/2019/04/14/038_ReentrantLock/"/>
    <id>https://blog.timberliu.com/2019/04/14/038_ReentrantLock/</id>
    <published>2019-04-13T16:00:00.000Z</published>
    <updated>2019-04-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入理解-ReentrantLock"><a href="#深入理解-ReentrantLock" class="headerlink" title="深入理解 ReentrantLock"></a>深入理解 ReentrantLock</h1><p><code>ReentrantLock</code> 是一种可重入锁，它指的是一个线程能够对资源重复加锁。<code>ReentrantLock</code> 与 <code>synchronized</code> 类似，能够保证解决线程安全问题，但是却提供了比 <code>synchronized</code> 更强大、灵活的机制，例如可中断式的获取锁、可定时的获取锁等。<a id="more"></a></p><p>另外，<code>ReentrantLock</code> 也提供了公平锁与非公平锁的选择，它们之间的区别主要就是看对锁的获取与获取锁的请求的顺序是否是一致的，选择公平锁时，等待时间最长的线程会最优先获取到锁，但是公平锁获取的效率通常比非公平锁要低。可以在构造方法中通过传参的方式来具体指定选择公平或非公平。</p><h1 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h1><p>在 <code>ReentrantLock</code> 中，有一个抽象内部类 <code>Sync</code>，它继承自 <code>AQS</code>，<code>ReentrantLock</code> 的大部分功能都委托给 <code>Sync</code> 进行实现，其内部定义了 <code>lock()</code> 抽象方法，默认实现了 <code>nonfairTryAcquire()</code> 方法，它是非公平锁的默认实现。</p><p><code>Sync</code> 有两个子类：公平锁 <code>FairSync</code> 和 <code>NonFairSync</code>，实现了 <code>Sync</code> 中的 <code>lock()</code> 方法和 <code>AQS</code> 中的 <code>tryAcquire()</code> 方法。</p><h2 id="NonFairSync"><a href="#NonFairSync" class="headerlink" title="NonFairSync"></a>NonFairSync</h2><p><code>NonFairSync</code> 中 <code>lock()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，非公平锁可以立即尝试获取锁，如果失败的话，会调用 <code>AQS</code> 中的 <code>acquire</code> 方法，其中 <code>acquire</code> 方法又会调用由自定义组件实现的 <code>tryAcquire</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>nonfairTryAcquire()</code> 方法在 <code>Sync</code> 中已经默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 CAS 设置同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// 整数溢出</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，首先会判断的当前线程的状态是否为 <code>0</code>，也就是该锁是否处于空闲状态，如果是的话则尝试获取锁，设置成功将当前线程设置为持有锁的线程。</p><p>否则的话，就判断当前线程是否为持有锁的线程，如果是的话，则增加同步状态值，获取到锁，这里也就验证了锁的可重入，再获取了锁之后，可以继续获取锁，只需增加同步状态值即可。</p><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h2><p><code>FairSync</code> 中 <code>lock()</code> 方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>公平锁只能调用 <code>AQS</code> 的 <code>acquire()</code> 方法，再去调用由自定义组件实现的 <code>tryAcquire()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里唯一与非公平锁不同的是在获取同步状态时，会调用 <code>hasQueuedPredecessors</code> 方法，这个方法用来判断同步队列中是否有前驱节点。也就是当前线程前面再没有其他线程时，它才可以尝试获取锁。</p><h2 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h2><p><code>ReentrantLock</code> 的 <code>unlock</code> 方法内部调用 <code>AQS</code> 的 <code>release</code> 方法释放锁，而其中又调用了自定义组件实现的 <code>tryRelease</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="comment">// 当前线程不是持有锁的线程，不能释放</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，判断当前线程是否是持有锁的线程，如果不是会抛出异常。如果是的话，再减去同步状态值，判断同步状态是否为 <code>0</code>，即锁被完全释放，其他线程可以获取同步状态了。</p><p>如果没有完全释放，则仅使用 <code>setState</code> 方法设置同步状态值。</p><h2 id="指定公平性"><a href="#指定公平性" class="headerlink" title="指定公平性"></a>指定公平性</h2><p>在 <code>ReentrantLock</code> 的构造函数中可以指定公平性：</p><ul><li>默认创建一个非公平的锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建一个指定公平性的锁。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="synchronized-和-ReentrantLock-区别"><a href="#synchronized-和-ReentrantLock-区别" class="headerlink" title="synchronized 和 ReentrantLock 区别"></a>synchronized 和 ReentrantLock 区别</h1><p>这里总结一下 synchronized 和 ReentrantLock 的异同，它们之间的相同点如下：</p><ul><li>都可以用于实现线程间的同步访问；</li><li>两者都是可重入锁，即一个线程能够对资源重复加锁；</li></ul><p>其不同点如下：</p><ul><li>同步实现机制不同：<ul><li><code>synchronized</code> 通过 <code>Java</code> 对象关联的 <code>Monitor</code> 监视器实现（不考虑偏向锁、轻量级锁）；</li><li><code>ReentrantLock</code> 通过 <code>CAS</code>、<code>AQS</code> 和 <code>LockSupport</code> 等共同实现；</li></ul></li><li>可见性实现机制不同：<ul><li><code>synchronized</code> 依赖 <code>JVM</code> 内存模型保证包含共享变量的多线程内存可见性。</li><li><code>ReentrantLock</code> 通过 <code>ASQ</code> 中 <code>volatile</code> 类型的 <code>state</code> 同步状态值保证包含共享变量的多线程内存可见性。</li></ul></li><li>使用方式不同：<ul><li><code>synchronized</code> 可以用于修饰实例方法（锁住实例对象）、静态方法（锁住类对象）、同步代码块（指定的锁对象）。</li><li><code>ReentrantLock</code> 需要显式地调用 <code>lock</code> 方法，并在 <code>finally</code> 块中释放。</li></ul></li><li>功能丰富程度不同：<ul><li><code>synchronized</code> 只提供最简单的加锁。</li><li><code>ReentrantLock</code> 提供定时获取锁、可中断获取锁、<code>Condition</code>（提供 <code>await</code>、<code>signal</code> 等方法）等特性。</li></ul></li><li>锁类型不同：<ul><li><code>synchronized</code> 只支持非公平锁。</li><li><code>ReentrantLock</code> 提供公平锁和非公平锁实现。但非公平锁相比于公平锁效率较高。</li></ul></li></ul><p>在 <code>synchronized</code> 优化以前，它比较重量级，其性能比 <code>ReentrantLock</code> 要差很多，但是自从 <code>synchronized</code> 引入了偏向锁、轻量级锁（自旋锁）、锁消除、锁粗化等技术后，两者的性能就相差不多了。</p><p>一般来说，仅当需要使用 <code>ReentrantLock</code> 提供的其他特性时，例如：可中断的、可定时的、可轮询的、公平地获取锁等，才考虑使用 <code>ReentrantLock</code>。否则应该使用 <code>synchronized</code>，简单方便。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;深入理解-ReentrantLock&quot;&gt;&lt;a href=&quot;#深入理解-ReentrantLock&quot; class=&quot;headerlink&quot; title=&quot;深入理解 ReentrantLock&quot;&gt;&lt;/a&gt;深入理解 ReentrantLock&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ReentrantLock&lt;/code&gt; 是一种可重入锁，它指的是一个线程能够对资源重复加锁。&lt;code&gt;ReentrantLock&lt;/code&gt; 与 &lt;code&gt;synchronized&lt;/code&gt; 类似，能够保证解决线程安全问题，但是却提供了比 &lt;code&gt;synchronized&lt;/code&gt; 更强大、灵活的机制，例如可中断式的获取锁、可定时的获取锁等。&lt;/p&gt;
    
    </summary>
    
      <category term="2.4 Java 并发" scheme="https://blog.timberliu.com/categories/2-4-Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://blog.timberliu.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Lock 与 AQS 同步器</title>
    <link href="https://blog.timberliu.com/2019/04/12/037_Lock%20%E4%B8%8E%20AQS%20%E5%90%8C%E6%AD%A5%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/04/12/037_Lock 与 AQS 同步器/</id>
    <published>2019-04-11T16:00:00.000Z</published>
    <updated>2019-04-11T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><p>在 <code>Java5</code> 之前，只能使用 <code>synchronized</code> 关键字来实现锁。它使用起来比较简单，但是有一些局限性：</p><ul><li>无法中断一个正在等待获取锁的线程；</li><li>无法在请求获取一个锁时等待一段时间。<a id="more"></a></li></ul><p>而在 <code>Java5</code> 中，并发包中增加了 <code>Lock</code> 接口及其实现类，它的功能与 <code>synchronized</code> 类似，需要进行显示地获取和释放锁，但是却提供了很多 <code>synchronized</code> 不具有的特性。举一个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意的是获取锁的 <code>lock</code> 方法应该写在 <code>try</code> 块之外，因为如果写在 <code>try</code> 块中，获取锁时发生了异常，抛出异常的同时也会导致锁无故释放，而不是等到执行 <code>finally</code> 语句时才释放锁。</p><p>在 <code>Lock</code> 接口中，定义了锁获取和释放的基本操作，包括可中断的获取锁、超时获取锁等特性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可中断地获取锁，即获取锁时，其他线程可以中断当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试获取锁，调用后会立即返回，能获取就返回 true，否则返回 false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在给定时间内可中断地尝试获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个绑定到该 Lock 实例上的 Condition</span></span><br><span class="line">    <span class="comment">// 只有当前线程持有了锁，才能调用 await 方法，await 方法的调用将会自动释放锁</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Lock</code> 接口的主要实现就是 <code>ReentrantLock</code>。而 <code>Lock</code> 接口的实现基本都是通过内部实现了一个同步器 <code>AQS</code> 的子类来实现线程访问控制的。</p><h1 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h1><p>同步器 <code>AbstractQueuedSynchronizer</code>，是用来构建锁或其他同步组件的基础框架。它使用一个 <code>int</code> 成员变量表示同步状态，通过内置的 <code>FIFO</code> 同步队列来完成线程获取资源时的排队等待工作。</p><p>在自定义同步组件时，推荐定义一个静态内部类，使其继承自同步器 <code>AQS</code> 并实现它的抽象方法来管理同步状态，在实现抽象方法时，对同步状态的管理可以使用同步器提供的三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置当前同步状态</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 CAS 设置当前状态，保证原子性</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步器是实现同步组件的关，它们二者的关系如下：</p><ul><li>同步组件是面向使用者的，定义了使用者与同步组件交互的接口，隐藏了实现细节；</li><li>同步器面向的是同步组件的实现者，它简化了同步组件的实现方式。</li></ul><h2 id="同步器的接口"><a href="#同步器的接口" class="headerlink" title="同步器的接口"></a>同步器的接口</h2><p>同步器是基于模板方法模式的。使用者需要继承同步器并重写指定的方法。而可重写的方法主要有：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>tryAcquire</td><td>独占式获取同步状态</td></tr><tr><td>tryRelease</td><td>独占式释放同步状态</td></tr><tr><td>tryAcquireShared</td><td>共享式获取同步状态</td></tr><tr><td>tryReleaseShared</td><td>共享式释放同步状态</td></tr><tr><td>isHeldExclusively</td><td>判断同步器是否被线程独占</td></tr></tbody></table><p>随后将同步器组合到自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法会调用使用者重写的方法。</p><p>可调用的模板方法主要有三类：独占式获取与释放同步状态、共享式获取与释放状态、以及查询同步队列中的等待线程情况。下文会介绍它们，并简单分析其实现原理。</p><h2 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h2><p>同步器内部使用一个 <code>FIFO</code> 同步队列来管理同步状态，在线程获取同步状态失败时，同步器会将当前线程与等待状态等信息构造成一个节点，将其加入到同步队列中，同时会阻塞当前线程。当释放同步状态时，则会唤醒队列中首节点的线程，使其再次尝试获取同步状态。</p><p>同步队列中的节点的主要属性有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 前驱节点，在入队时被赋值</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后继节点，</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入节点的线程，该线程获取到同步状态</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>等待状态 <code>waitStatus</code> 的取值主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 同步队列中等待的线程等待超时或被中断，需要取消等待，之后节点的状态将不会再改变</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后继节点的线程处于等待状态</span></span><br><span class="line"><span class="comment">// 当前节点的线程释放或取消同步状态时，会唤醒它的后继节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 节点目前在等待队列中</span></span><br><span class="line"><span class="comment">// 当节点被唤醒时，从等待队列转移到同步队列中，尝试获取同步状态</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享式同步状态被传播给其他节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化 waitStatus 值为 0</span></span><br></pre></td></tr></table></figure><p>同步器中包含两个引用，分别指向同步队列的首节点和尾节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头节点，惰性初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 尾节点，惰性初始化</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br></pre></td></tr></table></figure><p>当线程无法获取同步状态，会将该线程构造成一个节点加入同步队列中，使用 <code>addWaiter</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    <span class="comment">// 快速尝试</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果快速尝试添加尾节点失败，则调用 <code>enq</code> 方法通过死循环来保证节点的正确添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 如果未初始化，则会先初始化，再继续尝试</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而这个过程可能会有多个线程同时执行，所以必须要保证线程安全，提供了基于 <code>CAS</code> 的设置尾节点的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetTail</span><span class="params">(Node expect, Node update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步队列中，首节点是获取同步状态成功的节点，线程在释放同步状态时，会唤醒后继节点，后继节点成功获取同步状态时将自己设置为首节点，由于只有一个线程能获取到同步状态，所以设置头节点的方法不需要 <code>CAS</code> 方法保证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHead</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    head = node;</span><br><span class="line">    node.thread = <span class="keyword">null</span>;</span><br><span class="line">    node.prev = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="独占式获取与释放"><a href="#独占式获取与释放" class="headerlink" title="独占式获取与释放"></a>独占式获取与释放</h2><p>独占式获取与释放同步状态主要有四个模板方法，分别是：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>独占式获取同步状态</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>可响应中断的独占式获取同步状态</td></tr><tr><td>boolean tryAcquireNanos(int arg, long nanos)</td><td>可响应中断的独占式超时获取同步状态</td></tr><tr><td>boolean release(int arg)</td><td>独占式释放同步状态</td></tr></tbody></table><h3 id="独占式获取"><a href="#独占式获取" class="headerlink" title="独占式获取"></a>独占式获取</h3><p><code>acquire</code> 方法可以获取同步状态，该方法为独占式获取，不可中断，也就是如果线程获取同步状态失败，加入到同步队列中，后续对线程进行中断操作，线程并不会被移除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>acquire</code> 方法中，首先调用 <code>tryAcquire</code> 方法尝试获取同步状态，该方法由自定义组件自己实现。如果获取失败，调用 <code>addWaiter</code> 方法将当前线程加入到同步队列末尾。最后调用 <code>acquiredQueued</code> 方法通过死循环的方式来获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，通过死循环的方式来获取同步状态，并且只有前驱节点是头节点时，才能够尝试获取同步状态，这样做就是为了保持 <code>FIFO</code> 同步队列原则，即先加入到同步队列中的线程先尝试获取同步状态。</p><p>另外，在自旋时首先会调用 <code>shouldParkAfterFailedAcquire</code> 方法判断是否应该被阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">// 前驱节点状态为 SIGNAL ，则当前节点可以被阻塞</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 前驱节点处于取消状态，也就是超时或被中断，需要从同步队列中删除</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，将当前节点设置为 SIGNAL，不会阻塞</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要是根据前驱节点的 <code>waitStatus</code> 来判断当前节点的线程，如果当前节点应该被阻塞，则会调用 <code>parkAndCheckInterrupt</code> 方法阻塞：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法调用 <code>LockSupport.park()</code> 方法阻塞当前线程，并返回当前线程的中断状态。</p><h3 id="可中断式获取"><a href="#可中断式获取" class="headerlink" title="可中断式获取"></a>可中断式获取</h3><p><code>acquireInterruptibly</code> 方法以可响应中断的方式获取同步状态，其中调用 <code>tryAcquire</code> 方法失败后，会调用 <code>doAcquireInterruptibly</code> 方法自旋式获取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>doAcquireInterruptibly</code> 方法与普通地独占式获取同步状态非常类似，只是不再使用 <code>interrupt</code> 标志，而是直接抛出 <code>InterruptedException</code> 异常。</p><h3 id="超时可中断式获取"><a href="#超时可中断式获取" class="headerlink" title="超时可中断式获取"></a>超时可中断式获取</h3><p><code>tryAcquireNanos</code> 方法可以超时获取同步状态，即在指定时间内可中断地获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">return</span> tryAcquire(arg) ||</span><br><span class="line">        doAcquireNanos(arg, nanosTimeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先调用 <code>tryAcquire</code> 方法尝试获取同步状态，如果获取失败，则会调用 <code>doAcquireNanos</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doAcquireNanos</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">long</span> nanosTimeout)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 计算总的超时时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = System.nanoTime() + nanosTimeout;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.EXCLUSIVE);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 剩余的超时时间</span></span><br><span class="line">            nanosTimeout = deadline - System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (nanosTimeout &lt;= <span class="number">0L</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                nanosTimeout &gt; spinForTimeoutThreshold)</span><br><span class="line">                <span class="comment">// 如果超时时间大于 临界值，则会阻塞线程，否则快速自旋</span></span><br><span class="line">                LockSupport.parkNanos(<span class="keyword">this</span>, nanosTimeout);</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先计算出超时的最终时间，然后将当前节点加入到同步队列中。</p><p>然后自旋进行判断，如果当前节点为头节点，则会调用 <code>tryAcquire</code> 方法尝试获取同步状态；否则重新计算超时时间，如果 <code>nanosTimeout</code> 小于 <code>0</code>，则获取失败。否则继续判断超时时间是否大于 <code>spinForTimeoutThreshold</code> 临界值，如果大于表示时间较长，调用 <code>LockSupport.parkNanos</code> 使线程阻塞。</p><p>如果时间较短，则直接进入自旋过程，继续判断。另外，还会判断线程是否被中断。</p><h3 id="独占式释放"><a href="#独占式释放" class="headerlink" title="独占式释放"></a>独占式释放</h3><p><code>release</code> 方法用来释放同步状态，该方法释放了同步状态后，会唤醒后继节点，使其重新尝试获取同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先调用 <code>tryRelease</code> 方法尝试释放同步状态，该方法由自定义同步组件自己实现。然后调用 <code>unparkSuccessor</code> 方法来唤醒后继节点：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>) <span class="comment">// 节点状态设置为 0</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">// 如果后继节点超时或者被中断</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 从 tail 向前，找最靠近 head 的可用节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先找到一个可用的 <code>waitStatus</code> 值大于 <code>0</code> 的节点，然后调用 <code>LockSupport.unpark</code> 方法唤醒该线程。</p><h2 id="共享式获取与释放"><a href="#共享式获取与释放" class="headerlink" title="共享式获取与释放"></a>共享式获取与释放</h2><p>共享式与独占式最大的区别就是同一时刻有多个线程同时获取到同步状态。</p><p>共享式获取与释放同步状态主要有四个模板方法，分别是：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>acquireShared(int arg)</td><td>共享式获取同步状态</td></tr><tr><td>acquireSharedInterruptibly(int arg)</td><td>可响应中断的共享式获取同步状态</td></tr><tr><td>tryAcquireSharedNanos(int arg, long anos)</td><td>可响应中断的共享式超时获取同步状态</td></tr><tr><td>releaseShared(int arg)</td><td>共享式释放同步状态</td></tr></tbody></table><h3 id="共享式获取"><a href="#共享式获取" class="headerlink" title="共享式获取"></a>共享式获取</h3><p><code>acquireShared</code> 方法可以共享式地获取同步状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中，首先调用 <code>tryAcquireShared</code> 方法尝试获取同步状态，如果返回值大于等于 <code>0</code>，则表示获取成功。否则获取失败，则会调用 <code>doAcquireShared</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取前驱节点</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">// 大于等于 0，表示获取成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先以共享节点加入到等待队列中，然后以死循环的方式进行判断，如果当前节点的前驱节点为头节点，则调用 <code>doAcquireShared</code> 方法尝试获取同步状态，直到其返回值大于等于 <code>0</code>。</p><p>可响应中断、超时获取的共享式获取同步状态与之前类似，这里也就不多介绍。</p><h3 id="共享式释放"><a href="#共享式释放" class="headerlink" title="共享式释放"></a>共享式释放</h3><p><code>releaseShared</code> 方法用于共享式释放同步状态，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法首先调用 <code>tryReleaseShared</code> 尝试释放同步状态，如果释放失败，则会调用 <code>doReleaseShared</code> 方法；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法中在释放同步状态时，由于有多个线程，需要保证线程安全。首先，如果后继节点的线程需要唤醒，则将当前节点的状态设置为 <code>0</code>，然后调用 <code>unparkSuccessor</code> 方法唤醒后继节点。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>方腾飞：《Java并发编程的艺术》</li><li><a href="http://cmsblogs.com/?p=2174" target="_blank" rel="noopener">【死磕Java并发】—–J.U.C之AQS：AQS简介</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Lock-接口&quot;&gt;&lt;a href=&quot;#Lock-接口&quot; class=&quot;headerlink&quot; title=&quot;Lock 接口&quot;&gt;&lt;/a&gt;Lock 接口&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;Java5&lt;/code&gt; 之前，只能使用 &lt;code&gt;synchronized&lt;/code&gt; 关键字来实现锁。它使用起来比较简单，但是有一些局限性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;无法中断一个正在等待获取锁的线程；&lt;/li&gt;
&lt;li&gt;无法在请求获取一个锁时等待一段时间。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="2.4 Java 并发" scheme="https://blog.timberliu.com/categories/2-4-Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://blog.timberliu.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Java 内存模型</title>
    <link href="https://blog.timberliu.com/2019/03/03/035_Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://blog.timberliu.com/2019/03/03/035_Java 内存模型/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h1><p>计算机的 <code>CPU</code> 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下：</p><ul><li><code>CPU</code> 增加了高速缓存，以均衡与内存的速度差异；</li><li>操作系统增加了进程、线程，以分时复用 <code>CPU</code>，均衡 <code>CPU</code> 与 <code>I/O</code> 设备的差异；</li><li>编译器优化指令执行次序，使得缓存能得到更加充分的利用。<a id="more"></a></li></ul><p>虽然高速缓存很好地解决了处理器与内存的速度矛盾，但是又出现了一个新的问题。在多核处理机中，每个处理器都有自己的高速缓存，它们共享同一主内存。当多个处理器的任务涉及到同一块主内存区域时，可能导致缓存的数据不一致的情况，这就是可见性问题，可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>操作系统基于线程来进行任务调度。高级语言的一条语句往往需要多条指令完成，但是任务切换可以发生在任何一条 <code>CPU</code> 指令后，在多线程环境下这就可能导致数据与预期的不一致，即原子性问题。原子性是指一个或多个操作在 <code>CPU</code> 执行过程中不被中断。</p><p>编译器的指令重排序优化同样不能保证最终的结果与预期的一致。这里的重排序会满足以下两个条件：</p><ul><li><code>as-if-serial</code>：在单线程环境下不管怎么重排序，不能改变程序运行的结果。</li><li>数据依赖性：存在数据依赖关系的不能重排序。</li></ul><p>需要注意的是：虽然重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。也就是有序性问题，有序性指的是程序按照代码的先后顺序（逻辑先后）执行。</p><p>所以，<code>JVM</code> 试图虚拟机定义了一种 <code>Java</code> 内存模型（<code>Java Memory Model</code>，<code>JMM</code>）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 <code>Java</code> 程序在各种平台下都能达到一致的内存访问效果，也就是解决以上三个问题。</p><h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p><code>Java</code> 内存模型主要是为了定义程序中各个变量的访问规则，此处的变量指的是实例字段、静态字段和构成数组对象的元素等共享变量。</p><p><code>Java</code> 内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，其中保存了该线程使用的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程之间的变量值传递需要通过主内存来完成。</p><p>线程、工作内存、主内存三者的关系如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" width="60%"></p><h1 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h1><p>对于主内存与工作内存之间交互的实现细节，<code>Java</code> 内存模型中定义了 <code>8</code> 种操作来实现，虚拟机实现时必须保证这些操作是原子性的。</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92.jpg" width="60%"></p><ul><li><code>read</code>（读取）：把一个变量的值从主内存传输到工作内存中；</li><li><code>load</code>（载入）：把 <code>read</code> 操作从主内存得到的变量放入工作内存的变量副本中；</li><li><code>use</code>（使用）；把工作内存中一个变量的值传递给执行引擎；</li><li><code>assign</code>（使用）：把一个从执行引擎接收到的值赋给工作内存的变量；</li><li><code>store</code>（存储）：把工作内存中一个变量的值传送到主内存中；</li><li><code>write</code>（写入）：把 <code>store</code> 操作从工作内存中得到的变量放入主内存的变量中。</li></ul><h1 id="volatile-型变量"><a href="#volatile-型变量" class="headerlink" title="volatile 型变量"></a>volatile 型变量</h1><p>关键字 <code>volatile</code> 是 <code>JVM</code> 提供的轻量级的同步机制。当一个变量被定义为 <code>volatile</code> 后，它可以保证内存的可见性。</p><p>使用 <code>volatile</code> 还可以禁止指令重排序优化。它是 <code>Java</code> 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>内存屏障（<code>Memory Barrier</code>）是一组处理器指令，用于实现对内存访问操作的顺序限制。在重排序时不能把后面的指令重排序到内存屏障之前的位置。</p><h1 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h1><p><code>Java</code> 内存模型保证了并发的三个特性：原子性、可见性、有序性，下面学习一下哪些操作实现了这三个特性：</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>Java</code> 内存模型保证了内存间交互的 <code>8</code> 个操作的原子性，但对于 <code>64</code> 位的数据类型（<code>long</code> 和 <code>double</code>），允许虚拟机的实现可以不保证 <code>64</code> 位数据类型的 <code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 这 <code>4</code> 个操作的原子性。但目前虚拟机几乎都把 <code>64</code> 位数据的读写操纵作为原子性来对待。也就是说可以认为基本类型的读写访问是具备原子性的。</p><p><code>JMM</code> 还提供了 <code>lock</code> 和 <code>unlock</code> 操作来保证更大范围的原子性，尽管虚拟机并未将其开放给用户，但可使用 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令来隐式地使用这两个操作，对应到 <code>Java</code> 代码中就是 <code>synchronized</code> 关键字，所以 <code>synchronized</code> 同步块也是原子性的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>主要有三种方式实现可见性：</p><ul><li><code>volatile</code>：<code>volatile</code> 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</li><li><code>synchronized</code>：对同步块加锁解锁，在执行 <code>unlock</code> 操作前必须把此变量值同步到主内存中。</li><li><code>final</code>：被 <code>final</code> 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 <code>this</code> 引用逃逸（其它线程可能通过引用访问到初始化了一半的对象），那么其它线程就能看见 <code>final</code> 字段的值。</li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p><code>Java</code> 中有两种方式保证线程之间操作的有序性；</p><ul><li><code>volatile</code> 关键字通过添加内存屏障的方式来禁止指令重排。</li><li>通过 <code>synchronized</code> 来保证有序性，它保证每个时刻只有一个线程执行同步代码，即让线程串行地执行同步代码。</li></ul><h1 id="Happends-Before-原则"><a href="#Happends-Before-原则" class="headerlink" title="Happends-Before 原则"></a>Happends-Before 原则</h1><p>前面说的保证并发安全的定义实践起来比较麻烦，有一个等效判断原则——<code>Happens-Before</code> 原则，来确定一个访问在并发环境下是否安全。</p><p><code>Happens-Before</code> 的含义就是前面一个操作的结果对后续操作是可见的。要想保证执行操作 <code>B</code> 的线程看到线程 <code>A</code> 的结果，那么 <code>A</code> 和 <code>B</code> 之间必须满足 <code>Happens-Before</code> 原则。如果两个操作之间缺乏 <code>Happens-Before</code> 原则，那么 <code>JVM</code> 就可以对它们任意地重排序，那么就会产生数据竞争问题。</p><p><code>Happens-Before</code> 原则包括：</p><ul><li>程序顺序规则：一个线程内按照控制流顺序，前面的操作 <code>Happens-Before</code> 于后面的操作。</li><li>管程锁定规则：一个 <code>unlock</code> 操作 <code>Happens-Before</code> 于后面对同一个锁的 <code>lock</code> 操作。</li><li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 变量的写操作 <code>Happens-Before</code> 于对该变量的读操作。</li><li>线程启动规则：<code>Thread</code> 对象的 <code>start</code> 方法 <code>Happens-Before</code> 于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都 <code>Happens-Before</code> 于对该线程的终止检测，可通过 <code>Thread.join</code> 方法结束，或 <code>Thread.isAlive</code> 方法的返回值，检测到线程已经终止执行。</li><li>线程中断规则：对线程 <code>interrupt</code> 方法的调用 <code>Happens-Before</code> 于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成 <code>Happens-Before</code> 于它的 <code>finalize</code> 方法的开始。</li><li>传递性：如果操作 <code>A</code>  <code>Happens-Before</code> 于操作 <code>B</code>，操作 <code>B</code>  <code>Happens-Before</code> 于操作 <code>C</code>，那么操作 <code>A</code> 就 <code>Happens-Before</code> 于操作 <code>C</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《深入理解 Java 虚拟机》</li><li>CyC2018：<a href="https://note.youdao.com/" target="_blank" rel="noopener">CS-Notes / Java 并发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要有内存模型&quot;&gt;&lt;a href=&quot;#为什么要有内存模型&quot; class=&quot;headerlink&quot; title=&quot;为什么要有内存模型&quot;&gt;&lt;/a&gt;为什么要有内存模型&lt;/h1&gt;&lt;p&gt;计算机的 &lt;code&gt;CPU&lt;/code&gt; 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; 增加了高速缓存，以均衡与内存的速度差异；&lt;/li&gt;
&lt;li&gt;操作系统增加了进程、线程，以分时复用 &lt;code&gt;CPU&lt;/code&gt;，均衡 &lt;code&gt;CPU&lt;/code&gt; 与 &lt;code&gt;I/O&lt;/code&gt; 设备的差异；&lt;/li&gt;
&lt;li&gt;编译器优化指令执行次序，使得缓存能得到更加充分的利用。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="2.4 Java 并发" scheme="https://blog.timberliu.com/categories/2-4-Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://blog.timberliu.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之深入分析 synchronized 关键字</title>
    <link href="https://blog.timberliu.com/2019/03/03/036_%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20synchronized%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.timberliu.com/2019/03/03/036_深入分析 synchronized 实现原理/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized-概述"><a href="#synchronized-概述" class="headerlink" title="synchronized 概述"></a>synchronized 概述</h1><p><code>synchronized</code> 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。<a id="more"></a></p><ul><li>互斥性：同一时刻只允许一个线程持有某个对象锁，一次实现对共享资源的互斥访问。</li><li>可见性：确保在锁释放前，对共享变量做的修改，对随后获得该锁的另一个线程是可见的。 </li></ul><p><code>synchronized</code> 的获取和释放锁由 <code>JVM</code> 实现，用户不需要显示的获取和释放锁，非常方便。但是当线程尝试获取锁的时候，如果获取不到锁该线程会一直阻塞。</p><p>在早期版本中，<code>synchronized</code> 是一个重量级锁，效率低下。但从 <code>JDK1.6</code> 开始，从 <code>JVM</code> 层面对 <code>synchronized</code> 引入了各种锁优化技术，例如：自旋锁、适应性自旋锁、锁消除、锁粗化、轻量级锁和偏向锁等，大大减少了锁操作的开销。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>使用 <code>synchronized</code> 实现同步有同步方法块、同步方两种方式。</p><h2 id="同步方法块"><a href="#同步方法块" class="headerlink" title="同步方法块"></a>同步方法块</h2><p>作用于代码块时，括号中可以是指定的对象，也可以是 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的是指定的对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁定是指定的类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>作用于方法时，锁的是当前的对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于静态方法，锁的是类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理基础"><a href="#原理基础" class="headerlink" title="原理基础"></a>原理基础</h1><p><strong>HotSpot 对象头</strong></p><p><code>HotSpot</code> 虚拟机的对象头分为两部分信息：</p><ul><li><code>Mark Word</code>：用于存放对象自身的运行时数据，如哈希码、<code>GC</code> 分代年龄、锁类型、锁标志位等信息，这部分数据在 <code>32</code> 位和 <code>64</code> 位虚拟机中分别为 <code>32</code> 和 <code>64 bit</code>。它是实现轻量级锁和偏向锁的关键。</li><li><code>Class Metadata Address</code>：用于存储指向方法区对象类型数据的指针，如果是数组，还会有一个额外的部分用于存放数组长度。</li></ul><p><code>Mark Word</code> 被设计为一个非固定的数据结构以便存储更多的信息，它会根据对象的状态复用自己的存储空间。例如，在 <code>32</code> 位的 <code>HotSpot</code> 虚拟机中,各种状态下对象的存储内容如下：</p><p><img src="http://media.timberliu.com/image/2019/3/3/ObjectHead.png" width="60%"></p><p><strong>Monitor</strong></p><p>每个 <code>Java</code> 对象都有一个 <code>Monitor</code> 对象与之关联，它被称为管程（监视器锁），前面的表格中，锁状态为重量级锁时，指针就指向 <code>Monitor</code> 对象的起始地址。当一个 <code>Monitor</code> 被某个线程持有后，便处于锁定状态。在 <code>HotSpot</code> 虚拟机的源码实现中，<code>ObjectMonitor</code> 对象相关属性有：</p><ul><li><code>_count</code>：计数器；</li><li><code>_owner</code>：指向持有 <code>ObjectMonitor</code> 对象的线程；</li><li><code>_WaitSet</code>：等待池；</li><li><code>_EntryList</code>：锁池；</li></ul><p>多个线程访问同步代码时，首先会进入 <code>_EntryList</code> 锁池中被阻塞，当线程获取到对象的 <code>Monitor</code> 后，就会把 <code>_owner</code> 指向当前线程，同时 <code>Monitor</code> 中的 <code>_count</code> 计数器加一。如果线程调用 <code>wait</code> 方法，<code>_owner</code> 就被恢复为 <code>null</code>，<code>_count</code> 计数器减一，同时该线程就会进入 <code>_WaitSet</code> 等待池中。</p><p>当线程执行完毕，将对应的变量复位，以便其他线程获取 Monitor 锁。</p><p><strong>四种状态</strong></p><p><code>synchronized</code> 有四种状态：无锁、偏向锁、轻量级锁和重量级锁。随着对锁的竞争逐渐激烈，锁的状态进行升级。</p><h1 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h1><h2 id="同步方法块-1"><a href="#同步方法块-1" class="headerlink" title="同步方法块"></a>同步方法块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ···</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -c -v</code> 对 <code>SynchronizedTest.class</code> 进行反汇编：</p><p><img src="http://media.timberliu.com/image/2019/2/27/synchronized%20%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%97.png" width="80%"></p><p>可以看到，在同步代码块的开始位置插入 <code>monitorenter</code> 指令，在结束位置插入 <code>monitorexit</code> 指令，而且必须保证每一个 <code>monitorenter</code> 都有一个 <code>monitorexit</code> 与之对应。</p><p><code>synchronized</code> 便是通过 <code>Monitor</code> 获取锁的。当线程执行到 <code>monitorenter</code> 指令时，将会尝试获取 <code>Monitor</code> 所有权。当计数器为 <code>0</code>，则成功获取；获取后将锁计数器置为 <code>1</code>。在执行 <code>monitorexit</code> 指令时，将锁计数器置为 <code>0</code>。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h2 id="同步方法-1"><a href="#同步方法-1" class="headerlink" title="同步方法"></a>同步方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -c -v</code> 对 <code>SynchronizedTest.class</code> 进行反汇编：</p><p><img src="http://media.timberliu.com/image/2019/2/27/synchronized%20%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" width="80%"></p><p>可以看到，被同步的方法也仅是被翻译成普通的方法调用和返回指令。在 <code>JVM</code> 字节码层面并没有任何特别的指令来实现 <code>synchronized</code> 修饰的方法。</p><p>但是在 <code>Class</code> 文件的方法表中将方法的 <code>flags</code> 字段中的 <code>ACC_SYNCHRONIZED</code> 标志位置为 <code>1</code>，表示该方法是同步方法。在执行方法时，线程就会持有 <code>Monitor</code> 对象。</p><h1 id="底层优化"><a href="#底层优化" class="headerlink" title="底层优化"></a>底层优化</h1><p><code>JDK1.6</code> 对锁引入了大量的优化，如自旋锁、自适应自旋锁、锁消除、锁粗化、轻量级锁、偏向锁等技术来减少锁操作的开销。</p><h2 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h2><p>在实现同步互斥时，如果获取锁失败，就会使当前线程阻塞，但线程的挂起和恢复都需要在内核态和用户态之间转换，对系统的性能影响很大。许多情况下共享数据的锁定状态持续时间不会很长，切换线程不值得。</p><p>自旋锁就是让线程在请求共享数据的锁时执行一个忙循环（自旋），如果能够很快获得锁，就避免其进入阻塞状态。</p><p>自旋等待虽然避免了线程切换的开销，但它要求多处理器，而且要占用处理器时间。如果锁占用时间过长，那么反而会消耗更多的资源。因此，对自旋等待的时间必须进行限制，另外自旋的次数也不能过多，默认为 <code>10</code> 次，可使用 <code>-XX:PreBlockSpin</code> 参数修改。</p><p><code>JDK1.6</code> 中引入了自适应的自旋锁，它的自旋时间由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机的即时编译器在运行时，如果代码要求同步，但检测发现不可能存在共享数据竞争时，那么就进行锁消除。</p><p>锁消除主要根据逃逸分析，如果判断在一段代码中，堆上的所有数据都不会逃逸出去，那就可以将它们认为是线程私有的，也就无须进行同步加锁。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁也是出现循环体中，那么即使没有数据竞争，频繁地加锁解锁也会导致不必须的性能消耗。</p><p>锁粗化指的就是如果虚拟机探测到这样的情况，那就将加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是在无竞争的情况下消除整个同步，也就是减少同一线程获取锁的代价。它的思想是这个锁会偏向于第一个获得它的线程，如果接下来该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>当锁对象第一次被线程获取时，锁进入偏向模式，同时 Mard Word 的结构也变为偏向锁结构。锁标志位为“01”，同时使用 <code>CAS</code> 操作把获取到这个锁的线程的 <code>ID</code> 记录在对象的 <code>Mark Word</code> 中，如果 <code>CAS</code> 操作成功，这个线程以后每次进入这个锁相关的同步块时，都可以不用再进行任何同步操作。</p><p>不适用于锁竞争比较激烈的多线程场合。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是相对于使用操作系统互斥量实现的传统锁而言的。偏向锁运行在一个线程进入同步块时，如果有第二个线程加入锁竞争，则偏向锁就会升级为轻量级锁。它适用于线程交替执行的场景。</p><p>在代码进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机将先在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前 <code>Mark Word</code> 的拷贝。如下图，左侧是一个线程的虚拟机栈，右侧是一个锁对象：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20CAS%20%E4%B9%8B%E5%89%8D%E5%A0%86%E6%A0%88%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" width="60%"></p><p>然后，虚拟机将使用 <code>CAS</code> 操作尝试将对象的 <code>Mark Word</code> 更新为指向 <code>Lock Record</code> 的指针，并将 <code>Lock Record</code> 里的 <code>owner</code> 指针指向对象的 <code>Mark Word</code>。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象的 <code>Mark Word</code> 的锁标志位转变为“00”，即表示对象处于轻量级锁定状态。多线程堆栈和对象头的状态如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20CAS%20%E5%90%8E%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E7%8A%B6%E6%80%81.png" width="60%"></p><p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果已指向则说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，如果没有指向则说明这个锁对象已经被其他对象抢占了。</p><p>如果有两条以上的线程争用同一个锁，那轻量级锁就要膨胀为重量级锁，锁标志变为“10”，<code>Mark Word</code> 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。</p><p>对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了重量级锁使用互斥量的开销，提升了程序同步的性能。</p><p>偏向锁、轻量级锁的状态转化及对象 <code>Mark Word</code> 的关系如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E5%81%8F%E5%90%91%E9%94%81.jpg" width="60%"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《深入理解 Java 虚拟机》</li><li>CyC2018：<a href="https://note.youdao.com/" target="_blank" rel="noopener">CS-Notes / Java 并发</a></li><li>Hollis：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized-概述&quot;&gt;&lt;a href=&quot;#synchronized-概述&quot; class=&quot;headerlink&quot; title=&quot;synchronized 概述&quot;&gt;&lt;/a&gt;synchronized 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;
    
    </summary>
    
      <category term="2.4 Java 并发" scheme="https://blog.timberliu.com/categories/2-4-Java-%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java 并发" scheme="https://blog.timberliu.com/tags/Java-%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 类加载机制</title>
    <link href="https://blog.timberliu.com/2019/03/02/034_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.timberliu.com/2019/03/02/034_类加载机制/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code> 源程序经过编译器编译后，会生成 <code>Class</code> 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。<a id="more"></a></p><h1 id="类加载概述"><a href="#类加载概述" class="headerlink" title="类加载概述"></a>类加载概述</h1><p>类加载机制，就是 <code>JVM</code> 将描述类的数据从 <code>Class</code> 文件加载到内存中，并对数据进行校验、转换解析和初始化，最终会形成可以被 <code>JVM</code> 直接使用的 <code>Java</code> 类型。</p><p>类被从加载，到卸载会经历如下七个生命周期：</p><p><img src="http://media.timberliu.com/image/2019/2/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" width="80%"> </p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序的确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始。</p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类加载在何时开始，<code>Java</code> 虚拟机规范并没有明确规定。但是对初始化阶段，则是严格规定了有且只有五种情况必须立即对类进行初始化：</p><ul><li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 四条字节码指令时，如果类没有被初始化，则需要先进行初始化。它们对应的代码场景分别是：<ul><li><code>new</code>：使用 <code>new</code> 关键在实例化对象时；</li><li><code>getstatic</code>：读取一个类的静态字段；</li><li><code>putstatic</code>：设置一个类的静态字段；</li><li><code>invokestatic</code>：调用一个类的静态方法时；</li></ul></li><li>使用 <code>java.lang.reflect</code> 包中的方法对类进行反射调用时，如果类没有被初始化，则需要先进行初始化。</li><li>当初始化一个类时，如果其父类还没有被初始化，则需要先对其父类进行初始化。</li><li>当虚拟机启动时，需要指定一个要执行的主类（包含 <code>main</code> 方法的类），虚拟机会先初始化这个主类。</li><li>当使用 <code>JDK1.7</code> 的动态语言支持时，如果一个 <code>java.lang.invoke.MehodHandle</code> 实例最后的解析结果 <code>REF_getStatic</code>、<code>REF_getStatic</code>、<code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先进行初始化。</li></ul><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>下面详细学习一下类加载的全过程，也就是加载、验证、准备、解析和初始化五个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载阶段，<code>JVM</code> 需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时的数据结构。</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>加载完成后，二进制字节流按照 <code>JVM</code> 所需的格式存储在方法区之中，方法区中的数据存储格式由 <code>JVM</code> 具体的实现中定义。然后在内存中实例化一个 <code>java.lang.Class</code> 类的对象，这个对象将作为程序访问方法区中的数据的外部接口。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 <code>Class</code> 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证阶段大致会完成 <code>4</code> 个阶段的检验动作，其中第一个阶段是基于二进制字节流进行的，之后进入内存的方法区中存储；而后三个阶段是基于方法区的存储结构进行的：</p><ul><li>文件格式验证：验证字节流是否符合 <code>Class</code> 文件格式的规范，并且能被当前版本的虚拟机处理。例如：是否以魔数 <code>0xCAFEBABE</code> 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 <code>Java</code> 语言规范的要求。例如：这个类是否有父类，这个类的父类是否继承了不允许被继承的类( <code>final</code> 类)。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对方法体进行校验分析，保证被校验方法的安全性。</li><li>符号引用验证：在解析阶段发生。对类自身以外的信息进行匹配性校验，例如符号引用中通过字符串描述的全限定名是否能找到对应的类等。</li></ul><p>验证阶段非常重要，但不是必须的，因为它对程序运行期没有影响。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。该阶段有需要注意以下几点：</p><ul><li>这个阶段进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等）。</li><li>如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性，即同时被 <code>final</code> 和 <code>static</code> 修饰，那么在准备阶段变量就会被初始化为 <code>ConstValue</code> 属性所指定的值。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用与直接应用区别如下：</p><ul><li>符号引用：以一组符号来描述引用的目标，可以是任何形式的字面量。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><p>解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 <code>7</code> 类符号引用进行。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在准备阶段，变量已经被赋过一次系统要求的初始值。而在初始化阶段，则按照程序去初始化类变量，或者说，初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法。</p><p><code>&lt;clinit&gt;</code> 方法运行的特点和细节如下：</p><ul><li><code>&lt;clinit&gt;</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。收集的顺序是语句在源文件中出现的顺序决定，静态语句块只能访问定义在静态语句块之前的变量。定义在它之后的变量，在之前的静态语句块可以赋值，但不能访问。</li><li>虚拟机会保证子类的 <code>&lt;clinit&gt;</code> 方法执行之前，父类的 <code>clinit</code> 方法已执行完毕。</li><li>执行接口的 <code>&lt;clinit&gt;</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;</code> 方法。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>加载阶段的“通过一个类的全限定类名来获取此类的二进制字节流”这个动作放到 <code>JVM</code> 外部实现，以便让应用程序自己决定如何获取所需的类。这个模块称为“类加载器”。</p><p>类加载器除了用于实现类的加载动作，还用来比较两个类是否“相等”。这里的相等指的是：只有两个类是由同一个类加载器的前提下，两个类来源于同一 <code>Class</code> 文件，被同一个虚拟机加载，两个类才相等。</p><p>这里的“相等”，包括：</p><ul><li>代表类的 <code>Class</code> 对象的 <code>equals()</code> 方法；</li><li><code>isAssignableFrom()</code> 方法；</li><li><code>isInstance()</code> 方法；</li><li>使用 <code>instanceof</code> 关键字对对象所属关系判断；</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h2><p><code>Java</code> 程序一般会使用三种系统提供的类加载器：启动类加载器、扩展类加载器和应用程序加载器（<code>HotSpot</code> 虚拟机）。它们的层次关系如下图：</p><p><img src="http://media.timberliu.com/image/2019/2/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" width="80%"></p><p>这种层次关系，称为类加载器的双亲委派模型。其中除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。子类加载器和父类加载器不是以继承关系来实现，而是通过组合关系来复用父加载器的代码。</p><p>三种类加载器如下：</p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：使用 <code>C++</code> 语言实现，是虚拟机自身的一部分。这个类加载器负责加载 <code>JVM</code> 启动所需要的类（<code>&lt;JAVA_HOME&gt;\lib</code> 或 <code>-Xbootclasspath</code> 目录下的类库）。</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：除了启动类加载器外，其他类加载器都由 <code>Java</code> 实现，独立于虚拟机外部。它负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，或者被 <code>java.ext.dirs</code> 系统变量指定的路径中的类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（<code>Application ClassLoader</code>）：这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值。它负责加载用户类路径（<code>ClassPath</code>）上所指定的类库。开发者可以直接使用这个类加载器。</li></ul><p>使用双亲委派模型组织类加载器之间的关系，使得 <code>Java</code> 类随着它的类加载器一起具备了带有优先级的层次关系，而不会出现关系混乱的类加载器。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>双亲委派模型的工作过程如下：</p><ul><li>如果一个类加载器收到类加载的请求，它首先从自己的加载类缓存中，查询该类是否已经被加载，如果已经加载则直接返回原来已经加载的类。</li><li>如果没有加载，则会委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到顶层的启动类加载器。</li><li>只有当父加载器无法完成这个加载请求，即它的搜索范围中没有找到所需的类时，子加载器才会尝试自己去加载。</li><li>如果一个类加载器加载类后，会将其放入自己的缓存中，以便下次有加载请求的时候直接返回。</li></ul><h2 id="优先使用父-ClassLoader-加载类"><a href="#优先使用父-ClassLoader-加载类" class="headerlink" title="优先使用父 ClassLoader 加载类"></a>优先使用父 ClassLoader 加载类</h2><p>主要有以下两个好处：</p><ol><li>共享功能：可以避免重复加载，当父加载器已经加载了该类时，就不需要子类再次加载，一些顶层的类被 <code>ClassLoader</code> 加载过就会缓存在内存里，以后用到时都不需要重新加载。</li><li>隔离功能：为了安全性，避免用户自己编写的类替换 <code>Java</code> 的一些核心类，比如 <code>String</code> ，同时也避免了重复加载，因为 <code>JVM</code> 中区分不同类，不仅仅是根据类名，相同的 <code>class</code> 文件被不同的 <code>ClassLoader</code> 加载就是不同的两个类，如果相互转型的话会抛 <code>java.lang.ClassCastException</code>。</li></ol><h2 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h2><p>双亲委派模型的代码都集中在在 <code>java.lang.ClassLoader</code> 的 <code>loadClass</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                </span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>loadClass</code> 方法的加载过程如下：</p><ul><li>首先检查请求的类是否已经被加载。</li><li>如果没有调用，则调用父加载器的 <code>loadClass</code> 方法。</li><li>如果父加载器为空，则默认使用启动类加载器加载。</li><li>如果父加载器加载失败，抛出 <code>ClassNotFoundException</code> 异常，再调用自己的 <code>findClass</code> 方法进行加载。</li></ul><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型仅是 <code>Java</code> 推荐的类加载器实现方式。大部分的类加载器也都遵循这个模型，双亲委派模型主要出现过 <code>3</code> 次被破坏的情况。</p><p>第一次破坏是发生在双亲委派模型出现之前。为了向前兼容 <code>JDK1.0</code> 就存在的类加载器和抽象类 <code>java.lang.ClassLoader</code>，在 <code>JDK1.2</code> 后的 <code>java.lang.ClassLoader</code> 添加了一个新的 <code>protected</code> 方法 <code>findClass()</code>。</p><p>第二次破坏是由模型自身的缺陷导致的。用户代码总是调用基础类，但是上层类加载器加载的基础类不能调用回用户的代码。<code>Java</code> 中引入了线程上下文类加载器，可以使用这个线程上下文类加载器请求子类加载器去完成类加载的动作。</p><p>第三次破坏是由于用户对程序的动态性的追求导致的。例如 <code>OSGI</code> 实现模块化热部署，在 <code>OSGI</code> 环境下，类加载器不再是双亲委派模型中的树形结构，而是发展为网状结构。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>指 · 间：<a href="http://www.zhenchao.org/2016/12/04/jvm/class-load/" target="_blank" rel="noopener">探秘 JVM：类加载机制</a></li><li>芋道源码：《精尽 Java【虚拟机】面试题》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 源程序经过编译器编译后，会生成 &lt;code&gt;Class&lt;/code&gt; 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="2.3 JVM" scheme="https://blog.timberliu.com/categories/2-3-JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 垃圾收集器</title>
    <link href="https://blog.timberliu.com/2019/02/26/033_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/02/26/033_垃圾收集器/</id>
    <published>2019-02-25T16:00:00.000Z</published>
    <updated>2019-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中学习了 <code>JVM</code> 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 <code>HotSpot</code> 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><code>HotSpot</code> 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。<a id="more"></a></p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p><code>Serial</code> 收集器是一个单线程的收集器，它不仅只会使用一个 <code>CPU</code> 或一条收集线程去完成垃圾收集工作，而且在垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><code>Serial</code> 收集器是 <code>HotSpot</code> 虚拟机在运行 <code>Client</code> 模式下的默认新生代收集器。在垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。</p><p>但它也有优点，与其他收集器的单线程相比，由于没有现成交互的开销，专心做垃圾收集，所以其简单而高效；</p><p>可以使用 <code>-XX:UseSerialGC</code> 参数选择使用 <code>Serial</code> 收集器，此时年轻代采用 <code>Serail</code>，老年代采用 <code>Serial Old</code>。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><code>ParNew</code> 收集器是 <code>Serial</code> 收集器的多线程版本，除了使用多线程进行垃圾回收外，其他几乎一样。</p><p>它是许多运行在 <code>Server</code> 模式下的虚拟机首选的新生代收集器，一个很重要的原因是除了 <code>Serial</code> 收集器外，只有 <code>ParNew</code> 收集器与 <code>CMS</code> 收集器配合工作。垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。</p><p><code>ParNew</code> 收集器默认开启的线程数与 <code>CPU</code> 的数量相同，可以使用 <code>-XX:ParallelGCThreas</code> 参数来限制垃圾收集的线程数。使用 <code>-XX:UseParNewGC</code> 参数来使用 <code>ParNew</code> 收集器。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p><code>Parallel Scavenge</code> 收集器是新生代收集器，也是使用复制算法的多线程收集器。与其他收集器不同的是，它关注的是达到一个可控制的吞吐量，吞吐量 = 运行代码时间 / （运行代码时间 + 垃圾收集时间）。</p><p><code>Parallel Scanenge</code> 收集器提供了两个参数用于精确控制吞吐量。第一个是控制最大垃圾收停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数。它允许是一个大于 <code>0</code> 的毫秒数，收集器将尽可能保证内存回收时间不超过设定值。这个参数也不是越小越好，GC 停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</p><p>第二个是直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数。它允许是一个大于 <code>0</code> 且小于 <code>100</code> 的整数，就是垃圾收集时间占总时间的比率。</p><p>另外，<code>Parallel Scavenge</code> 收集器拥有自适应调节机制，它不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 与 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象大小 <code>-XX:PretenureSizeThreshold</code> 等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间及最大的吞吐量。可使用 <code>-XX:UseAdaptiveSizePolicy</code> 参数来开启。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><code>Serial Old</code> 是 <code>Serial</code> 收集器的老年代版本，是一个单线程收集器，使用“标记-整理算法”。</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p><code>Parallel Old</code> 是 <code>Parallel Scavenge</code> 收集器的老年代版本，使用多线程和“标记-整理”算法。如果新生代选择了 <code>Parallel Scavenge</code> 收集器，老年代只能选择 <code>Serial Old</code> 收集器。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p><code>CMS(Concurrent Mark Sweep)</code> 是一种以获取最短停顿时间为目标的收集器，使用“标记-清除”算法。如果应用重视响应速度，希望停顿时间最短，就可以选择 <code>CMS</code> 收集器。</p><p>它的运作过程可分为 <code>4</code> 个步骤：</p><ul><li>初始标记：仅仅标记 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要 <code>Stop the world</code>。</li><li>并发标记：进行 <code>GC Roots Tracing</code> 过程。 </li><li>重新标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。</li><li>并发清除。</li></ul><p><code>CMS</code> 的主要优点是并发收集、低停顿。但也有三个缺点：</p><ul><li>对 <code>CPU</code> 资源非常敏感。并发阶段虽不会导致用户线程停顿，但会因为占用资源而导致程序变慢，总吞吐量降低。</li><li>无法处理浮动垃圾，也就是在标记过程后，清除阶段产生但当次收集中不能处理的垃圾，可能出现 <code>Concurrent Mode Failure</code> 失败而导致另一次 <code>Full FC</code> 的产生。</li><li><code>CMS</code> 基于标记-清除算法，收集结束时会产生大量空间碎片。碎片过多时，无法找到足够的连续空间来分配大对象，不得不提前出发一次 <code>Full GC</code>。</li></ul><p>可以使用 <code>-XX:UseConcMarkSweepGC</code> 参数来选择 <code>CMS</code> 收集器。</p><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p><code>G1(Garbage-First)</code> 是一款面向服务端应用的垃圾收集器。它的特点如下：</p><ul><li>并行与并发：充分利用多 <code>CPU</code>、多核环境，使用多个 <code>CPU</code> 来缩短停顿的时间，部分需要其他收集器原本需要停顿 <code>Java</code> 线程执行的 <code>GC</code> 动作，<code>G1</code> 收集器可通过并发的方式让 <code>Java</code> 程序继续执行。</li><li>分代收集：<code>G1</code> 收集器能独立管理整个 <code>GC</code> 堆，并且能采用不同的方式处理不同时期的对象。</li><li>空间整合：<code>G1</code> 收集器从整体来看，基于“标记-整理”算法实现；从局部来看，基于“复制”算法实现。</li><li>可预测的停顿：<code>G1</code> 能明确指定垃圾收集的限制时间。</li></ul><p>使用 <code>G1</code> 收集器时，将 <code>Java</code> 堆划分为多个大小相等的区域 <code>Region</code>。<code>G1</code> 跟踪各个 <code>Region</code> 的回收价值和成本（回收获得空间及回收时间），后台会维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>。它通过使用 <code>Remembered Set</code> 来避免全堆扫描。</p><p><code>G1</code> 收集器的运行步骤可分为：</p><ul><li>初始标记：仅仅标记一下 <code>GC Roots</code> 直接能关联到的对象，需要停顿，但耗时很短。</li><li>并发标记：从 <code>GC Roots</code> 开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，但可并发执行。</li><li>最终标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。</li><li>筛选回收：对各个 <code>Region</code> 的回收价值和成本进行排序，根据指定的 <code>GC</code> 停顿时间制定回收计划。</li></ul><h1 id="常用收集器组合"><a href="#常用收集器组合" class="headerlink" title="常用收集器组合"></a>常用收集器组合</h1><p><code>HotSpot</code> 虚拟机中包含了七种垃圾收集器，如下图：</p><p><img src="http://media.timberliu.com/image/2019/2/23/GC%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.png" width="60%"></p><p>它们的组合说明如下：</p><table><thead><tr><th>新生代收集器</th><th>年老代收集器</th><th>说明</th></tr></thead><tbody><tr><td>Serial</td><td>Serial Old</td><td>都是单线程，GC 时会暂停所有应用线程。<br>使用 -XX:+UseSerialGC 选项来开启</td></tr><tr><td>Serial</td><td>CMS + Serial Old</td><td>CMS 是并发 GC，不需要暂停所有应用线程。<br>当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC<br>使用 -XX:+UseConcMarkSweepGC 选项来开启</td></tr><tr><td>ParNew</td><td>CMS</td><td>ParNew 是 Serial 的并行版本，可以指定 GC 线程数<br>默认 GC 线程数为 CPU 的数量</td></tr><tr><td>ParNew</td><td>Serial Old</td><td>使用 -XX:+UseParNewGC 选项来开启</td></tr><tr><td>Parallel Scavenge</td><td>Serial Old</td><td>Parallel Scavenge 策略关注吞吐量，适用于后台持久运行的应用程序<br>使用 -XX:+UseParallelGC 选项来开启</td></tr><tr><td>Parallel Scavenge</td><td>Parallel Old</td><td>Parallel Old 是 Serial Old 的并行版本<br>使用 -XX:+UseParallelOldGC 选项来开启</td></tr><tr><td>G1GC</td><td>G1GC</td><td>-XX:+UseG1GC #开启<br>-XX:MaxGCPauseMillis #暂停时间目标</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>雨点的名字：<a href="https://www.cnblogs.com/qdhxhz/p/9211269.html" target="_blank" rel="noopener">【JVM虚拟机】（3）—垃圾回收器</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中学习了 &lt;code&gt;JVM&lt;/code&gt; 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 &lt;code&gt;HotSpot&lt;/code&gt; 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。&lt;/p&gt;
&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;p&gt;&lt;code&gt;HotSpot&lt;/code&gt; 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。&lt;/p&gt;
    
    </summary>
    
      <category term="2.3 JVM" scheme="https://blog.timberliu.com/categories/2-3-JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
</feed>
