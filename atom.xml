<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimberLiu&#39;s Blog</title>
  
  <subtitle>Easy coding, easy life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.timberliu.com/"/>
  <updated>2019-02-17T16:00:00.000Z</updated>
  <id>https://blog.timberliu.com/</id>
  
  <author>
    <name>TimberLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 反射与动态代理</title>
    <link href="https://blog.timberliu.com/2019/02/18/023_Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://blog.timberliu.com/2019/02/18/023_Java 反射与动态代理/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。</p><p>一般来说，<code>Java</code> 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。<a id="more"></a></p><h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>反射机制指的是程序在运行时自省（<code>introspect</code>，即能够获取自身信息）的能力。在 <code>Java</code> 中，只要给定类的完全限定名，就可以通过反射直接操作类或对象。它主要有以下几个作用：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时判断任意一个类具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>在运行时构造任意一个类的对象；</li></ul><p>可以看到，反射提高了程序的灵活性和扩展性。但同时降低了代码的可读性和维护性；又因为反射涉及到动态类型，无法执行某些虚拟机优化，所以代码的执行性能也降低；另外，可以访问任意成员变量和方法，也破坏了封装性。一般来说，在业务代码中应尽量避免使用反射，但必须能理解中间件或框架中的反射代码。</p><p>反射的应用场景非常多。例如，对象序列化，动态代理，<code>JDBC</code> 的 <code>Class.forName()</code>，<code>RPC</code> 框架，<code>Spring</code> 的 <code>IOC/DI</code>。</p><h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p><code>Java</code> 的 <code>Class</code> 类是反射机制的基础，包含了被装入到 JVM 中的类（包括类和接口）的信息。每个类（型）都有一个 <code>Class</code> 对象，也就是说每当编写并编译了一个新类，就会产生一个 <code>Class</code> 对象，被保存在一个同名的 <code>.class</code> 文件中。</p><p>所有的类都是在对其第一次使用时，动态加载到 <code>JVM</code> 中的。当运行程序时，类加载器会首先检查这个类的 <code>class</code> 对象是否已经加载，如果没有加载，类加载器就会根据类名查找 <code>.class</code> 文件，并将其 <code>Class</code> 对象载入。</p><p>获取某一个类所对应的 <code>Class</code> 对象有三种方法：</p><p>1). 根据对象的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Class c = user.getClass();</span><br></pre></td></tr></table></figure><p>2). 根据 <code>Class</code> 的静态方法 <code>forName()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"com.timber.User"</span>);</span><br></pre></td></tr></table></figure><p>3). 根据类名 <code>.class</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class;</span><br></pre></td></tr></table></figure><p>对于基本类型来说，它们的包装类型拥有一个名为 <code>TYPE</code> 的 <code>final</code> 静态字段，指向该基本类型对应的 <code>Class</code> 对象。例如，<code>Integer.TYPE</code> 指向 <code>int.class</code>。</p><p>对于数组类型来说，可以使用 <code>类名 + [].class</code> 来访问 <code>Class</code> 对象。例如，<code>int[].class</code>。</p><h1 id="使用反射创建对象"><a href="#使用反射创建对象" class="headerlink" title="使用反射创建对象"></a>使用反射创建对象</h1><p>在 <code>Java</code> 中创建对象主要有四种方式：</p><ul><li>通过 <code>new</code> 关键字创建；</li><li>使用反射；</li><li>使用 <code>clone</code> 方法；</li><li>使用反序列化；</li></ul><p><strong>使用反射</strong></p><p><code>Java</code> 中使用反射创建对象主要有两种方法：</p><p>1). 使用 <code>Class</code> 类的 <code>newInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">Class&lt;?&gt; userClass = Class.forName(<span class="string">"com.timber.User"</span>);  <span class="comment">// 给定类的完全限定名</span></span><br><span class="line">User user = (User) userClass.newInstance();</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">User user = User.class.newInstance();</span><br></pre></td></tr></table></figure><p>2). 使用 <code>Constructor</code> 类的 <code>newInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = (User) constructor.newInstance();</span><br></pre></td></tr></table></figure><p>事实上，<code>Class</code> 的 <code>newInstance</code> 方法内部就是调用 <code>Constructor</code> 的 <code>newInstance</code> 方法。如下为 <code>Class</code> 类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Unsafe.getUnsafe().throwException(e.getTargetException());</span><br><span class="line">        <span class="comment">// Not reached</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用反射功能"><a href="#使用反射功能" class="headerlink" title="使用反射功能"></a>使用反射功能</h1><p>在得到 <code>Class</code> 对象后，可以正式使用反射功能了。除了使用 <code>newInstance()</code> 生成类的实例，还有以下几项： </p><p>1). 使用 <code>isInstance(Object o)</code> 来判断一个对象是否该类的实例，等同于 <code>instanceof</code> 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class.newInstance();</span><br><span class="line"><span class="keyword">boolean</span> b = c.isInstance(user);</span><br></pre></td></tr></table></figure><p>2). 使用 <code>Array.newInstance(Class c, int size)</code> 来构造该类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = Array.newInstance(<span class="keyword">int</span>[].class, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>3). 使用 <code>getFields()/getConstructors()/getMethods()</code> 来访问该类的成员。需要注意，方法名中带 <code>Declared</code> 的不会返回父类的成员，但是会返回私有成员；而不带 <code>Declared</code> 的则相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = c.getMethods();</span><br><span class="line">Method[] methods = c.getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>当获得类成员之后，可以进一步做如下操作：</p><ul><li>使用 <code>Constructor/Field/Method.setAccessible()</code> 来修改访问限制</li><li>使用 <code>Constructor.newInstance(Object[])</code> 来生成该类的实例</li><li>使用 <code>Field.set/get(Object)</code> 来访问字段值</li><li>使用 <code>Method.invoke(Object, Object[])</code> 来调用方法</li></ul><p>实例：在泛型为 <code>Integer</code> 的 <code>ArrayList</code> 中存放一个 <code>String</code> 类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; listClass = list.getClass();</span><br><span class="line">        Method method = listClass.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(list, <span class="string">"test"</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h1><p>在前面的方法中，<code>Class.forName</code> 会调用本地方法，<code>Class.getMethod()</code> 会遍历该类的共有方法，如果找不到，还会遍历父类的私有方法，所以它们的操作都很费时。另外，<code>Method.getMethods()</code> 等方法还会返回查找结果的一份拷贝。</p><p>在实践中，应该避免在热点代码中使用 <code>Method.getMethods()</code> 和 <code>Method.getDeclaredMethods()</code> 方法。并且往往会缓存 <code>Class.forName()</code> 和 <code>Method.getMethod()</code> 的结果。</p><p>在反射调用时会带来不少性能开销，主要原因有三个：</p><ul><li>由于 <code>Method.invoke</code> 是一个变长参数方法，在调用时会生成一个 <code>Object</code> 数组</li><li>由于 <code>Object</code> 数组不能存储基本类型，所以会对基本类型进行自动装箱、拆箱</li><li>如果拥有多个不同的反射调用，就会对应多个 <code>GeneratedMethodAccessor</code>，可能由于 <code>JVM</code> 调用点的类型 <code>profile</code> 无法同时记住多个类，而没有被内联</li></ul><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>代理是基本的设计模式之一。它可以通过访问代理对象来完成对目标对象的访问，在不修改原对象的情况下扩充其功能。可以分为静态代理和动态代理两种。</p><p>静态代理，就是代理类由程序员自己编写，代理模式中的所有对象在编译期就已经确定。下面是一个简单的例子，首先定义一个接口和其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"目标对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是代理模式中的目标对象和目标对象的接口，接下来定义代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用目标对象之前"</span>);</span><br><span class="line">        target.say();</span><br><span class="line">        System.out.println(<span class="string">"调用目标对象之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个代理类，它同样实现了目标对象的接口，并重写了 say 方法。下面是一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(target);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用目标对象之前</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 调用目标对象之后</span></span><br></pre></td></tr></table></figure><p>静态代理也存在一些局限，例如，需要程序员手写很多代码，并且当需要代理的类中方法比较多，或者同时需要代理多个对象时，实现会很复杂。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理中的代理类是在运行期动态生成的。在 <code>Java</code> 中，动态代理有两种方式：</p><p>1). <code>JDK</code> 接口 + 反射方式</p><p>这种方式主要通过 <code>java.lang.reflect</code> 包中的 <code>Proxy</code> 类和 <code>InvocationHandler</code> 接口实现。由于是 <code>JDK</code> 本身支持，可能比 <code>cglib</code> 更加可靠，代码实现也比较简单。<br>但是它有一个限制，就是代理对象必须实现一个或多个接口。</p><p>2). <code>cglib</code> 继承 + <code>asm</code> 方式</p><p><code>cglib</code> 是一个第三方代码生成类库，通过在运行时动态生成一个子类对象来实现，它底层通过一个小而快字节码处理框架 <code>asm</code>，转换字节码来生成新的类。这种方式无需实现接口，达到了代理类无侵入。但是无法代理 <code>final</code> 类和父类的 <code>static/final</code> 方法。</p><p><code>cglib</code> 虽然性能较高，但是它需要对 <code>JVM</code> 内部结构包括 <code>Class</code> 文件格式和指令集很熟悉，所以不鼓励使用。</p><p><code>Java</code> 的动态代理最主要的用途就是应用在各种框架中。例如，<code>RPC</code> 框架，<code>Spring</code> 中的 <code>AOP</code>，<code>Servlet</code> 的过滤器、拦截器。像 <code>Mybatis</code> 的分页插件，<code>Spring AOP</code> 中类似日志、事务、权限、性能监控等都用到了动态代理，以在不同模块的特定阶段实现某些功能。</p><h1 id="两种实现方法"><a href="#两种实现方法" class="headerlink" title="两种实现方法"></a>两种实现方法</h1><p>1). <code>JDK</code> 动态代理</p><p>目标对象的接口和实现和静态代理中一样，下面定义调用处理器类，它需要实现 <code>IovacationHandler</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前:"</span> + method.getName());</span><br><span class="line">        <span class="comment">// 将请求转发给目标对象，并传入相应的参数</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"调用后:"</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入类加载器、希望该代理类实现的接口类数组、调用处理器，构造代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        JDKInvocationHandler handler = <span class="keyword">new</span> JDKInvocationHandler(target);</span><br><span class="line">        UserService proxy = (UserService) handler.getProxy();</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用前:say</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 调用后:say</span></span><br></pre></td></tr></table></figure><p>2). <code>Cglib</code> 动态代理</p><p>目标对象和之前的一致，下面定义代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class c)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(c);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开事务"</span>);</span><br><span class="line">        Object retVal = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"关闭事务"</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserServiceImpl proxyImpl = (UserServiceImpl) proxy.getProxy(UserServiceImpl.class);</span><br><span class="line">        proxyImpl.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开事务</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 关闭事务</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;code&gt;Java&lt;/code&gt; 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型、枚举、注解</title>
    <link href="https://blog.timberliu.com/2019/02/17/022_%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.timberliu.com/2019/02/17/022_泛型、枚举、注解/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2019-02-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h1><p><code>Java</code> 泛型是 <code>JDK5</code> 中引入的一个特性，允许在定义类和接口时使用类型参数。声明的类型参数在使用时用具体的类型来替换。最主要的应用就是在集合类框架中。</p><p>泛型最大的好处就是可以提高代码的复用性。例如，<code>List</code> 接口，可以将 <code>String</code>、<code>Integer</code> 等多种类型放入到 <code>List</code> 中。<a id="more"></a></p><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><p>不同语言中，编译器处理泛型有两种方式：</p><ul><li><code>Code Specilization</code>。在实例化一个泛型类或泛型方法时，都会产生一个新的目标代码(字节码或二进制代码)。在 <code>C++</code> 和 <code>C#</code> 中就使用这种机制，但是会导致代码膨胀。基于这种方法实现的泛型也称为真实泛型。 </li><li><code>Code Sharing</code>。每个泛型类只生成唯一的一份目标代码，该类的所有实例都映射到这份目标代码，在需要时执行类型检查和类型转换。基于这种方法实现的泛型也称为伪泛型。 </li></ul><p>在 <code>Java</code> 中，它只在程序源码中存在，在编译后的字节码文件中，已经被替换为原生类型，并在相应地方插入了强制转型代码。所以说，<code>Java</code> 的泛型仅是一种语法糖，它的实现方法就称为类型擦除。</p><p>类型擦除指的是通过类型参数合并，将泛型参数实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并在必要时添加类型检查和类型转换的方法。</p><p>例如，下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"timber"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"timber"</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型擦除的问题"><a href="#类型擦除的问题" class="headerlink" title="类型擦除的问题"></a>类型擦除的问题</h1><p>如果泛型遇到重载，可能会遇到问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"List&lt;String&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"List&lt;Integer&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，参数类型看起来不同，是重载方法。但这段代码是编译通不过的。在编译后，参数 <code>List&lt;Integer&gt;</code> 和 <code>List&lt;String&gt;</code> 在类型擦除后都变成了 <code>List</code>，导致方法特性签名一样。</p><h1 id="泛型限定通配符"><a href="#泛型限定通配符" class="headerlink" title="泛型限定通配符"></a>泛型限定通配符</h1><p>限定通配符用于对泛型进行限制，在初始化时就必须使用限定内的类型，否则会导致编译错误。有两种限定通配符：</p><ul><li><code>&lt;? extends T&gt;</code>：设定泛型类型的上边界，保证泛型类型必须是 <code>T</code> 的子类；</li><li><code>&lt;? super T&gt;</code>：设定泛型类型的下边界，包装泛型类型必须是 <code>T</code> 的父类。</li></ul><p>在使用时可根据 <code>PECS</code> 原则判断：</p><ul><li>如果要从集合中读取类型 <code>T</code> 的数据，但不写入，可以使用 <code>&lt;? extends T&gt;</code> 的通配符（<code>Producer Extends</code>）。</li><li>如果要从集合中写入类型 <code>T</code> 的数据，但不读取，可以使用 <code>&lt;? super T&gt;</code> 通配符（<code>Consumer super</code>）。</li><li>如果既要写入又要读取，那就不要使用任何通配符。</li></ul><p>非限定通配符 <code>&lt;?&gt;</code> 表示可以用任意泛型类型来替代。</p><h1 id="List、List-lt-gt-、List"><a href="#List、List-lt-gt-、List" class="headerlink" title="List、List&lt;?&gt;、List"></a>List、List&lt;?&gt;、List<object></object></h1><ul><li><code>List</code>：在编译时编译器不会对 <code>List</code> 进行类型安全检查；可以把任何带参数的类型传递给 <code>List</code>；</li><li><code>List&lt;?&gt;</code>：未知类型的 <code>List</code>，可以把任何带参数的类型传递给 <code>List</code>；</li><li><code>List&lt;Object&gt;</code>：任意类型的 <code>List</code>，在编译时编译器会对 <code>List&lt;?&gt;</code> 进行类型安全检查；不能把任何带参数的类型传递给 <code>List&lt;Object&gt;</code>；</li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举（<code>enum</code>）从 <code>JDK1.5</code> 引入，是指由一组固定的常量组成合法的类型。由关键字 <code>enum</code> 来定义一个枚举。例如：</p><p><code>Java</code> 中的枚举类型有以下特点：</p><ul><li>使用关键字 <code>enum</code> 和类型名称</li><li>一串允许的值</li><li>枚举可以单独定义在一个 <code>Java</code> 类中，也可以嵌在其它 <code>Java</code> 类中</li><li>枚举可以实现一个或多个接口（Interface）</li><li>可以定义新的变量和方法</li><li>可以定义根据具体枚举值而相异的类</li></ul><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </span><br><span class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), </span><br><span class="line">    GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), </span><br><span class="line">    BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), </span><br><span class="line">    YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c.getIndex() == index) &#123;  </span><br><span class="line">                <span class="keyword">return</span> c.name;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举是如何实现的"><a href="#枚举是如何实现的" class="headerlink" title="枚举是如何实现的"></a>枚举是如何实现的</h1><p><code>enum</code> 关键字也是 <code>Java</code> 提供的一个语法糖。如果对刚才的这个枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>jad Season.class</code> 进行反编译，看它是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timberliu.enum0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Season[] values() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Season[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Season)Enum.valueOf(timberliu/enum0/Season, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Season $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> Season(<span class="string">"SPRING"</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> Season(<span class="string">"SUMMER"</span>, <span class="number">1</span>);</span><br><span class="line">        AUTUMN = <span class="keyword">new</span> Season(<span class="string">"AUTUMN"</span>, <span class="number">2</span>);</span><br><span class="line">        WINTER = <span class="keyword">new</span> Season(<span class="string">"WINTER"</span>, <span class="number">3</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Season[] &#123;</span><br><span class="line">            SPRING, SUMMER, AUTUMN, WINTER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>public final class Season extends Enum</code> 说明该类是继承 <code>Enum</code>，同时 <code>final</code> 也说明该类不能被继承。</p><p>四个变量 <code>SPRING</code>、<code>SUMMER</code>、<code>AUTUMN</code>、<code>WINTER</code> 都是 <code>static final</code> 的，通过 <code>static</code> 进行初始化。而 <code>static</code> 类型的属性在类加载时就被初始化，所以创建一个 <code>enum</code> 类型是线程安全的。</p><h1 id="Enum-源码"><a href="#Enum-源码" class="headerlink" title="Enum 源码"></a>Enum 源码</h1><p><code>Enum</code> 类是 <code>java.lang</code> 包中一个类，是 <code>Java</code> 中所有枚举类型的公共基类。</p><p><strong>定义</strong></p><p>首先看以下 <code>Enum</code> 类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>可以看到，它是一个抽象类，由于抽象类不能被实例化，所以在程序中不能使用 <code>new</code> 关键字来声明一个 <code>Enum</code>。</p><p>从之前反编译的代码可以看到，在使用 <code>enum</code> 关键字定义一个枚举时，编译时默认继承 <code>Enum</code> 类，并加上 <code>final</code> 声明，故枚举无法继承。</p><p><code>Enum</code> 类实现了 <code>Serializable</code> 接口，可以序列化。实现了 Comparable 接口，可以进行比较，默认情况下只有同类型的 <code>enum</code> 可以比较。</p><p><code>E extends Enum&lt;E&gt;</code> 表示一个继承了 <code>Enum&lt;E&gt;</code> 类型的枚举类型，<code>Enum&lt;E extends Enum&lt;E&gt;&gt;</code> 就是一个 <code>Enum</code> 只接受一个 <code>Enum</code> 或者它的子类作为参数。</p><p><strong>成员变量</strong></p><p>在 <code>Enum</code> 中，有两个成员变量，一个是名字(<code>name</code>)，一个是序号(<code>ordinal</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序号是一个枚举常量，表示在枚举中的位置，从 <code>0</code> 开始，依次递增。</p><p><strong>构造器</strong></p><p>在 <code>Enum</code> 类中只有一个保护类型的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面反编译的代码中 <code>super(s, i);</code> 就是调用 <code>Enum</code> 类中的这个保护类型的构造函数来初始化 <code>name</code> 和 <code>ordinal</code>。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><code>Java</code> 注解，也叫元数据，一种代码级别的说明。在 <code>JDK1.5</code> 之后引入，可以声明在类、方法、字段、方法、方法参数等前面，用来对元素进行说明注释。</p><p>元注解就是用来定义其他注解的注解。元注解主要以下四个：</p><ul><li><code>@Target</code>：表示该注解可以用于什么地方，可能的值在枚举类 <code>ElementType</code> 中；</li><li><code>@Retention</code>：表示在什么级别保存该注解信息，可能的值在 <code>RetentionPolicy</code> 中；</li><li><code>@Documented</code>：将此注解包含在 <code>javadoc</code> 中；</li><li><code>@Inherited</code>：允许子类继承父类。</li></ul><p>自定义注解就是通过元注解定义出来的注解。除了元注解外，其他都是自定义注解。例如常见的 <code>Override</code>、<code>Autowrited</code> 等。</p><h1 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h1><p>在 <code>Java</code> 中，注解的定义和接口差不多，但增加了一个 <code>@</code> 符号，即 <code>@interface</code>。代码中可以定义成员变量，用于描述信息。也可以添加默认值。</p><p>然后还要在注解上面添加元注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType类中的常量值)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy=RUNTIME)</span><br><span class="line">[<span class="meta">@Documented</span>]</span><br><span class="line">[<span class="meta">@Inherited</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    返回类型 方法名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-中常用的注解"><a href="#Spring-中常用的注解" class="headerlink" title="Spring 中常用的注解"></a>Spring 中常用的注解</h1><ul><li><code>@Component</code>：泛指组件，当组件不好归类时，可以使用这个注解进行标注；</li><li><code>@Service</code>：用于标注业务层组件；</li><li><code>@Controller</code>：用于标注控制层组件；</li><li><code>@Repository</code>：用于标注数据访问层组件；</li><li><code>@AutoWried</code>：默认按类型装配；可结合 <code>@qualifier</code> 注解按名称装配；</li><li><code>@RequestMapping</code>：用于将 <code>HTTP</code> 请求映射到 <code>Controller</code> 的处理方法上；</li><li><code>@PathVariable</code>：用于将 <code>URL</code> 中占位符的参数绑定到 <code>Controller</code> 处理方法的参数上;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-泛型&quot;&gt;&lt;a href=&quot;#Java-泛型&quot; class=&quot;headerlink&quot; title=&quot;Java 泛型&quot;&gt;&lt;/a&gt;Java 泛型&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 泛型是 &lt;code&gt;JDK5&lt;/code&gt; 中引入的一个特性，允许在定义类和接口时使用类型参数。声明的类型参数在使用时用具体的类型来替换。最主要的应用就是在集合类框架中。&lt;/p&gt;
&lt;p&gt;泛型最大的好处就是可以提高代码的复用性。例如，&lt;code&gt;List&lt;/code&gt; 接口，可以将 &lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt; 等多种类型放入到 &lt;code&gt;List&lt;/code&gt; 中。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://blog.timberliu.com/2019/02/17/021_%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://blog.timberliu.com/2019/02/17/021_序列化与反序列化/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2019-02-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>序列化(<code>Serialization</code>)是将对象转换为可传输的格式的过程，一般是以字节码或 <code>XML</code> 格式传输。而反序列化是将字节码或 <code>XML</code> 码编码格式还原为完全相等的对象的过程。</p><p>对象序列化机制也是一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并在需要时将这个字节数组通过反序列化的方式再转换成对象，如此可以很容易地在对象和字节数组之间进行转换。</p><p>除了持久化时用到序列化之外，当在网络中传输对象、使用 <code>RMI</code> 和 <code>RPC</code> 时，都会用到对象序列化。<a id="more"></a></p><h1 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h1><p>Java 中提供了一套方便的 API 来支持，将对象进行序列化和反序列化。其中包括以下接口和类：</p><ul><li><code>java.io.Serializable</code></li><li><code>java.io.Externalizable</code></li><li><code>ObjectOutputStream</code></li><li><code>ObjectInputStream</code></li><li><code>ObjectOutput</code></li><li><code>ObjectInput</code></li></ul><h2 id="ObjectInput-和-ObjectOutput-接口"><a href="#ObjectInput-和-ObjectOutput-接口" class="headerlink" title="ObjectInput 和 ObjectOutput 接口"></a>ObjectInput 和 ObjectOutput 接口</h2><p><strong>ObjectInput</strong></p><p><code>ObjectInput</code> 接口扩展自 <code>DataInput</code> 接口以包含对象的读操作。</p><p><code>DataInput</code> 接口用于从二进制流中读取字节，并根据所有 <code>Java</code> 基本类型数据进行重构。同时还提供根据 <code>UTF-8</code> 修改版格式的数据重构 <code>String</code> 的工具。</p><p>对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (<code>end of file</code>)，则将抛出 <code>EOFException</code>（<code>IOException</code> 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 <code>IOException</code> 而不是 <code>EOFException</code>。尤其是，在输入流已关闭的情况下，将抛出 <code>IOException</code>。</p><p><strong>ObjectOutput</strong></p><p><code>ObjectOutput</code> 扩展 <code>DataOutput</code> 接口以包含对象的写入操作。</p><p><code>DataOutput</code> 接口用于将数据从任意 <code>Java</code> 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 <code>String</code> 转换成 <code>UTF-8</code> 修改版格式并写入所得到的系列字节的工具。</p><p>对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 <code>IOException</code>。</p><h2 id="ObjectInputStream-和-ObjectOutputStream-类"><a href="#ObjectInputStream-和-ObjectOutputStream-类" class="headerlink" title="ObjectInputStream 和 ObjectOutputStream 类"></a>ObjectInputStream 和 ObjectOutputStream 类</h2><p>通过 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 可以对对象进行序列化及反序列化。一般使用 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法把一个对象进行持久化，再使用 <code>ObjectInputStream</code> 的 <code>readObject</code> 从持久化存储中把对象读取出来。</p><h2 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h2><p>Java 中，只要类实现 <code>java.io.Serializable</code> 接口就表示可以被序列化。没有实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p><p>当试图对一个对象进行序列化的时候，如果遇到不支持 <code>Serializable</code> 接口的对象。在此情况下，将抛出 <code>NotSerializableException</code>。</p><p>如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该实现 <code>java.io.Serializable</code> 接口。</p><p>举个栗子，下面是一个实现了 <code>java.io.Serializable</code> 接口的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个 <code>User1</code> 对象进行序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User1 user = <span class="keyword">new</span> User1();</span><br><span class="line">        user.setName(<span class="string">"timber"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"before: "</span> + user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User1 newUser = (User1) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">"after: "</span> + newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: User1&#123;name=<span class="string">'timber'</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">after: User1&#123;name=<span class="string">'timber'</span>, age=<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h2><p>除了 <code>Serializable</code> 之外， <code>Java</code> 中还提供了另一个序列化接口 <code>Externalizable</code> 来自定义序列化和反序列化策略。该接口中定义了抽象方法：<code>writeExternal</code> 与 <code>readExternal</code> 方法。当使用 <code>Externalizable</code> 进行序列化和反序列化时需要实现这两个方法。</p><p>如果在这两个方法中没有定义序列化实现细节，进行序列化和反序列化后得到的对象的所有属性的值都变成了默认值。也就是说之前的那个对象的状态并没有被持久化下来。</p><p>另外，若使用 <code>Externalizable</code> 接口进行序列化，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 <code>Externalizable</code> 接口的类必须要提供一个 <code>public</code> 的无参的构造器。</p><p>下面是一个实现 <code>Externalizable</code> 接口的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User1&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个 <code>User2</code> 对象进行序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user = <span class="keyword">new</span> User2();</span><br><span class="line">        user.setName(<span class="string">"timber"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to file</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        User2 user2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">            user2 = (User2) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p><code>transient</code> 关键字可以控制变量的序列化。如果在变量声明前加上该关键字，可以阻止该变量被序列化。在被反序列化时，<code>transient</code> 变量的值被设为初始值，如 <code>int</code> 类型是 <code>0</code>，引用类型是 <code>null</code>。</p><h2 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 <code>ID</code> 是否一致（就是 <code>private static final long serialVersionUID</code>)。</p><p>序列化 <code>ID</code> 一般有两种生成策略：</p><ul><li>一种是固定的 <code>1L</code>。如果没有特殊需求，就是用默认的 <code>1L</code> 就可以；</li><li>一种是随机生成一个不重复的 <code>long</code> 类型数据。有时可通过改变序列化 <code>ID</code> 可以用来限制某些用户的使用。</li></ul><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>在 <code>Java</code> 序列化保存对象时，会将其状态保存为一组字节，在需要时将这些字节封装成对象。这里的状态指的是对象的成员变量，也就是说不会保存类中的静态变量。</p><h2 id="Serializable接口为空？"><a href="#Serializable接口为空？" class="headerlink" title="Serializable接口为空？"></a>Serializable接口为空？</h2><p><code>Serializable</code> 虽只是一个空接口。但底层实现中，在序列化操作时，会判断要被序列化的类是否是 <code>Enum</code>、<code>Array</code> 和 <code>Serializable</code> 类型，如果不是则直接抛出 <code>NotSerializableException</code>。以此来保证只有实现了该接口的方法才能进行序列化与反序列化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序列化与反序列化&quot;&gt;&lt;a href=&quot;#序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化&quot;&gt;&lt;/a&gt;序列化与反序列化&lt;/h1&gt;&lt;p&gt;序列化(&lt;code&gt;Serialization&lt;/code&gt;)是将对象转换为可传输的格式的过程，一般是以字节码或 &lt;code&gt;XML&lt;/code&gt; 格式传输。而反序列化是将字节码或 &lt;code&gt;XML&lt;/code&gt; 码编码格式还原为完全相等的对象的过程。&lt;/p&gt;
&lt;p&gt;对象序列化机制也是一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并在需要时将这个字节数组通过反序列化的方式再转换成对象，如此可以很容易地在对象和字节数组之间进行转换。&lt;/p&gt;
&lt;p&gt;除了持久化时用到序列化之外，当在网络中传输对象、使用 &lt;code&gt;RMI&lt;/code&gt; 和 &lt;code&gt;RPC&lt;/code&gt; 时，都会用到对象序列化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String 源码阅读</title>
    <link href="https://blog.timberliu.com/2019/02/16/020_String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://blog.timberliu.com/2019/02/16/020_String源码阅读/</id>
    <published>2019-02-15T16:00:00.000Z</published>
    <updated>2019-02-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 JDK1.8，在其他版本中会有不同。</p></blockquote><h1 id="定义及属性"><a href="#定义及属性" class="headerlink" title="定义及属性"></a>定义及属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>String</code> 类被 <code>final</code> 修饰，表示不可变。实现了 <code>Serializable</code>, <code>Comparable&lt;String&gt;</code>, <code>CharSequence</code> 接口。<a id="more"></a></p><ul><li><code>value[]</code>：<code>String</code> 类底层通过 <code>final</code> 类型的 <code>char</code> 数组实现，用于存储字符串内容；</li><li><code>hash</code>：用于缓存当前字符串的 <code>hashcode</code> 值，默认为 <code>0</code>；</li></ul><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p><code>String</code> 类中重载的构造器很多，其中比较常用的有：</p><h2 id="字符串构造"><a href="#字符串构造" class="headerlink" title="字符串构造"></a>字符串构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个 <code>String</code> 类型的对象来初始化 <code>String</code>。实现中直接将源 <code>String</code> 的 <code>value</code> 和 <code>hash</code> 两个属性直接赋值给目标 <code>String</code>。</p><p>可以看出，新创建的 <code>String</code> 对象是传入的参数 <code>String</code> 的一个副本。除非确实需要显式得赋值一个字符串对象，否则没有必要使用此构造器来创建一个 <code>String</code> 对象。</p><h2 id="字符数组构造"><a href="#字符数组构造" class="headerlink" title="字符数组构造"></a>字符数组构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check bounds</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用一个 <code>char</code> 数组来创建一个 <code>String</code>，实现中通过 <code>Array.copyOf</code> 或 <code>Array.copyOfRange</code> 方法，将原有的字符数组中的内容逐一地赋值到新 <code>String</code> 的字符数组中。</p><p>在复制时，即可以复制整个字符数组，也可以通过 <code>offset</code> 和 <code>count</code> 两个参数来复制字符数组的一部分。</p><h2 id="字节数组构造"><a href="#字节数组构造" class="headerlink" title="字节数组构造"></a>字节数组构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>byte</code> 数组来构造一个 <code>String</code>，需要将 <code>byte</code> 数组转换为 <code>char</code> 数组。由于在网络传输中，经常需要在 <code>byte[]</code>、<code>char[]</code> 和 <code>String</code> 之间相互转化，所以 <code>StringCoding</code> 类提供了一系列重载的构造方法，例如这里的 <code>StringCoding.decode(charset, bytes, offset, length)</code> 方法，它通过指定的 <code>charset</code> 对 <code>byte</code> 数组解码为 <code>unicode</code> 的 <code>char</code> 数组，构造新的 <code>String</code>。</p><p>还有其他几种类似的构造方法，可以选择性地指定编码格式、解码的第一个字节下标、解码的字节数。</p><p>在 <code>StringCoding.decode</code> 方法中，如果没有指定编码格式，则默认使用 <code>ISO-8859-1</code> 格式进行操作。</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h2><p><code>equals</code> 方法用于比较当前对象与传入的字符串对象是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果它们是一个对象，肯定为 true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的对象必须是 String</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 将 Object 强转为 String 类型</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 两者的字符序列长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 逐一比较两个字符数组的每一个字符</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 只要有一个不等，即返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>regionMatches</code> 方法用于比较当前对象与传入的字符串对象的指定区域是否相等。但可以传入一个 <code>boolean</code> 值用于指定是否忽略大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">            <span class="comment">// 根据传入的 boolean 值来判断是否分别转换为大写、小写进行比较</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code> 方法按照字典序比较两个字符串的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 逐一比较每一个字符的大小</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="comment">// 只要有一个能分为大小，即返回</span></span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>String</code> 类计算的 <code>hashcode</code> 的公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>]*<span class="number">31</span>^(n-<span class="number">1</span>) + s[<span class="number">1</span>]*<span class="number">31</span>^(n-<span class="number">2</span>) + ... + s[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charset, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指定的字符集编码将 <code>String</code> 对象编码成一个 <code>byte</code> 数组。也有不指定编码格式的 <code>getBytes</code> 版本，会默认使用系统的编码方式，例如在中文操作系统中可能使用 <code>GBK</code>，在英文系统中可能使用 <code>IOS-8859-1</code> 格式。</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p><code>indexOf</code> 方法返回指定字符在当前 <code>String</code> 对象第一次出现的索引位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> max = value.length;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &gt;= max) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个完整的 Unicode 字符叫代码点 CodePoint，</span></span><br><span class="line">    <span class="comment">// String 对象以 UTF-16 保存 Unicode 字符，需要两个字符表示一个超大字符集的汉字</span></span><br><span class="line">    <span class="comment">// 如果 cd 参数小于 Unicode 补充代码点的最小值 0x010000</span></span><br><span class="line">    <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="comment">// 遍历字符数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符等于 ch，则返回索引 i</span></span><br><span class="line">            <span class="keyword">if</span> (value[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexOfSupplementary(ch, fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lastIndexOf</code> 方法返回指定字符在当前 <code>String</code> 对象最后一次出现的索引位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastIndexOfSupplementary(ch, fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p><code>replace</code> 方法将当前字符串对象中所有的 <code>oldChar</code> 字符替换为 <code>newChar</code>，返回一个新的 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从索引位置零开始，查找当前字符串中第一次出现字符 oldChar 的索引位置</span></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="comment">// 将 [0,i) 之间的字符直接缓存到 buf 字符数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历 [i, len - 1] 之间的字符</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                <span class="comment">// 如果遍历到的字符与 oldChar 相等，则替换，否则保持不变</span></span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法根据给定的正则表达式替换匹配到的第一个或全部的子字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><p><code>copyValueOf</code> 方法将指定的字符数组转换成一个 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>valueOf</code> 方法将六种基本数据类型的变量转换成 <code>String</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Float.toString(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>将指定的字符串拼接到当期字符串的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="comment">// 创建一个 len + otherLen 大小的数组，将 value 拷贝过去</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    <span class="comment">// 将 str 中的字符拷贝到 buf 中</span></span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h2><p>判断当前字符串从索引位置 <code>toofset</code> 开始是否以指定的前缀字符串开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前字符串是否以指定的前缀字符串开头或结尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>trim 方法可去掉字符串两端的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第一个不为 ' ' 的下标</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到最后一个不为 ' ' 的下标</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 substring 方法截取 [st, len] 之间的字符串</span></span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串中第 index 个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将 String 转换为 字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将 String 按照字符 regex 分为 limit 份</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 转换为大写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 转换为小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文基于 JDK1.8，在其他版本中会有不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;定义及属性&quot;&gt;&lt;a href=&quot;#定义及属性&quot; class=&quot;headerlink&quot; title=&quot;定义及属性&quot;&gt;&lt;/a&gt;定义及属性&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;CharSequence&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 类被 &lt;code&gt;final&lt;/code&gt; 修饰，表示不可变。实现了 &lt;code&gt;Serializable&lt;/code&gt;, &lt;code&gt;Comparable&amp;lt;String&amp;gt;&lt;/code&gt;, &lt;code&gt;CharSequence&lt;/code&gt; 接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String 类详解</title>
    <link href="https://blog.timberliu.com/2019/02/15/019_String%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.timberliu.com/2019/02/15/019_String类详解/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2019-02-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h1><p><code>String</code> 对象是不可变（<code>Immutable</code>）的，也就是一旦 <code>String</code> 类实例被创建后，就不能改变其值。这里的不可变指的是引用既不能指向其他对象，而且引用指向的对象的值也不能改变。<a id="more"></a></p><h2 id="为什么不可变"><a href="#为什么不可变" class="headerlink" title="为什么不可变"></a>为什么不可变</h2><p>在 <code>JDK1.6</code> 中，<code>String</code> 类中的成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在 <code>JDK1.7</code> 中，<code>String</code> 类主要改变了 <code>substring</code> 方法的实现，成员变量剩下了两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p>可以看出，<code>String</code> 就是字符数组的封装。在 <code>JDK6</code> 中，<code>value</code> 是一个 <code>char</code> 数组，<code>offset</code> 是 <code>String</code> 对象实际的起始位置，而 <code>count</code> 是所占的个数。在 <code>JDK7</code> 中，<code>value</code> 中的所有字符都属于 <code>String</code> 对象。</p><p><code>value</code>、<code>offset</code> 和 <code>count</code> 这三个变量都是 <code>private final</code> 的，并且没有 <code>setter</code> 方法来修改，所以 <code>String</code> 类外部无法修改 <code>String</code>。所以，一旦初始化后就不能修改，<code>String</code> 对象也就是不可变的。</p><h2 id="真的不可变吗"><a href="#真的不可变吗" class="headerlink" title="真的不可变吗"></a>真的不可变吗</h2><p><code>String</code> 中的 <code>char</code> 数组 <code>value</code> 是 <code>private final</code> 的，被 <code>final</code> 修饰 虽然不能指向其他数组对象，但却可以通过反射修改其指向的数组。</p><p>使用反射可以得到 <code>String</code> 类的 <code>value</code> 属性，修改访问权限，然后就可以对数组内容进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">// 获取 value 字段</span></span><br><span class="line">    Field field = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">// 修改 value 字段访问权限</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 获取 s 对象上 value 属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) field.get(s);</span><br><span class="line">    value[<span class="number">1</span>] = <span class="string">'d'</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// adc</span></span><br></pre></td></tr></table></figure><p>可以看到，通过反射是可以修改 “不可变” 对象的。</p><h2 id="不可变的优点"><a href="#不可变的优点" class="headerlink" title="不可变的优点"></a>不可变的优点</h2><p><code>String</code> 被设计为不可变的，在 <code>Security</code>、<code>Cache</code>、<code>Thread Safe</code> 方面都有很多优点：</p><ul><li>安全性。<code>String</code> 被广泛地使用在其他 <code>Java</code> 类中充当参数。例如 网络连接、<code>IO</code> 操作、数据库连接等，如果字符串可变，那么可能会导致安全问题。</li><li>字符串常量池。<code>String</code> 类维护了一个运行时常量池，会对创建的字符串进行缓存，如此在使用时更加高效。而这就建立在不可变的基础上，不用担心数据冲突问题。</li><li>缓存 <code>hashcode</code>。<code>Java</code> 中经常用到字符串的哈希值，字符串的不可变能保证其 <code>hashcode</code> 永远保持一致，这样在每次使用一个字符串的 <code>hashcode</code> 时，就不用重新计算一次，也更加高效。</li><li>线程安全性。由于 <code>String</code> 对象不能被改变，所以同一个字符串实例可以被多个线程共享，而不用因为线程安全问题使用同步。</li></ul><h2 id="不可变的缺点"><a href="#不可变的缺点" class="headerlink" title="不可变的缺点"></a>不可变的缺点</h2><p>当然，设计为不可变也会出现一些缺点，例如在类似拼接、裁剪等操作时，都会创建新的 <code>String</code> 对象，如果程序设计不当，便会产生大量无用的字符串对象，耗费时间空间。</p><h1 id="“-”-的实现"><a href="#“-”-的实现" class="headerlink" title="“+” 的实现"></a>“+” 的实现</h1><p>1、对于两个编译期常量(编译期可知)，例如 <code>String s = &quot;a&quot; + &quot;b&quot;</code>，编译器会进行常量折叠，即变成 <code>String s = &quot;ab&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String s1 = "ab";</span></span><br><span class="line"><span class="comment"> * String s2 = "a1";</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s1 = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>2、对于能够进行优化的(例如 <code>String s = &quot;a&quot; + s1</code> 等)用 <code>StringBuilder</code> 的 <code>append()</code> 方法替代，最后调用 <code>toString()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String s3 = (new StringBuilder()).append("a").append(s1).toString();</span></span><br><span class="line"><span class="comment"> * String s4 = (new StringBuilder()).append(s2).append(s3).toString();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s3 = <span class="string">"a"</span> + s1;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String s6 =</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; 2; i++) &#123;</span></span><br><span class="line"><span class="comment"> *     s6 = (new StringBuilder()).append(s6).append(i).toString();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s6 = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    s6 += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="substring-在-jdk6-和-7-的区别"><a href="#substring-在-jdk6-和-7-的区别" class="headerlink" title="substring 在 jdk6 和 7 的区别"></a>substring 在 jdk6 和 7 的区别</h1><p><code>substring</code> 是一个比较常用的方法，而且在 <code>jdk6</code> 和 <code>jdk7</code> 中的实现不同。<code>substring(int beginIndex, in endIndex)</code> 方法的作用是截取字符串并返回其 <code>[beginIndex, endIndex - 1]</code> 范围内的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abcdef"</span>;</span><br><span class="line">String substring = str.substring(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(substring);</span><br></pre></td></tr></table></figure><p>输出结果为：<code>cd</code>。</p><p><strong>JDK6 中的 substring</strong></p><p>前面说过，在 <code>JDK 6</code> 中，<code>String</code> 类的三个成员变量：<code>char value[]</code>，<code>int offset</code>，<code>int count</code>，三个变量决定了 <code>String</code> 存储的真正的字符数组。</p><p><code>String</code> 中主要相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检查边界</span></span><br><span class="line"><span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">    <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>substring</code> 方法时，会创建一个 <code>String</code> 对象，但 <code>value</code> 引用仍然指向堆中的同一个字符数组。它的内存变化：</p><p><img src="http://media.timberliu.com/image/2019/2/14/jdk6%E7%9A%84substring%E6%96%B9%E6%B3%95.jpeg" width="60%"></p><p>如果字符串很长，在使用 <code>substring</code> 进行切割时只需要很短的一段，就可能导致性能问题.。因为只需要一小段字符串，但是却引用了整个字符串，这个很长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露。</p><p><strong>JDK7 中的 substring</strong></p><p>在 <code>JDK7</code> 中，主要剩下一个 <code>value</code> 变量，它的主要源码如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>JDK 7</code> 中的 <code>subString</code> 方法，使用 <code>new String</code> 创建了一个新字符串，避免对老字符串的引用，从而解决了内存泄露问题。它的内存变化如下：</p><p><img src="http://media.timberliu.com/image/2019/2/14/jdk7%E7%9A%84substring%E6%96%B9%E6%B3%95.jpeg" width="60%"></p><h1 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h1><p><strong>String</strong></p><p><code>String</code> 是不可变对象，被声明为 <code>final class</code>，所有属性也都是 <code>final</code> 的。由于其不可变性，类似拼接、裁剪等操作，都会产生一个新的 <code>String</code> 对象，然后指针指向新的 <code>String</code> 对象，如果操作不当，可能会产生大量临时字符串。</p><p>在字符串内容不经常变化的业务场景优先使用 String 类。例如：常量声明、少量的字符串拼接等。</p><p><strong>StringBuffer</strong></p><p><code>StringBuffer</code> 是一个线程安全的可变字符序列。它解决了由于拼接产生太多中间对象的问题，可以用 <code>append</code> 或 <code>add</code> 方法，把字符串添加到字符串的末尾或指定位置。</p><p>它虽然保证了线程安全，也带来了额外的性能开销，所以除非有线程安全的需要，否则还是推荐使用 <code>StringBuilder</code>。</p><p><strong>StringBulider</strong></p><p><code>StringBuilder</code> 在能力与 <code>StringBuffer</code> 没有本质区别，但不保证同步，有效减小了开销。如果可能，在字符串拼接时建议优先使用。</p><p>为了能实现可修改的目的，<code>StringBuffer</code> 和 <code>StringBuilder</code> 底层都是可修改的数组，二者都继承了 <code>AbstarctStringBuilder</code>，包含了基本操作，区别仅在于最终的方法是否加了 <code>synchronized</code>。</p><h1 id="JDK-9-改进"><a href="#JDK-9-改进" class="headerlink" title="JDK 9 改进"></a>JDK 9 改进</h1><p>在 <code>JDK9</code> 之前，<code>String</code> 类内部使用 <code>char</code> 数组来存储数据，但 <code>char</code> 是两个字节大小，这样就造成了一定的浪费。</p><p>在 <code>JDK9</code> 中，引入了 <code>Compact Strings</code> 的设计，对字符串进行改进，将 <code>char</code> 数组改变为 <code>byte</code> 数组加上一个标识编码的 <code>coder</code>，并且对相关字符串操作进行修改。</p><p>成员变量变化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br></pre></td></tr></table></figure><p>改进之后，在存储数据时，如果传入 <code>byte</code> 数组，直接赋值就好，如果传入 <code>char</code> 数组，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len, Void sig) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (COMPACT_STRINGS) &#123; <span class="comment">// COMPACT_STRINGS 默认初始化为 true</span></span><br><span class="line">        <span class="keyword">byte</span>[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">this</span>.coder = LATIN1;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.coder = UTF16;</span><br><span class="line">    <span class="keyword">this</span>.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>StringUTF16.compress</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compress(<span class="keyword">char</span>[] val, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ret = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">    <span class="keyword">if</span> (compress(val, off, ret, <span class="number">0</span>, len) == len) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] src, <span class="keyword">int</span> srcOff, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstOff, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = src[srcOff];</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0xFF</span>) &#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dst[dstOff] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        srcOff++;</span><br><span class="line">        dstOff++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>for</code> 循环中，如果 <code>char</code> 数组中每一个字符都小于等于 <code>0xFF</code>，那么将 <code>char</code> 转换为 <code>byte</code>，完成构造，其 <code>coder</code> 为 <code>LATIN1</code>。</p><p>而如果存在一个大于 <code>0xFF</code> 的字符，就会跳出循环，最终 <code>StringUTF6.compress</code> 方法返回 <code>null</code>，通过 <code>StringUTF16.toBytes</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toBytes(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] val = newBytesFor(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        putChar(val, i, value[off]);</span><br><span class="line">        off++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] newBytesFor(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="comment">// check bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="comment">// intrinsic performs no bounds checks</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putChar</span><span class="params">(<span class="keyword">byte</span>[] val, <span class="keyword">int</span> index, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length(val) : <span class="string">"Trusted caller missed bounds check"</span>;</span><br><span class="line">    index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    val[index++] = (<span class="keyword">byte</span>)(c &gt;&gt; HI_BYTE_SHIFT);</span><br><span class="line">    val[index]   = (<span class="keyword">byte</span>)(c &gt;&gt; LO_BYTE_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>newBytesFor</code> 方法 <code>new</code> 一个两倍长度的 <code>byte</code> 数组，在 <code>for</code> 循环中，通过 <code>putChar</code> 方法来填充 <code>byte</code> 数组，将 <code>char</code> 字符分为两部分，存储两个相邻的 <code>byte</code> 数组中。</p><p><code>String</code> 类中方法基本都重新实现了一遍，但对外提供的接口没有改变。重构后，在字符串中所有字符小于 <code>0xFF</code> 时，可以节省一半的内存。</p><h1 id="JDK-11-新特性"><a href="#JDK-11-新特性" class="headerlink" title="JDK 11 新特性"></a>JDK 11 新特性</h1><p><code>JDK 11</code> 中 <code>String</code> 类增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line">System.out.println(<span class="string">" "</span>.isBlank());              <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首尾空格</span></span><br><span class="line">System.out.println(<span class="string">" Timber "</span>.strip());           <span class="comment">// Timber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line">System.out.println(<span class="string">" Timber"</span>.stripLeading());     <span class="comment">// Timber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line">System.out.println(<span class="string">"Timber "</span>.stripTrailing());    <span class="comment">// Timber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line">System.out.println(<span class="string">"Timber"</span>.repeat(<span class="number">2</span>));           <span class="comment">// TimberTimber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串中的行数</span></span><br><span class="line">System.out.println(<span class="string">"A\nB\nC"</span>.lines().count());  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.hollischuang.com/archives/1232" target="_blank" rel="noopener">三张图彻底了解JDK 6和JDK 7中substring的原理及区别</a></li><li><a href="https://my.oschina.net/netconst/blog/1542362" target="_blank" rel="noopener">JDK9的String类内部实现变更了！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;不可变性&quot;&gt;&lt;a href=&quot;#不可变性&quot; class=&quot;headerlink&quot; title=&quot;不可变性&quot;&gt;&lt;/a&gt;不可变性&lt;/h1&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 对象是不可变（&lt;code&gt;Immutable&lt;/code&gt;）的，也就是一旦 &lt;code&gt;String&lt;/code&gt; 类实例被创建后，就不能改变其值。这里的不可变指的是引用既不能指向其他对象，而且引用指向的对象的值也不能改变。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 环境搭建</title>
    <link href="https://blog.timberliu.com/2019/02/14/018_mmallv2.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.timberliu.com/2019/02/14/018_mmallv2.0项目环境搭建/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-配置与安装"><a href="#Redis-配置与安装" class="headerlink" title="Redis 配置与安装"></a>Redis 配置与安装</h1><p>从官网下载 <code>redis</code> 到 <code>/developer/setup</code> 目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//download.redis.io/releases/redis-4.0.12.tar.gz</span></span><br></pre></td></tr></table></figure><p>然后，将其解压到 <code>/developer</code> 目录下，进入到 <code>redis-4.0.12</code> 目录下，进行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-<span class="number">4.0</span>.12.tar.gz -C ../</span><br><span class="line">cd redis-<span class="number">4.0</span>.12/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><a id="more"></a><p>再将其名修改为 <code>redis-4.0.12_1</code>，另外再拷贝一份为 <code>redis-4.0.12_2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv redis-<span class="number">4.0</span>.12/ redis-<span class="number">4.0</span>.12_1</span><br><span class="line">cp redis-<span class="number">4.0</span>.12_1/ redis-<span class="number">4.0</span>.12_2/ -R</span><br></pre></td></tr></table></figure><p>然后，修改 <code>redis-4.0.12_2/src/</code> 目录下的 <code>redis.conf</code> 文件，端口修改为 <code>6380</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">6380</span></span><br></pre></td></tr></table></figure><p>然后，分别进入到 <code>src/</code> 目录下，后台启动 <code>redis</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf &amp;</span><br></pre></td></tr></table></figure><h1 id="Tomcat-配置多实例"><a href="#Tomcat-配置多实例" class="headerlink" title="Tomcat 配置多实例"></a>Tomcat 配置多实例</h1><p>在单机部署多应用时，官方不建议复制一个又一份的全部 <code>Tomcat</code> 目录进行多实例的部署，而是按照如下图实现：</p><p><img src="http://media.timberliu.com/image/2019/1/30/Tomcat%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%83%A8%E7%BD%B2.png" width="60%"></p><p><code>CATALINA_HOME</code> 指 <code>Tomcat</code> 的安装路径，包含 <code>bin</code> 和 <code>lib</code> 目录，而 <code>CATALINA_BASE</code> 指实例存放路径，包含 <code>conf</code>、<code>webapps</code>、<code>logs</code> 等目录。</p><p><strong>复制出两个实例</strong></p><p>首先新建两个 <code>tomcat1</code>、<code>tomcat2</code> 文件夹，并把 <code>apache-tomcat-8.5.35</code> 目录下的 <code>conf</code>、<code>webapps</code>、<code>temp</code>、<code>logs</code>、<code>work</code> 五个文件移动到 <code>tomcat1</code> 中，再将其复制一份到 <code>tomcat2</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat1 tomcat2</span><br><span class="line">cd apache-tomcat-<span class="number">8.5</span>.11</span><br><span class="line">mv conf/ webapps/ temp/ logs/ work/ -t ../tomcat1</span><br><span class="line">cp -r ../tomcat1<span class="comment">/* ../tomcat2</span></span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="http://media.timberliu.com/image/2019/1/30/%E5%A4%8D%E5%88%B6%E5%87%BA%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BE%8B.png" width="80%"></p><p><strong>配置 server.xml 端口</strong></p><p>修改 <code>conf/server.xml</code> 中的三个端口：</p><ul><li><code>Server port</code>：用于监听关闭 <code>Tomcat</code> 的 shutdown 命令，默认为 <code>8005</code></li><li><code>Connector port</code>：用于监听 <code>HTTP</code> 请求，默认为 8080</li><li><code>Connector port</code>（protocol=”AJP/1.3”）：用于监听 <code>AJP</code> 协议上的请求，通常用于整合 <code>Apache Server</code> 等其他 <code>HTTP</code> 服务器，默认为 <code>8009</code></li></ul><p>将 <code>tomcat2</code> 实例的端口分别修改为 <code>8006</code>、<code>8080</code>、<code>8010</code>，并对 <code>webapps/ROOT</code> 下的 <code>index.jsp</code> 首页作相应修改。</p><p><strong>创建启动、关闭脚本</strong></p><p>新建一个 <code>tomcat-shell</code> 文件夹，存放启动和关闭脚本，并赋予其执行权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat-shell</span><br><span class="line">cd tomcat-shell/</span><br><span class="line">vim start.sh</span><br><span class="line">vim shutdown.sh</span><br><span class="line">chmod u+x start.sh shutdown.sh</span><br></pre></td></tr></table></figure><p>start.sh 脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/developer/$<span class="number">1</span></span><br><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line"></span><br><span class="line">cd $CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><p>shutdown.sh 脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/developer/$<span class="number">1</span></span><br><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line"></span><br><span class="line">cd $CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">sh shutdown.sh</span><br></pre></td></tr></table></figure><p>启动和关闭脚本中，<code>$1</code> 表示执行时的第一个参数。</p><p><strong>启动实例</strong></p><p>执行以下命令，启动两个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start.sh tomcat1</span><br><span class="line">./start.sh tomcat2</span><br></pre></td></tr></table></figure><p><img src="http://media.timberliu.com/image/2019/1/30/%E5%AE%9E%E4%BE%8B%E5%90%AF%E5%8A%A8.png" width="80%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-配置与安装&quot;&gt;&lt;a href=&quot;#Redis-配置与安装&quot; class=&quot;headerlink&quot; title=&quot;Redis 配置与安装&quot;&gt;&lt;/a&gt;Redis 配置与安装&lt;/h1&gt;&lt;p&gt;从官网下载 &lt;code&gt;redis&lt;/code&gt; 到 &lt;code&gt;/developer/setup&lt;/code&gt; 目录下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//download.redis.io/releases/redis-4.0.12.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，将其解压到 &lt;code&gt;/developer&lt;/code&gt; 目录下，进入到 &lt;code&gt;redis-4.0.12&lt;/code&gt; 目录下，进行编译：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf redis-&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.12.tar.gz -C ../&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd redis-&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.12/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 分布式锁实现定时关单</title>
    <link href="https://blog.timberliu.com/2019/02/14/017_mmallv2.0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9A%E6%97%B6%E5%85%B3%E5%8D%95/"/>
    <id>https://blog.timberliu.com/2019/02/14/017_mmallv2.0分布式锁定时关单/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在电商项目中，用户购买商品在生成订单后，一定时间内如果没有付款，应该将订单关闭。这里，主要用 <code>Spring Schedule</code>和分布式锁来实现，而分布式锁也分别用 <code>Redis</code> 命令原生实现和 <code>Redisson</code> 框架两种方式。</p><h1 id="Spring-Schedule-介绍"><a href="#Spring-Schedule-介绍" class="headerlink" title="Spring Schedule 介绍"></a>Spring Schedule 介绍</h1><p><code>Spring Schedule</code> 是一个任务调度框架，用于定时任务调度等。主要通过 <code>@Scheduled</code> 注解来创建定时任务，可通过 <code>cron</code> 表达式来指定任务特定的执行时间。<a id="more"></a></p><h2 id="Cron-表达式"><a href="#Cron-表达式" class="headerlink" title="Cron 表达式"></a>Cron 表达式</h2><p><code>Cron</code> 表达式是一个字符串，由 <code>6</code> 或 <code>7</code> 个字段组成，对应为 秒、分、时、日、月、周、年(可选)。 </p><p><strong>允许的值和特殊字符</strong></p><table><thead><tr><th>字段名</th><th>允许的值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * / </td></tr><tr><td>分</td><td>0-59</td><td>, - * / </td></tr><tr><td>时</td><td>0-23</td><td>, - * / </td></tr><tr><td>月内第几天</td><td>1-31</td><td>, - * / ? L W C</td></tr><tr><td>月</td><td>1-12 或 JAN-DEC</td><td>, - * / </td></tr><tr><td>周内第几天</td><td>1-7 或 SUN-SAT</td><td>, - * / ? L  C # </td></tr><tr><td>年(可选)</td><td>留空，1970-2099</td><td>, - * / </td></tr></tbody></table><p><strong>特殊字符的含义</strong></p><ul><li><code>*</code>：匹配任意值，例如秒域为 <code>*</code> 表示每秒都会触发事件；</li><li><code>?</code>: 只能在月内第几天和周内第几天两个域使用，用于执行不明确的值。当两个域之一被指定值后，为避免冲突，需要将另一个的值设为 <code>?</code>；</li><li><code>-</code>: 指定一个范围，例如分域为 <code>3-6</code>，表示从 <code>3</code> 分到 <code>6</code> 分钟每分钟触发一次；  </li><li><code>/</code> : 指定增量，表示起始时间开始触发，然后每隔固定时间触发一次，例如分域为 <code>5/15</code>，则意味着 <code>5</code> 分、<code>20</code> 分、<code>35</code> 分、<code>50</code> 分，分别触发一次；  </li><li><code>,</code>：指定几个可选值。例如在分域使用 <code>5,15</code>，则意味着在 <code>5</code> 和 <code>20</code> 分各触发一次；  </li><li><code>L</code> : 表示最后，只能出现在周内第几天和月内第几天域，表示一月的最后一天，或一周的最后一天。如果在周内第几天域前加上数字，表示一月的最后一个第几天。例如 <code>5L</code> 表示一个月的最后一个周五；</li><li><code>W</code> : 指定有效工作日(周一到周五)，只能在月内第几天域使用，系统将在离指定日期的最近的有效工作日触发。注意一点，<code>W</code> 的最近寻找不会跨过月份；  </li><li><code>LW</code> : 两个字符可以连用，表示一月的最后一个工作日，即最后一个星期五。  </li><li><code>#</code> : 指定一月的周内第几天，只能出现在月内第几天域。例如在 <code>2#3</code>，表示一月的第三个星期一(<code>2</code> 表示周一，<code>3</code> 表示第三周)。</li><li><code>C</code>：可以在月内第几天和周内第几天使用。</li></ul><p><strong>举例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"0 1 * * * *"</span>               表示每小时<span class="number">1</span>分<span class="number">0</span>秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"*/20 * * * * *"</span>            表示每<span class="number">20</span>秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0 9-12 * * *"</span>            表示每天<span class="number">9</span>，<span class="number">10</span>，<span class="number">11</span>，<span class="number">12</span>点执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0/20 9-12 * * *"</span>         表示每天<span class="number">9</span>点到<span class="number">12</span>点，每<span class="number">20</span>分钟执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0 9-12 * * 2-6"</span>          表示每周一至周五，<span class="number">9</span>点到<span class="number">12</span>点的<span class="number">0</span>分<span class="number">0</span>秒执行一次</span><br><span class="line"></span><br><span class="line"><span class="string">"0 0 0 1 4 ?"</span>               表示<span class="number">4</span>月<span class="number">1</span>日<span class="number">0</span>时<span class="number">0</span>分<span class="number">0</span>秒执行一次</span><br></pre></td></tr></table></figure><h2 id="实现定时任务"><a href="#实现定时任务" class="headerlink" title="实现定时任务"></a>实现定时任务</h2><p>首先，在 <code>applicationContext.xml</code> 文件中配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;task:annotation-driven/&gt;</span><br></pre></td></tr></table></figure><p>开启定时任务。注意，导入约束时导入的是 <code>http://www.springframework.org/schema/task</code>。</p><p>然后，创建定时关闭订单的 <code>task</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseOrderTask</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> IOrderService iOrderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron=<span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">        <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>, <span class="string">"1"</span>));</span><br><span class="line">        iOrderService.closeOrder(hour);</span><br><span class="line">        log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表示每隔一分钟就查看是否有超过一个小时的订单未付款，如果有则进行关闭。<code>IOrderServiceImpl</code> 的 <code>closeOrder</code> 方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(<span class="keyword">int</span> hour)</span> </span>&#123;</span><br><span class="line">    Date closeDateTime = DateUtils.addHours(<span class="keyword">new</span> Date(), -hour);</span><br><span class="line">    List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(), DateTimeUtil.dateToStr(closeDateTime));</span><br><span class="line">    <span class="keyword">for</span> (Order order : orderList) &#123;</span><br><span class="line">        List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo());</span><br><span class="line">        <span class="keyword">for</span> (OrderItem orderItem : orderItemList) &#123;</span><br><span class="line">            Integer stock = productMapper.selectStockByProductId(orderItem.getId());</span><br><span class="line">            <span class="keyword">if</span> (stock == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Product product = <span class="keyword">new</span> Product();</span><br><span class="line">            product.setId(orderItem.getProductId());</span><br><span class="line">            product.setStock(stock + orderItem.getQuantity());</span><br><span class="line">            productMapper.updateByPrimaryKeySelective(product);</span><br><span class="line">        &#125;</span><br><span class="line">        orderMapper.closeOrderByOrderId(order.getId());</span><br><span class="line">        log.info(<span class="string">"关闭订单OrderNo：&#123;&#125;"</span>, order.getOrderNo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要逻辑是，首先查询超过一个小时的订单列表，然后对列表中的每一条订单，根据订单号查询商品列表，对每一件商品的库存进行更新，最后，对订单的状态进行修改，即意味着删除。</p><p>如此，定时关闭一定时间内未付款的订单的 <code>v1</code> 版本就完成了。但是在 <code>tomcat</code> 集群环境下，每次只需要一台机器执行即可，不用每台机器都执行；而且，多台机器同时执行也容易造成数据错乱。所以，这就需要使用分布式锁来进行保证。</p><h1 id="Redis-命令实现分布式锁"><a href="#Redis-命令实现分布式锁" class="headerlink" title="Redis 命令实现分布式锁"></a>Redis 命令实现分布式锁</h1><h2 id="Redis-命令"><a href="#Redis-命令" class="headerlink" title="Redis 命令"></a>Redis 命令</h2><p>下面是其中会用到的一下 Redis 命令：</p><p>1).<code>setnx key value</code></p><p><code>SET if Not eXists</code> 的简称。如果键不存在，则将键 <code>key</code> 的值设置为 <code>value</code>。否则如果键已经存在，则不做任何操作。</p><p>设置成功时返回 <code>1</code>，设置失败时返回 <code>0</code>。</p><p>2).<code>getset key value</code></p><p>将键 <code>key</code> 的值设为 <code>value</code>，并返回键 <code>key</code> 在被设置之前的旧值。</p><p>如果键 <code>key</code> 存在旧值，则会返回。否则如果不存在旧值，也就是键 <code>key</code> 在设置之前并不存在，则返回 <code>nil</code>。</p><p>3).<code>expire key seconds</code></p><p>为给定的键 <code>key</code> 设置生存时间，当 <code>key</code> 的生存时间为 <code>0</code>(过期) 时，它会被自动删除。</p><p>4).<code>del key [key...]</code></p><p>删除给定的一个或多个 <code>key</code>。</p><h2 id="Redis-分布式锁"><a href="#Redis-分布式锁" class="headerlink" title="Redis 分布式锁"></a>Redis 分布式锁</h2><p><strong>Redis 分布式锁原理</strong> </p><p><code>Redis</code> 分布式锁的流程图如下:</p><p><img src="http://media.timberliu.com/image/2019/2/11/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" width="40%"></p><p>它的主要原理是：首先，通过 <code>setnx</code> 存入一个 <code>lockkey</code>，如果设置成功，也就是获取锁成功，就为锁设置一个有效期，然后执行业务，之后将 <code>lockkey</code> 删除，最后将锁释放。如果设置失败，也就是获取锁失败，则直接结束。</p><p>这里使用 <code>setnx</code> 命令，开始时 <code>Redis</code> 中不存在 <code>lockkey</code>，<code>setnx(lockkey)</code> 就会返回 <code>1</code>，表示本台机器获取到了锁，可以定时执行业务。而其他机器在有效期内获取锁时，<code>lockkey</code> 已经存在，就会返回 <code>0</code>，表示没有获取到锁，其他机器正在执行业务。</p><p><strong>构建分布式任务调度</strong></p><p>利用 <code>Spring Schedule + Redis</code> 分布式锁构建分布式任务调度，方法 <code>closeOrderTaskV2</code> 版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>, <span class="string">"5000"</span>));</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));</span><br><span class="line">    <span class="keyword">if</span> (setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回值是 1，代表设置成功，获取锁</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.info(<span class="string">"没有获取到分布式锁：&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">closeOrder</span><span class="params">(String lockName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 修改存活时间</span></span><br><span class="line">    RedisShardedPoolUtil.expire(lockName, <span class="number">5</span>);</span><br><span class="line">    log.info(<span class="string">"获取&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line">    <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>, <span class="string">"2"</span>));</span><br><span class="line">    iOrderService.closeOrder(hour);</span><br><span class="line">    <span class="comment">// 删除 key</span></span><br><span class="line">    RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    log.info(<span class="string">"释放&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点</strong></p><p>如果某台 <code>tomcat</code> 机器成功获取到锁，但在为锁设置有效期之前，<code>tomcat</code> 机器意外关闭，这时就会产生死锁。</p><p>可以在 <code>CloseOrderTask</code> 中添加一个 <code>delLock</code> 方法，在销毁之前删除分布式锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PreDestroy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但如果直接 <code>kill</code> 掉 <code>tomcat</code> 进程，仍然不会调用这个方法，从而产生死锁。</p><h2 id="Redis-分布式锁双重防死锁"><a href="#Redis-分布式锁双重防死锁" class="headerlink" title="Redis 分布式锁双重防死锁"></a>Redis 分布式锁双重防死锁</h2><p><strong>Redis 分布式锁优化原理</strong></p><p><code>Redis</code> 分布式锁优化后的流程图如下:</p><p><img src="http://media.timberliu.com/image/2019/2/11/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E4%BC%98%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" width="70%"></p><p>它的原理是：同样首先通过 <code>setnx</code> 存入一个 <code>lockkey</code>，如果设置成功，同之前一样。否则，通过 <code>get</code> 获得之前设置的 <code>currentTime + timeout</code>，判断 <code>lockValeA</code> 是否不为 <code>null</code>，并且 <code>currentTime</code> 大于 <code>lockValueA</code>，即分布式锁是否过期。</p><p>如果过期，通过 <code>getset</code> 将 <code>lockkey</code> 对应的 <code>value</code> 设置为 <code>currentTime + timeout</code>，并得到之前的旧值 <code>lockValueB</code>，判断 <code>lockValueB</code> 是否为 <code>null</code>，即 <code>lockkey</code> 是否还存在，或者 <code>lockValueA</code> 是否等于 <code>lockValueB</code>，即在这个过程中锁没有改变。如果条件满足，则表示获取锁成功，同 <code>setnx</code> 获取锁成功一样。</p><p>如果锁没有过期，则表示获取锁失败，直接结束。在 <code>getset</code> 后，如果 <code>lockValueB</code> 不为空，即 <code>lockkey</code> 仍然存在，或者锁被改变了，也表示获取锁失败，直接结束。</p><p><strong>构建分布式任务调度</strong></p><p>利用 <code>Spring Schedule + Redis</code> 分布式锁构建分布式任务调度，方法 <code>closeOrderTaskV3</code> 版本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务启动"</span>);</span><br><span class="line">    <span class="keyword">long</span> lockTimeout = Long.parseLong(PropertiesUtil.getProperty(<span class="string">"lock.timeout"</span>, <span class="string">"5000"</span>));</span><br><span class="line">    <span class="comment">// 获取锁</span></span><br><span class="line">    Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));</span><br><span class="line">    <span class="keyword">if</span> (setnxResult != <span class="keyword">null</span> &amp;&amp; setnxResult.intValue() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果返回值是 1，代表设置成功，获取锁</span></span><br><span class="line">        closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 未获取到锁，继续判断时间戳，看锁是否过期</span></span><br><span class="line">        String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        <span class="keyword">if</span> (lockValueStr != <span class="keyword">null</span> &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr)) &#123;</span><br><span class="line">            <span class="comment">// 锁过期，重置并获取锁</span></span><br><span class="line">            String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout));</span><br><span class="line">            <span class="keyword">if</span> (getSetResult == <span class="keyword">null</span> || (getSetResult != <span class="keyword">null</span> &amp;&amp; StringUtils.equals(lockValueStr, getSetResult))) &#123;</span><br><span class="line">                closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.info(<span class="string">"没有获取到分布式锁：&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"没有获取到分布式锁：&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"关闭订单定时任务结束"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redisson-实现分布式锁"><a href="#Redisson-实现分布式锁" class="headerlink" title="Redisson 实现分布式锁"></a>Redisson 实现分布式锁</h1><p><code>Redisson</code> 是架设在 <code>Redis</code> 上的一个 <code>Java</code> 驻内存数据网格，它在基于 <code>NIO</code> 的 <code>Netty</code> 框架上，充分地利用了 <code>Redis</code> 键值数据库提供的一系列优势。</p><p>将 <code>Redisson</code> 集成到项目中，只需要在 <code>pom.xml</code> 文件需要添加 <code>redisson</code> 和 <code>jackson-dataformat-avro</code> 的依赖。</p><p><strong>Redisson 初始化类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedissonManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Config config = <span class="keyword">new</span> Config();</span><br><span class="line">    <span class="keyword">private</span> Redisson redisson;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String redis1IP = PropertiesUtil.getProperty(<span class="string">"redis1.ip"</span>, <span class="string">"192.168.23.130"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis1.port"</span>, <span class="string">"6379"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            config.useSingleServer().setAddress(redis1IP + <span class="string">":"</span> + redis1Port);</span><br><span class="line">            redisson = (Redisson) Redisson.create(config);</span><br><span class="line">            log.info(<span class="string">"初始化 Redisson 结束"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"初始化 Redisson 失败"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Redisson <span class="title">getRedisson</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> redisson;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用单服务器模式，在传入地址时采用 <code>ip:port</code> 格式。</p><p><strong>任务调度 v4 版本</strong></p><p><code>tryLock</code> 方法在获取锁时，三个参数分别为：尝试获取锁最多等待的时间、获取锁后自动释放的时间、时间单元。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Scheduled</span>(cron = <span class="string">"0 */1 * * * ?"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeOrderTaskV4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);</span><br><span class="line">    <span class="keyword">boolean</span> locked = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(locked = lock.tryLock(<span class="number">0</span>, <span class="number">5</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            log.info(<span class="string">"Redisson 获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">int</span> hour = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"close.order.task.time.hour"</span>, <span class="string">"2"</span>));</span><br><span class="line">            iOrderService.closeOrder(hour);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.info(<span class="string">"Redisson 没有获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;"</span>, Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        log.error(<span class="string">"Redisson 获取分布式锁异常"</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!locked) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        log.info(<span class="string">"Redisson 释放分布式锁"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>tryLock</code> 方法在获取锁之后，如果后续的执行业务时间小于 <code>1</code> 秒，而另外的 <code>tomcat</code> 在等待 <code>1</code> 秒后，又能重新获取锁，就会出现两个进程都获得锁的情况。</p><p>所以，应该将 <code>waitTime</code> 设置为 <code>0</code>（<code>waitTime</code> 时间小于业务执行时间）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在电商项目中，用户购买商品在生成订单后，一定时间内如果没有付款，应该将订单关闭。这里，主要用 &lt;code&gt;Spring Schedule&lt;/code&gt;和分布式锁来实现，而分布式锁也分别用 &lt;code&gt;Redis&lt;/code&gt; 命令原生实现和 &lt;code&gt;Redisson&lt;/code&gt; 框架两种方式。&lt;/p&gt;
&lt;h1 id=&quot;Spring-Schedule-介绍&quot;&gt;&lt;a href=&quot;#Spring-Schedule-介绍&quot; class=&quot;headerlink&quot; title=&quot;Spring Schedule 介绍&quot;&gt;&lt;/a&gt;Spring Schedule 介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Spring Schedule&lt;/code&gt; 是一个任务调度框架，用于定时任务调度等。主要通过 &lt;code&gt;@Scheduled&lt;/code&gt; 注解来创建定时任务，可通过 &lt;code&gt;cron&lt;/code&gt; 表达式来指定任务特定的执行时间。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 Redis + Cookie 实现单点登录</title>
    <link href="https://blog.timberliu.com/2019/02/14/016_mmallv2.0redis+cookie%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://blog.timberliu.com/2019/02/14/016_mmallv2.0redis+cookie实现单点登录/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>电商项目中，在单服务器时，用户登录时将用户信息设置到 <code>session</code> 中，获取用户信息从 <code>session</code> 中获取，退出时从 <code>session</code> 中删除即可。</p><p>但在搭建 <code>Tomcat</code> 集群后，就需要考虑 <code>Session</code> 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 <code>Redis + Cookie</code> 自己实现，另一种是借助 <code>Spring Session</code> 框架解决。<a id="more"></a></p><h1 id="Redis-Cookie-实现"><a href="#Redis-Cookie-实现" class="headerlink" title="Redis+Cookie 实现"></a>Redis+Cookie 实现</h1><h1 id="单点登录的思路"><a href="#单点登录的思路" class="headerlink" title="单点登录的思路"></a>单点登录的思路</h1><p>用户登录：</p><ul><li>首先验证用户密码是否正确，并返回用户信息；</li><li>使用 <code>uuid</code> 或 <code>session.getId</code> 生成唯一 <code>id(token)</code>，设置到 <code>cookie</code> 中，将其写给客户端；</li><li>将用户信息(<code>user</code> 对象)转换为 <code>json</code> 格式；</li><li>以 <code>key=token</code>，<code>value=(user 的 json 格式)</code>，写到 <code>redis</code> 中，并设置过期时间；</li></ul><p>退出登录：</p><ul><li>用户请求时会携带 <code>cookie</code>，从 <code>cookie</code> 中获取到 <code>token</code>；</li><li>从请求中获取到 <code>cookie</code>，将其过期时间设置为 <code>0</code>，再写入到响应中，即删除了 <code>token</code>；</li><li>再从 <code>redis</code> 中删除 <code>token</code>；</li></ul><p>获取用户信息：</p><ul><li>从请求携带的 <code>cookie</code> 中获取到 <code>token</code>；</li><li>根据 <code>token</code> 在 <code>redis</code> 中查询相应的 <code>user</code> 对象的 <code>json</code> 串；</li><li>将 <code>json</code> 串转换为 <code>user</code> 对象；</li></ul><h1 id="Redis-连接池及工具类"><a href="#Redis-连接池及工具类" class="headerlink" title="Redis 连接池及工具类"></a>Redis 连接池及工具类</h1><p>由于 <code>token</code> 和 <code>user</code> 对象都会存储在 <code>redis</code> 中，所以这里封装一个 <code>redis</code> 的连接池和工具类。</p><p>首先，封装一个 <code>redis</code> 连接池，每次直接从连接池中获取 <code>jedis</code> 实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String redisIP = PropertiesUtil.getProperty(<span class="string">"redis.ip"</span>, <span class="string">"192.168.23.130"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.port"</span>, <span class="string">"6379"</span>));</span><br><span class="line">    <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.max.total"</span>, <span class="string">"20"</span>));</span><br><span class="line">    <span class="comment">// 最大的 idle 状态的 jedis 实例个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.max.idle"</span>, <span class="string">"10"</span>));</span><br><span class="line">    <span class="comment">// 最小的 idle 状态的 jedis 实例个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.min.idle"</span>, <span class="string">"2"</span>));</span><br><span class="line">    <span class="comment">// 在 borrow 一个 jedis 实例时，是否要进行验证操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty(<span class="string">"redis.test.borrow"</span>, <span class="string">"true"</span>));</span><br><span class="line">    <span class="comment">// 在 return 一个 jedis 实例时，是否要进行验证操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty(<span class="string">"redis.test.return"</span>, <span class="string">"true"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(maxTotal);</span><br><span class="line">        config.setMaxIdle(maxIdle);</span><br><span class="line">        config.setMinIdle(minIdle);</span><br><span class="line">        config.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        config.setTestOnReturn(testOnReturn);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config, redisIP, redisPort, <span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">returnJedis</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再将其封装成一个工具类，基本操作就是从 <code>redis</code> 连接池中获取 <code>jedis</code> 实例，进行 <code>set/get/expire</code> 等操作，然后将其放回到 <code>redis</code> 连接池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exTime 以秒为单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> exTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Long result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.expire(key, exTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"expire key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Long result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.del(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"del key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"get key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.set(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"set key:&#123;&#125;, value:&#123;&#125;, error"</span>, key, value, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exTime 以秒为单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setEx</span><span class="params">(String key, String value, <span class="keyword">int</span> exTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.setex(key, exTime, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"setex key:&#123;&#125;, value:&#123;&#125;, error"</span>, key, value, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JsonUtil-工具类"><a href="#JsonUtil-工具类" class="headerlink" title="JsonUtil 工具类"></a>JsonUtil 工具类</h1><p>将 <code>user</code> 对象存储在 <code>redis</code> 中，需要转换为 <code>json</code> 格式，从 <code>redis</code> 中获取 <code>user</code> 对象，又需要转换为 <code>user</code> 对象。这里封装一个 <code>json</code> 的工具类。</p><p><code>JsonUtil</code> 工具类主要使用 <code>ObjectMapper</code> 类。</p><ul><li><code>bean</code> 类转换为 <code>String</code> 类型，使用 <code>writerValueAsString</code> 方法。</li><li><code>String</code> 类型转换为 <code>bean</code> 类，使用 <code>readValue</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化时将所有字段列入</span></span><br><span class="line">        objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.ALWAYS);</span><br><span class="line">        <span class="comment">// 取消默认将 DATES 转换为 TIMESTAMPS</span></span><br><span class="line">        objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 忽略空 bean 转 json 的错误</span></span><br><span class="line">        objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 所有日期样式统一</span></span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        <span class="comment">// 忽略 在 json 字符串中存在，在 java 对象中不存在对应属性的情况</span></span><br><span class="line">        objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">obj2Str</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> String ? (String) obj : objectMapper.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse Object to String error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">obj2StrPretty</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> String ? (String) obj :</span><br><span class="line">                    objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse Object to String error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str) || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.equals(String.class) ? (T)str : objectMapper.readValue(str, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, TypeReference&lt;T&gt; typeReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str) || typeReference == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typeReference.getType().equals(String.class) ? (T)str : objectMapper.readValue(str, typeReference);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, Class&lt;?&gt; collectionClass, Class&lt;?&gt; elementClass)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(str, javaType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CookieUtil-工具类"><a href="#CookieUtil-工具类" class="headerlink" title="CookieUtil 工具类"></a>CookieUtil 工具类</h1><p>登录时需要将 <code>token</code> 设置到 <code>cookie</code> 中返回给客户端，退出时需要从 <code>request</code> 中携带的 <code>cookie</code> 中读取 <code>token</code>，设置过期时间后，又将其设置到 <code>cookie</code> 中返回给客户端，获取用户信息时，获取用户信息时，需要从 <code>request</code> 中携带的 <code>cookie</code> 中读取 <code>token</code>，在 <code>redis</code> 中查询后获得 <code>user</code> 对象。这里呢，也封装一个 <code>cookie</code> 的工具类。</p><p>在 <code>CookieUtil</code> 中：</p><ul><li><code>readLoginToken</code> 方法主要从 <code>request</code> 读取 <code>Cookie</code>；</li><li><code>writeLoginToken</code> 方法主要设置 <code>Cookie</code> 对象加到 <code>response</code> 中；</li><li><code>delLoginToken</code> 方法主要从 <code>request</code> 中读取 <code>Cookie</code>，将其 <code>maxAge</code> 设置为 <code>0</code>，再添加到 <code>response</code> 中；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_DOMAIN = <span class="string">".happymmall.com"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_NAME = <span class="string">"mmall_login_token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readLoginToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                log.info(<span class="string">"read cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123;</span><br><span class="line">                    log.info(<span class="string">"return cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                    <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeLoginToken</span><span class="params">(HttpServletResponse response, String token)</span> </span>&#123;</span><br><span class="line">        Cookie cookie  = <span class="keyword">new</span> Cookie(COOKIE_NAME, token);</span><br><span class="line">        cookie.setDomain(COOKIE_DOMAIN);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 防止脚本攻击</span></span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 单位是秒，如果是 -1，代表永久；</span></span><br><span class="line">        <span class="comment">// 如果 MaxAge 不设置，cookie 不会写入硬盘，而是在内存，只在当前页面有效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span>);</span><br><span class="line">        log.info(<span class="string">"write cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delLoginToken</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123;</span><br><span class="line">                    cookie.setDomain(COOKIE_DOMAIN);</span><br><span class="line">                    cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">                    <span class="comment">// maxAge 设置为 0，表示将其删除</span></span><br><span class="line">                    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                    log.info(<span class="string">"del cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具体业务"><a href="#具体业务" class="headerlink" title="具体业务"></a>具体业务</h1><p>登录时验证密码后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CookieUtil.writeLoginToken(response, session.getId());</span><br><span class="line">RedisShardedPoolUtil.setEx(session.getId(), JsonUtil.obj2Str(serverResponse.getData()), Const.RedisCacheExtime.REDIS_SESSION_EXTIME);</span><br></pre></td></tr></table></figure><p>退出登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String loginToken = CookieUtil.readLoginToken(request);</span><br><span class="line">CookieUtil.delLoginToken(request, response);</span><br><span class="line">RedisShardedPoolUtil.del(loginToken);</span><br></pre></td></tr></table></figure><p>获取用户信息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String loginToken = CookieUtil.readLoginToken(request);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(loginToken)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"用户未登录，无法获取当前用户信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String userJsonStr = RedisShardedPoolUtil.get(loginToken);</span><br><span class="line">User user = JsonUtil.str2Obj(userJsonStr, User.class);</span><br></pre></td></tr></table></figure><h1 id="SessionExpireFilter-过滤器"><a href="#SessionExpireFilter-过滤器" class="headerlink" title="SessionExpireFilter 过滤器"></a>SessionExpireFilter 过滤器</h1><p>另外，在用户登录后，每次操作后，都需要重置 <code>Session</code> 的有效期。可以使用过滤器来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionExpireFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        String loginToken = CookieUtil.readLoginToken(httpServletRequest);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(loginToken)) &#123;</span><br><span class="line">            String userJsonStr = RedisShardedPoolUtil.get(loginToken);</span><br><span class="line">            User user = JsonUtil.str2Obj(userJsonStr, User.class);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在 <code>web.xml</code> 文件中进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">mmall</span>.<span class="title">controller</span>.<span class="title">common</span>.<span class="title">SessionExpireFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">sessionExpireFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="此方式的缺陷"><a href="#此方式的缺陷" class="headerlink" title="此方式的缺陷"></a>此方式的缺陷</h1><ul><li><code>redis + cookie</code> 方式实现的单点登录对代码侵入性比较大；</li><li>客户端必须启用 <code>cookie</code>，而有些浏览器不支持 <code>cookie</code>；</li><li><code>Cookie</code> 设置 <code>domain</code> 时必须统一，服务器也必须统一域名方式；</li></ul><h1 id="Spring-Session-实现"><a href="#Spring-Session-实现" class="headerlink" title="Spring Session 实现"></a>Spring Session 实现</h1><p><code>Spring Session</code> 是 <code>Spring</code> 的项目之一，它提供了创建和管理 <code>Server</code> <code>HTTPSession</code> 的方案。并提供了集群 <code>Session</code> 功能，默认采用外置的 <code>Redis</code> 来存储 <code>Session</code> 数据，以此来解决 <code>Session</code> 共享的问题。</p><p><code>Spring Session</code> 可以无侵入式地解决 <code>Session</code> 共享问题，但是不能进行分片。</p><h1 id="Spring-Session-项目集成"><a href="#Spring-Session-项目集成" class="headerlink" title="Spring Session 项目集成"></a>Spring Session 项目集成</h1><p>1、引入 <code>Spring Session pom</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置 <code>DelegatingFilterProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">DelegatingFilterProxy</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">springSessionRepositoryFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、配置 <code>RedisHttpSessionConfiguration</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"redisHttpSessionConfiguration"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxInactiveIntervalInSeconds"</span> value=<span class="string">"1800"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、配置 <code>JedisPoolConfig</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"jedisPoolConfig"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxTotal"</span> value=<span class="string">"20"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>5、配置 <code>JedisSessionFactory</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"jedisConnectionFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> &gt;</span><br><span class="line">    &lt;property name=<span class="string">"hostName"</span> value=<span class="string">"192.168.23.130"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"port"</span> value=<span class="string">"6379"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"database"</span> value=<span class="string">"0"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"poolConfig"</span> ref=<span class="string">"jedisPoolConfig"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>6、配置 <code>DefaultCookieSerializer</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"defaultCookieSerializer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.session.web.http.DefaultCookieSerializer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieName"</span> value=<span class="string">"SESSION_NAME"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"domainName"</span> value=<span class="string">".happymmall.com"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"useHttpOnlyCookie"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookiePath"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieMaxAge"</span> value=<span class="string">"31536000"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h1 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h1><p>用户登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(Const.CURRENT_USER, response.getData());</span><br></pre></td></tr></table></figure><p>退出登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.removeAttribute(Const.CURRENT_USER);</span><br></pre></td></tr></table></figure><p>获得用户信息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User) session.getAttribute(Const.CURRENT_USER);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电商项目中，在单服务器时，用户登录时将用户信息设置到 &lt;code&gt;session&lt;/code&gt; 中，获取用户信息从 &lt;code&gt;session&lt;/code&gt; 中获取，退出时从 &lt;code&gt;session&lt;/code&gt; 中删除即可。&lt;/p&gt;
&lt;p&gt;但在搭建 &lt;code&gt;Tomcat&lt;/code&gt; 集群后，就需要考虑 &lt;code&gt;Session&lt;/code&gt; 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 &lt;code&gt;Redis + Cookie&lt;/code&gt; 自己实现，另一种是借助 &lt;code&gt;Spring Session&lt;/code&gt; 框架解决。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之环境搭建</title>
    <link href="https://blog.timberliu.com/2019/01/29/015_mmallv1.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.timberliu.com/2019/01/29/015_mmallv1.0项目环境搭建/</id>
    <published>2019-01-28T16:00:00.000Z</published>
    <updated>2019-01-28T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="配置软件源"><a href="#配置软件源" class="headerlink" title="配置软件源"></a>配置软件源</h1><p>首先，需要进行源配置，可使用阿里云的源，可查看：<a href="https://opsx.alibaba.com/mirror" target="_blank" rel="noopener"> https://opsx.alibaba.com/mirror</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、备份</span><br><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br><span class="line"><span class="number">2</span>、下载新的CentOS-Base.repo 到/etc/yum.repos.d/</span><br><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http:<span class="comment">//mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"><span class="number">3</span>、生成缓存</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="创建用户并修改密码"><a href="#创建用户并修改密码" class="headerlink" title="创建用户并修改密码"></a>创建用户并修改密码</h1><p>首先，添加普通用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd  timberliu</span><br></pre></td></tr></table></figure><p>再更改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd timberliu</span><br></pre></td></tr></table></figure><p>之后退出重新登录验证。</p><h1 id="安装-JDK"><a href="#安装-JDK" class="headerlink" title="安装 JDK"></a>安装 JDK</h1><p><strong style="color:#ff6600">删除系统自带 jdk</strong></p><p>首先，执行以下命令查看自带的 <code>jdk</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep jdk</span><br></pre></td></tr></table></figure><p>然后，使用 <code>sudo yum remove xxx</code> 命令进行删除。</p><p><strong style="color:#ff6600">下载与安装</strong></p><p>首先，在根目录创建一个 <code>developer</code>，再创建一个 <code>setup</code>，用于存放安装包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /developer/setup</span><br></pre></td></tr></table></figure><p>从 <code>Oracle</code> 官网得到 <code>jdk1.8</code> 的下载地址（可能会改变）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm</span></span><br></pre></td></tr></table></figure><p>使用 <code>wget</code> 命令安装到 <code>setup</code> 下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --no-cookie --header <span class="string">"Cookie:oraclelicense=accept-securebackup-cookie"</span> https:<span class="comment">//download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm</span></span><br></pre></td></tr></table></figure><p>需要注意的是：在 Oracle 官网下载 rpm 时需要在 <code>wget</code> 后面加上 <code>--no-cookie --header &quot;Cookie:oraclelicense=accept-securebackup-cookie&quot;</code> 接受许可协议。</p><p>然后执行下面的命令进行安装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivh jdk-<span class="number">8</span>u201-linux-x64.rpm</span><br></pre></td></tr></table></figure><p>默认会安装到 <code>/usr/java</code> 目录下。</p><p><strong style="color:#ff6600">配置环境变量</strong></p><p>执行 <code>sudo vim /etc/profile</code> 命令配置环境变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>然后，执行 <code>source /etc/profile</code> 使配置生效。使用 <code>java -version</code>，查看是否配置成功：</p><h1 id="安装-Tomcat"><a href="#安装-Tomcat" class="headerlink" title="安装 Tomcat"></a>安装 Tomcat</h1><p>首先，使用 <code>wget</code> 命令从阿里云镜像网站下载 <code>tomcat</code>，到 <code>setup</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz</span></span><br></pre></td></tr></table></figure><p>再使用 <code>tar</code> 命令解压缩到 <code>developer</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-<span class="number">8.5</span>.35.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>再执行 <code>vim /etc/profile</code> 配置环境变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line">export PATH=$CATALINA_HOME/bin:</span><br></pre></td></tr></table></figure><p>再修改 <code>apache-tomcat-8.5.35</code> 下的 <code>conf/server.xml</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim conf/server.xml</span><br></pre></td></tr></table></figure><p>修改 <code>8080</code> 端口的 <code>URI</code> 的字符编码为 <code>&quot;UTF-8&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port=<span class="string">"8080"</span> protocol=<span class="string">"HTTP/1.1"</span></span><br><span class="line">   connectionTimeout=<span class="string">"20000"</span></span><br><span class="line">   redirectPort=<span class="string">"8443"</span> URIEncoding=<span class="string">"UTF-8"</span> /&gt;</span><br></pre></td></tr></table></figure><p>最后，启动 <code>tomcat</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/startup.sh</span><br></pre></td></tr></table></figure><h1 id="安装-Maven"><a href="#安装-Maven" class="headerlink" title="安装 Maven"></a>安装 Maven</h1><p>和 <code>tomcat</code> 一样，得到 <code>maven</code> 的下载地址，进行下载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//mirrors.aliyun.com/apache/maven/maven-3/3.0.5/binaries/apache-maven-3.0.5-bin.tar.gz</span></span><br></pre></td></tr></table></figure><p>然后，使用 <code>tar</code> 解压缩到 <code>developer</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-maven-<span class="number">3.0</span>.5-bin.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>然后，将 <code>maven</code> 配置到环境变量中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/developer/apache-maven-<span class="number">3.0</span>.5</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin</span><br></pre></td></tr></table></figure><p>执行 <code>source /etc/profile</code> 使配置生效。执行 <code>mvn -version</code> 查看是否安装成功。</p><h1 id="安装-vsftpd"><a href="#安装-vsftpd" class="headerlink" title="安装 vsftpd"></a>安装 vsftpd</h1><p><strong style="color:#ff6600">下载与安装</strong></p><p>使用 <code>yum</code> 直接执行下面的命令安装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install vsftpd</span><br></pre></td></tr></table></figure><p>在根目录下创建 <code>product</code> 目录，再创建 <code>ftpfile</code> 目录，用于存放上传的文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /product/ftpfile</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">添加匿名用户</strong></p><p>首先，添加一个匿名用户：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd ftpuser -d /product/ftpfile -s /sbin/nologin</span><br></pre></td></tr></table></figure><p>修改 <code>ftpfile</code> 文件夹的权限，用户组和用户都是 <code>ftpuser</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R ftpuser.ftpuser ./ftpfile/</span><br></pre></td></tr></table></figure><p>修改 <code>ftpuser</code> 的密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd ftpuser</span><br></pre></td></tr></table></figure><p>然后，在 <code>etc/vsftpd</code> 下创建 chroot_list 文件，在其中添加用户名，这里就是 <code>ftpuser</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/vsftpd/</span><br><span class="line">vim chroot_list</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">确认安全策略</strong></p><p>查看安全策略，确保其中的 <code>SELINUX</code> 为 <code>disabled</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/selinux/config</span><br></pre></td></tr></table></figure><p>为避免验证时碰到 550 拒绝访问错误，执行下面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[timberliu<span class="meta">@iZ</span>2ze222ncoofcesrn22waZ vsftpd]$ sudo setsebool -P ftp_home_dir <span class="number">1</span></span><br><span class="line">setsebool:  SELinux is disabled.</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">配置 vsftpd.conf 文件</strong></p><p>使用 <code>sudo vim vsftpd.conf</code> 命令编辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">local_root=/product/ftpfile</span><br><span class="line">#chroot_local_user=YES</span><br><span class="line">anon_root=/product/ftpfile</span><br><span class="line">use_localtime=YES</span><br><span class="line"></span><br><span class="line">#匿名</span><br><span class="line">anonymous_enable=NO</span><br><span class="line"></span><br><span class="line">chroot_local_user=NO</span><br><span class="line">chroot_list_enable=YES</span><br><span class="line"># (default follows)</span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br><span class="line"></span><br><span class="line">#pasv_enable=YES</span><br><span class="line">pasv_min_port=<span class="number">61001</span></span><br><span class="line">pasv_max_port=<span class="number">62000</span></span><br></pre></td></tr></table></figure><p><strong>启动 vsftpd</strong></p><p>启动 <code>vsftpd</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start vsftpd</span><br></pre></td></tr></table></figure></p><p>查看 <code>vsftpd</code> 服务的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status vsftpd.service</span><br></pre></td></tr></table></figure><p>将其设置开机自启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable vsftpd.service</span><br></pre></td></tr></table></figure><h1 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h1><p><strong style="color:#ff6600">下载与安装</strong></p><p>首先，安装 <code>Nginx</code> 需要依赖的环境：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br></pre></td></tr></table></figure><p>使用 <code>wget</code> 命令从官网下载 <code>Nginx</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//nginx.org/download/nginx-1.14.0.tar.gz</span></span><br></pre></td></tr></table></figure><p>使用 <code>tar</code> 解压缩到 <code>setup</code> 目录：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-<span class="number">1.14</span>.0.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>进入 <code>Nginx</code> 目录，分别执行以下命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">更改配置</strong></p><p>然后，进入到 <code>Nginx</code> 安装目录的 <code>conf</code>下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/nginx/conf</span><br></pre></td></tr></table></figure><p>编辑 <code>nginx.conf</code> 文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim nginx.conf</span><br></pre></td></tr></table></figure><p>在其中添加如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include vhost<span class="comment">/*.conf;</span></span><br></pre></td></tr></table></figure><p>然后，在 <code>conf</code> 目录下创建 <code>vhost</code> 文件夹。在 <code>vhost</code> 文件夹中创建 <code>admin.timberliu.com.conf</code>、<code>timberliu.com.conf</code>、<code>s.timberliu.com.conf</code> 和 <code>img.timberliu.com.conf</code> 文件。</p><p>在启动 <code>Nginx</code> 后，访问 <code>123.56.9.126</code>，即可看到 <code>Nginx</code> 页面。</p><h1 id="安装-MySQL"><a href="#安装-MySQL" class="headerlink" title="安装 MySQL"></a>安装 MySQL</h1><p>首先，需要删除掉系统自装或以前安装的 <code>mysql</code>：</p><blockquote><p>rosten：<a href="https://blog.csdn.net/rosten/article/details/25096159?utm_source=blogxgwz2" target="_blank" rel="noopener">centos下完全卸载mysql</a></p></blockquote><p>下载与安装： </p><blockquote><p>近博：<a href="https://www.cnblogs.com/jimboi/p/6405560.html" target="_blank" rel="noopener">Centos6.8通过yum安装mysql5.7</a><br>Linux社区-xyang81：<a href="https://www.linuxidc.com/Linux/2016-09/135288.htm" target="_blank" rel="noopener">CentOS7 64位下MySQL5.7安装与配置（YUM）</a></p></blockquote><p>注意：<code>CentOS 6</code> 和 <code>7</code> 中对于服务的管理也出现不同。<code>CentOS 6</code> 中使用 <code>service</code> 命令进行启动停止服务，使用 <code>chkconfig</code> 命令设置开机自启；而在 <code>CentOS 7</code> 中对所有服务都集中在到 <code>systemctl</code> 中，通过 <code>/usr/lib/systemd/system</code> 下以 <code>.service</code> 结尾的配置文件来管理。</p><p>在安装完 <code>MySQL</code> 后，使用 <code>mysql -u root</code> 进入 <code>mysql</code>，通过如下方式修改密码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">update mysql.user set authentication_string=password(<span class="string">'root'</span>) where user=<span class="string">'root'</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>然后退出 <code>mysql</code>，重新登录。使用如下命令创建一个新用户 <code>mmall</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant usage on *.* to <span class="string">'username'</span>@<span class="string">'localhost'</span> identified by <span class="string">'password'</span> with grant option;</span><br></pre></td></tr></table></figure><p>然后创建数据库：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database `mmall` <span class="keyword">default</span> character set utf8 COLLATE utf8_genernal_ci;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p>对新建的用户赋予权限，并刷新权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on mmall.* to <span class="string">'username'</span>@<span class="string">'localhost'</span> identified by <span class="string">'password'</span>;</span><br></pre></td></tr></table></figure><p>再导入 <code>sql</code> 文件创建表。这里需要先将 <code>sql</code> 文件上传到服务器上，然后使用 <code>source</code> 命令就可以创建表了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /developer/mmall.sql</span><br></pre></td></tr></table></figure><h1 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h1><p>首先，安装 <code>git</code> 环境需要的依赖：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder</span><br></pre></td></tr></table></figure><p>再下载 <code>git</code> 的压缩包到 <code>setup</code> 目录下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https:<span class="comment">//www.kernel.org/pub/software/scm/git/git-2.11.1.tar.gz</span></span><br></pre></td></tr></table></figure><p>对刚才的包解压缩：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf git-<span class="number">2.11</span>.1.tar.gz -C ../</span><br></pre></td></tr></table></figure><p>然后进行编译，安装:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /developer/git-<span class="number">2.11</span>.1</span><br><span class="line">make prefix=/usr/local/git all</span><br><span class="line">make prefix=/usr/local/git install</span><br></pre></td></tr></table></figure><p>打开 <code>vim /etc/profile</code> 配置环境变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin:/usr/local/git/bin</span><br></pre></td></tr></table></figure><p>执行 <code>source /etc/profile</code> 使之生效。可以使用 <code>git --version</code> 查看版本。</p><p>然后，添加用户名和邮箱：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"yourusername"</span></span><br><span class="line">git config --global user.email <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>另外，在 linux 和 windows 下换行符不同，这里配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p>表示使 <code>git</code> 不要转换换行符。还需要配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath off</span><br></pre></td></tr></table></figure><p>表示防止中文乱码问题。然后，设置编码为 <code>utf-8</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global gui.encoding utf-<span class="number">8</span></span><br></pre></td></tr></table></figure><p>创建密钥，默认即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail"</span></span><br></pre></td></tr></table></figure><p>然后，执行下面的命令:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>如果出现 <code>Could not open a connection to your authentication agent.</code>，则执行 <code>eval</code>，再执行上面的命令：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval `ssh-agent`</span><br><span class="line">ssh-add ~/.ssh/id_rsa</span><br></pre></td></tr></table></figure><p>然后，使用下面的命令获取公钥：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将其复制到 <code>github</code> 的 <code>SSH keys</code> 中即可。</p><h1 id="防火墙配置"><a href="#防火墙配置" class="headerlink" title="防火墙配置"></a>防火墙配置</h1><p>在阿里云服务器中，需要配置规则，放行所需端口入方向规则。可以参考这篇文章：aquarius_wing：<a href="https://www.jianshu.com/p/087774e1cc22" target="_blank" rel="noopener">阿里云服务器上tomcat无法访问的问题</a></p><p>在 <code>CentOS7</code> 下默认使用 <code>firewall</code> 作为防火墙，使用 <code>iptables</code> 需要重新设置一下。在 <code>/etc/sysconfig</code> 目录下没有 <code>iptables</code> 文件，需要执行以下命令进行安装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install iptables-services</span><br></pre></td></tr></table></figure><p>然后在 <code>iptables</code> 文件中配置端口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">*filter</span><br><span class="line">:INPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">:FORWARD ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">:OUTPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>]</span><br><span class="line">-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">-A INPUT -p icmp -j ACCEPT</span><br><span class="line">-A INPUT -i lo -j ACCEPT</span><br><span class="line"></span><br><span class="line">#ssh port </span><br><span class="line">-A INPUT -m state --state NEW -m tcp -p tcp --dport <span class="number">22</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">#vsftpd</span><br><span class="line">-A INPUT -p TCP --dport <span class="number">61001</span>:<span class="number">62000</span> -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport <span class="number">61001</span>:<span class="number">62000</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p TCP --dport <span class="number">20</span> -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport <span class="number">20</span> -j ACCEPT</span><br><span class="line">-A INPUT -p TCP --dport <span class="number">21</span> -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport <span class="number">21</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">#nginx</span><br><span class="line">-A INPUT -p tcp -m tcp --dport <span class="number">80</span> -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited</span><br><span class="line">COMMIT</span><br></pre></td></tr></table></figure><p>保存退出后，执行以下命令启动防火墙:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart iptables.service</span><br></pre></td></tr></table></figure><p>然后，设置防火墙开机自启动：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable iptables.service</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;配置软件源&quot;&gt;&lt;a href=&quot;#配置软件源&quot; class=&quot;headerlink&quot; title=&quot;配置软件源&quot;&gt;&lt;/a&gt;配置软件源&lt;/h1&gt;&lt;p&gt;首先，需要进行源配置，可使用阿里云的源，可查看：&lt;a href=&quot;https://opsx.alibaba.com/mirror&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; https://opsx.alibaba.com/mirror&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;、备份&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;、下载新的CentOS-Base.repo 到/etc/yum.repos.d/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;wget -O /etc/yum.repos.d/CentOS-Base.repo http:&lt;span class=&quot;comment&quot;&gt;//mirrors.aliyun.com/repo/Centos-7.repo&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;、生成缓存&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;yum makecache&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之购物车、收货地址、订单模块</title>
    <link href="https://blog.timberliu.com/2019/01/28/013_mmallv1.0%E8%B4%AD%E7%89%A9%E8%BD%A6%E3%80%81%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E3%80%81%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.timberliu.com/2019/01/28/013_mmallv1.0购物车、收货地址、订单模块/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="购物车模块"><a href="#购物车模块" class="headerlink" title="购物车模块"></a>购物车模块</h1><p>1、购物车模块中购物车的设计，购物车对象如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartVo</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 商品集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CartProductVo&gt; cartProductVoList;</span><br><span class="line">    <span class="comment">// 购物车总价</span></span><br><span class="line">    <span class="keyword">private</span> BigDecimal cartTotalPrice;</span><br><span class="line">    <span class="comment">// 是否全被选中</span></span><br><span class="line">    <span class="keyword">private</span> Boolean allChecked;</span><br><span class="line">    <span class="comment">// 图片域名</span></span><br><span class="line">    <span class="keyword">private</span> String imageHost;</span><br><span class="line">    <span class="comment">// getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>其中，购物车每一件商品 <code>CartProductVo</code> 对象设计如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CartProductVo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> Integer productId;</span><br><span class="line">    <span class="comment">// 商品数量</span></span><br><span class="line">    <span class="keyword">private</span> Integer quantity;</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line">    <span class="keyword">private</span> String productSubtitle;</span><br><span class="line">    <span class="keyword">private</span> String productMainImage;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal price;</span><br><span class="line">    <span class="keyword">private</span> Integer productStatus;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal productTotalPrice;</span><br><span class="line">    <span class="keyword">private</span> Integer productStock;</span><br><span class="line">    <span class="comment">// 此商品是否勾选</span></span><br><span class="line">    <span class="keyword">private</span> Integer productChecked;</span><br><span class="line">    <span class="comment">// 限制数量的一个返回结果</span></span><br><span class="line">    <span class="keyword">private</span> String limitQuantity;</span><br><span class="line">    <span class="comment">// getter/setter 方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、封装一个高可用的购物车核心方法：获取购物车中所有商品信息 <code>getCartVoLimit()</code> 方法。设计思想如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> CartVo <span class="title">getCartVoLimit</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">    CartVo cartVo = <span class="keyword">new</span> CartVo();</span><br><span class="line">    <span class="comment">// 根据用户 Id 查询购物车信息</span></span><br><span class="line">    List&lt;Cart&gt; cartList = cartMapper.selectCartByUserId(userId);</span><br><span class="line"></span><br><span class="line">    List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList();</span><br><span class="line">    BigDecimal cartTotalPrice = <span class="keyword">new</span> BigDecimal(<span class="string">"0"</span>);</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(cartList)) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Cart cart : cartList) &#123;</span><br><span class="line">            CartProductVo cartProductVo = <span class="keyword">new</span> CartProductVo();</span><br><span class="line">            cartProductVo.setId(cart.getId());</span><br><span class="line">            cartProductVo.setUserId(cart.getUserId());</span><br><span class="line">            cartProductVo.setProductId(cart.getProductId());</span><br><span class="line"></span><br><span class="line">            Product product = productMapper.selectByPrimaryKey(cart.getProductId());</span><br><span class="line">            <span class="keyword">if</span> (product != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cartProductVo.setProductMainImage(product.getMainImage());</span><br><span class="line">                cartProductVo.setProductName(product.getName());</span><br><span class="line">                cartProductVo.setProductSubtitle(product.getSubtitle());</span><br><span class="line">                cartProductVo.setProductStatus(product.getStatus());</span><br><span class="line">                cartProductVo.setPrice(product.getPrice());</span><br><span class="line">                cartProductVo.setProductStock(product.getStock());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> buyLimitCount = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (product.getStock() &gt;= cart.getQuantity()) &#123;</span><br><span class="line">                    <span class="comment">// 库存足够</span></span><br><span class="line">                    buyLimitCount = cart.getQuantity();</span><br><span class="line">                    cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_SECCESS);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 库存不足</span></span><br><span class="line">                    buyLimitCount = product.getStock();</span><br><span class="line">                    cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_FAIL);</span><br><span class="line">                    <span class="comment">// 购物车中更新为有效的库存</span></span><br><span class="line">                    Cart cartForQuantity = <span class="keyword">new</span> Cart();</span><br><span class="line">                    cartForQuantity.setId(cart.getId());</span><br><span class="line">                    cartForQuantity.setQuantity(buyLimitCount);</span><br><span class="line">                    cartMapper.updateByPrimaryKeySelective(cartForQuantity);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cartProductVo.setQuantity(buyLimitCount);</span><br><span class="line">                <span class="comment">// 计算单件商品总价</span></span><br><span class="line">                cartProductVo.setProductTotalPrice(BigDecimalUtil.mul(product.getPrice().doubleValue(), cartProductVo.getQuantity().doubleValue()));</span><br><span class="line">                cartProductVo.setProductChecked(cart.getChecked());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果商品被选中，则相加到购物中总价中</span></span><br><span class="line">            <span class="keyword">if</span> (cart.getChecked() == Const.Cart.CHECKED) &#123;</span><br><span class="line">                cartTotalPrice = BigDecimalUtil.add(cartTotalPrice.doubleValue(), cartProductVo.getProductTotalPrice().doubleValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cartProductVoList.add(cartProductVo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cartVo.setCartProductVoList(cartProductVoList);</span><br><span class="line">    cartVo.setAllChecked(getAllCheckedStatus(userId));</span><br><span class="line">    cartVo.setCartTotalPrice(cartTotalPrice);</span><br><span class="line">    cartVo.setImageHost(PropertiesUtil.getProperty(<span class="string">"ftp.server.http.prefix"</span>));</span><br><span class="line">    <span class="keyword">return</span> cartVo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、对于浮点型在商业运算中丢失精度问题，可以使用 <code>BigDecimal</code> 对象，将参数转为 <code>String</code> 类型进行计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimalUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.add(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">sub</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.subtract(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">mul</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="keyword">return</span> b1.multiply(b2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BigDecimal <span class="title">div</span><span class="params">(<span class="keyword">double</span> v1, <span class="keyword">double</span> v2)</span> </span>&#123;</span><br><span class="line">        BigDecimal b1 = <span class="keyword">new</span> BigDecimal(Double.toString(v1));</span><br><span class="line">        BigDecimal b2 = <span class="keyword">new</span> BigDecimal(Double.toString(v2));</span><br><span class="line">        <span class="comment">// 保留两位小数，使用四舍五入模式</span></span><br><span class="line">        <span class="keyword">return</span> b1.divide(b2, <span class="number">2</span>, BigDecimal.ROUND_HALF_UP);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="收货地址模块"><a href="#收货地址模块" class="headerlink" title="收货地址模块"></a>收货地址模块</h1><p>1、<code>Mybatis</code> 自动生成主键、配置和使用</p><p>在添加收货地址时，可以自动生成主键，这里指定为 <code>id</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"insert"</span> parameterType=<span class="string">"com.mmall.pojo.Shipping"</span> useGeneratedKeys=<span class="string">"true"</span> keyProperty=<span class="string">"id"</span>&gt;</span><br></pre></td></tr></table></figure></p><p>然后，就可以使用 <code>shipping.getId()</code> 得到新添加收货地址后的 <code>id</code>。</p><p>2、在更新收货地址信息时，为防止横向越权，在 <code>ShippingMapper.xml</code> 文件中，根据用户 <code>Id</code> 和 <code>ShippingId</code> 进行更新：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;update id=<span class="string">"updateByShipping"</span> parameterType=<span class="string">"com.mmall.pojo.Shipping"</span>&gt;</span><br><span class="line">    update mmall_shipping</span><br><span class="line">    set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;,</span><br><span class="line">      receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;,</span><br><span class="line">      create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;,</span><br><span class="line">      update_time = now()</span><br><span class="line">    where id = #&#123;id,jdbcType=INTEGER&#125;</span><br><span class="line">          and user_id = #&#123;userId,jdbcType=INTEGER&#125;</span><br><span class="line">&lt;/update&gt;</span><br></pre></td></tr></table></figure><h1 id="订单模块"><a href="#订单模块" class="headerlink" title="订单模块"></a>订单模块</h1><p>1、创建订单时需要将订单详情插入到数据库中，可以使用 MyBatis 的批量插入。使用 foreach 标签，集合中每一个对象使用括号括起来，用逗号进行分隔。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"batchInsert"</span> parameterType=<span class="string">"list"</span>&gt;</span><br><span class="line">    <span class="function">insert into <span class="title">mmall_order_item</span> <span class="params">(id, user_id, order_no,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  product_id, product_name, product_image,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  current_unit_price, quantity, total_price,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  create_time, update_time)</span></span></span><br><span class="line"><span class="function">    values</span></span><br><span class="line"><span class="function">    &lt;foreach collection</span>=<span class="string">"list"</span> index=<span class="string">"index"</span> item=<span class="string">"item"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">      (</span><br><span class="line">      #&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.userId,jdbcType=INTEGER&#125;, #&#123;item.orderNo,jdbcType=BIGINT&#125;,</span><br><span class="line">      #&#123;item.productId,jdbcType=INTEGER&#125;, #&#123;item.productName,jdbcType=VARCHAR&#125;, #&#123;item.productImage,jdbcType=VARCHAR&#125;,</span><br><span class="line">      #&#123;item.currentUnitPrice,jdbcType=DECIMAL&#125;, #&#123;item.quantity,jdbcType=INTEGER&#125;, #&#123;item.totalPrice,jdbcType=DECIMAL&#125;,</span><br><span class="line">      now(), now()</span><br><span class="line">      )</span><br><span class="line">    &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure><p>另外，需要注意的是：Mybatis 批量插入时默认的最大数据量是 1 M，如果超过则会报 <code>PacketTooBigException</code> 异常。可以通过 mysql 安装目录下的 my.ini 文件中，mysqld 段的 <code>max_allowed_packet = 1 M</code> 进行调整；</p><p>2、对于产品状态、订单状态、支付平台、支付方式，都使用枚举类表示。如何设计一个实用安全扩展性强大的枚举类？例如，订单状态如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> OrderStatusEnum &#123;</span><br><span class="line">    CANCELED(<span class="number">0</span>, <span class="string">"已取消"</span>),</span><br><span class="line">    NO_PAY(<span class="number">10</span>, <span class="string">"未支付"</span>),</span><br><span class="line">    PAID(<span class="number">20</span>, <span class="string">"已支付"</span>),</span><br><span class="line">    SHIPPED(<span class="number">40</span>, <span class="string">"已发货"</span>),</span><br><span class="line">    ORDER_SUCCESS(<span class="number">50</span>, <span class="string">"订单完成"</span>),</span><br><span class="line">    ORDER_CLOSED(<span class="number">60</span>, <span class="string">"订单关闭"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> code;</span><br><span class="line">    OrderStatusEnum(<span class="keyword">int</span> code, String value) &#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> code; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> OrderStatusEnum <span class="title">codeOf</span><span class="params">(<span class="keyword">int</span> code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (OrderStatusEnum orderStatusEnum : values()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(orderStatusEnum.getCode() == code) &#123;</span><br><span class="line">                <span class="keyword">return</span> orderStatusEnum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到对应的枚举"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、订单号的生成规则，必须唯一严谨。由于这里用户量不多，并发量小，可使用如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">long</span> <span class="title">generateOrderNo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">return</span> currentTime + <span class="keyword">new</span> Random().nextInt(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用当前时间戳并加上一个 100 以内的随机数生成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;购物车模块&quot;&gt;&lt;a href=&quot;#购物车模块&quot; class=&quot;headerlink&quot; title=&quot;购物车模块&quot;&gt;&lt;/a&gt;购物车模块&lt;/h1&gt;&lt;p&gt;1、购物车模块中购物车的设计，购物车对象如下：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;CartVo&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 商品集合&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; List&amp;lt;CartProductVo&amp;gt; cartProductVoList;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 购物车总价&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; BigDecimal cartTotalPrice;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 是否全被选中&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; Boolean allChecked;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 图片域名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; String imageHost;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// getter/setter 方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之支付模块</title>
    <link href="https://blog.timberliu.com/2019/01/28/014_mmallv1.0%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.timberliu.com/2019/01/28/014_mmallv1.0支付模块/</id>
    <published>2019-01-27T16:00:00.000Z</published>
    <updated>2019-01-27T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="扫码支付支付流程"><a href="#扫码支付支付流程" class="headerlink" title="扫码支付支付流程"></a>扫码支付支付流程</h1><p><img src="http://media.timberliu.com/image/2019/1/29/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.png" width="80%"></p><p>在商家发出预下单请求后，支付宝后台会返回二维码信息给用户，然后用户通过支付宝钱包扫码，之后支付宝后台会把支付结果信息返回给商家后台。<a id="more"></a></p><h1 id="扫码支付调用流程"><a href="#扫码支付调用流程" class="headerlink" title="扫码支付调用流程"></a>扫码支付调用流程</h1><p><img src="http://media.timberliu.com/image/2019/1/29/%E6%94%AF%E4%BB%98%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B.png" width="60%"></p><p>主要的思路如下：</p><ol><li>商家系统调用支付宝接口发起预下单请求，获得二维码图片地址；然后通过二维码串生成二维码图片，上传至图片服务器，并将 <code>url</code> 返回给前台；</li><li>发起轮询获得支付结果：通过支付时传入的商品订单号查询支付结果；</li><li>还可以通过异步通知获得支付结果，注意：一定要对异步通知进行验签，确保通知是支付宝发出的。另外，还要更新数据库中的信息</li></ol><h1 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h1><p><strong style="color:#ff6600">预下单请求</strong></p><p>首先，创建扫码支付请求 <code>builder</code>，并设置标题、总金额、交易号、回调地址、商品列表集合等请求参数。在创建商品时，可以使用 <code>newInstance</code>方法传入商品 <code>id</code>、名称、单价、数量等信息创建，然后添加到商品列表集合中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">List&lt;GoodsDetail&gt; goodsDetailList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo, userId);</span><br><span class="line"><span class="keyword">for</span> (OrderItem orderItem : orderItemList) &#123;</span><br><span class="line">    <span class="comment">// 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail</span></span><br><span class="line">    GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(),</span><br><span class="line">            BigDecimalUtil.add(orderItem.getCurrentUnitPrice().doubleValue(), <span class="number">100.0</span>).longValue(), orderItem.getQuantity());</span><br><span class="line">    <span class="comment">// 创建好一个商品后添加至商品明细列表</span></span><br><span class="line">    goodsDetailList.add(goods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlipayTradePrecreateRequestBuilder builder = <span class="keyword">new</span> AlipayTradePrecreateRequestBuilder()</span><br><span class="line">    .setSubject(subject).setTotalAmount(totalAmount)</span><br><span class="line">    .setOutTradeNo(outTradeNo).setUndiscountableAmount(undiscountableAmount)</span><br><span class="line">    .setSellerId(sellerId).setBody(body).setOperatorId(operatorId)</span><br><span class="line">    .setStoreId(storeId).setExtendParams(extendParams).setTimeoutExpress(timeoutExpress)</span><br><span class="line">    .setNotifyUrl(PropertiesUtil.getProperty(<span class="string">"alipay.callback.url"</span>))   <span class="comment">//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</span></span><br><span class="line">    .setGoodsDetailList(goodsDetailList);</span><br></pre></td></tr></table></figure><p>然后，使用 <code>Config.init()</code> 加载 <code>zbinfo</code> 配置文件，其中配置了支付宝的支付宝网关名、<code>pid</code>、<code>appid</code>、<code>RSA</code>私钥、公钥等。注意：加载文件一定要在创建 <code>AlipayTradeService</code> 对象之前调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Configs.init(<span class="string">"zfbinfo.properties"</span>);</span><br></pre></td></tr></table></figure><p>再然后，创建 <code>AlipayTradeService</code> 单例或静态对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlipayTradeService tradeService = <span class="keyword">new</span> AlipayTradeServiceImpl.ClientBuilder().build();</span><br></pre></td></tr></table></figure><p>最后，使用 <code>tradePrecreate()</code> 方法发起预下单请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">同步订单的二维码串，并生成二维码</strong></p><p>首先，判断上一步中 <code>result</code> 的订单状态，如果为 <code>SUCCESS</code>，则表示预下单成功；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (result.getTradeStatus()) &#123;</span><br><span class="line">    <span class="keyword">case</span> SUCCESS:</span><br><span class="line">        log.info(<span class="string">"支付宝预下单成功: )"</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，可以使用 <code>result.getResponse()</code> 得到响应对象。再使用 <code>response.getOutTradeNo()</code> 得到订单号，并创建上传到服务器的存放路径。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AlipayTradePrecreateResponse response = result.getResponse();</span><br><span class="line">···</span><br><span class="line">String qrPath = String.format(path + <span class="string">"/qr-%s.png"</span>, response.getOutTradeNo());</span><br></pre></td></tr></table></figure><p>然后，使用 <code>ZxingUtils.getQRCodeImge()</code> 方法将 <code>getQrCode()</code> 得到的二维码串转换为宽度为 <code>256</code> 的图片存放在 <code>qrPath</code> 下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZxingUtils.getQRCodeImge(response.getQrCode(), <span class="number">256</span>, qrPath);</span><br></pre></td></tr></table></figure><p>最后，使用 <code>FtpUtil.uploadFile</code> 方法将图片上传到图片服务器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File targetFile = <span class="keyword">new</span> File(qrPath);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    FtpUtil.uploadFile(Lists.newArrayList(targetFile));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    log.error(<span class="string">"上传二维码失败"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">轮询查看交易的状态</strong></p><p>这里，主要是到数据库中查询订单信息，判断订单状态即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Order order = orderMapper.selectByUserIdAndOrderNo(userId, orderNo);</span><br><span class="line">···</span><br><span class="line"><span class="keyword">if</span>(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode()) &#123;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.createBySuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong style="color:#ff6600">异步通知结果</strong></p><p>首先，在收到异步通知时，参数以 <code>Map&lt;String, String[]&gt;</code> 的形式封装在 <code>request</code> 中，需要将其转换为 <code>Map&lt;String, String&gt;</code> 形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; params = Maps.newHashMap();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String[]&gt; requestParams = request.getParameterMap();</span><br><span class="line"><span class="keyword">for</span>(Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) &#123;</span><br><span class="line">    String name = (String) iter.next();</span><br><span class="line">    String[] values = (String[]) requestParams.get(name);</span><br><span class="line">    String valueStr = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">        valueStr = (i == values.length - <span class="number">1</span>) ? valueStr + values[i] : valueStr + values[i] + <span class="string">","</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    params.put(name, valueStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，对于返回的结果，除了 <code>sign</code>、<code>sign_type</code> 两个参数，其他都需要验签。在源码实现中，已经移除了 <code>sign</code> 参数，只需要移除 <code>sign_type</code> 即可。另外对剩余参数进行 <code>url_encode</code>，并进行字段排序组成待验签字符串，还有将 <code>sign</code> 使用 <code>base64</code> 解码为字节码串也都已实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params.remove(<span class="string">"sign_type"</span>);</span><br></pre></td></tr></table></figure><p>然后，使用 <code>RSA</code> 验签方法，通过签名字符串、支付宝公钥、字符编码、<code>signType</code> 验证签名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> alipayRSACheckedV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), <span class="string">"utf-8"</span>, Configs.getSignType());</span><br></pre></td></tr></table></figure><p>然后，在服务层中，需要更改订单的支付时间与支付状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)) &#123;</span><br><span class="line">    order.setPaymentTime(DateTimeUtil.strToDate(params.get(<span class="string">"gmt_payment"</span>)));</span><br><span class="line">    order.setStatus(Const.OrderStatusEnum.PAID.getCode());</span><br><span class="line">    orderMapper.updateByPrimaryKeySelective(order);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，再将支付信息添加到支付信息表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PayInfo payInfo = <span class="keyword">new</span> PayInfo();</span><br><span class="line">payInfo.setUserId(order.getUserId());</span><br><span class="line">payInfo.setOrderNo(orderNo);</span><br><span class="line">payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode());</span><br><span class="line">payInfo.setPlatformNumber(tradeNo);</span><br><span class="line">payInfo.setPlatformStatus(tradeStatus);</span><br><span class="line"></span><br><span class="line">payInfoMapper.insert(payInfo);</span><br></pre></td></tr></table></figure><h1 id="NatAPP-内网穿透"><a href="#NatAPP-内网穿透" class="headerlink" title="NatAPP 内网穿透"></a>NatAPP 内网穿透</h1><p>在支付时，支付宝异步回调需要让回调地址可以被外网访问，可以使用 <code>natapp</code> 进行内网穿透。这里参考文档 <a href="https://natapp.cn/article/natapp_newbie" target="_blank" rel="noopener">NATAPP1分钟快速新手图文教程</a> 即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;扫码支付支付流程&quot;&gt;&lt;a href=&quot;#扫码支付支付流程&quot; class=&quot;headerlink&quot; title=&quot;扫码支付支付流程&quot;&gt;&lt;/a&gt;扫码支付支付流程&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://media.timberliu.com/image/2019/1/29/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B.png&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;
&lt;p&gt;在商家发出预下单请求后，支付宝后台会返回二维码信息给用户，然后用户通过支付宝钱包扫码，之后支付宝后台会把支付结果信息返回给商家后台。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v1.0 项目总结之用户、分类、商品模块</title>
    <link href="https://blog.timberliu.com/2019/01/27/012_mmallv1.0%E7%94%A8%E6%88%B7%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97/"/>
    <id>https://blog.timberliu.com/2019/01/27/012_mmallv1.0用户、分类、商品模块/</id>
    <published>2019-01-26T16:00:00.000Z</published>
    <updated>2019-01-26T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h1><p>使用 <code>IDEA</code> 创建项目，并上传到 <code>Github</code> 上。</p><p>参考文章：<a href="https://blog.csdn.net/stevennest/article/details/77877074" target="_blank" rel="noopener">stevennest：IDEA创建项目及上传到github</a></p><h1 id="用户模块"><a href="#用户模块" class="headerlink" title="用户模块"></a>用户模块</h1><p>在用户模块中，主要包括以下几个功能：</p><p><img src="http://media.timberliu.com/image/2019/1/27/mmall-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97.jpg" width="80%"><a id="more"></a></p><p>需要注意的问题有以下几点：</p><p>1、在忘记密码-检查问题时，使用 <code>UUID</code> 生成唯一标识，存储在缓存中，并将这个标识传递给前端；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String forgetToken = UUID.randomUUID().toString();</span><br><span class="line">TokenCache.setKey(TokenCache.TOKEN_PREFIX + username, forgetToken);</span><br></pre></td></tr></table></figure><p>在忘记密码-重置密码时，前端需要携带 <code>token</code>，服务器端需要判断 <code>token</code> 是否过期，并与缓存中的 <code>token</code> 进行对比，以防止横向越权访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX + username);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(StringUtils.equals(forgetToken, token)) &#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、在后台管理模块中，为防止纵向越权，在数据表设计时添加了 <code>role</code> 属性，在登录后台，或修改其数据时，都需要检验该用户的 <code>role</code>。</p><p>3、对于密码的存储，使用 <code>MD5</code> 进行加密，并且增加了 <code>Salt</code> 值。</p><p>4、在忘记密码-检查问题时，生成的 <code>token</code> 使用 <code>Guava</code> 进行缓存，以 <code>key/value</code> 形式进行存储。缓存使用主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> LoadingCache&lt;String, String&gt; localCache = CacheBuilder.newBuilder()</span><br><span class="line">            .initialCapacity(<span class="number">1000</span>)</span><br><span class="line">            <span class="comment">// 设置缓存最大值为 10000，如果超过这个值，会使用 LRU 算法进行清除</span></span><br><span class="line">            .maximumSize(<span class="number">10000</span>)</span><br><span class="line">            <span class="comment">// 过期时间，及单位</span></span><br><span class="line">            .expireAfterAccess(<span class="number">12</span>, TimeUnit.HOURS)</span><br><span class="line">            .build(<span class="keyword">new</span> CacheLoader&lt;String, String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">load</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"null"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br></pre></td></tr></table></figure><p>然后，可通过 <code>set/get</code> 方法设置、并获取值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">    localCache.put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    value = localCache.get(key);</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>5、使用 <code>ServerResponse</code> 高复用响应式对象。其中三个属性如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> status;</span><br><span class="line"><span class="keyword">private</span> String msg;</span><br><span class="line"><span class="keyword">private</span> T data;</span><br></pre></td></tr></table></figure><p>使用 <code>enum</code> 枚举类来表示不同的响应码。主要有四种响应码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ResponseCode &#123;</span><br><span class="line"></span><br><span class="line">    SUCCESS(<span class="number">0</span>, <span class="string">"SUCCESS"</span>),</span><br><span class="line">    ERROR(<span class="number">1</span>, <span class="string">"ERROR"</span>),</span><br><span class="line">    NEED_LOGIN(<span class="number">10</span>, <span class="string">"NEED_LOGIN"</span>),</span><br><span class="line">    ILLEGAL_ARGUMENT(<span class="number">2</span>, <span class="string">"ILLEGAL_ARGUMENT"</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，其中使用了 <code>@JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL)</code> 标记 <code>ServerResponse</code>，表示在序列化对象时，忽略为空的属性，使用了 <code>@JsonIgnore</code> 标记 <code>isSuccess</code> 方法，表示在序列化时，忽略此方法。</p><p>6、用户登录信息使用 <code>Session</code> 进行存储。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(Const.CURRENT_USER, response.getData());</span><br></pre></td></tr></table></figure><p>7、使用 <code>StringUtils</code>、<code>CollectionUtils</code> 等工具类简化操作。</p><p>8、使用 <code>slf4j</code> 的 <code>LoggerFactory</code> 生成 <code>logger</code> 对象，打印日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TokenCache.class);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"···"</span>);</span><br></pre></td></tr></table></figure><h1 id="分类管理模块"><a href="#分类管理模块" class="headerlink" title="分类管理模块"></a>分类管理模块</h1><p>1、在分类管理中，需要用到无限层级的树状数据结构显示分类。可以在设计数据表时添加 <code>parentId</code> 属性，表示其父结点的 <code>Id</code>。另外，如果 <code>parentId</code> 为 <code>0</code>，表示当前结点为根结点分类。</p><p>2、在查询子结点分类时，需要用到递归算法。首先，根据前台传来的 <code>id</code> 判断该结点是否存在，如果存在，则添加到 <code>categorySet</code> 中。然后调用 <code>findChildCategory</code> 方法查询子节点分类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Category category = categoryMapper.selectByPrimaryKey(categoryId);</span><br><span class="line"><span class="keyword">if</span>(category != <span class="keyword">null</span>) &#123;</span><br><span class="line">    categorySet.add(category);</span><br><span class="line">&#125;</span><br><span class="line">findChildCategory(categorySet, categoryId);</span><br></pre></td></tr></table></figure><p>其中，会根据 <code>parentId</code> 查询与子分类平级的结点得到一个 <code>List</code> 集合。然后遍历此集合，将子分类结点添加到 <code>categroySet</code>，再递归查询子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findChildCategory</span><span class="params">(Set&lt;Category&gt; categorySet, Integer parentId)</span> </span>&#123;</span><br><span class="line">    List&lt;Category&gt; categoryList = categoryMapper.getChildrenCategoryByParentId(parentId);</span><br><span class="line">    <span class="keyword">for</span> (Category category: categoryList) &#123;</span><br><span class="line">        categorySet.add(category);</span><br><span class="line">        findChildCategory(categorySet, category.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，创建 <code>List</code> 集合，遍历 <code>categorySet</code>，将 <code>category</code> 的 <code>id</code> 添加到 <code>categoryIdList</code> 中，返回给前端。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; categoryIdList = Lists.newArrayList();</span><br><span class="line"><span class="keyword">if</span>(categoryId != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (Category categoryItem: categorySet) &#123;</span><br><span class="line">        categoryIdList.add(categoryItem.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、在存储 <code>category</code> 时，为了防止对象重复，这里使用 <code>Set</code> 进行排重。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;Category&gt; categorySet = Sets.newHashSet();</span><br></pre></td></tr></table></figure><p>另外，<code>Set</code> 中存放的对象 <code>Category</code> 要判断是否相等，这里针对 <code>id</code>，重写了 <code>hashCode</code> 和 <code>equals</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123; <span class="keyword">return</span> <span class="keyword">true</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Category)) &#123; <span class="keyword">return</span> <span class="keyword">false</span>; &#125;</span><br><span class="line">    Category category = (Category) o;</span><br><span class="line">    <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.equals(category.id) : category.id == <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id != <span class="keyword">null</span> ? id.hashCode() : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="商品管理模块"><a href="#商品管理模块" class="headerlink" title="商品管理模块"></a>商品管理模块</h1><p>1、<code>SpringMVC</code> 文件上传使用 <code>FTPClient</code>。在上传文件之前，首先需要连接服务并登陆。另外，还需要设置远程目录、缓存大小、编码格式等。最后，使用 <code>storeFile</code> 方法传入文件名和文件输入流，上传文件。需要注意的是，上传后要关闭输入流和 <code>FtpClient</code>。主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">uploadFile</span><span class="params">(String remotePath, List&lt;File&gt; fileList)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> uploaded = <span class="keyword">false</span>;</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = connectServer(ip, port, user, password); <span class="comment">// 连接服务器</span></span><br><span class="line">    <span class="keyword">if</span>(isSuccess) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ftpClient.changeWorkingDirectory(remotePath); <span class="comment">// 远程目录</span></span><br><span class="line">            ftpClient.setBufferSize(<span class="number">1024</span>); <span class="comment">// 缓存</span></span><br><span class="line">            ftpClient.setControlEncoding(<span class="string">"UTF-8"</span>); <span class="comment">// 编码格式            ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 文件类型</span></span><br><span class="line">            ftpClient.enterLocalPassiveMode();</span><br><span class="line">            <span class="keyword">for</span> (File fileItem : fileList) &#123;</span><br><span class="line">                fis = <span class="keyword">new</span> FileInputStream(fileItem);</span><br><span class="line">                ftpClient.storeFile(fileItem.getName(), fis);</span><br><span class="line">            &#125;</span><br><span class="line">            uploaded = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"上传文件异常"</span>, e);</span><br><span class="line">            uploaded = <span class="keyword">false</span>;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fis != <span class="keyword">null</span>) &#123; fis.close(); &#125;</span><br><span class="line">            ftpClient.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> uploaded;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">connectServer</span><span class="params">(String ip, <span class="keyword">int</span> port, String user, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isSuccess = <span class="keyword">false</span>;</span><br><span class="line">    ftpClient = <span class="keyword">new</span> FTPClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ftpClient.connect(ip, port); <span class="comment">// 连接服务器</span></span><br><span class="line">        isSuccess = ftpClient.login(user, password); <span class="comment">// 登录</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"连接 FTP 服务器失败"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、使用流来读取 <code>Properties</code> 配置文件，这里使用 <code>java.util.Properties</code> 类的 <code>load</code> 方法来加载 <code>mmall.properties</code> 文件，再使用 <code>getProperty</code> 方法得到配置。主要实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用静态块来初始化并加载配置文件</span></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    String fileName = <span class="string">"mmall.properties"</span>;</span><br><span class="line">    props = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        props.load(<span class="keyword">new</span> InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),<span class="string">"UTF-8"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"配置文件读取异常"</span>,e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 然后，可以使用 getProperty 获取</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span></span>&#123;</span><br><span class="line">    String value = props.getProperty(key.trim());</span><br><span class="line">    <span class="keyword">if</span>(StringUtils.isBlank(value))&#123;</span><br><span class="line">        value = defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value.trim();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、使用 <code>joda-time</code> 处理时间。主要有两种形式：分别为将 <code>String</code> 转为 <code>Date</code> 和将 <code>Date</code> 转为 <code>String</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 String 转为 Date</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Date <span class="title">strToDate</span><span class="params">(String str, String formatStr)</span> </span>&#123;</span><br><span class="line">    DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr);</span><br><span class="line">    DateTime dateTime = dateTimeFormatter.parseDateTime(str);</span><br><span class="line">    <span class="keyword">return</span> dateTime.toDate();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将 Date 转为 String</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">dateToStr</span><span class="params">(Date date, String formatStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(date == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> StringUtils.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line">    DateTime dateTime = <span class="keyword">new</span> DateTime(date);</span><br><span class="line">    <span class="keyword">return</span> dateTime.toString(formatStr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、对于 <code>dao</code> 层生成的 <code>pojo</code>，在 <code>service</code> 和 <code>controller</code> 层使用时，可能由于其他业务逻辑，已不能满足需求，这时就可以使用 <code>BO</code>（<code>business Object</code>）、<code>VO</code>（<code>view Object</code>） 对象。它是在原有 <code>pojo</code> 对象的基础上另外添加一些属性以满足业务的需求。</p><p>项目中，由于业务逻辑还不是特别复杂，所以使用的是简化版本，即 <code>VO</code>(<code>value Object</code>) 对象。</p><p>5、使用 <code>MyBatis-PageHelper</code> 分页及动态排序。一般，都需要先设置页数和每页数量。然后创建 <code>PageInfo</code> 对象，设置 <code>List</code> 集合对象。最后将 <code>PageInfo</code> 对象返回即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PageHelper.startPage(pageNum, pageSize);</span><br><span class="line"></span><br><span class="line">PageInfo pageInfo = <span class="keyword">new</span> PageInfo(productList);</span><br><span class="line">pageInfo.setList(productListVoList);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;项目搭建&quot;&gt;&lt;a href=&quot;#项目搭建&quot; class=&quot;headerlink&quot; title=&quot;项目搭建&quot;&gt;&lt;/a&gt;项目搭建&lt;/h1&gt;&lt;p&gt;使用 &lt;code&gt;IDEA&lt;/code&gt; 创建项目，并上传到 &lt;code&gt;Github&lt;/code&gt; 上。&lt;/p&gt;
&lt;p&gt;参考文章：&lt;a href=&quot;https://blog.csdn.net/stevennest/article/details/77877074&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;stevennest：IDEA创建项目及上传到github&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;用户模块&quot;&gt;&lt;a href=&quot;#用户模块&quot; class=&quot;headerlink&quot; title=&quot;用户模块&quot;&gt;&lt;/a&gt;用户模块&lt;/h1&gt;&lt;p&gt;在用户模块中，主要包括以下几个功能：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://media.timberliu.com/image/2019/1/27/mmall-%E7%94%A8%E6%88%B7%E6%A8%A1%E5%9D%97.jpg&quot; width=&quot;80%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(6)-虚拟内存和文件分配</title>
    <link href="https://blog.timberliu.com/2019/01/11/011_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    <id>https://blog.timberliu.com/2019/01/11/011_虚拟内存/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>虚拟内存在逻辑上实现了对内存容量的扩充，既满足了用户的需要，又改善了系统性能。这篇文章总结了虚拟内存的基本概念、实现方式以及几种页面置换算法。最后是几种文件分配方式。</p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>局部性原理：程序执行时，在一较短时间内，程序的执行仅仅局限于某一部分，其访问的存储空间也局限于某个区域。主要表现在两个方面：</p><ul><li>时间局限性：如果某条指令被执行，不久以后该指令可能再次执行；如果某些数据被访问，不久以后该数据可能再次被访问；</li><li>空间局限性：如果某段存储单元被访问，其附近的存储单元可能也会被访问。<a id="more"></a>  </li></ul><p>基于局部性原理，在加载程序时，只需将当前执行所需的部分页面或段装入内存。程序执行时，如果要访问的页面或段不在内存中，则发生缺页中断，于是 <code>OS</code> 利用请求调页功能将相应的页面或段调入内存，继续执行。如果内存已满，则利用置换功能，将内存中暂时不用的页面或段调出到外存，再将所需的页面或段调入内存，使程序继续执行。</p><p>虚拟内存是指具有请求调入功能和置换功能，从逻辑上对内存容量进行扩充的一种内存系统。实现方式有三种：请求分页存储管理方式、请求段式存储管理方式和请求段页式存储管理方式。</p><h1 id="请求分页存储管理"><a href="#请求分页存储管理" class="headerlink" title="请求分页存储管理"></a>请求分页存储管理</h1><p>请求分页存储管理是在分页存储管理的基础上，增加请求调页和页面置换功能。它允许用户程序只装入部分页面就启动程序运行。在运行中如果发现所需页面不在内存中，则发出缺页中断，<code>OS</code> 就会将外存中相应的页面调入内存使其继续运行。每次调入和换出的基本单位是长度固定的页面。</p><p>请求分页存储管理中的地址转换与分页式相比，在页表项中添加了一些标志位：</p><ul><li>状态位：表示该页是否已调入内存。</li><li>修改位：表示该页在调入内存后是否被修改过。在置换该页时，判断是否要把它写回外存。</li><li>访问位：表示该页在一段时间内被访问的次数。供置换算法在选择换出页面时参考。</li><li>外存地址：表示该页在外存上的地址。</li></ul><p>请求分页存储管理系统中，在进行地址转换时，首先在快表中查找要访问的页。如果找到，便修改页表项中的访问位，供置换算法选择换出页面时参考。如果是写指令，还需要将修改位置为 <code>1</code>，表示该页在调入内存后被修改过。然后利用页表项中的物理块号和页内地址，得到物理地址。</p><p>如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位来判断该页是否调入内存。如果该页已调入，则应将该页的页表项写入快表；如果该页没有调入内存，则应该产生缺页中断，操作系统从外存中找到缺失的页面。</p><p>如果内存已满，则利用置换算法选择一页换出，如果该页被修改过，则需要将该页写回到外存中。最后将缺页从外存换入到内存中，继续运行程序。</p><h1 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h1><p><strong>最优算法（Optimal）</strong></p><p>置换在未来最长时间内不再被访问的页面。这只是一种理想情况，只能用来评价其他置换算法的性能。</p><p><strong>先进先出算法（FIFO）</strong></p><p>选择进入内存时间最长的页面进行置换。在实现时维护一个所有已调入内存的页面的链表，按照进入内存的先后次序排序，链首最早，链尾最进。在出现缺页时，选择链首的页面进行置换，将新页面添加到链尾。</p><p>这种算法实现简单。但调出的页面可能会经常访问，性能较差，一般和其他算法结合使用。</p><p><strong>最近最久未使用算法（LRU）</strong></p><p>选择最长时间没有使用的页面进行置换。它依据的是如果某个页面长时间没有被访问，则在将来一段时间可能还不会访问。</p><p>在实现时维护一个按最近一次访问时间排序的链表，链表首是刚使用过的页面，链表尾是最久未使用的页面。在访问页面时，找到相应的页面，将其移动到链表首；在出现缺页时，删除链表尾节点，将新页面添加到链表首。</p><p>这种算法是最优算法的一种近似，但实现起来仍然比较复杂。</p><p><strong>时钟算法（Clock）</strong></p><p>也称为最近未使用算法（<code>NRU</code>）。在实现时，在页表项中增加一个访问位，表示过去一段时间内是否被访问过，初始时都置为 <code>0</code>，另外将页面组织成环形链表，添加一条指针指向最先被调入内存的页面。</p><p>当访问某页面时，将其访问项置为 <code>1</code>。在出现缺页异常时，从指针处开始查找，如果页面没有被访问过，即访问项为 <code>0</code>，则进行置换；如果被访问过，则将访问项置为 <code>0</code>，暂不换出，再将指针指向下一个页面继续查找，直到找到可以置换的页面。</p><p><strong>最少使用算法（LFU）</strong></p><p>置换最近一段时间访问次数最少的页面。在实现时，对每个页面设置一个访问计数，在访问页面时，对访问计数加 <code>1</code>；在出现缺页异常时，置换访问计数最少的页面。</p><h1 id="文件分配"><a href="#文件分配" class="headerlink" title="文件分配"></a>文件分配</h1><p>文件分配实际上是如何表示分配给一个文件的数据块的位置和顺序。主要有以下几种分配方式：连续分配、链式分配和索引分配。</p><p><strong>连续分配</strong></p><p>使用连续的若干个数据块来存储文件。它在文件控制块中记录起始第一个数据块的位置和长度。</p><p>采用连续分配方式，读取文件的顺序访问和随机访问效率较高，但是剩余的碎片难以利用，另外文件长度增长也比较复杂。</p><p><strong>链式分配</strong></p><p>将文件以数据块链表的形式存储。文件控制块中包含了第一个数据块和最后一个数据块的指针。</p><p>链式分配方式在创建、增大、缩小文件时比较容易，而且没有碎片，但是不能实现真正的随机访问，另外一个数据块被破坏，后面的数据块就都丢了。</p><p><strong>索引分配</strong></p><p>为每个文件创建一个索引数据块，索引数据块中存储了指向文件数据块的指针列表，文件控制块中包含了指向索引数据块的指针。</p><p>这种实现在创建文件、增大、缩小文件时比较容易，也没有碎片，也支持随机访问。但是在文件很小时，存储索引开销相对较大，在文件很大时，需要增加额外的索引快。</p><p><strong>UFS（Unix File System）</strong></p><p>UFS 的多级索引分配：在文件控制块中，如果数据块小于 <code>10</code>，采用直接索引；如果大于 <code>10</code> 块，第 <code>11</code> 块开始采用一级间接索引，它先指向一个索引块，索引块中再指向实际的数据块。如果数据块大到一定程度，会采用二级间接索引，依次类推。</p><p>多级索引分配方式大大提高了文件大小的限制阈值，可以动态分配数据块，文件扩展很容易，对于小文件开销较小，对于大文件使用间接索引也比较合理。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;虚拟内存在逻辑上实现了对内存容量的扩充，既满足了用户的需要，又改善了系统性能。这篇文章总结了虚拟内存的基本概念、实现方式以及几种页面置换算法。最后是几种文件分配方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;局部性原理：程序执行时，在一较短时间内，程序的执行仅仅局限于某一部分，其访问的存储空间也局限于某个区域。主要表现在两个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;时间局限性：如果某条指令被执行，不久以后该指令可能再次执行；如果某些数据被访问，不久以后该数据可能再次被访问；&lt;/li&gt;
&lt;li&gt;空间局限性：如果某段存储单元被访问，其附近的存储单元可能也会被访问。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(5)-内存管理</title>
    <link href="https://blog.timberliu.com/2019/01/11/010_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/"/>
    <id>https://blog.timberliu.com/2019/01/11/010_内存分配/</id>
    <published>2019-01-10T16:00:00.000Z</published>
    <updated>2019-01-10T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。</p></blockquote><h1 id="连续内存分配"><a href="#连续内存分配" class="headerlink" title="连续内存分配"></a>连续内存分配</h1><p>在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。</p><p>动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。<a id="more"></a>  </p><h2 id="内存管理方式"><a href="#内存管理方式" class="headerlink" title="内存管理方式"></a>内存管理方式</h2><p>为实现动态分区分配，系统必须对空闲的内存进行管理，主要有两种方法：位图法和空闲区链表。</p><p><strong>位图法</strong></p><p>使用位图方法时，内存可能被划分为小到几个字或大到几千个字节的分配单元。每个分配单元对应位图中的一位，<code>0</code> 表示空闲，<code>1</code> 表示占用。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c362872002dc?w=1100&h=355&f=png&s=17765" width="80%"></p><p>位图的缺点是如果想要调入一个占 <code>k</code> 个分配单元的进程，必须搜索位图，找出有 <code>k</code> 个连续 <code>0</code> 的串。查找位图中指定长度的连续 <code>0</code> 串的操作很耗时。</p><p><strong>空闲区链表法</strong></p><p>链表法是维护一个已分配内存段和空闲内存段的链表。链表的结点包括一个进程，或两个进程间的一块空闲区。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628979c765?w=887&h=282&f=png&s=16628" width="80%"></p><h2 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h2><p>在将程序加载入内存时，需要按照一定的算法，从位图或空闲链表中选择分区分配给进程。</p><p><strong>首次适配(first fit)</strong></p><p>首次适配算法要求空闲区链表按照地址递增的顺序排序。在分配内存时，沿着链表进行搜索，直到找到一个足够大的分区，将其分为两部分，一部分供进程使用，一部分形成新的空闲区。</p><p>它的实现比较简单，但是低地址部分不断被划分，会留下许多小空闲分区。</p><p><strong>下次适配(next fit)</strong></p><p>下次适配算法和首次适配算法类似，只是不再像首次适配算法那样每次都从头开始，而是从上次找到的空闲分区的下一个空闲分区开始搜索。</p><p><strong>最佳适配(best fit)</strong></p><p>最佳适配算法要求将空闲分区按照其容量大小进行排序。在分配内存时，查找一个能满足要求、又是最小的的空闲分区，分配给进程。</p><p>这种算法的缺点是分区在每次分配后的剩余部分总是最小的，会留下许多难以利用的碎片。</p><p><strong>最差适配(worst fit)</strong></p><p>最差适配算法在分配内存时，总是选择一个最大的空闲分区，划分为两部分，一部分给进程使用，另一部分形成新的空闲分区。</p><p>最差适配算法使得剩下的空闲分区不至于产生太小的碎片；但是这样容易破坏大的空闲分区，后续难以找到大的分区。</p><p><strong>快速适配(quick fit)</strong></p><p>快速适配算法是将空闲分区按照其容量进行分类，为每一类相同容量的空闲分区单独维护一个链表。同时，设立一张管理索引表，表中每一项对应一种空闲分区类型。</p><p>快速适配算法的缺点是在进程被终止或换出释放分区时，有效地合并分区非常耗时。</p><h1 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h1><p>在非连续分配时，根据所分配地址空间的基本单位不同，可将其分为分页存储管理、分段存储管理、段页式存储管理三种方式。</p><h2 id="分页存储管理"><a href="#分页存储管理" class="headerlink" title="分页存储管理"></a>分页存储管理</h2><p>在分页存储管理方式中，把用户程序的地址空间划分为若干个固定大小的页。典型的页面大小为 <code>1KB</code>。相应地，也将内存空闲分为若干个物理块，页和块大小相同，这样可以将用户程序的任一页放入任一物理快中实现非连续分配。</p><p>分页地址中的地址结构为：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628983ec51?w=561&h=149&f=png&s=5286" width="40%"></p><p>地址长度为 <code>32</code> 位，其中 <code>0~11</code> 位为页内地址，即每页的大小为 <code>4KB</code>；<code>12~31</code> 位为页号，最多允许有 <code>1M</code> 页。</p><p>系统为每一个进程建立了一张页表，它负责逻辑页号到物理块号之间的地址转换。每一个页面对应一个页表项，记录了相应页在内存中对应的物理块号。</p><p>在 <code>CPU</code> 中设置一个页表基址寄存器，存储着页表的起始地址和页表的长度。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628b5610bf?w=810&h=426&f=png&s=20679" width="60%"></p><p>在进行地址转换时，首先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问地址已超过进程的地址空间，产生越界中断。如果没有发生越界中断，则将页表始址与页号和页表项长度的乘积相加，得到该页表项在页表中的位置，于是可从中得到该页的物理块号，最后根据物理块号和页内地址便可得到物理地址。</p><p>分页式存储管理方式主要有两个缺点：</p><ul><li>性能问题：访问一个内存单元需要两次内存访问，第一次访问获取页表项，第二次访问才访问数据。（快表）</li><li>如果每页太小，页表可能会非常大，较难找到连续的大内存空间。（多级页表）</li></ul><h2 id="页表改进"><a href="#页表改进" class="headerlink" title="页表改进"></a>页表改进</h2><p><strong>快表</strong></p><p>为提高地址转换速度，可在地址转换机构中增加一个可并行查询的缓冲寄存器，称为快表。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c36289e63a6f?w=934&h=601&f=png&s=33581" width="70%"></p><p>在进行地址转换时，首先将页号与快表中的所有页号进行比较，如果其中有与此相匹配的页号，便可直接从快表中读出该页所对应的物理块号。如果在快表中没有对应的页表项，则还需要去访问内存中的页表，在找到物理块号后，得到要访问的物理地址。另外，还要将此页表项存入到快表中。如果快表已满，则需要找到一个合适的页表项，将其换出。</p><p><strong>两级页表或多级页表</strong></p><p>两级页表或多级页表的方法，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。同样，建立一张外层页表，每个页表项中记录了页表层面的物理块号。</p><p>在进行地址变换时，需要增加一个外层页表寄存器，用于存放外层页表的起始地址。利用外层页表始址和逻辑地址中的外层页号找到指定页表分页的始址，再利用外层页内地址找到指定的页表项，从中得到该页在内存的物理块号，最终得到物理地址。访问一次内存单元一共需要 <code>3</code> 次内存访问。</p><h2 id="分段式存储管理"><a href="#分段式存储管理" class="headerlink" title="分段式存储管理"></a>分段式存储管理</h2><p>在分段式存储管理方式中，进程的地址空间被划分为若干个段，例如主代码段、子模块代码段、堆栈段、初始化数据段、符号表等。每个段都从 <code>0</code> 开始编址，采用连续的地址空间，各段的长度也并不相等。</p><p>分段地址中的地址结构如下：</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c3628abeddf3?w=561&h=151&f=png&s=4715" width="50%"></p><p>该地址结构中，允许一个进程最多有 <code>64K</code> 个段，每个段的最大长度为 <code>64KB</code>。</p><p>系统为每个进程建立了一张段表，用于实现从逻辑段到物理内存区的映射。每个段在表中占有一个表项，其中记录了该段在内存中的基址和段的长度。</p><p>系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址转换时，首先将段号与段表长度进行比较。如果段号大于段表长度，则访问越界。</p><p>如果没有越界，则根据段表的始址和该段的段号，得到该段对应段表项的位置，从中读出该段在内存的起始地址。再检查段内地址是否超过该段的段长。如果超过，同样产生越界中断；否则将该段的基址和段内地址相加，最后得到要访问的内存地址。</p><h2 id="分页式和分段式比较"><a href="#分页式和分段式比较" class="headerlink" title="分页式和分段式比较"></a>分页式和分段式比较</h2><ul><li>采用分页存储是为了提高内存的利用率；采用分段是为了更好地满足用户的需要。</li><li>分页存储中，页面的大小由系统决定，而且大小固定；分段存储中，段的长度由用户程序决定。</li><li>分页存储中，页表中主要存储物理块号；分段存储中，段表中主要存储段基址和段长。</li></ul><h2 id="段页式存储管理"><a href="#段页式存储管理" class="headerlink" title="段页式存储管理"></a>段页式存储管理</h2><p>段页式存储是分段和分页的结合，先将用户程序分为若干个段，再把每个段分成若干个页。段页式的地址结构为段号、段内页号和页内地址三部分。</p><p>为实现地址转换，系统中需要同时设置段表和页表。不过这里的段表中存储的是页表始址和段长。</p><p><img src="https://user-gold-cdn.xitu.io/2019/1/11/1683c2eba0bb6bb7?w=886&h=525&f=png&s=30075" width="60%"></p><p>在进行地址转换时，首先将段号与段长进行比较，如果段号小于段长表示未越界，于是利用段表始址和段号求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号来获得对应页的页表项位置，从中读出该页所在的物理块号，再利用块号和页内地址来得到物理地址。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;连续内存分配&quot;&gt;&lt;a href=&quot;#连续内存分配&quot; class=&quot;headerlink&quot; title=&quot;连续内存分配&quot;&gt;&lt;/a&gt;连续内存分配&lt;/h1&gt;&lt;p&gt;在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。&lt;/p&gt;
&lt;p&gt;动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(4)--死锁</title>
    <link href="https://blog.timberliu.com/2019/01/10/009_%E6%AD%BB%E9%94%81/"/>
    <id>https://blog.timberliu.com/2019/01/10/009_死锁/</id>
    <published>2019-01-09T16:00:00.000Z</published>
    <updated>2019-01-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="死锁概念"><a href="#死锁概念" class="headerlink" title="死锁概念"></a>死锁概念</h1><p>在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。</p><p>死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。</p><p>出现死锁的四个必要条件：</p><ul><li>互斥。在任何时刻一个资源只能被一个进程使用。</li><li>拥有和请求。已经得到某个资源的进程可以再请求新的资源；</li><li>不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放；</li><li>循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。<a id="more"></a>  </li></ul><p>对于死锁，有四种处理的策略：1. 忽略；2. 预防死锁；3. 避免死锁；4. 检测死锁并恢复。</p><h1 id="死锁预防"><a href="#死锁预防" class="headerlink" title="死锁预防"></a>死锁预防</h1><p>预防是指通过破坏死锁产生的四个必要条件的一个或多个，以避免发生死锁。</p><ul><li>破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源；</li><li>破坏拥有和请求：有两种方案：<ul><li>已拥有资源的进程不能再去请求其他资源。一种实现方法是要求进程在开始执行前请求需要的所有资源。</li><li>要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源。</li></ul></li><li>破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占；</li><li>破坏循环等待：有两种方案：<ul><li>一种方法是保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源；</li><li>另一种方法是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源。</li></ul></li></ul><h1 id="死锁避免"><a href="#死锁避免" class="headerlink" title="死锁避免"></a>死锁避免</h1><p>死锁避免是利用一些事先已知的信息，在分配资源时判断是否会出现死锁，如果不会出现死锁才会分配资源。</p><p>而判断是否会出现死锁就是看是否能找到一个安全序列，系统能按照这个安全序列，也就是进程的推进顺序为每个进程分配其所需资源，直到满足每个进程所需的资源，使每个进程都能顺序执行。</p><h2 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h2><p>为实现银行家算法，进程在进入系统时，要求进程声明需要资源的最大数目，但不能超过系统能提供的最大资源数目。当一个进程请求资源时，需要确定是否有足够资源分配给该进程，如果有，再检查在分配资源后，系统是否安全。</p><p>假定线程数量为 <code>n</code>，资源类型数量为 <code>m</code>，银行家算法的数据结构如下：</p><ul><li><code>Max</code> (总需求量)：<code>n*m</code> 矩阵，表示进程 <code>Ti</code> 最多请求 <code>Max[i, j]</code> 个类型为 <code>Rj</code> 的资源；</li><li><code>Available</code> (剩余空闲量)：长度为 <code>m</code> 的向量，表示当前有 <code>Available[i]</code> 个类型 <code>Rj</code> 的可用资源；</li><li><code>Allocation</code> (已分配量)：<code>n*m</code> 矩阵，表示进程 <code>Ti</code> 当前分配了 <code>Allocation[i, j]</code> 个类型为 <code>Rj</code> 的资源；</li><li><code>Need</code> (未来需要量)：<code>n*m</code> 矩阵，表示进程 <code>Ti</code> 未来需要 <code>Need[i, j]</code> 个类型为 <code>Rj</code> 资源；</li></ul><p>可以得出它们满足等式：<code>Need[i, j] = Max[i, j] - Allocation[i, j]</code>。</p><p>银行家算法的核心部分，安全状态的判断如下：</p><ol><li>创建长度为 <code>m</code> 的向量 <code>Work</code>，表示当前资源剩余量，并进行初始化：<code>Work = Avaiable;</code></li><li>在未运行的进程中寻找未来需要量 <code>Need[i]</code> 比当前可用量 <code>Work</code> 小的进程 <code>Ti</code>，如果找到则继续执行 <code>3</code>，否则转 <code>4</code>；</li><li>执行 <code>Work = Work + Allocation[j];</code> ，将资源分配给进程 <code>Ti</code> 运行完毕后，回收其资源。转 <code>2</code>：</li><li>如果资源可以分配给所有进程，则系统处于安全状态；</li></ol><p>如此完整的银行家算法如下：首先进行初始化，<code>Request_i</code> 表示进程 <code>Ti</code> 的资源请求向量，<code>Request_i[j]</code> 表示进程 <code>Ti</code> 请求资源 <code>Rj</code> 的实例。然后循环判断：</p><ol><li>如果 <code>Request_i &lt;= Need[i]</code>，转到 <code>2</code>。否则拒绝资源请求，因为进程已经超过最大要求；</li><li>如果 <code>Request_i &lt;= Available</code>，转到 <code>3</code>。否则进程 <code>Ti</code> 必须等待，因为现在可用资源不足；</li><li>通过安全状态判断来确定是否分配资源给 <code>Ti</code>，如果安全则分配，否则拒绝 <code>Ti</code> 的资源请求。</li></ol><h1 id="死锁检测和恢复"><a href="#死锁检测和恢复" class="headerlink" title="死锁检测和恢复"></a>死锁检测和恢复</h1><p>可以允许系统进入死锁状态，但会维护一个系统的资源分配图，定期调用死锁检测算法来检测途中是否存在死锁，检测到死锁发生后，采取死锁恢复算法进行恢复。</p><p>死锁检测方法如下：</p><ul><li>在资源分配图中，找到不会阻塞又不独立的进程结点，使该进程获得其所需资源并运行，运行完毕后，再释放其所占有的全部资源。也就是消去该进程结点的请求边和分配边。</li><li>使用上面的算法进行一系列简化，若能消去所有边，则表示不会出现死锁，否则会出现死锁。</li></ul><p>在检测死锁时，可以采用两种方法：</p><ul><li>抢占资源。从一个或多个进程中抢占资源分配给死锁进程。</li><li>终止进程。可以终止所有的死锁进程；也可以按照某种顺序，逐个终止进程，释放其占有资源，直到死锁解除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;死锁概念&quot;&gt;&lt;a href=&quot;#死锁概念&quot; class=&quot;headerlink&quot; title=&quot;死锁概念&quot;&gt;&lt;/a&gt;死锁概念&lt;/h1&gt;&lt;p&gt;在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。&lt;/p&gt;
&lt;p&gt;死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。&lt;/p&gt;
&lt;p&gt;出现死锁的四个必要条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥。在任何时刻一个资源只能被一个进程使用。&lt;/li&gt;
&lt;li&gt;拥有和请求。已经得到某个资源的进程可以再请求新的资源；&lt;/li&gt;
&lt;li&gt;不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放；&lt;/li&gt;
&lt;li&gt;循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(3)--进程的同步和通信方式</title>
    <link href="https://blog.timberliu.com/2019/01/08/008_%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1/"/>
    <id>https://blog.timberliu.com/2019/01/08/008_进程的同步与通信/</id>
    <published>2019-01-07T16:00:00.000Z</published>
    <updated>2019-01-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程间同步"><a href="#进程间同步" class="headerlink" title="进程间同步"></a>进程间同步</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。</p><p>对于同步机制，需要遵循以下四个规则：</p><ul><li>空闲则入：没有进程在临界区时，任何进程可以进入；</li><li>忙则等待：有进程在临界区时，其他进程均不能进入临界区；</li><li>有限等待：等待进入临界区的进程不能无限期等待；</li><li>让权等待（可选）：不能进入临界区的进程，应该释放 <code>CPU</code>，如转换到阻塞态；<a id="more"></a>  </li></ul><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量机制（<code>semaphore</code>）是一种协调共享资源访问的方法。信号量由一个变量 <code>semaphore</code> 和两个原子操作组成，信号量只能通过 <code>P</code> 和 <code>V</code> 操作来完成，而且 <code>P</code><br>和 <code>V</code> 操作都是原子操作。</p><p>将信号量表示如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    int value;</span><br><span class="line">    struct process_control_block *list;</span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure><p>相应的 <code>P(wait)</code> 操作和 <code>V(signal)</code> 操作如下实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value &lt; 0) &#123;</span><br><span class="line">        block(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">signal(semaphore *S) &#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    if(S-&gt;value &lt;= 0) &#123;</span><br><span class="line">        wakeup(S-&gt;list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>信号量可分为两类：互斥信号量，信号量大小为为 <code>0</code> 或 <code>1</code>，用来实现进程的互斥访问；资源信号量，信号量大小为资源数，用来表示系统资源数目。</p><p><strong>资源信号量</strong></p><p>代表资源信号量时，<code>S-&gt;value</code> 初值表示系统资源的数目，<code>P</code> 操作意味着进程请求一个资源，于是系统中可分配的资源数减一，如果 <code>S-&gt;value &lt; 0</code>，表示该类资源已分配完毕，因此阻塞该进程，并插入信号量链表 <code>S-&gt;list</code> 中。小于 <code>0</code> 时，<code>S-&gt;value</code> 的绝对值表示该信号量链表中阻塞的进程数。</p><p><code>V</code> 操作表示进程释放一个资源，于是系统中可分配的资源数加一，如果增加一后仍然 <code>S-&gt;value &lt;= 0</code>，表示该信号量链表中仍然有阻塞的进程，因此调用 <code>wakeup</code>，将 <code>S-&gt;list</code> 中的第一个进程唤醒。</p><p><strong>互斥信号量</strong></p><p>代表互斥信号量时，<code>S-&gt;value</code> 初值为 <code>1</code>，表示只允许一个进程访问该资源。</p><p>利用信号量实现两个进程互斥描述如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = 1;</span><br><span class="line">P() &#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    临界区；</span><br><span class="line">    signal(mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>mutex = 1</code> 时，表示两个进程都没有进入临界区，当 <code>mutex = 0</code> 时，表示一个进程进入临界区运行；当 <code>mutex = -1</code> 时，表示一个进程进入临界区运行，另一个进程被阻塞在信号量队列中。</p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p>管程采用面向对象思想，将表示共享资源的数据结构及相关的操作，包括同步机制，都集中并封装到一起。所有进程都只能通过管程间接访问临界资源，而管程只允许一个进程进入并执行操作，从而实现进程互斥。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor_name &#123;</span><br><span class="line">    share variable declarations;</span><br><span class="line">    condition declarations;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    void P1(···) &#123;</span><br><span class="line">        ···</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">        initialization code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>管程中设置了多个条件变量，表示多个进程被阻塞或挂起的条件，条件变量的形式为 <code>condition x, y;</code>，它也是一种抽象数据类型，每个变量保存了一条链表，记录因该条件而阻塞的进程，与条件变量相关的两个操作：<code>condition.cwait</code> 和 <code>condition.csignal</code>。</p><ul><li><code>condition.cwait</code>：正在调用管程的进程因 <code>condition</code> 条件需要被阻塞，则调用 <code>condition.cwait</code> 将自己插入到 <code>condition</code> 的等待队列中，并释放管程。此时其他进程可以使用该管程。</li><li><code>condition.csignal</code>：正在调用管程的进程发现 <code>condition</code> 条件发生变化，则调用 <code>condition.csignal</code> 唤醒一个因 <code>condition</code> 条件而阻塞的进程。如果没有阻塞的进程，则不产生任何结果。</li></ul><h1 id="经典同步问题"><a href="#经典同步问题" class="headerlink" title="经典同步问题"></a>经典同步问题</h1><h2 id="生产者-消费者问题"><a href="#生产者-消费者问题" class="headerlink" title="生产者-消费者问题"></a>生产者-消费者问题</h2><p>生产者-消费者问题描述的是：生产者和消费者两个线程共享一个公共的固定大小的缓冲区，生产者在生成产品后将产品放入缓冲区；而消费者从缓冲区取出产品进行处理。</p><p>它需要保证以下三个问题：</p><ul><li>在任何时刻只能有一个生产者或消费者访问缓冲区（互斥访问）；</li><li>当缓冲区已满时，生产者不能再放入数据，必须等待消费者取出一个数据（条件同步）；</li><li>而当缓冲区为空时，消费者不能读数据，必须等待生产者放入一个数据（条件同步）。</li></ul><p><strong>利用信号量解决</strong></p><p>用信号量解决生产者-消费者问题，使用了三个信号量：</p><ul><li>互斥信号量 <code>mutex</code>：用来保证生产者和消费者对缓冲区的互斥访问；</li><li>资源信号量 <code>full</code>：记录已填充的缓冲槽数目；</li><li>资源信号量 <code>empty</code>：记录空的缓冲槽数目。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#define N 10</span><br><span class="line">int in = 0, out = 0;</span><br><span class="line">item buffer[N];</span><br><span class="line">semaphere mutex = 1, full = 0, empty = N;</span><br><span class="line"></span><br><span class="line">void producer(void) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        item nextp = produce_item();</span><br><span class="line">        wait(empty);          </span><br><span class="line">        wait(mutex);                 </span><br><span class="line">        buffer[in] = nextp;</span><br><span class="line">        in = (in + 1) % N;</span><br><span class="line">        signal(mutex);              </span><br><span class="line">        signal(full);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer(void) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(full);</span><br><span class="line">        wait(mutex);</span><br><span class="line">        item nextc = buffer[out];</span><br><span class="line">        out = (out + 1) % N;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);</span><br><span class="line">        consume_item(nextc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是进程中的多个 <code>wait</code> 操作顺序不能颠倒，否则可能造成死锁。例如在生产者中，当系统中没有空的缓冲槽时，生产者进程的 <code>wait(mutex)</code> 获取了缓冲区的访问权，但 <code>wait(empty)</code> 会阻塞，这样消费者也无法执行。</p><p><strong>利用管程解决</strong></p><p>利用管程解决时，需要为它们建立一个管程，其中 <code>count</code> 表示缓冲区中已有的产品数目，条件变量 <code>full</code> 和 <code>empty</code> 有 <code>cwait</code> 和 <code>csignal</code> 两个操作，另外还包括两个过程：</p><ul><li><code>put(x)</code>：生产者将自己生产的产品放入到缓冲区中，而如果 <code>count &gt;= N</code>，表示缓冲区已满，生产者需要等待；</li><li><code>get(x)</code>：消费者从缓冲区中取出一个产品，如果 <code>count &lt;= 0</code>，表示缓冲区为空，消费者应该等待；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Monitor producerconsumer &#123;</span><br><span class="line">    item buffer[N];</span><br><span class="line">    int in, out;</span><br><span class="line">    condition full, emtpy;</span><br><span class="line">    int count;</span><br><span class="line">    </span><br><span class="line">    public:</span><br><span class="line">    void put(item x) &#123;</span><br><span class="line">        if(count &gt;= N) &#123; </span><br><span class="line">            cwait(full);</span><br><span class="line">        &#125;</span><br><span class="line">        buffer[in] = x;</span><br><span class="line">        in = (in + 1) % N;</span><br><span class="line">        count++;</span><br><span class="line">        csignal(emtpy);</span><br><span class="line">    &#125;</span><br><span class="line">    item get() &#123;</span><br><span class="line">        if(count &lt;= 0) &#123;</span><br><span class="line">            cwait(emtpy);</span><br><span class="line">        &#125;</span><br><span class="line">        x = buffer[out];</span><br><span class="line">        out = (out + 1) % N;</span><br><span class="line">        count--;</span><br><span class="line">        csignal(full);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#123; in = 0; out = 0; count = 0; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是生产者和消费者可描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">void producer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        item nextp = produce_item();</span><br><span class="line">        producerconsumer.put(nextp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void consumer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        item nextc = producerconsumer.get();</span><br><span class="line">        consume_item(nextc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>哲学家就餐问题描述的是：有五个哲学家共用一个圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们交替地进行思考和进餐。哲学家在平时进行思考，在饥饿时试图获取左右两只筷子，拿到两只筷子才能进餐，进餐完后放下筷子继续思考。</p><p>为实现筷子的互斥使用，可以用一个信号量表示一只筷子，五个信号量构成信号量数组，也都被初始化为 <code>1</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;</span><br></pre></td></tr></table></figure><p>第 <code>i</code> 位哲学家的活动可描述为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void philosopher(int i) &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">        wait(chopstick[(i + 1) % 5]);</span><br><span class="line">        // eat</span><br><span class="line">        signal(chopstick[i]);</span><br><span class="line">        signal(chopstick[(i + 1) % 5]);</span><br><span class="line">        // think</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述解法中，如果五位哲学家同时饥饿而都拿起左边的筷子，再试图去拿右边的筷子时，会出现无限期等待而引起死锁。</p><h2 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h2><p>读者-写者问题描绘的是：一个文件可以被多个进程共享，允许多个 <code>Reader</code> 进程同时读这个文件，但不允许 <code>Wirter</code> 进程和其他 <code>Reader</code> 进程或 <code>Writer</code> 进程同时访问这个文件。所以读者-写者需要保证一个 <code>Writer</code> 进程必须与其他进程互斥地访问共享对象。</p><p>解决这个问题需要设置两个互斥信号量和一个整形变量：</p><ul><li>互斥信号量 <code>wmutext</code>：实现 <code>Reader</code> 进程和 <code>Writer</code> 进程在读或写时的互斥；</li><li>整形变量 <code>readcount</code>：正在读的进程数目；</li><li>互斥信号量 <code>rmutext</code>：实现多个 <code>Reader</code> 进程对 <code>readcount</code> 变量的互斥访问；</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex = 1, wmutex = 1;</span><br><span class="line">int readcount = 0;</span><br><span class="line"></span><br><span class="line">void Reader() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        if(readcount == 0) &#123;</span><br><span class="line">            wait(wmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">        // perform read opertaion</span><br><span class="line">        wait(rmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        if(readcount == 0) &#123;</span><br><span class="line">            signal(wmutex);</span><br><span class="line">        &#125;</span><br><span class="line">        signal(rmutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">void Writer() &#123;</span><br><span class="line">    while(TRUE) &#123;</span><br><span class="line">        wait(wmutex);</span><br><span class="line">        // perform wirte opertaion</span><br><span class="line">        signal(wmutex);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要有一个 <code>Reader</code> 进程在读，便不允许 <code>Writer</code> 进程去写。所以，仅当 <code>readcount = 0</code>，表示没有 <code>Reader</code> 进程在读时，<code>Reader</code> 进程才需要执行 <code>wait(wmutex)</code> 操作，而 <code>readcount != 0</code> 时，表示有其他 <code>Reader</code> 进程在读，也就肯定没有 <code>Writer</code> 在写。同理，仅当 <code>readcount = 0</code> 时，才执行 <code>signal(wmutex)</code> 类似。</p><h1 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h1><p>进程通信是指进程之间的信息交换。在进程间要传送大量数据时，应利用高级通信方法。</p><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>在共享内存系统中，多个通信的进程共享某些数据结构或存储区，进程之间能够通过这些空间进行通信。</p><p>可分为两种类型：</p><ul><li>基于共享数据结构的通信方式。多个进程共用某些数据结构，实现进程之间的信息交换，例如生产者-消费者问题中的缓冲区。这种方式仅适用于少量的数据，通信效率低下。</li><li>基于共享存储区的通信方式。在内存中分配一块共享存储区，多个进程可通过对该共享区域的读或写交换信息。通信的进程在通信前，需要先向系统申请共享存储区的一个分区，以便对其中的数据进行读写。</li></ul><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道（<code>Pipe</code>）是指用于连接一个读进程和一个写进程以实现进程间通信的一个共享文件。发送进程以字符形式将数据送入管道，而接收进程则从管道中接收数据。</p><p>管道机制提供了三方面的协调能力：</p><ul><li>互斥：当一个进程对管道执行读或写操作时，其他进程必须等待；</li><li>同步：当写进程把一定数量的数据写入管道，便睡眠等待，直到读进程取走数据后再把它唤醒；</li><li>确定对方是否存在，只有确定对方存在才能通信。</li></ul><h2 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h2><p>消息传递机制中，进程以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的原语，在进程之间进行消息传递，完成进程间数据交换。</p><p>按照实现方式，可分为两类：</p><ul><li>直接通信方式：发送进程利用操作系统提供的发送原语，直接把消息发送给进程，接收进程则利用接收原语来接收消息；</li><li>间接通信方式：发送和接收进程，通过共享中间实体方式进行消息的发送和接收，完成进程间的通信。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程间同步&quot;&gt;&lt;a href=&quot;#进程间同步&quot; class=&quot;headerlink&quot; title=&quot;进程间同步&quot;&gt;&lt;/a&gt;进程间同步&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。&lt;/p&gt;
&lt;p&gt;对于同步机制，需要遵循以下四个规则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空闲则入：没有进程在临界区时，任何进程可以进入；&lt;/li&gt;
&lt;li&gt;忙则等待：有进程在临界区时，其他进程均不能进入临界区；&lt;/li&gt;
&lt;li&gt;有限等待：等待进入临界区的进程不能无限期等待；&lt;/li&gt;
&lt;li&gt;让权等待（可选）：不能进入临界区的进程，应该释放 &lt;code&gt;CPU&lt;/code&gt;，如转换到阻塞态；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(2)--进程和线程</title>
    <link href="https://blog.timberliu.com/2019/01/07/007_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.timberliu.com/2019/01/07/007_进程和线程/</id>
    <published>2019-01-06T16:00:00.000Z</published>
    <updated>2019-01-06T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>进程（<code>process</code>）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 <code>OS</code> 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。</p><p>在某一瞬间，一个 <code>CPU</code> 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。<br><a id="more"></a><br>进程和程序间的联系和区别如下：</p><ul><li>程序是一段静态的代码；进程是一个动态运行的过程；</li><li>程序是产生进程的基础；进程是程序功能的体现；</li><li>程序的每次执行都构成了不同的进程，通过多次运行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序；</li></ul><h2 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h2><p>为了实现进程，操作系统维护了一张进程表（结构数组），每个进程占用一个进程表项（进程控制块 <code>PCB</code>），它是进程存在的唯一标志。该表项包含了进程状态的重要信息，包括进程标识符、状态、优先级、程序计数器、堆栈指针、寄存器等；</p><p>对进程的管理就是对通过 <code>PCB</code> 的组织管理来实现的。由于保存了在进程的状态变化时的必要信息，在中断一个正在执行的进程，并在后来恢复时，就好像进程从未中断过。它是支持多进程和提供多处理的关键。</p><h2 id="进程的状态及转换"><a href="#进程的状态及转换" class="headerlink" title="进程的状态及转换"></a>进程的状态及转换</h2><p>如下图是进程的三种状态的状态图。一个进程的三种状态是：</p><ul><li>运行态：进程正在占用 <code>CPU</code> 执行；</li><li>就绪态：进程处于准备运行状态，已经获得除 <code>CPU</code> 外的所有资源；</li><li>阻塞态：进程由于等待某种外部事件而暂停运行，即使获得 <code>CPU</code>，也不能运行。</li></ul><p><img src="https://note.youdao.com/yws/public/resource/9bce5a7b445fc99c2cd7358f25bd4c1d/xmlnote/CE2E283B6F144294859EA68C058832B2/75804" width="60%"></p><p>进程之间主要有四种转换关系：</p><ul><li>由运行态转换为就绪态：在时间片用完后，不得不让出 <code>CPU</code>；</li><li>由就绪态转换为运行态：进程被调度，获得处理机资源；</li><li>由阻塞态转换为就绪态：进程的 <code>I/O</code> 请求完成；</li><li>由运行态转换为阻塞态：进程发出 <code>I/O</code> 请求；</li></ul><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>线程（<code>thread</code>）是进程中的一条执行流程。在引入线程的操作系统中，进程是拥有资源的基本单位；而线程是 <code>CPU</code> 调度和分派的基本单位。</p><p>一个进程中可以有多个线程，多个线程可以并发执行，它们之间共享相同的地址空间。但如果一个线程崩溃，可能会导致其所属进程的所有线程崩溃。</p><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li>调度性：传统 OS 中，进程是调度和分派的基本单位，但在引入线程后，线程是调度和分派的基本单位；</li><li>并发性：在引入线程后，多个进程可以并发执行，一个进程中的多个线程也可以并发执行；</li><li>拥有资源：进程是拥有资源的基本单位，而线程本身并不拥有资源；</li><li>系统开销：进程切换付出的系统开销明显大于线程；</li></ul><h2 id="线程实现的三种方式"><a href="#线程实现的三种方式" class="headerlink" title="线程实现的三种方式"></a>线程实现的三种方式</h2><p>有三种线程的实现方式：</p><ul><li>用户线程：用户空间实现，由用户线程库管理；</li><li>内核线程：内核中实现，由操作系统管理；</li><li>轻量级进程：内核中实现，支持用户线程；</li></ul><p><strong>用户线程</strong></p><p>用户线程是把整个线程包放在用户空间中，不依赖于操作系统的内核，所以它可以在不支持线程的操作系统上实现。可以用一组用户级的线程函数库来实现线程。</p><p><img src="https://note.youdao.com/yws/public/resource/9bce5a7b445fc99c2cd7358f25bd4c1d/xmlnote/2CD68ECA7B1C401FABAE9CD82860590C/70250" width="60%"></p><p>每个进程都需要私有的线程表，用来跟踪记录该进程中线程的状态信息，不过仅记录每个线程的程序计数器、堆栈指针、寄存器和状态等，该线程表由运行时系统管理。而且用户线程的切换由线程库函数来完成，不需要用户态、核心态切换，所以线程调度速度特别快。另外，也允许每个进程都拥有自定义的线程调度算法。</p><p>但如果一个线程发起系统调用而阻塞，尽管其他线程可以运行，但整个进程都会阻塞。当一个线程开始运行后，除非它主动较交出 <code>CPU</code>，否则它所在的进程中的其他线程将无法运行。</p><p><strong>内核线程</strong></p><p>内核线程在操作系统的内核中实现，由内核来完成对线程的创建、终止和管理。</p><p><img src="https://note.youdao.com/yws/public/resource/9bce5a7b445fc99c2cd7358f25bd4c1d/xmlnote/C9CBECFDE0E84441B4714E85049A20A7/70252" width="60%"></p><p>由于线程的创建、终止和切换通过系统调用执行，由内核完成的，其系统开销比较大；</p><p>但在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他使用内核线程的运行；</p><p><strong>轻量级进程</strong></p><p>轻量级进程是内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。而轻量级进程内部可以对应多个用户线程。</p><h1 id="CPU-调度"><a href="#CPU-调度" class="headerlink" title="CPU 调度"></a>CPU 调度</h1><h2 id="调度概念"><a href="#调度概念" class="headerlink" title="调度概念"></a>调度概念</h2><p>处理机调度是当有多个进程（线程）竞争 <code>CPU</code> 时，调度程序需要从从就绪队列中挑选下一个占用 <code>CPU</code> 运行的进程。</p><p>调度算法是为了解决通过什么样的准则来挑选就绪对列中的哪一个进程来执行。在每次调度时需要决定在下一个 <code>CPU</code> 计算时将哪个进程交给 <code>CPU</code>。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><p><strong>先来先服务算法FCFS</strong></p><p>根据进程进入就绪态的先后顺序排列。当进程进入阻塞态或结束时，就绪队列中的下一个进程占用 <code>CPU</code>。</p><p>实现简单，但可能短进程排在长进程后面，导致平均等待时间波动较大。</p><p><strong>短进程优先算法SJF</strong></p><p>选择就绪队列中执行时间最短的进程占用 <code>CPU</code> 运行。</p><ul><li>可抢占系统改进：短剩余时间优先算法，即选择剩余运行时间最短的进程运行。</li></ul><p>短进程优先算法有最优的平均周转时间，但连续的短进程可能会使长进程无法获得 <code>CPU</code> 资源，导致饥饿；运行时间不可预估，并不可靠。</p><p><strong>最高响应比优先算法HRN</strong></p><p>选择就绪队列中响应比最高的进程。它是基于短进程优先算法的改进，它不允许抢占，另外等待时间越长，响应比越高，可以避免长时间地等待。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">R = (w+s)/s     // 其中 w 为等待时间，s 为执行时间。</span><br></pre></td></tr></table></figure><p><strong>时间片轮转算法RR</strong></p><p>按时间片分配给进程运行。在轮转中，每个进程分到执行 <code>1/n</code> 的时间，时间片结束时，按先来先服务算法切换到下一个就绪进程，每隔 <code>n-1</code> 个时间片进程会再次执行。</p><p>如果时间片过大，进程等待时间过长，极限情况下会退化为先来先服务算法；如果时间片过小，虽然反应迅速，但上下文切换开销较大，会影响系统吞吐量。</p><p><strong>多级反馈队列算法</strong></p><p>就绪队列被划分为多个独立的子队列，而且每个队列可以有自己的调度策略，在队列之间可以设置优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短。</p><p>在执行时，进程在不同队列间移动，如果进程在当前优先级的时间片下没有完成，则下降到低一优先级的队列，以此类推。只有当一个队列为空时才会去执行下一个队列中的进程。</p><p>这种算法对于 <code>CPU</code> 密集型进程的优先级下降很快，而 <code>I/O</code> 密集型进程停留在高优先级。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;进程（&lt;code&gt;process&lt;/code&gt;）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 &lt;code&gt;OS&lt;/code&gt; 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。&lt;/p&gt;
&lt;p&gt;在某一瞬间，一个 &lt;code&gt;CPU&lt;/code&gt; 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识回顾(1)--操作系统概述</title>
    <link href="https://blog.timberliu.com/2019/01/06/006_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0/"/>
    <id>https://blog.timberliu.com/2019/01/06/006_操作系统概述/</id>
    <published>2019-01-05T16:00:00.000Z</published>
    <updated>2019-01-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。</p></blockquote><p>参考学习：</p><ul><li>书籍：《现代操作系统》、《深入理解计算机系统》</li><li>视频：学堂在线 - <a href="https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about" target="_blank" rel="noopener">操作系统（自主模式）</a><a id="more"></a><h2 id="操作系统知识点"><a href="#操作系统知识点" class="headerlink" title="操作系统知识点"></a>操作系统知识点</h2></li></ul><p><img src="https://note.youdao.com/yws/public/resource/7d90079e62501fa244a7166b342cc723/xmlnote/D445C1EA0B1443518C811D4DDD4DD598/75546" width="80%"></p><ul><li>操作系统概述：<ul><li>操作系统的定义以及功能；</li><li>计算机系统体系结构；</li><li>操作系统的四个特性：并发、共享、虚拟、异步；</li><li>用户态和核心态的区别；</li></ul></li><li>进程和线程：<ul><li>进程的几种状态及其转换；</li><li>进程与线程的区别；</li><li>进程调度的算法；</li><li>进程同步的方式；</li><li>进程通信的方式；</li></ul></li><li>死锁：<ul><li>死锁的概念、导致死锁的原因；</li><li>导致死锁的四个必要条件；</li><li>处理死锁的四种方式：预防、避免、检测、解除；</li></ul></li><li>存储器：<ul><li>内存连续分配方式采用的算法及优缺点；</li><li>分页存储管理方式；</li><li>分段存储管理方式；</li><li>段页式存储管理方法；</li><li>几种存储方式的比较及各自优缺点；</li><li>从逻辑地址到物理地址的转换过程；</li></ul></li><li>虚拟存储器：<ul><li>虚拟存储器的定义与实现方式；</li><li>页面置换算法，计算所需换页数；</li></ul></li><li>文件系统：<ul><li>文件系统基本概念；</li><li>文件分配方式；</li></ul></li></ul><h1 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h1><p>计算机系统一般由一个或多个处理器、内存、<code>I/O</code> 设备等组成，而操作系统就是这些硬件之上的一种软件，它为应用程序提供了一个抽象，并管理这些计算机资源。具体可以从功能上来认识操作系统。</p><p>作为扩展机器，它隐藏硬件底层实现细节，对硬件提供抽象，方便程序或用户的使用：</p><ul><li>进程是对 <code>CPU</code>、主存及 <code>I/O</code> 设备的抽象；</li><li>虚拟内存（虚拟地址空间）是对主存和 <code>I/O</code> 设备的抽象；</li><li>文件是对 <code>I/O</code> 设备的抽象；</li></ul><p>作为资源管理器，它在多个竞争程序之间合理地控制对处理器、存储器及 <code>I/O</code> 设备的分配，避免资源使用冲突。有两种共享资源的方式：</p><ul><li>时间复用：不同程序或用户轮流使用；</li><li>空间复用：每个程序或用户得到资源的一部分；</li></ul><h1 id="内核态和用户态"><a href="#内核态和用户态" class="headerlink" title="内核态和用户态"></a>内核态和用户态</h1><p>如下图是一般计算机系统的简化图。多数计算机有两种运行模式：内核态和运行态。</p><p><img src="https://note.youdao.com/yws/public/resource/7d90079e62501fa244a7166b342cc723/xmlnote/425E7051004C4FD78C847BBB67477125/75565" width="60%"></p><p>操作系统运行在内核态，它对所有硬件具有访问权，可以执行任何指令。用户接口程序和其余软件运行在用户态，<br>它只能执行机器指令中的一个子集。</p><h1 id="四大特性"><a href="#四大特性" class="headerlink" title="四大特性"></a>四大特性</h1><p>操作系统主要有四大特性，分别为：</p><ul><li>并发：在宏观上有多个程序在同时运行，需要 <code>OS</code> 管理和调度，而在微观上是分时交替运行；<blockquote><p>注意并发和并行的区别：</p><ul><li>并发指的是在<strong>一段时间内</strong>有多个应用程序可以运行；</li><li>并行指的是在<strong>一个时间点</strong>有多个应用程序可以执行，并行需要计算机有多个 <code>CPU</code>；</li></ul></blockquote></li><li>共享：资源可以供内存中多个并发执行的进程共同使用，在宏观上是同时访问该资源，而在微观上是采用互斥共享。</li><li>虚拟：利用多道程序设计，让每个应用程序都觉得有一个计算机专门为它服务。</li><li>异步：程序的执行不是连贯的，而是间断性的，其速度也不可知，但只要运行环境相同，其运行结果需要保证相同。</li></ul><h1 id="计算机体系结构"><a href="#计算机体系结构" class="headerlink" title="计算机体系结构"></a>计算机体系结构</h1><p>计算机系统主要由处理器、主存、<code>I/O</code> 设备及系统总线组成。</p><p><strong>处理器</strong></p><p>也称中央处理单元（<code>CPU</code>），是用来解释或执行主存中的指令的引擎。在任何时候，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，指向下一条指令。</p><p><strong>主存</strong></p><p>主存，是一个临时存储设备，用来存放程序和程序要处理的数据。存储系统大多采用分层次的存储结构。如下图：</p><p><img src="https://note.youdao.com/yws/public/resource/7d90079e62501fa244a7166b342cc723/xmlnote/C1BFECBD70544A8C917FE9B1C41F2448/75693" width="60%"></p><p>存储层次最顶层是寄存器。下一层是两层高速缓存 <code>L1、L2</code>。再下一层是主存，所有不能再高速缓存行命中的访问请求会转到内存。如果内存中还没有，可能还会到虚拟内存中查找。</p><p>在层次结构中，较高层次的存储设备可以作为较低层次设备的高速缓存。更高层次的存储设备比底层的更快，但价格也更昂贵。</p><p><strong>I/O 设备</strong></p><p><code>I/O</code> 设备是系统与外界联系的通道。主要包括磁盘、显示器、键盘等。每个 <code>I/O</code> 设备都通过一个控制器或适配器与 <code>I/O</code> 总线相连，来传递信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考学习：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;书籍：《现代操作系统》、《深入理解计算机系统》&lt;/li&gt;
&lt;li&gt;视频：学堂在线 - &lt;a href=&quot;https://www.xuetangx.com/courses/course-v1:TsinghuaX+30240243X+sp/about&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;操作系统（自主模式）&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="操作系统" scheme="https://blog.timberliu.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://blog.timberliu.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 异常</title>
    <link href="https://blog.timberliu.com/2018/11/08/005_Java%E5%BC%82%E5%B8%B8/"/>
    <id>https://blog.timberliu.com/2018/11/08/005_Java异常/</id>
    <published>2018-11-07T16:00:00.000Z</published>
    <updated>2018-11-07T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-标准异常"><a href="#Java-标准异常" class="headerlink" title="Java 标准异常"></a>Java 标准异常</h1><p><code>Throwable</code> 是 <code>Java</code> 中最顶级的异常类，继承自 <code>Object</code>，实现了序列化接口，它有两个重要的子类：<code>Exception</code> 和 <code>Error</code>，二者都是 <code>Java</code> 异常处理的重要子类，它们之间的区别和联系如下：</p><ul><li><code>Error</code>：表示系统级的错误，是 <code>Java</code> 运行环境内部或硬件问题，一般与虚拟机相关，例如：栈溢出、内存溢出等。这种异常抛出后不能指望程序来进行处理。</li><li><code>Exception</code>：表示需要程序捕获并处理的异常，是由程序设计的不完善而出现的问题，包括运行时异常（<code>RuntimeException</code>）和其他异常，例如 <code>IOException</code> 等。<a id="more"></a></li></ul><p>异常体系图如下：</p><p><img src="http://media.timberliu.com/image/2019/1/29/Java%E5%BC%82%E5%B8%B8.png" width="80%"></p><h1 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h1><p><code>Java</code> 中的异常可分为两类：非受检异常（<code>Unchecked Exception</code>）和受检异常（<code>Checked Exception</code>）。</p><p>其中 <code>Error</code> 和 <code>RuntimeExcpetion</code> 表示属于非受检异常。这种异常不需要显式地捕获，也不需要在异常说明中声明，但是如果发生异常就会中断程序的执行。这种异常一般是由于代码原因导致的，例如空指针、数组越界、转型异常等。所以，只要代码没问题，这些异常就可以避免，也就不需要显式处理。</p><p>而其他的异常都属于受检异常。这种异常需要使用 <code>try-catch</code> 捕获处理或者在异常说明中进行声明，<br>如果一个方法调用了有受检异常抛出的方法那么就需要对该异常进行处理，否则编译就不能通过。例如 <code>IOException</code>、<code>SQLException</code>、<code>ClassNotFoundException</code> 等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 异常捕获</span></span><br><span class="line">        Class.forName(<span class="string">"timberliu.exception.User"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 异常说明中进行声明</span></span><br><span class="line"><span class="comment">// throws 用来声明方法可能抛出的所有异常</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>受检异常在 <code>IO</code> 操作中使用较多。例如 <code>FileNotFoundException</code>，它表示的是：告诉方法调用者，不保证这个寻找文件的操作一定成功，取决于外部因素，所以需要明确地对调用失败的情况进行特殊处理。</p><h1 id="异常的处理"><a href="#异常的处理" class="headerlink" title="异常的处理"></a>异常的处理</h1><p>在异常被捕获后，有两种处理方式：1. 自己进行处理；2. 向上抛出，交给调用者处理。具体处理时，如果不知道如何处理那就向上抛出；如果知道如何处理，那么有以下处理方式：</p><ul><li>打印记录日志</li><li>封装异常后重新抛出</li><li>返回失败通用对象 <code>Response.Failed()</code></li><li>更改程序结果后正常返回</li><li>忽略或 <code>e.printStackTrace()</code>，一般禁止这样使用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 明确抛出一个异常</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="comment">// 处理异常</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 关闭 IO、网络连接等资源</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将捕获的异常重新封装到一个新的异常里重新抛出，这称为异常链。大多用于将受检异常封装成非受检异常。另外，抛出的新异常必须包含原有异常，这样在处理程序时才可以通过 <code>getCause()</code> 和 <code>initCause()</code> 方法访问异常的根源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// 将 e 封装到新创建的异常里</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="意外情况"><a href="#意外情况" class="headerlink" title="意外情况"></a>意外情况</h1><p><strong style="color:#000000;font-size:16px">1.在 return 中使用 finally</strong></p><p>在 <code>try</code> 语句中有 <code>return</code> 语句时，<code>finally</code> 中的代码会在 <code>try</code> 或 <code>catch</code> 块中的 <code>return</code> 语句执行之后，返回之前执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"try"</span>);</span><br><span class="line">        <span class="keyword">return</span> i = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"before finally: "</span> + i);</span><br><span class="line">        i = <span class="number">3</span>;</span><br><span class="line">        System.out.println(<span class="string">"after finally: "</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return: "</span> + test());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try</span></span><br><span class="line"><span class="comment">// before finally: 2</span></span><br><span class="line"><span class="comment">// after finally: 3</span></span><br><span class="line"><span class="comment">// return: 2</span></span><br></pre></td></tr></table></figure><p>可以看到，这里的执行顺序是先执行 <code>i = 2</code>；然后执行 <code>finally</code> 块中的语句；最后 <code>return</code>。但是在 <code>finally</code> 语句中修改 <code>a</code> 的值，对结果不会造成影响。</p><p>如果 <code>finally</code> 语句中也有 <code>return</code> 语句，还会覆盖 <code>try</code> 或 <code>catch</code> 中的 <code>return</code> 语句的返回结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i = <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"return: "</span> + test());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// return 3</span></span><br></pre></td></tr></table></figure><p><strong style="color:#000000;font-size:16px">2.异常丢失</strong></p><p>如果在 <code>try/catch</code> 块中，执行 <code>System.exit(0);</code> 后，进程会被杀死，<code>finally</code> 中的代码就不会执行了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"try"</span>);</span><br><span class="line">        System.exit(<span class="number">0</span>);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try</span></span><br></pre></td></tr></table></figure><h1 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h1><ul><li><code>IndexOutOfBoundsException</code>：数组下标越界异常</li><li><code>ArrayStoreException</code>：向数组中存放与声明类型不兼容的对象异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal[] a = <span class="keyword">new</span> Dog[<span class="number">1</span>];</span><br><span class="line">a[<span class="number">0</span>] = <span class="keyword">new</span> Cat();</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.ArrayStoreException: timberliu.exception.Cat</span></span><br></pre></td></tr></table></figure><ul><li><code>ArithmeticException</code>：算术运算异常，例如除 <code>0</code> 运算</li><li><code>ClassCastException</code>：类型强制转换异常</li><li><code>DateTimeException</code>：时间运算异常</li><li><code>IllegalArgumentException</code>：非法参数异常</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal animal = <span class="keyword">new</span> Dog();</span><br><span class="line">Cat cat = (Cat)animal;</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.ClassCastException: timberliu.exception.Dog cannot be cast to timberliu.exception.Cat</span></span><br></pre></td></tr></table></figure><ul><li><code>NegativeArraySizeException</code>：创建一个大小为负数的数组错误</li><li><code>NullPointerException</code>：空指针异常</li><li><code>NumberFormatException</code>：数字格式异常，例如在字符串转换为数字时：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = Integer.parseInt(<span class="string">"abc"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.lang.NumberFormatException: For input string: "abc"</span></span><br></pre></td></tr></table></figure><ul><li><code>SecurityException</code>：安全异常</li><li><code>UnSupportedOperationException</code>：不支持的操作异常</li></ul><p>更多的异常可见官方的 <code>doc</code>：<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/RuntimeException.html" target="_blank" rel="noopener">RuntimeExcpetion（Java Platform SE 8）</a></p><h1 id="Java7-新特性"><a href="#Java7-新特性" class="headerlink" title="Java7 新特性"></a>Java7 新特性</h1><p><strong style="color:#000000;font-size:16px">try-with-resources</strong></p><p>在 <code>Java7</code> 之前，对于 <code>IO</code> 操作、网络连接等，用完之后必须在 <code>finally</code> 块中调用 <code>close</code> 方法进行关闭，否则可能会导致内存泄露等问题。而从 <code>Java7</code> 中，可以使用 <code>try-with-resources</code> 语句，不需要再显式地关闭资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"e:\\file.txt"</span>));) &#123;</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译一下，看它背后的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"e:\\file.txt"</span>));</span><br><span class="line">        Throwable var2 = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String line;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>((line = bufferedReader.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println(line);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var12) &#123;</span><br><span class="line">                var2 = var12;</span><br><span class="line">                <span class="keyword">throw</span> var12;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (bufferedReader != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        bufferedReader.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">                        var2.addSuppressed(var11);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bufferedReader.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var14) &#123;</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，编译器自动生成了关闭资源的操作。而且，以前在关闭资源时有可能也会抛出异常，在 <code>Java7</code> 中可以使用 <code>Throwable.addSuppressed</code> 方法来抑制可能抛出的异常，这也是 <code>Java7</code> 增加的方法。</p><p><strong style="color:#000000;font-size:16px">Multi-Catch Exceptions</strong></p><p>它表示 <code>catch</code> 语句能同时捕获多个异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BufferedReader bufferedReader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"e:\\file.txt"</span>));</span><br><span class="line">        String line = bufferedReader.readLine();</span><br><span class="line"></span><br><span class="line">        SimpleDateFormat format = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">        Date date = format.parse(line);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ParseException | IOException e) &#123;</span><br><span class="line">        <span class="comment">// handle exception</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以用同样的异常处理程序，来处理多个异常。</p><p><strong style="color:#000000;font-size:16px">Rethrowing Exceptions</strong></p><p>能够直接再次抛出已捕获的异常。注意：<code>throw new Exception(e)</code> 抛出的是重新包装之后的异常；而 <code>throw e</code> 抛出的是原始的异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"IOException"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// IOException</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-标准异常&quot;&gt;&lt;a href=&quot;#Java-标准异常&quot; class=&quot;headerlink&quot; title=&quot;Java 标准异常&quot;&gt;&lt;/a&gt;Java 标准异常&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Throwable&lt;/code&gt; 是 &lt;code&gt;Java&lt;/code&gt; 中最顶级的异常类，继承自 &lt;code&gt;Object&lt;/code&gt;，实现了序列化接口，它有两个重要的子类：&lt;code&gt;Exception&lt;/code&gt; 和 &lt;code&gt;Error&lt;/code&gt;，二者都是 &lt;code&gt;Java&lt;/code&gt; 异常处理的重要子类，它们之间的区别和联系如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Error&lt;/code&gt;：表示系统级的错误，是 &lt;code&gt;Java&lt;/code&gt; 运行环境内部或硬件问题，一般与虚拟机相关，例如：栈溢出、内存溢出等。这种异常抛出后不能指望程序来进行处理。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Exception&lt;/code&gt;：表示需要程序捕获并处理的异常，是由程序设计的不完善而出现的问题，包括运行时异常（&lt;code&gt;RuntimeException&lt;/code&gt;）和其他异常，例如 &lt;code&gt;IOException&lt;/code&gt; 等。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>接口与内部类</title>
    <link href="https://blog.timberliu.com/2018/11/06/004_%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>https://blog.timberliu.com/2018/11/06/004_接口与内部类/</id>
    <published>2018-11-05T16:00:00.000Z</published>
    <updated>2018-11-05T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><p>抽象方法指的是仅有声明而没有方法体的方法。使用 <code>abstract</code> 关键字进行声明：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>而包含一个或多个抽象方法的类，就叫抽象类，用 <code>abstract</code>关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。<br><a id="more"></a><br>抽象类的主要目的是代码重用。大多用于抽象相关 <code>Java</code> 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 <code>java.util.AbstractList</code>。</p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 <code>static</code> 和 <code>final</code> 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 <code>enum</code> 枚举类。</p><p>接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 <code>Cloneable</code>、<code>Serializable</code>，表示这个类可以克隆或者可以序列化。</p><p><code>Java</code> 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Study</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Play</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">Class Person &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Study</span>, <span class="title">Play</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"student doSomething"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"study"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"play"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Diner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sleeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口可以继承接口（支持多继承）</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Diner</span>, <span class="title">Sleeper</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类可以实现接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Undergraduate</span> <span class="keyword">implements</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"eat"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sleep"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">study</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="抽象类与接口比较"><a href="#抽象类与接口比较" class="headerlink" title="抽象类与接口比较"></a>抽象类与接口比较</h1><ul><li>一个类只能继承一个抽象类，但可以实现多个接口；</li><li>接口中的字段只能是 <code>static</code> 和 <code>final</code> 的，而抽象类的字段没有限制；</li><li>接口中的方法只能是 <code>public</code> 的，而抽象类的方法则没有限制。</li></ul><p>一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 <code>Java8</code> 开始也增加了默认方法，使得修改接口的成本也降低很多。</p><p>如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。</p><h1 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h1><p>在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。</p><p>所以从 <code>Java8</code> 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sized</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如，Java 8 中 List 接口的 sort 方法就是默认方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="inline-toc">1.</span><strong>可选方法</strong></p><p>默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。</p><p>例如，在 <code>Java8</code> 中，<code>Iterator</code> 接口为 <code>remove</code> 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 <code>Iterator</code> 接口的每一个类都声明一个空的 <code>remove</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnSupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><span id="inline-toc">2.</span><strong>行为的多继承</strong></p><p>默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Moveable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">moveHorizontally</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setX(getX() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getWidth</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setWidth</span><span class="params">(<span class="keyword">int</span> width)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">resizeWidth</span><span class="params">(<span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">        setWidth(getWidth() + distance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">Moveable</span>, <span class="title">Resizable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Change c = <span class="keyword">new</span> Change();</span><br><span class="line">        c.moveHorizontally(<span class="number">10</span>);</span><br><span class="line">        c.resizeWidth(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h1><p><code>Java</code> 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。</p><p><strong>第一条规则</strong></p><p>在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello form B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。</p><p><strong>第二条规则</strong></p><p>如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello form B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello form B</span></span><br></pre></td></tr></table></figure><p>在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。</p><p><strong>第三条规则</strong></p><p>如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello from B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">A</span>, <span class="title">B</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        A.<span class="keyword">super</span>.hello();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> C().hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello from A</span></span><br></pre></td></tr></table></figure><p>上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 <code>hello</code> 方法，并且在调用时，使用 <code>X.super.f()</code> 这种语法，显式地指定使用哪一个接口中的方法。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>从外部类对象的非静态方法之外的任意位置创建某个内部类的对象，那么必须指明这个对象的类型：<code>OuterClassName.InnerClassName</code>。而且当生成一个内部类对象时，内部类对象会拥有一个指向外部类对象的引用，也就拥有了外围类所有成员的访问权。</p><p>要想创建内部类对象，必须使用外部类的对象来创建，这需要使用 .new 语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.new Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在内部类中如果想要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer.f()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123; </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Outer <span class="title">outer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Outer.<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Outer.Inner inner = outer.new Inner();</span><br><span class="line">        inner.outer().f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Outer.f()</span></span><br></pre></td></tr></table></figure><p><strong style="color:#000000;font-size:16px">匿名内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"inner class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">inner</span><span class="params">(<span class="keyword">final</span> String str)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Inner() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"inner subclass: "</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">        Inner inner = outer.inner(<span class="string">"Inner"</span>);</span><br><span class="line">        inner.value();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// inner subclass: Inner</span></span><br></pre></td></tr></table></figure><p>上面就是一个匿名内部类的例子，表示创建一个继承自 Inner 的匿名类的对象。在匿名内部类中，一般使用默认的构造器来生成内部类。另外，如果在匿名内部类希望使用一个在外部定义的对象，那么必须将其声明为 final。</p><p>但是匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但两者不能兼备。它只能扩展一个类或者只实现一个接口。</p><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><p>接口一般用来实现多重继承，而生成遵循某个接口的对象可以使用工厂设计模式。一般在工厂对象上调用的是创建方法，而该工厂对象会生成接口的某个实现的对象。</p><p>工厂模式的实现在使用匿名内部类时会更加优雅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">getGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Checkers</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Checkers</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> moves = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MOVES = <span class="number">3</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Checkers move "</span> + moves);</span><br><span class="line">        <span class="keyword">return</span> ++moves != MOVES;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GameFactory factory = <span class="keyword">new</span> Factory() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Game <span class="title">getGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Checkers();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Games</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playGame</span><span class="params">(GameFactory factory)</span> </span>&#123;</span><br><span class="line">        Game g = factory.getGame();</span><br><span class="line">        <span class="keyword">while</span>(s.move()) ;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        playGame(Checkers.factory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Checkers move 0</span></span><br><span class="line"><span class="comment">// Checkers move 1</span></span><br><span class="line"><span class="comment">// Checkers move 2</span></span><br></pre></td></tr></table></figure><p>可以看到，在使用匿名内部类时，构造器都是 private 的，并且没有任何必须去创建一个额外的工厂类。另外，对于经常只需要单一的工厂对象，也被创建为 static。</p><h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><p>嵌套类，也就是静态内部类，要创建嵌套类对象，不需要外部类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"static inner class"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// static inner class</span></span><br></pre></td></tr></table></figure><p>与内部类相比，区别如下：</p><ul><li>创建内部类需要外部类的对象；嵌套类不需要外围类的对象</li><li>内部类不可以定义静态成员变量；嵌套类可以定义静态成员变量</li><li>内部类可以访问外部类的成员变量；嵌套类不可以访问非静态的外部类的成员变量</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;抽象类&quot;&gt;&lt;a href=&quot;#抽象类&quot; class=&quot;headerlink&quot; title=&quot;抽象类&quot;&gt;&lt;/a&gt;抽象类&lt;/h1&gt;&lt;p&gt;抽象方法指的是仅有声明而没有方法体的方法。使用 &lt;code&gt;abstract&lt;/code&gt; 关键字进行声明：&lt;br&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;abstract&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而包含一个或多个抽象方法的类，就叫抽象类，用 &lt;code&gt;abstract&lt;/code&gt;关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
