<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TimberLiu&#39;s Blog</title>
  
  <subtitle>Easy coding, easy life</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.timberliu.com/"/>
  <updated>2019-03-02T16:00:00.000Z</updated>
  <id>https://blog.timberliu.com/</id>
  
  <author>
    <name>TimberLiu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入分析 synchronized 关键字</title>
    <link href="https://blog.timberliu.com/2019/03/03/036_%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20synchronized%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://blog.timberliu.com/2019/03/03/036_深入分析 synchronized 实现原理/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-02T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="synchronized-概述"><a href="#synchronized-概述" class="headerlink" title="synchronized 概述"></a>synchronized 概述</h1><p><code>synchronized</code> 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。<a id="more"></a></p><ul><li>互斥性：同一时刻只允许一个线程持有某个对象锁，一次实现对共享资源的互斥访问。</li><li>可见性：确保在锁释放前，对共享变量做的修改，对随后获得该锁的另一个线程是可见的。 </li></ul><p><code>synchronized</code> 的获取和释放锁由 <code>JVM</code> 实现，用户不需要显示的获取和释放锁，非常方便。但是当线程尝试获取锁的时候，如果获取不到锁该线程会一直阻塞。</p><p>在早期版本中，<code>synchronized</code> 是一个重量级锁，效率低下。但从 <code>JDK1.6</code> 开始，从 <code>JVM</code> 层面对 <code>synchronized</code> 引入了各种锁优化技术，例如：自旋锁、适应性自旋锁、锁消除、锁粗化、轻量级锁和偏向锁等，大大减少了锁操作的开销。</p><h1 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h1><p>使用 <code>synchronized</code> 实现同步有同步方法块、同步方两种方式。</p><h2 id="同步方法块"><a href="#同步方法块" class="headerlink" title="同步方法块"></a>同步方法块</h2><p>作用于代码块时，括号中可以是指定的对象，也可以是 Class 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁的是指定的对象实例</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 锁定是指定的类对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span> <span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(Test.class) &#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="同步方法"><a href="#同步方法" class="headerlink" title="同步方法"></a>同步方法</h2><p>作用于方法时，锁的是当前的对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用于静态方法，锁的是类对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="原理基础"><a href="#原理基础" class="headerlink" title="原理基础"></a>原理基础</h1><p><strong>HotSpot 对象头</strong></p><p><code>HotSpot</code> 虚拟机的对象头分为两部分信息：</p><ul><li><code>Mark Word</code>：用于存放对象自身的运行时数据，如哈希码、<code>GC</code> 分代年龄、锁类型、锁标志位等信息，这部分数据在 <code>32</code> 位和 <code>64</code> 位虚拟机中分别为 <code>32</code> 和 <code>64 bit</code>。它是实现轻量级锁和偏向锁的关键。</li><li><code>Class Metadata Address</code>：用于存储指向方法区对象类型数据的指针，如果是数组，还会有一个额外的部分用于存放数组长度。</li></ul><p><code>Mark Word</code> 被设计为一个非固定的数据结构以便存储更多的信息，它会根据对象的状态复用自己的存储空间。例如，在 <code>32</code> 位的 <code>HotSpot</code> 虚拟机中,各种状态下对象的存储内容如下：</p><p><img src="http://media.timberliu.com/image/2019/3/3/ObjectHead.png" width="60%"></p><p><strong>Monitor</strong></p><p>每个 <code>Java</code> 对象都有一个 <code>Monitor</code> 对象与之关联，它被称为管程（监视器锁），前面的表格中，锁状态为重量级锁时，指针就指向 <code>Monitor</code> 对象的起始地址。当一个 <code>Monitor</code> 被某个线程持有后，便处于锁定状态。在 <code>HotSpot</code> 虚拟机的源码实现中，<code>ObjectMonitor</code> 对象相关属性有：</p><ul><li><code>_count</code>：计数器；</li><li><code>_owner</code>：指向持有 <code>ObjectMonitor</code> 对象的线程；</li><li><code>_WaitSet</code>：等待池；</li><li><code>_EntryList</code>：锁池；</li></ul><p>多个线程访问同步代码时，首先会进入 <code>_EntryList</code> 锁池中被阻塞，当线程获取到对象的 <code>Monitor</code> 后，就会把 <code>_owner</code> 指向当前线程，同时 <code>Monitor</code> 中的 <code>_count</code> 计数器加一。如果线程调用 <code>wait</code> 方法，<code>_owner</code> 就被恢复为 <code>null</code>，<code>_count</code> 计数器减一，同时该线程就会进入 <code>_WaitSet</code> 等待池中。</p><p>当线程执行完毕，将对应的变量复位，以便其他线程获取 Monitor 锁。</p><p><strong>四种状态</strong></p><p><code>synchronized</code> 有四种状态：无锁、偏向锁、轻量级锁和重量级锁。随着对锁的竞争逐渐激烈，锁的状态进行升级。</p><h1 id="synchronized-实现原理"><a href="#synchronized-实现原理" class="headerlink" title="synchronized 实现原理"></a>synchronized 实现原理</h1><h2 id="同步方法块-1"><a href="#同步方法块-1" class="headerlink" title="同步方法块"></a>同步方法块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// ···</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -c -v</code> 对 <code>SynchronizedTest.class</code> 进行反汇编：</p><p><img src="http://media.timberliu.com/image/2019/2/27/synchronized%20%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%9D%97.png" width="80%"></p><p>可以看到，在同步代码块的开始位置插入 <code>monitorenter</code> 指令，在结束位置插入 <code>monitorexit</code> 指令，而且必须保证每一个 <code>monitorenter</code> 都有一个 <code>monitorexit</code> 与之对应。</p><p><code>synchronized</code> 便是通过 <code>Monitor</code> 获取锁的。当线程执行到 <code>monitorenter</code> 指令时，将会尝试获取 <code>Monitor</code> 所有权。当计数器为 <code>0</code>，则成功获取；获取后将锁计数器置为 <code>1</code>。在执行 <code>monitorexit</code> 指令时，将锁计数器置为 <code>0</code>。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><h2 id="同步方法-1"><a href="#同步方法-1" class="headerlink" title="同步方法"></a>同步方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ···</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>javap -c -v</code> 对 <code>SynchronizedTest.class</code> 进行反汇编：</p><p><img src="http://media.timberliu.com/image/2019/2/27/synchronized%20%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95.png" width="80%"></p><p>可以看到，被同步的方法也仅是被翻译成普通的方法调用和返回指令。在 <code>JVM</code> 字节码层面并没有任何特别的指令来实现 <code>synchronized</code> 修饰的方法。</p><p>但是在 <code>Class</code> 文件的方法表中将方法的 <code>flags</code> 字段中的 <code>ACC_SYNCHRONIZED</code> 标志位置为 <code>1</code>，表示该方法是同步方法。在执行方法时，线程就会持有 <code>Monitor</code> 对象。</p><h1 id="底层优化"><a href="#底层优化" class="headerlink" title="底层优化"></a>底层优化</h1><p><code>JDK1.6</code> 对锁引入了大量的优化，如自旋锁、自适应自旋锁、锁消除、锁粗化、轻量级锁、偏向锁等技术来减少锁操作的开销。</p><h2 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h2><p>在实现同步互斥时，如果获取锁失败，就会使当前线程阻塞，但线程的挂起和恢复都需要在内核态和用户态之间转换，对系统的性能影响很大。许多情况下共享数据的锁定状态持续时间不会很长，切换线程不值得。</p><p>自旋锁就是让线程在请求共享数据的锁时执行一个忙循环（自旋），如果能够很快获得锁，就避免其进入阻塞状态。</p><p>自旋等待虽然避免了线程切换的开销，但它要求多处理器，而且要占用处理器时间。如果锁占用时间过长，那么反而会消耗更多的资源。因此，对自旋等待的时间必须进行限制，另外自旋的次数也不能过多，默认为 <code>10</code> 次，可使用 <code>-XX:PreBlockSpin</code> 参数修改。</p><p><code>JDK1.6</code> 中引入了自适应的自旋锁，它的自旋时间由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除是指虚拟机的即时编译器在运行时，如果代码要求同步，但检测发现不可能存在共享数据竞争时，那么就进行锁消除。</p><p>锁消除主要根据逃逸分析，如果判断在一段代码中，堆上的所有数据都不会逃逸出去，那就可以将它们认为是线程私有的，也就无须进行同步加锁。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁也是出现循环体中，那么即使没有数据竞争，频繁地加锁解锁也会导致不必须的性能消耗。</p><p>锁粗化指的就是如果虚拟机探测到这样的情况，那就将加锁同步的范围扩展（粗化）到整个操作序列的外部。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>偏向锁是在无竞争的情况下消除整个同步，也就是减少同一线程获取锁的代价。它的思想是这个锁会偏向于第一个获得它的线程，如果接下来该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p><p>当锁对象第一次被线程获取时，锁进入偏向模式，同时 Mard Word 的结构也变为偏向锁结构。锁标志位为“01”，同时使用 <code>CAS</code> 操作把获取到这个锁的线程的 <code>ID</code> 记录在对象的 <code>Mark Word</code> 中，如果 <code>CAS</code> 操作成功，这个线程以后每次进入这个锁相关的同步块时，都可以不用再进行任何同步操作。</p><p>不适用于锁竞争比较激烈的多线程场合。</p><p>当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态或者轻量级锁状态。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁是相对于使用操作系统互斥量实现的传统锁而言的。偏向锁运行在一个线程进入同步块时，如果有第二个线程加入锁竞争，则偏向锁就会升级为轻量级锁。它适用于线程交替执行的场景。</p><p>在代码进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机将先在当前线程的栈帧中建立一个名为锁记录（<code>Lock Record</code>）的空间，用于存储锁对象目前 <code>Mark Word</code> 的拷贝。如下图，左侧是一个线程的虚拟机栈，右侧是一个锁对象：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20CAS%20%E4%B9%8B%E5%89%8D%E5%A0%86%E6%A0%88%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81.png" width="60%"></p><p>然后，虚拟机将使用 <code>CAS</code> 操作尝试将对象的 <code>Mark Word</code> 更新为指向 <code>Lock Record</code> 的指针，并将 <code>Lock Record</code> 里的 <code>owner</code> 指针指向对象的 <code>Mark Word</code>。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象的 <code>Mark Word</code> 的锁标志位转变为“00”，即表示对象处于轻量级锁定状态。多线程堆栈和对象头的状态如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%20CAS%20%E5%90%8E%E5%A0%86%E6%A0%88%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%A4%B4%E7%9A%84%E7%8A%B6%E6%80%81.png" width="60%"></p><p>如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果已指向则说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，如果没有指向则说明这个锁对象已经被其他对象抢占了。</p><p>如果有两条以上的线程争用同一个锁，那轻量级锁就要膨胀为重量级锁，锁标志变为“10”，<code>Mark Word</code> 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。</p><p>对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用 <code>CAS</code> 操作避免了重量级锁使用互斥量的开销，提升了程序同步的性能。</p><p>偏向锁、轻量级锁的状态转化及对象 <code>Mark Word</code> 的关系如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E5%81%8F%E5%90%91%E9%94%81.jpg" width="60%"></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《深入理解 Java 虚拟机》</li><li>CyC2018：<a href="https://note.youdao.com/" target="_blank" rel="noopener">CS-Notes / Java 并发</a></li><li>Hollis：<a href="https://www.hollischuang.com/archives/1953" target="_blank" rel="noopener">深入理解多线程（三）—— Java的对象头</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;synchronized-概述&quot;&gt;&lt;a href=&quot;#synchronized-概述&quot; class=&quot;headerlink&quot; title=&quot;synchronized 概述&quot;&gt;&lt;/a&gt;synchronized 概述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;synchronized&lt;/code&gt; 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。&lt;/p&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发之 Java 内存模型</title>
    <link href="https://blog.timberliu.com/2019/03/03/035_Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://blog.timberliu.com/2019/03/03/035_Java 内存模型/</id>
    <published>2019-03-02T16:00:00.000Z</published>
    <updated>2019-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么要有内存模型"><a href="#为什么要有内存模型" class="headerlink" title="为什么要有内存模型"></a>为什么要有内存模型</h1><p>计算机的 <code>CPU</code> 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下：</p><ul><li><code>CPU</code> 增加了高速缓存，以均衡与内存的速度差异；</li><li>操作系统增加了进程、线程，以分时复用 <code>CPU</code>，均衡 <code>CPU</code> 与 <code>I/O</code> 设备的差异；</li><li>编译器优化指令执行次序，使得缓存能得到更加充分的利用。<a id="more"></a></li></ul><p>虽然高速缓存很好地解决了处理器与内存的速度矛盾，但是又出现了一个新的问题。在多核处理机中，每个处理器都有自己的高速缓存，它们共享同一主内存。当多个处理器的任务涉及到同一块主内存区域时，可能导致缓存的数据不一致的情况，这就是可见性问题，可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。</p><p>操作系统基于线程来进行任务调度。高级语言的一条语句往往需要多条指令完成，但是任务切换可以发生在任何一条 <code>CPU</code> 指令后，在多线程环境下这就可能导致数据与预期的不一致，即原子性问题。原子性是指一个或多个操作在 <code>CPU</code> 执行过程中不被中断。</p><p>编译器的指令重排序优化同样不能保证最终的结果与预期的一致。这里的重排序会满足以下两个条件：</p><ul><li><code>as-if-serial</code>：在单线程环境下不管怎么重排序，不能改变程序运行的结果。</li><li>数据依赖性：存在数据依赖关系的不能重排序。</li></ul><p>需要注意的是：虽然重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。也就是有序性问题，有序性指的是程序按照代码的先后顺序（逻辑先后）执行。</p><p>所以，<code>JVM</code> 试图虚拟机定义了一种 <code>Java</code> 内存模型（<code>Java Memory Model</code>，<code>JMM</code>）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 <code>Java</code> 程序在各种平台下都能达到一致的内存访问效果，也就是解决以上三个问题。</p><h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p><code>Java</code> 内存模型主要是为了定义程序中各个变量的访问规则，此处的变量指的是实例字段、静态字段和构成数组对象的元素等共享变量。</p><p><code>Java</code> 内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，其中保存了该线程使用的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程之间的变量值传递需要通过主内存来完成。</p><p>线程、工作内存、主内存三者的关系如下：</p><p><img src="http://media.timberliu.com/image/2019/2/27/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" width="60%"></p><h1 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h1><p>对于主内存与工作内存之间交互的实现细节，<code>Java</code> 内存模型中定义了 <code>8</code> 种操作来实现，虚拟机实现时必须保证这些操作是原子性的。</p><p><img src="http://media.timberliu.com/image/2019/2/27/%E5%86%85%E5%AD%98%E9%97%B4%E4%BA%A4%E4%BA%92.jpg" width="60%"></p><ul><li><code>read</code>（读取）：把一个变量的值从主内存传输到工作内存中；</li><li><code>load</code>（载入）：把 <code>read</code> 操作从主内存得到的变量放入工作内存的变量副本中；</li><li><code>use</code>（使用）；把工作内存中一个变量的值传递给执行引擎；</li><li><code>assign</code>（使用）：把一个从执行引擎接收到的值赋给工作内存的变量；</li><li><code>store</code>（存储）：把工作内存中一个变量的值传送到主内存中；</li><li><code>write</code>（写入）：把 <code>store</code> 操作从工作内存中得到的变量放入主内存的变量中。</li></ul><h1 id="volatile-型变量"><a href="#volatile-型变量" class="headerlink" title="volatile 型变量"></a>volatile 型变量</h1><p>关键字 <code>volatile</code> 是 <code>JVM</code> 提供的轻量级的同步机制。当一个变量被定义为 <code>volatile</code> 后，它可以保证内存的可见性。</p><p>使用 <code>volatile</code> 还可以禁止指令重排序优化。它是 <code>Java</code> 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。</p><p>内存屏障（<code>Memory Barrier</code>）是一组处理器指令，用于实现对内存访问操作的顺序限制。在重排序时不能把后面的指令重排序到内存屏障之前的位置。</p><h1 id="原子性、可见性、有序性"><a href="#原子性、可见性、有序性" class="headerlink" title="原子性、可见性、有序性"></a>原子性、可见性、有序性</h1><p><code>Java</code> 内存模型保证了并发的三个特性：原子性、可见性、有序性，下面学习一下哪些操作实现了这三个特性：</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p><code>Java</code> 内存模型保证了内存间交互的 <code>8</code> 个操作的原子性，但对于 <code>64</code> 位的数据类型（<code>long</code> 和 <code>double</code>），允许虚拟机的实现可以不保证 <code>64</code> 位数据类型的 <code>load</code>、<code>store</code>、<code>read</code> 和 <code>write</code> 这 <code>4</code> 个操作的原子性。但目前虚拟机几乎都把 <code>64</code> 位数据的读写操纵作为原子性来对待。也就是说可以认为基本类型的读写访问是具备原子性的。</p><p><code>JMM</code> 还提供了 <code>lock</code> 和 <code>unlock</code> 操作来保证更大范围的原子性，尽管虚拟机并未将其开放给用户，但可使用 <code>monitorenter</code> 和 <code>monitorexit</code> 字节码指令来隐式地使用这两个操作，对应到 <code>Java</code> 代码中就是 <code>synchronized</code> 关键字，所以 <code>synchronized</code> 同步块也是原子性的。</p><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>主要有三种方式实现可见性：</p><ul><li><code>volatile</code>：<code>volatile</code> 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。</li><li><code>synchronized</code>：对同步块加锁解锁，在执行 <code>unlock</code> 操作前必须把此变量值同步到主内存中。</li><li><code>final</code>：被 <code>final</code> 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 <code>this</code> 引用逃逸（其它线程可能通过引用访问到初始化了一半的对象），那么其它线程就能看见 <code>final</code> 字段的值。</li></ul><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p><code>Java</code> 中有两种方式保证线程之间操作的有序性；</p><ul><li><code>volatile</code> 关键字通过添加内存屏障的方式来禁止指令重排。</li><li>通过 <code>synchronized</code> 来保证有序性，它保证每个时刻只有一个线程执行同步代码，即让线程串行地执行同步代码。</li></ul><h1 id="Happends-Before-原则"><a href="#Happends-Before-原则" class="headerlink" title="Happends-Before 原则"></a>Happends-Before 原则</h1><p>前面说的保证并发安全的定义实践起来比较麻烦，有一个等效判断原则——<code>Happens-Before</code> 原则，来确定一个访问在并发环境下是否安全。</p><p><code>Happens-Before</code> 的含义就是前面一个操作的结果对后续操作是可见的。要想保证执行操作 <code>B</code> 的线程看到线程 <code>A</code> 的结果，那么 <code>A</code> 和 <code>B</code> 之间必须满足 <code>Happens-Before</code> 原则。如果两个操作之间缺乏 <code>Happens-Before</code> 原则，那么 <code>JVM</code> 就可以对它们任意地重排序，那么就会产生数据竞争问题。</p><p><code>Happens-Before</code> 原则包括：</p><ul><li>程序顺序规则：一个线程内按照控制流顺序，前面的操作 <code>Happens-Before</code> 于后面的操作。</li><li>管程锁定规则：一个 <code>unlock</code> 操作 <code>Happens-Before</code> 于后面对同一个锁的 <code>lock</code> 操作。</li><li><code>volatile</code> 变量规则：对一个 <code>volatile</code> 变量的写操作 <code>Happens-Before</code> 于对该变量的读操作。</li><li>线程启动规则：<code>Thread</code> 对象的 <code>start</code> 方法 <code>Happens-Before</code> 于此线程的每一个动作。</li><li>线程终止规则：线程中的所有操作都 <code>Happens-Before</code> 于对该线程的终止检测，可通过 <code>Thread.join</code> 方法结束，或 <code>Thread.isAlive</code> 方法的返回值，检测到线程已经终止执行。</li><li>线程中断规则：对线程 <code>interrupt</code> 方法的调用 <code>Happens-Before</code> 于被中断线程的代码检测到中断事件的发生。</li><li>对象终结规则：一个对象的初始化完成 <code>Happens-Before</code> 于它的 <code>finalize</code> 方法的开始。</li><li>传递性：如果操作 <code>A</code>  <code>Happens-Before</code> 于操作 <code>B</code>，操作 <code>B</code>  <code>Happens-Before</code> 于操作 <code>C</code>，那么操作 <code>A</code> 就 <code>Happens-Before</code> 于操作 <code>C</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>《深入理解 Java 虚拟机》</li><li>CyC2018：<a href="https://note.youdao.com/" target="_blank" rel="noopener">CS-Notes / Java 并发</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;为什么要有内存模型&quot;&gt;&lt;a href=&quot;#为什么要有内存模型&quot; class=&quot;headerlink&quot; title=&quot;为什么要有内存模型&quot;&gt;&lt;/a&gt;为什么要有内存模型&lt;/h1&gt;&lt;p&gt;计算机的 &lt;code&gt;CPU&lt;/code&gt; 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CPU&lt;/code&gt; 增加了高速缓存，以均衡与内存的速度差异；&lt;/li&gt;
&lt;li&gt;操作系统增加了进程、线程，以分时复用 &lt;code&gt;CPU&lt;/code&gt;，均衡 &lt;code&gt;CPU&lt;/code&gt; 与 &lt;code&gt;I/O&lt;/code&gt; 设备的差异；&lt;/li&gt;
&lt;li&gt;编译器优化指令执行次序，使得缓存能得到更加充分的利用。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="并发" scheme="https://blog.timberliu.com/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="并发" scheme="https://blog.timberliu.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 类加载机制</title>
    <link href="https://blog.timberliu.com/2019/03/02/034_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.timberliu.com/2019/03/02/034_类加载机制/</id>
    <published>2019-03-01T16:00:00.000Z</published>
    <updated>2019-03-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code> 源程序经过编译器编译后，会生成 <code>Class</code> 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。<a id="more"></a></p><h1 id="类加载概述"><a href="#类加载概述" class="headerlink" title="类加载概述"></a>类加载概述</h1><p>类加载机制，就是 <code>JVM</code> 将描述类的数据从 <code>Class</code> 文件加载到内存中，并对数据进行校验、转换解析和初始化，最终会形成可以被 <code>JVM</code> 直接使用的 <code>Java</code> 类型。</p><p>类被从加载，到卸载会经历如下七个生命周期：</p><p><img src="http://media.timberliu.com/image/2019/2/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" width="80%"> </p><p>其中加载、验证、准备、初始化和卸载这五个阶段的顺序的确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始。</p><h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><p>类加载在何时开始，<code>Java</code> 虚拟机规范并没有明确规定。但是对初始化阶段，则是严格规定了有且只有五种情况必须立即对类进行初始化：</p><ul><li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 四条字节码指令时，如果类没有被初始化，则需要先进行初始化。它们对应的代码场景分别是：<ul><li><code>new</code>：使用 <code>new</code> 关键在实例化对象时；</li><li><code>getstatic</code>：读取一个类的静态字段；</li><li><code>putstatic</code>：设置一个类的静态字段；</li><li><code>invokestatic</code>：调用一个类的静态方法时；</li></ul></li><li>使用 <code>java.lang.reflect</code> 包中的方法对类进行反射调用时，如果类没有被初始化，则需要先进行初始化。</li><li>当初始化一个类时，如果其父类还没有被初始化，则需要先对其父类进行初始化。</li><li>当虚拟机启动时，需要指定一个要执行的主类（包含 <code>main</code> 方法的类），虚拟机会先初始化这个主类。</li><li>当使用 <code>JDK1.7</code> 的动态语言支持时，如果一个 <code>java.lang.invoke.MehodHandle</code> 实例最后的解析结果 <code>REF_getStatic</code>、<code>REF_getStatic</code>、<code>REF_invokeStatic</code> 的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先进行初始化。</li></ul><h1 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h1><p>下面详细学习一下类加载的全过程，也就是加载、验证、准备、解析和初始化五个阶段。</p><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><p>加载阶段，<code>JVM</code> 需要完成以下事情：</p><ul><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将字节流所代表的静态存储结构转换为方法区的运行时的数据结构。</li><li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口。</li></ul><p>加载完成后，二进制字节流按照 <code>JVM</code> 所需的格式存储在方法区之中，方法区中的数据存储格式由 <code>JVM</code> 具体的实现中定义。然后在内存中实例化一个 <code>java.lang.Class</code> 类的对象，这个对象将作为程序访问方法区中的数据的外部接口。</p><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 <code>Class</code> 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>验证阶段大致会完成 <code>4</code> 个阶段的检验动作，其中第一个阶段是基于二进制字节流进行的，之后进入内存的方法区中存储；而后三个阶段是基于方法区的存储结构进行的：</p><ul><li>文件格式验证：验证字节流是否符合 <code>Class</code> 文件格式的规范，并且能被当前版本的虚拟机处理。例如：是否以魔数 <code>0xCAFEBABE</code> 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等。</li><li>元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 <code>Java</code> 语言规范的要求。例如：这个类是否有父类，这个类的父类是否继承了不允许被继承的类( <code>final</code> 类)。</li><li>字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对方法体进行校验分析，保证被校验方法的安全性。</li><li>符号引用验证：在解析阶段发生。对类自身以外的信息进行匹配性校验，例如符号引用中通过字符串描述的全限定名是否能找到对应的类等。</li></ul><p>验证阶段非常重要，但不是必须的，因为它对程序运行期没有影响。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。该阶段有需要注意以下几点：</p><ul><li>这个阶段进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量。</li><li>这里所设置的初始值通常情况下是数据类型默认的零值(如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等）。</li><li>如果类字段的字段属性表中存在 <code>ConstantValue</code> 属性，即同时被 <code>final</code> 和 <code>static</code> 修饰，那么在准备阶段变量就会被初始化为 <code>ConstValue</code> 属性所指定的值。</li></ul><h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>符号引用与直接应用区别如下：</p><ul><li>符号引用：以一组符号来描述引用的目标，可以是任何形式的字面量。</li><li>直接引用：可以是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</li></ul><p>解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 <code>7</code> 类符号引用进行。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>在准备阶段，变量已经被赋过一次系统要求的初始值。而在初始化阶段，则按照程序去初始化类变量，或者说，初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法。</p><p><code>&lt;clinit&gt;</code> 方法运行的特点和细节如下：</p><ul><li><code>&lt;clinit&gt;</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。收集的顺序是语句在源文件中出现的顺序决定，静态语句块只能访问定义在静态语句块之前的变量。定义在它之后的变量，在之前的静态语句块可以赋值，但不能访问。</li><li>虚拟机会保证子类的 <code>&lt;clinit&gt;</code> 方法执行之前，父类的 <code>clinit</code> 方法已执行完毕。</li><li>执行接口的 <code>&lt;clinit&gt;</code> 方法不需要先执行父接口的 <code>&lt;clinit&gt;</code> 方法。</li></ul><h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><p>加载阶段的“通过一个类的全限定类名来获取此类的二进制字节流”这个动作放到 <code>JVM</code> 外部实现，以便让应用程序自己决定如何获取所需的类。这个模块称为“类加载器”。</p><p>类加载器除了用于实现类的加载动作，还用来比较两个类是否“相等”。这里的相等指的是：只有两个类是由同一个类加载器的前提下，两个类来源于同一 <code>Class</code> 文件，被同一个虚拟机加载，两个类才相等。</p><p>这里的“相等”，包括：</p><ul><li>代表类的 <code>Class</code> 对象的 <code>equals()</code> 方法；</li><li><code>isAssignableFrom()</code> 方法；</li><li><code>isInstance()</code> 方法；</li><li>使用 <code>instanceof</code> 关键字对对象所属关系判断；</li></ul><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><h2 id="层次关系"><a href="#层次关系" class="headerlink" title="层次关系"></a>层次关系</h2><p><code>Java</code> 程序一般会使用三种系统提供的类加载器：启动类加载器、扩展类加载器和应用程序加载器（<code>HotSpot</code> 虚拟机）。它们的层次关系如下图：</p><p><img src="http://media.timberliu.com/image/2019/2/24/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" width="80%"></p><p>这种层次关系，称为类加载器的双亲委派模型。其中除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。子类加载器和父类加载器不是以继承关系来实现，而是通过组合关系来复用父加载器的代码。</p><p>三种类加载器如下：</p><ul><li>启动类加载器（<code>Bootstrap ClassLoader</code>）：使用 <code>C++</code> 语言实现，是虚拟机自身的一部分。这个类加载器负责加载 <code>JVM</code> 启动所需要的类（<code>&lt;JAVA_HOME&gt;\lib</code> 或 <code>-Xbootclasspath</code> 目录下的类库）。</li><li>扩展类加载器（<code>Extension ClassLoader</code>）：除了启动类加载器外，其他类加载器都由 <code>Java</code> 实现，独立于虚拟机外部。它负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录，或者被 <code>java.ext.dirs</code> 系统变量指定的路径中的类库。开发者可以直接使用扩展类加载器。</li><li>应用程序类加载器（<code>Application ClassLoader</code>）：这个类加载器是 <code>ClassLoader</code> 中的 <code>getSystemClassLoader()</code> 方法的返回值。它负责加载用户类路径（<code>ClassPath</code>）上所指定的类库。开发者可以直接使用这个类加载器。</li></ul><p>使用双亲委派模型组织类加载器之间的关系，使得 <code>Java</code> 类随着它的类加载器一起具备了带有优先级的层次关系，而不会出现关系混乱的类加载器。</p><h2 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h2><p>双亲委派模型的工作过程如下：</p><ul><li>如果一个类加载器收到类加载的请求，它首先从自己的加载类缓存中，查询该类是否已经被加载，如果已经加载则直接返回原来已经加载的类。</li><li>如果没有加载，则会委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到顶层的启动类加载器。</li><li>只有当父加载器无法完成这个加载请求，即它的搜索范围中没有找到所需的类时，子加载器才会尝试自己去加载。</li><li>如果一个类加载器加载类后，会将其放入自己的缓存中，以便下次有加载请求的时候直接返回。</li></ul><h2 id="优先使用父-ClassLoader-加载类"><a href="#优先使用父-ClassLoader-加载类" class="headerlink" title="优先使用父 ClassLoader 加载类"></a>优先使用父 ClassLoader 加载类</h2><p>主要有以下两个好处：</p><ol><li>共享功能：可以避免重复加载，当父加载器已经加载了该类时，就不需要子类再次加载，一些顶层的类被 <code>ClassLoader</code> 加载过就会缓存在内存里，以后用到时都不需要重新加载。</li><li>隔离功能：为了安全性，避免用户自己编写的类替换 <code>Java</code> 的一些核心类，比如 <code>String</code> ，同时也避免了重复加载，因为 <code>JVM</code> 中区分不同类，不仅仅是根据类名，相同的 <code>class</code> 文件被不同的 <code>ClassLoader</code> 加载就是不同的两个类，如果相互转型的话会抛 <code>java.lang.ClassCastException</code>。</li></ol><h2 id="双亲委派模型的实现"><a href="#双亲委派模型的实现" class="headerlink" title="双亲委派模型的实现"></a>双亲委派模型的实现</h2><p>双亲委派模型的代码都集中在在 <code>java.lang.ClassLoader</code> 的 <code>loadClass</code> 方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123; &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line">                </span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到在 <code>loadClass</code> 方法的加载过程如下：</p><ul><li>首先检查请求的类是否已经被加载。</li><li>如果没有调用，则调用父加载器的 <code>loadClass</code> 方法。</li><li>如果父加载器为空，则默认使用启动类加载器加载。</li><li>如果父加载器加载失败，抛出 <code>ClassNotFoundException</code> 异常，再调用自己的 <code>findClass</code> 方法进行加载。</li></ul><h2 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h2><p>双亲委派模型仅是 <code>Java</code> 推荐的类加载器实现方式。大部分的类加载器也都遵循这个模型，双亲委派模型主要出现过 <code>3</code> 次被破坏的情况。</p><p>第一次破坏是发生在双亲委派模型出现之前。为了向前兼容 <code>JDK1.0</code> 就存在的类加载器和抽象类 <code>java.lang.ClassLoader</code>，在 <code>JDK1.2</code> 后的 <code>java.lang.ClassLoader</code> 添加了一个新的 <code>protected</code> 方法 <code>findClass()</code>。</p><p>第二次破坏是由模型自身的缺陷导致的。用户代码总是调用基础类，但是上层类加载器加载的基础类不能调用回用户的代码。<code>Java</code> 中引入了线程上下文类加载器，可以使用这个线程上下文类加载器请求子类加载器去完成类加载的动作。</p><p>第三次破坏是由于用户对程序的动态性的追求导致的。例如 <code>OSGI</code> 实现模块化热部署，在 <code>OSGI</code> 环境下，类加载器不再是双亲委派模型中的树形结构，而是发展为网状结构。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>指 · 间：<a href="http://www.zhenchao.org/2016/12/04/jvm/class-load/" target="_blank" rel="noopener">探秘 JVM：类加载机制</a></li><li>芋道源码：《精尽 Java【虚拟机】面试题》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 源程序经过编译器编译后，会生成 &lt;code&gt;Class&lt;/code&gt; 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 垃圾收集器</title>
    <link href="https://blog.timberliu.com/2019/02/26/033_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/02/26/033_垃圾收集器/</id>
    <published>2019-02-25T16:00:00.000Z</published>
    <updated>2019-02-25T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇文章中学习了 <code>JVM</code> 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 <code>HotSpot</code> 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p><code>HotSpot</code> 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。<a id="more"></a></p><h2 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h2><p><code>Serial</code> 收集器是一个单线程的收集器，它不仅只会使用一个 <code>CPU</code> 或一条收集线程去完成垃圾收集工作，而且在垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。</p><p><code>Serial</code> 收集器是 <code>HotSpot</code> 虚拟机在运行 <code>Client</code> 模式下的默认新生代收集器。在垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。</p><p>但它也有优点，与其他收集器的单线程相比，由于没有现成交互的开销，专心做垃圾收集，所以其简单而高效；</p><p>可以使用 <code>-XX:UseSerialGC</code> 参数选择使用 <code>Serial</code> 收集器，此时年轻代采用 <code>Serail</code>，老年代采用 <code>Serial Old</code>。</p><h2 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h2><p><code>ParNew</code> 收集器是 <code>Serial</code> 收集器的多线程版本，除了使用多线程进行垃圾回收外，其他几乎一样。</p><p>它是许多运行在 <code>Server</code> 模式下的虚拟机首选的新生代收集器，一个很重要的原因是除了 <code>Serial</code> 收集器外，只有 <code>ParNew</code> 收集器与 <code>CMS</code> 收集器配合工作。垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。</p><p><code>ParNew</code> 收集器默认开启的线程数与 <code>CPU</code> 的数量相同，可以使用 <code>-XX:ParallelGCThreas</code> 参数来限制垃圾收集的线程数。使用 <code>-XX:UseParNewGC</code> 参数来使用 <code>ParNew</code> 收集器。</p><h2 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h2><p><code>Parallel Scavenge</code> 收集器是新生代收集器，也是使用复制算法的多线程收集器。与其他收集器不同的是，它关注的是达到一个可控制的吞吐量，吞吐量 = 运行代码时间 / （运行代码时间 + 垃圾收集时间）。</p><p><code>Parallel Scanenge</code> 收集器提供了两个参数用于精确控制吞吐量。第一个是控制最大垃圾收停顿时间的 <code>-XX:MaxGCPauseMillis</code> 参数。它允许是一个大于 <code>0</code> 的毫秒数，收集器将尽可能保证内存回收时间不超过设定值。这个参数也不是越小越好，GC 停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。</p><p>第二个是直接设置吞吐量大小的 <code>-XX:GCTimeRatio</code> 参数。它允许是一个大于 <code>0</code> 且小于 <code>100</code> 的整数，就是垃圾收集时间占总时间的比率。</p><p>另外，<code>Parallel Scavenge</code> 收集器拥有自适应调节机制，它不需要手工指定新生代的大小（<code>-Xmn</code>）、<code>Eden</code> 与 <code>Survivor</code> 区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象大小 <code>-XX:PretenureSizeThreshold</code> 等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间及最大的吞吐量。可使用 <code>-XX:UseAdaptiveSizePolicy</code> 参数来开启。</p><h2 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h2><p><code>Serial Old</code> 是 <code>Serial</code> 收集器的老年代版本，是一个单线程收集器，使用“标记-整理算法”。</p><h2 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h2><p><code>Parallel Old</code> 是 <code>Parallel Scavenge</code> 收集器的老年代版本，使用多线程和“标记-整理”算法。如果新生代选择了 <code>Parallel Scavenge</code> 收集器，老年代只能选择 <code>Serial Old</code> 收集器。</p><h2 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h2><p><code>CMS(Concurrent Mark Sweep)</code> 是一种以获取最短停顿时间为目标的收集器，使用“标记-清除”算法。如果应用重视响应速度，希望停顿时间最短，就可以选择 <code>CMS</code> 收集器。</p><p>它的运作过程可分为 <code>4</code> 个步骤：</p><ul><li>初始标记：仅仅标记 <code>GC Roots</code> 能直接关联到的对象，速度很快，需要 <code>Stop the world</code>。</li><li>并发标记：进行 <code>GC Roots Tracing</code> 过程。 </li><li>重新标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。</li><li>并发清除。</li></ul><p><code>CMS</code> 的主要优点是并发收集、低停顿。但也有三个缺点：</p><ul><li>对 <code>CPU</code> 资源非常敏感。并发阶段虽不会导致用户线程停顿，但会因为占用资源而导致程序变慢，总吞吐量降低。</li><li>无法处理浮动垃圾，也就是在标记过程后，清除阶段产生但当次收集中不能处理的垃圾，可能出现 <code>Concurrent Mode Failure</code> 失败而导致另一次 <code>Full FC</code> 的产生。</li><li><code>CMS</code> 基于标记-清除算法，收集结束时会产生大量空间碎片。碎片过多时，无法找到足够的连续空间来分配大对象，不得不提前出发一次 <code>Full GC</code>。</li></ul><p>可以使用 <code>-XX:UseConcMarkSweepGC</code> 参数来选择 <code>CMS</code> 收集器。</p><h2 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h2><p><code>G1(Garbage-First)</code> 是一款面向服务端应用的垃圾收集器。它的特点如下：</p><ul><li>并行与并发：充分利用多 <code>CPU</code>、多核环境，使用多个 <code>CPU</code> 来缩短停顿的时间，部分需要其他收集器原本需要停顿 <code>Java</code> 线程执行的 <code>GC</code> 动作，<code>G1</code> 收集器可通过并发的方式让 <code>Java</code> 程序继续执行。</li><li>分代收集：<code>G1</code> 收集器能独立管理整个 <code>GC</code> 堆，并且能采用不同的方式处理不同时期的对象。</li><li>空间整合：<code>G1</code> 收集器从整体来看，基于“标记-整理”算法实现；从局部来看，基于“复制”算法实现。</li><li>可预测的停顿：<code>G1</code> 能明确指定垃圾收集的限制时间。</li></ul><p>使用 <code>G1</code> 收集器时，将 <code>Java</code> 堆划分为多个大小相等的区域 <code>Region</code>。<code>G1</code> 跟踪各个 <code>Region</code> 的回收价值和成本（回收获得空间及回收时间），后台会维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 <code>Region</code>。它通过使用 <code>Remembered Set</code> 来避免全堆扫描。</p><p><code>G1</code> 收集器的运行步骤可分为：</p><ul><li>初始标记：仅仅标记一下 <code>GC Roots</code> 直接能关联到的对象，需要停顿，但耗时很短。</li><li>并发标记：从 <code>GC Roots</code> 开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，但可并发执行。</li><li>最终标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。</li><li>筛选回收：对各个 <code>Region</code> 的回收价值和成本进行排序，根据指定的 <code>GC</code> 停顿时间制定回收计划。</li></ul><h1 id="常用收集器组合"><a href="#常用收集器组合" class="headerlink" title="常用收集器组合"></a>常用收集器组合</h1><p><code>HotSpot</code> 虚拟机中包含了七种垃圾收集器，如下图：</p><p><img src="http://media.timberliu.com/image/2019/2/23/GC%E6%94%B6%E9%9B%86%E5%99%A8%E7%BB%84%E5%90%88.png" width="60%"></p><p>它们的组合说明如下：</p><table><thead><tr><th>新生代收集器</th><th>年老代收集器</th><th>说明</th></tr></thead><tbody><tr><td>Serial</td><td>Serial Old</td><td>都是单线程，GC 时会暂停所有应用线程。<br>使用 -XX:+UseSerialGC 选项来开启</td></tr><tr><td>Serial</td><td>CMS + Serial Old</td><td>CMS 是并发 GC，不需要暂停所有应用线程。<br>当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC<br>使用 -XX:+UseConcMarkSweepGC 选项来开启</td></tr><tr><td>ParNew</td><td>CMS</td><td>ParNew 是 Serial 的并行版本，可以指定 GC 线程数<br>默认 GC 线程数为 CPU 的数量</td></tr><tr><td>ParNew</td><td>Serial Old</td><td>使用 -XX:+UseParNewGC 选项来开启</td></tr><tr><td>Parallel Scavenge</td><td>Serial Old</td><td>Parallel Scavenge 策略关注吞吐量，适用于后台持久运行的应用程序<br>使用 -XX:+UseParallelGC 选项来开启</td></tr><tr><td>Parallel Scavenge</td><td>Parallel Old</td><td>Parallel Old 是 Serial Old 的并行版本<br>使用 -XX:+UseParallelOldGC 选项来开启</td></tr><tr><td>G1GC</td><td>G1GC</td><td>-XX:+UseG1GC #开启<br>-XX:MaxGCPauseMillis #暂停时间目标</td></tr></tbody></table><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>雨点的名字：<a href="https://www.cnblogs.com/qdhxhz/p/9211269.html" target="_blank" rel="noopener">【JVM虚拟机】（3）—垃圾回收器</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上一篇文章中学习了 &lt;code&gt;JVM&lt;/code&gt; 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 &lt;code&gt;HotSpot&lt;/code&gt; 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。&lt;/p&gt;
&lt;h1 id=&quot;垃圾收集器&quot;&gt;&lt;a href=&quot;#垃圾收集器&quot; class=&quot;headerlink&quot; title=&quot;垃圾收集器&quot;&gt;&lt;/a&gt;垃圾收集器&lt;/h1&gt;&lt;p&gt;&lt;code&gt;HotSpot&lt;/code&gt; 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 JVM 内存结构</title>
    <link href="https://blog.timberliu.com/2019/02/25/031_JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    <id>https://blog.timberliu.com/2019/02/25/031_JVM 内存结构/</id>
    <published>2019-02-24T16:00:00.000Z</published>
    <updated>2019-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>Java</code> 虚拟机在运行 <code>Java</code> 程序 时，把它所管理的内存划分为若干个不同的数据区域，主要包括以下五个部分：程序计数器、<code>Java</code> 堆、<code>Java</code> 虚拟机栈、方法区和本地方法栈。<a id="more"></a></p><p><img src="http://media.timberliu.com/image/2019/2/23/Java%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" width="70%"></p><h1 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h1><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是当前线程所执行的字节码的行号指示器，它会指出下一条将要执行的指令的地址，字节码解释器就是通过改变计数器的值来选取程序接下来执行的操作。</p><p>程序计数器是线程私有的一小块内存，每条线程都要有一个独立的程序计数器，以使线程切换后恢复到正确的执行位置。</p><ul><li>如果线程正在执行 <code>Java</code> 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址</li><li>如果执行 <code>native</code> 方法，则计数器为空</li></ul><p>它也是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>与程序计数器一样，<code>Java</code> 虚拟机栈也是线程私有的，在线程创建时 <code>Java</code> 栈会被创建，每个方法在在执行的同时都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>一般所谓的“栈”，指的是虚拟机栈中局部变量表部分，其中存放了各种基本数据类型( <code>8</code> 种)，对象引用(<code>reference</code> 类型) 和 <code>returnAddress</code> 类型。局部变量表所需的空间在编译期就已经确定并完成分配，在方法运行期间不会被改变。</p><p><code>Java</code> 虚拟栈中可能出现两种异常：</p><ul><li><code>StackOverflowError</code>：线程请求的栈深度大于虚拟机所允许的深度</li><li><code>OutOfMemoryError</code>：虚拟机栈扩展时无法申请到足够的内存</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与 <code>Java</code> 虚拟机栈的作用类似，区别是 <code>Java</code> 虚拟机栈为虚拟机执行 <code>Java</code> 方法服务，而本地方法栈为虚拟机执行 <code>Native</code> 方法服务。有的虚拟机（例如 <code>HotSpot</code> 虚拟机）直接把本地方法栈和 <code>Java</code> 虚拟机栈合并在一起。</p><p>本地方法栈也可能会抛出 <code>StackOverflowError</code> 和 <code>OutOfMemoryError</code> 异常。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p><code>Java</code> 堆是是虚拟机中最主要的内存区域。它为线程共享，在虚拟机启动时创建，几乎所有的对象实例都存储在 <code>Java</code> 堆中。</p><p><code>Java</code> 堆也被称作 <code>&quot;GC&quot;</code> 堆。从内存回收角度看，可分为新生代和老年代。而新生代又可分为 <code>Eden</code> 区、<code>From Survivor</code> 区、<code>To Survivor</code> 区等。</p><p><code>Java</code> 堆的实现，既可以实现为固定的，也可以是扩展的。当前虚拟机都按照可扩展来实现，通过 <code>-Xmx</code> 和 <code>-Xms</code> 控制堆大小。</p><p>如果堆中没有内存并且也无法再扩展时，会抛出 <code>OutOfMemeoryError</code> 异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与 <code>Java</code> 堆一样，为线程共享。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。也叫作 <code>Non-Heap</code>（非堆）。</p><p>如果方法区无法满足内存分配需求，会抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。<code>Class</code> 文件中的常量池用于编译期生成的各种字面量和符号引用，这部分内容在类加载后被存入运行时常量池。</p><p>动态性是运行时常量池相对于 <code>Class</code> 文件常量池的一个重要特征，即不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中。</p><p>运行时常量池受到方法区内存的限制，如果常量池无法再申请内存，就会抛出 <code>OutOfMemoryError</code> 异常。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不由 <code>JVM</code> 管理，它是利用 <code>Native</code> 函数库在 <code>Java</code> 堆外申请分配的内存区域，可以避免在 <code>Java</code> 堆和 <code>Native</code> 堆中复制数据以提高性能。</p><p>例如 <code>NIO</code> 中的 <code>DirectByteBuffer</code> 就可以作为这块内存的引用进行操作直接内存。</p><h1 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h1><p>有时会看到方法区被称为永久代，其实两者有着本质的区别。方法区是 <code>JVM</code> 规范中的定义，而永久代是 <code>JVM</code> 规范的一种实现，并且只有在 <code>HotSpot</code> 虚拟机中如此，其他虚拟机中没有永久代的说法。</p><p>在 <code>JDK1.6</code> 之前，<code>HotSpot</code> 虚拟机把 <code>GC</code> 分代收集扩展至方法区，或者说使用永久代实现方法区。不过永久代有 <code>-XX:MaxPermSize</code> 的上限，很容易遇到内存溢出问题。</p><p>所以在 <code>JDK1.7</code> 中，将部分数据已经转移 <code>Java Heap</code> 或 <code>Native Heap</code> 中，例如：将原本放在永久代中的字符串池和类的静态变量移出到 <code>Java Heap</code> 中，将符号引用转移到 <code>Native Heap</code> 中。但永久代仍然存在，并没有移除。</p><p>在 <code>JDK1.8</code> 中，取消了永久代，代替为元空间实现，它也是 <code>JVM</code> 规范中方法区的一种实现。不过它与永久代最大的不同是：元空间并不在虚拟机中，而是将元空间放到本地内存中。所以默认情况下，它只受本地内存的限制，可以通过 <code>-XX:MetaspaceSize</code> 参数设置初始空间大小，默认没有最大空间限制。</p><h1 id="常见的-OOM-及原因"><a href="#常见的-OOM-及原因" class="headerlink" title="常见的 OOM 及原因"></a>常见的 OOM 及原因</h1><p><code>Java</code> 中的 <code>OOM</code> 指的就是 <code>java.lang.OutOfMemoryError</code> 异常。主要有以下几种：</p><p><strong>java.lang.OutOfMemoryError:Java heap space</strong></p><p><code>Java</code> 堆中主要用于存放各种对象实例。当堆中没有足够的空间分配给新对象时，或者说达到了堆空间设置的最大空间限制，则会抛出此异常。</p><p>引起内存溢出的原因主要有：</p><ul><li>流量访问量大，超过设置的堆空间大小；</li><li>内存泄露，不能被回收的对象消耗过多堆空间；</li></ul><p><strong>java.lang.OutOfMemoryError:Permgen space</strong></p><p>在 <code>JDK7</code> 中，<code>HotSpot</code> 虚拟机使用永久代实现方法区，永久代较小，而且回收效率较低，很容易出现内存溢出。</p><p>因此，<code>JDK8</code> 取消了永久代，使用元空间来实现方法区，存放在本地内存中。</p><p><strong>java.lang.OutOfMemoryError:Metaspace</strong></p><p>方法区主要存储类的元信息，<code>HotSpot</code> 元数据区。当元空间没有足够的空间分配给加载的类时，会抛出此异常。</p><p>引起元数据区空间不足的原因主要有：</p><ul><li>加载的类太多，常见于 <code>jsp</code> 页面过多时；</li><li>元空间被实现在堆外，主要受到进程本身的内存限制，一般很难出现溢出。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>Hollis：<a href="https://www.hollischuang.com/archives/2509" target="_blank" rel="noopener">JVM内存结构 VS Java内存模型 VS Java对象模型</a></li><li>liuxiaopeng：<a href="https://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">Java8内存模型—永久代(PermGen)和元空间(Metaspace)</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 虚拟机在运行 &lt;code&gt;Java&lt;/code&gt; 程序 时，把它所管理的内存划分为若干个不同的数据区域，主要包括以下五个部分：程序计数器、&lt;code&gt;Java&lt;/code&gt; 堆、&lt;code&gt;Java&lt;/code&gt; 虚拟机栈、方法区和本地方法栈。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 JVM 之 垃圾回收机制</title>
    <link href="https://blog.timberliu.com/2019/02/25/032_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.timberliu.com/2019/02/25/032_垃圾回收机制/</id>
    <published>2019-02-24T16:00:00.000Z</published>
    <updated>2019-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>虽然内存的分配和回收技术已相当成熟，但如果需要排查内存溢出、内存泄露问题，或者要求高并发、高性能时，就需要对垃圾的回收进行监控和调节，以更好优化系统提高性能。<a id="more"></a></p><h1 id="对象存活判定"><a href="#对象存活判定" class="headerlink" title="对象存活判定"></a>对象存活判定</h1><p><code>Java</code> 内存结构中，程序计数器、虚拟机栈、本地方法栈等随着线程而生，随线程而灭，不需要考虑内存回收问题。而 <code>Java</code> 堆和方法区则不同，它们的内存分配是动态的，只有在运行期间才能知道会创建哪些对象，垃圾回收关注的就是这两部分。</p><p>垃圾回收首先需要判断哪些对象还存活着，主要有引用计数和可达性分析两种算法。</p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>它的原理如下：给对象添加一个引用计数器，每当有一个地方引用它时，计时器值就加 <code>1</code>；当引用失效时，计数器值就减 <code>1</code>；如果计数器为 0，对象就不可能再被使用。</p><p>引用计数算法虽然实现简单、判定效率较高。但它很难解决对象之间循环引用的问题。</p><p>例如两个对象相互引用，实际上两个对象都不会再访问，但因为相互引用着对方，导致它们的计数器值都不为 <code>0</code>，于是引用技术算法无法通过 <code>GC</code> 收集器回收它们。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>它的原理如下：通过一系列称为 <code>GC Roots</code> 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 <code>GC Roots</code> 没有任何引用链相连时，则证明对象是不可用的。</p><p><code>Java</code> 中，可作为 <code>GC Roots</code> 的对象包括如下几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中 <code>JNI</code>( <code>Native</code> 方法) 引用的对象。</li></ul><h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>可以看到，对象回收判定算法判断对象是否存活都与引用有关。从 <code>JDK1.2</code> 开始，引用分为四种类型，用来实现不同的功能，它们的引用强度也依次递减。</p><p><strong>强引用（Strong Reference）</strong></p><p>平时使用的引用就是强引用。只要强引用还存在，该对象永远不会被回收。</p><p>可以通过将对象设置为 <code>null</code>，使其被回收。</p><p><strong>软引用（Soft Reference）</strong></p><p>用于描述一些还有用但并非必需的对象。当系统内存空间不足时，会回收这些软引用指向的对象。它通过 <code>SoftReference</code> 类来实现软引用。</p><p>可以用来实现高速缓存。</p><p><strong>弱引用（Weak Reference）</strong></p><p>用来描绘非必需对象。被弱引用指向的对象只能生存到下一次垃圾回收之前。只要垃圾收集器运行，弱引用指向的对象就会被回收。它通过 <code>WeakReference</code> 类来实现弱引用。</p><p><strong>虚引用（Phantom Reference）</strong></p><p>虚引用和没有引用没有任何区别。一个对象是否有虚引用，不会影响其生存时间，也无法通过虚引用获取对象实例。它通过 <code>PhantomReference</code> 来实现虚引用。必须和引用队列 <code>ReferenceQueue</code> 联合使用。</p><p>为一个对象设置虚引用的唯一目的是该对象被垃圾收集器回收前会收到一条系统通知。</p><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>方法区，或者说 <code>HotSpot</code> 虚拟机中的永久代，进行垃圾回收的效率一般比较低。回收主要包括两部分内容：废弃常量和无用的类。</p><p>判断一个常量是否是废弃常量比较简单，与回收 <code>Java</code> 堆中的对象类似。而判定一个类是否是无用的类需要满足三个条件：</p><ul><li>该类所有的实例都已经被回收；</li><li>加载该类的 <code>ClassLoader</code> 已经被回收；</li><li>该类对象的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h2><p>标记-清除算法分为两个标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记过程也就是对象存活判定算法。</p><p><img src="http://media.timberliu.com/image/2019/2/23/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.png" width="60%"></p><p>它是最基础的收集算法，主要有两个缺点：</p><ul><li>效率问题：标记和清除两个过程的效率都不高。</li><li>空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="复制算法（Copying）"><a href="#复制算法（Copying）" class="headerlink" title="复制算法（Copying）"></a>复制算法（Copying）</h2><p>复制算法将可用内存分为大小相等的两块，每次只使用其中的一块。在一块内存用完后，将仍存活的对象赋值到另一块上面，再把已使用过的内存一次清理掉。</p><p><img src="http://media.timberliu.com/image/2019/2/23/%E5%A4%8D%E5%88%B6.png" width="60%"></p><p>复制算法的优缺点如下：</p><ul><li>优点：每次对半个分区进行内存回收，内存分配时也不用考虑内存碎片等情况，实现简单，运行高效。</li><li>缺点：可使用的内存缩小为一半，代价较大。</li></ul><h2 id="标记-整理算法（Mark-compact）"><a href="#标记-整理算法（Mark-compact）" class="headerlink" title="标记-整理算法（Mark-compact）"></a>标记-整理算法（Mark-compact）</h2><p>标记-整理算法分为标记和整理两个阶段，标记阶段和“标记-清除算法”一样，但在整理阶段，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="http://media.timberliu.com/image/2019/2/23/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86.png" width="60%"></p><p>标记-整理算法的优缺点如下：</p><ul><li>避免了空间碎片，空间利用率较高。</li><li>效率不高，标记和清除过程的效率较低。</li></ul><h2 id="分代算法（Generational-Collection）"><a href="#分代算法（Generational-Collection）" class="headerlink" title="分代算法（Generational Collection）"></a>分代算法（Generational Collection）</h2><p>分代算法根据对象存活周期将内存划分为几块。一般是将 <code>Java</code> 对分为新生代和老年代，根据各个年代的特点采用适当的收集算法。</p><p>新生代中，每次垃圾收集时只有少量对象存活，选择复制算法；老年代中，对象存活率较高、没有额外空间进行分配，使用“标记-清理”或“标记-整理”算法。</p><p>为了对不同生命周期的对象采用不同的回收算法，所以垃圾收集器都采用分代收集算法，将堆分为新生代和老年代。</p><p>&emsp;&emsp;<img src="http://media.timberliu.com/image/2019/2/23/%E5%A0%86%E5%86%85%E5%AD%98%E5%88%92%E5%88%86.jpg" width="60%"></p><h1 id="内存分配和回收策略"><a href="#内存分配和回收策略" class="headerlink" title="内存分配和回收策略"></a>内存分配和回收策略</h1><h2 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h2><p>新生代主要用来存放新创建的对象，一般占堆 <code>1/3</code> 的空间。由于很多对象生命周期很短，每次 <code>Minor GC</code> 后只有少量对象存活，所以选用复制算法。</p><p>新生代又被分为一块较大的 <code>Eden</code> 区和两块较小的大小相等的 <code>Survivor</code> 区，使用 <code>from</code> 和 <code>to</code> 来分别指代两个 <code>Survivor</code> 区。<code>HotSpot</code> 虚拟机默认 <code>Eden</code> 和两块 <code>Survivor</code> 的大小比例为 <code>8:1:1</code>。每次只会使用 <code>Eden</code> 和其中一块 <code>Survivor</code> 区为对象服务，所以总是有一块 <code>Survivor</code> 区是空闲的，新生代实际可用的内存空间也就为 <code>90%</code>。</p><p>通常，对象会分配在 <code>Eden</code> 区中，当 <code>Eden</code> 区无法在分配对象时，<code>JVM</code> 便会触发一次 <code>Minor GC</code>，将存活下来的对象复制到 <code>from</code> 指向的 <code>Survivor</code> 区中。</p><p>当 <code>from</code> 指向的 <code>Survivor</code> 区也无法分配时，对 <code>Eden</code> 和 <code>from</code> 指向的 <code>Survivor</code> 区执行 <code>Minor GC</code>，将存活下来的对象复制到 <code>to</code> 指向的 <code>Survivor</code> 区中，然后交换 <code>from</code> 和 <code>to</code> 指针，使 <code>to</code> 指向的 <code>Survivor</code> 区为空，以保证下次 <code>Minor GC</code> 有复制的空闲空间。</p><h2 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h2><p>老年代用于存放大对象，或年龄超过一定程度的对象。一般占据堆 <code>2/3</code> 的空间。</p><p>如果对象需要大量连续的内存空间，例如很长的字符串及数组，这些对象会直接分配在老年代，以避免在 <code>Eden</code> 区及两个 <code>Survivor</code> 区之间发生大量的内存复制。</p><p>虚拟机为每个对象定义了一个对象年龄计数器，如果对象分配在 <code>Eden</code> 区，在经过一次 <code>Minor GC</code> 后仍然存活，之后移动到 <code>Survivor</code> 空间中，将其年龄设置为 <code>1</code>。对象在 <code>Survivor</code> 区中每经过一次 <code>Minor GC</code>，年龄就增加一次，当它的年龄增加到一定程度（默认为 <code>15</code>）时，也会被晋升到老年代中。</p><p>如果在 <code>Survivor</code> 区中相同年龄所有对象大小的总和大于 <code>Survivor</code> 区的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。</p><p>老年代的对象一般都比较稳定，<code>Major GC</code> 不会频繁执行。<code>Major GC</code> 采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。<code>MajorGC</code> 的耗时较长，而且会产生内存碎片。</p><h2 id="三种清理方式"><a href="#三种清理方式" class="headerlink" title="三种清理方式"></a>三种清理方式</h2><p><strong>Minor GC(Young GC)</strong></p><p>指发生在新生代的垃圾收集动作。当 <code>Eden</code> 区没有足够的空间分配时，就会触发一次 <code>Minor GC</code>。由于 <code>Java</code> 对象大多生命周期较短，所以 <code>Minor GC</code> 非常频繁，一般回收速度也比较快。</p><p><strong>Major GC</strong></p><p>指发生在老年代的垃圾收集动作，在进行 <code>Major GC</code> 前，一般都会进行至少一次 <code>Minor GC</code>。<code>Major GC</code> 的速度一般会比 <code>Minor GC</code> 慢 <code>10</code> 倍以上。</p><p><strong>Full GC</strong></p><p>指回收整个新生代和老年代的垃圾收集动作。成本较高，对系统性能产生影响。<code>FULL GC</code> 的时候会 <code>STOP THE WORD</code>。</p><p>它的触发条件主要有：</p><ul><li>在执行 <code>Minor GC</code> 之前，如果老年代最大可用的连续空间小于历次晋升到老生代对象的平均大小，则触发一次 <code>Full GC</code> 。</li><li>大对象直接进入老年代，或从年轻代晋升上来的老对象，在老年代尝试分配内存，但老年代内存空间不够时。</li><li>显式调用 <code>System.gc()</code> 方法时。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>雨点的名字：<a href="https://www.cnblogs.com/qdhxhz/p/9211095.html" target="_blank" rel="noopener">【JVM虚拟机】（2）—GC 算法与种类</a></li><li>Nutty：<a href="https://www.cnblogs.com/ygj0930/p/6522828.html" target="_blank" rel="noopener">JVM的新生代、老年代、MinorGC、MajorGC</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虽然内存的分配和回收技术已相当成熟，但如果需要排查内存溢出、内存泄露问题，或者要求高并发、高性能时，就需要对垃圾的回收进行监控和调节，以更好优化系统提高性能。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="https://blog.timberliu.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="https://blog.timberliu.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(6)之 HashMap 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/24/030_Java%E9%9B%86%E5%90%88%E4%B9%8B%20HashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/24/030_Java集合之 HashMap 源码解析/</id>
    <published>2019-02-23T16:00:00.000Z</published>
    <updated>2019-02-23T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>HashMap</code> 在日常开发中非常常用，它基于哈希表实现，以 <code>key-value</code> 形式存储。本文通过 <code>JDK1.8</code> 的源码，分析一下 <code>HashMap</code> 的内部结构和实现原理。</p><h1 id="HashMap-概述"><a href="#HashMap-概述" class="headerlink" title="HashMap 概述"></a>HashMap 概述</h1><p>在 <code>JDK1.7</code> 之前，<code>HashMap</code> 底层由数组 + 链表实现，也就是链表散列。当向 <code>HashMap</code> 中添加一个键值对时，首先计算 <code>key</code> 的 <code>hash</code> 值，以此确定插入数组中的位置，但可能会碰撞冲突，将其转换为链表存储。</p><p>而从 <code>JDK1.8</code> 开始，增加了红黑树，由数组 + 链表 + 红黑树实现，当链表长度超过 <code>8</code> 时，链表转换为红黑树以提高性能。<a id="more"></a><br>它的存储方式如下：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%E7%BB%93%E6%9E%84.png" width="50%"></p><h1 id="定义属性"><a href="#定义属性" class="headerlink" title="定义属性"></a>定义属性</h1><h2 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h2><p><code>HashMap</code> 的几个静态常量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认初始容量为 16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 最大容量为 2^30</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;        </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认负载因子为 0.75</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;     </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 默认链表中元素大于 8 时转为红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;             </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 扩容时，链表中元素小于这个值就会还原为链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 数组的容量大于 64 时才允许被树形化</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重要变量"><a href="#重要变量" class="headerlink" title="重要变量"></a>重要变量</h2><p>下面是 <code>HashMap</code> 中几个重要的变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">// 存储元素数组</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; <span class="comment">// 缓存 entry 返回的 Set </span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size; <span class="comment">// 键值对个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount; <span class="comment">// 内部结构修改次数</span></span><br><span class="line"><span class="keyword">int</span> threshold; <span class="comment">// 临界值</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">// 负载因子</span></span><br></pre></td></tr></table></figure><p><strong>Node&lt;K,V&gt;[] table</strong></p><p><code>Node&lt;K,V&gt;[] table</code> 数组用来存储具体的元素，是 <code>HashMap</code> 底层数组和链表的组成元素。在第一次使用时初始化(默认初始化容量为 <code>16</code>)，并在必要的时候进行扩容。</p><p>一般来说，由于素数导致冲突的概率较小，所以哈希表数组大小为素数。但 <code>Java</code> 的 <code>HashMap</code> 中采用非常规设计，数组的长度总是 <code>2</code> 的 <code>n</code> 次方，这样做可以在取模和扩容时做优化，同时也能减少碰撞冲突。</p><p><code>Node</code> 是 <code>HashMap</code> 的一个内部类，实现了 <code>Map.Entry</code> 接口，本质上就是一个映射（键值对）。它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;   <span class="comment">// 用来定位数组索引位置</span></span><br><span class="line">    <span class="keyword">final</span> K key;      <span class="comment">// 键</span></span><br><span class="line">    V value;          <span class="comment">// 值</span></span><br><span class="line">    Node&lt;K,V&gt; next;   <span class="comment">// 指向链表的下一个结点</span></span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; ··· &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重写了 hashCode 和 equals 方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123; ··· &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123; </span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">            <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                Objects.equals(value, e.getValue()))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>entrySet</strong></p><p><code>entrySet</code> 用于缓存 <code>entrySet()</code> 方法返回的 <code>Set</code>。后面会详细分析。</p><p><strong>size</strong></p><p><code>size</code> 是 <code>HashMap</code> 中键值对的数量。注意，键值对的数量 <code>size</code> 和哈希表数组的长度 <code>capacity</code>不同。</p><p><strong>modCount</strong></p><p><code>modCount</code> 用于记录 <code>HashMap</code> 内部结构发生变化的次数，用于使用迭代器遍历集合时修改内部结构，而快速失败。需要注意的是，这里指的是结构发生变化，例如增加或删除一个键值对或者扩容，但是修改键值对的值不属于结构变化。</p><p><strong>threshold 和 loadFactor</strong></p><p><code>threshold</code> 是 <code>HashMap</code> 能容纳的最大键值对个数，<code>loadFactor</code> 是负载因子，默认为 <code>0.75</code>。有如下等式(<code>capacity</code> 是数组容量)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">threshold = capacity * loadFactor;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">可以得出，在数组长度定义好之后，负载因子越大，所能容纳键值对越多。如果存储元素个数大于 `threshold`，就要进行扩容，扩容后的容量是之前的两倍。</span><br><span class="line"></span><br><span class="line">**TreeNode**</span><br><span class="line"></span><br><span class="line">当链表长度超过 `8`（阈值）时，将链表转换为红黑树存储，以提高查找的效率。下面是 `TreeNode` 的定义：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  // 父节点</span><br><span class="line">    TreeNode&lt;K,V&gt; left;    //左子树</span><br><span class="line">    TreeNode&lt;K,V&gt; right;   //右子树</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</span><br><span class="line">    boolean red;      //颜色属性</span><br><span class="line">    TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        super(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    // 返回当前节点的根节点</span><br><span class="line">    final TreeNode&lt;K,V&gt; root() &#123;</span><br><span class="line">        for (TreeNode&lt;K,V&gt; r = this, p;;) &#123;</span><br><span class="line">            if ((p = r.parent) == null)</span><br><span class="line">                return r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ······</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p><code>HashMap</code> 主要提供了四种构造方法：</p><p>1). 构造一个默认初始容量 <code>16</code> 和默认加载因子 <code>0.75</code> 的空 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2). 构造一个指定的初始容量和默认加载因子 <code>0.75</code> 的空 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3). 构造一个指定的初始容量和加载因子的空 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4). 使用给定的 <code>map</code> 构造一个新 <code>HashMap</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"># 基本方法</span><br><span class="line"></span><br><span class="line">`HashMap` 内部功能实现很多，这里主要从 `hash` 方法、`put` 方法、`get` 方法、`resize` 方法和 `entrySet` 方法进行分析。</span><br><span class="line"></span><br><span class="line">## hash 方法</span><br><span class="line"> </span><br><span class="line">`HashMap` 中，增删改查都需要用 `hash` 算法来计算元素在数组中的位置，所以 `hash` 算法是否均匀高效，对性能影响很大。看一下它的实现：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">// 优化了高位运算算法</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tab[i = (n - 1) &amp; hash] 取模</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    ···</span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>hash</code> 算法计算对象的保存位置，分为三步：取 <code>key</code> 的 <code>hashCode</code> 值、高位运算、取模运算。</p><p>由于取模元素消耗较大，<code>HashMap</code> 中用了一个很巧妙的方法，利用的就是底层数组长度总是 <code>2</code><br>的 <code>n</code> 次方。通过 <code>hash &amp; (table.length - 1)</code> 就可以得到对象的保存位置，相较于对 <code>length</code> 取模效率更高。</p><p><code>JDK1.8</code> 中优化了高位运算的算法，通过 <code>hashCode</code> 的高 <code>16</code> 位异或低 <code>16</code> 位实现。下面举例说明，<code>n</code> 为 <code>table</code> 的长度：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%E9%AB%98%E4%BD%8D%E8%BF%90%E7%AE%97.png" width="60%"></p><h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>来看一下 <code>HashMap</code> 的 <code>put</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用 hash 计算 key 的哈希值</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 如果 table 为空或长度为 0，则调用 resize 进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 根据 key 的 hash 计算数组索引值，如果当前位置为 null，则直接创建新节点插入</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// table[i] 不为空</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 如果 table[i] 的首元素和传入的 key 相等（hashCode 和 equals），则直接覆盖，这里容许 key 和 value 为 null</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 判断 table[i] 是否为 treeNode，即 table[i] 是否为红黑树，如果是则在树中插入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 否则遍历链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 如果 key 不存在</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 则新建一个结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 如果长度大于8，则转为红黑树处理</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果 key 已经存在，则直接覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 内部结构发生变化</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果超过最大容量就扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <code>put</code> 方法的几个步骤：：  </p><ul><li>判断哈希表数组 <code>table[]</code> 为空或者长度为 <code>0</code>，如果是则调用 <code>resize()</code> 进行扩容；</li><li>通过 <code>hash &amp; (table.length - 1)</code> 计算插入的数组索引值，如果当前位置为 <code>null</code>，则直接创建节点插入</li><li>判断 <code>table[i]</code> 的首个元素是否和 <code>key</code> 相等（<code>hashCode</code> 和 <code>equals</code>），如果相等则直接覆盖 <code>value</code>；</li><li>判断 <code>table[i]</code> 是否为 <code>treeNode</code>，即 <code>table[i]</code> 是否是红黑树，如果是红黑树，则直接在树中插入键值对；</li><li>否则遍历链表，如果 <code>key</code> 不存在，则直接创建节点插入，并判断链表长度是否大于 <code>8</code>，如果是红黑树则转为红黑树处理；如果遍历中发现 <code>key</code> 已经存在，则直接覆盖即可；</li><li>插入成功后，判断实际存在键值对是否超过了最大容量，如果是则进行扩容；</li></ul><p><code>HashMap</code> 的 <code>put</code> 方法可以通过下图理解：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23put%E6%96%B9%E6%B3%95.png" width="80%"></p><h2 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h2><p>来看一下 <code>HashMap</code> 的 <code>get</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">// 调用 getNode 方法，如果通过 key 获取的 Node 为 null，则返回 null；否则返回 node.value</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">// 如果数组不为空，数组长度大于 0</span></span><br><span class="line">    <span class="comment">// 通过 hash &amp; (length - 1) 计算数组的索引值，并且对应的位置不为 null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果桶中第一个元素与 key 相等，则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; </span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果当前桶是红黑树，则转换处理</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 否则，遍历链表处理</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h2><p>下面来分析一下 <code>resize</code> 方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    <span class="comment">// 保存原先的数组、容量、临界值</span></span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果扩容前容量 &gt; 0</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果数组大小已经达到最大 2^30，则修改阈值为最大值 2^31-1，以后也就不会再扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果没有超过最大值，就扩充为原来的 2 倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 如果扩容前容量 &lt;= 0，旧临界值 &gt; 0</span></span><br><span class="line">        <span class="comment">// 将数组的新容量设置为 旧数组扩容的临界值</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; <span class="comment">// 容量 &lt;= 0，旧临界值 &lt;= 0          </span></span><br><span class="line">        <span class="comment">// 否则设置为默认值</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的临界值</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建新的 table，容量为 newCap</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历旧哈希表的每个桶，将旧哈希表中的桶复制到新的哈希表中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果旧桶中只有一个 node</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="comment">// 则将 oldTab[j] 放入新哈希表中 e.hash &amp; (newCap - 1) 的位置</span></span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果旧桶中为红黑树，则转换处理</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>; <span class="comment">// 将下标不变的节点组织成一条链表</span></span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>; <span class="comment">// 将下标增加 oldCapaciry 的节点组织成另一条链表</span></span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="comment">// 原索引</span></span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到新数组中</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引 + oldCap 放到新数组中</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resize</code> 方法在扩容时，由于每次数组的长度变为原先的 <code>2</code> 倍，所以元素要么在原位置，要么在“原始位置 + 原数组长度”的位置。通过计算 <code>e.hash &amp; oldCap</code> 来判断是否需要移动。</p><p>看下图，<code>n</code> 为 <code>table</code> 的长度，图 <code>(a)</code> 为扩容前的 <code>key1</code> 和 <code>key2</code> 确定索引位置的示例，图 <code>(b)</code> 为扩容后的 <code>key1</code> 和 <code>key2</code> 确定索引位置的示例，其中 <code>key1(hash1)</code> 是 <code>key1</code> 对应的哈希与高位运算的结果：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23resize1.png" width="80%"></p><p>元素在重新计算 <code>hash</code> 后，因为 <code>n</code> 变为 <code>2</code> 倍，那么 <code>n - 1</code> 的 <code>mask</code> 的范围(红色)在高位多 <code>1bit</code>，因此新的 <code>index</code> 就会这样变化：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23resize2.png" width="80%"></p><p>因此，在扩容时，只需看看原来的 <code>hash</code> 值新增的 <code>bit</code> 位是 <code>1</code> 还是 <code>0</code>，如果是 <code>0</code>，索引不变，否则变成 “原索引 + <code>oldCapacity</code>“，可以看看下图 <code>16</code> 扩充为 <code>32</code> 的示意图：</p><p><img src="http://media.timberliu.com/image/2019/2/23/HashMap%23resize3.png" width="60%"></p><h2 id="entrySet-方法"><a href="#entrySet-方法" class="headerlink" title="entrySet 方法"></a>entrySet 方法</h2><p><code>HashMap</code> 的一种遍历方式就是使用 <code>entrySet</code> 方法返回的迭代器进行遍历。先来看一下 <code>entrySet</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</span><br><span class="line">    <span class="keyword">return</span> (es = entrySet) == <span class="keyword">null</span> ? (entrySet = <span class="keyword">new</span> EntrySet()) : es;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果缓存 <code>map</code> 中键值对的 <code>Set</code> 不为 <code>null</code>，则直接返回，否则会创建一个 <code>EntrySet</code> 对象。</p><p><code>EntrySet</code> 类的 <code>iterator</code> 方法会返回一个 <code>EntryIterator</code> 迭代器对象，另外还有两个迭代器 <code>KeyIterator</code>、<code>ValueIterator</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().key; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextNode().value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们三个都继承自 <code>HashIterator</code>，分别用于键遍历、值遍历、键值对遍历，它们都重写了 <code>Iterator</code> 的 <code>next</code> 方法，其中调用了 <code>HashIterator</code> 的 <code>nextNode</code> 方法。</p><p>而 <code>HashIterator</code> 是一个抽象类，实现了迭代器的大部分方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">    Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">    <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line"></span><br><span class="line">    HashIterator() &#123;</span><br><span class="line">        expectedModCount = modCount;</span><br><span class="line">        Node&lt;K,V&gt;[] t = table;</span><br><span class="line">        current = next = <span class="keyword">null</span>;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] t;</span><br><span class="line">        Node&lt;K,V&gt; e = next;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123; ··· &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出 <code>HashIterator</code> 迭代器的默认构造器中，将 <code>current</code> 设置为 <code>null</code>，然后循环在数组中查找不为 <code>null</code> 的桶， 让 <code>next</code> 指向第一个桶中的第一个节点 <code>Node</code>。</p><p>在遍历时，<code>next</code> 方法会调用 <code>nextNode()</code> 方法，这个方法首先把 <code>next</code> 赋给 <code>e</code> 以稍后返回，并把 <code>e</code> 赋给 <code>current</code>。然后判断 <code>next</code> 是否为空，如果不为空，返回 <code>e</code> 即可。</p><p>如果为空，就在数组中继续查找不为空的桶，找到后退出循环，最后返回 <code>e</code>。这样就能都遍历出来了。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><code>HashMap</code> 的特点主要有：</p><ul><li><code>HashMap</code> 根据键的 <code>hashCode</code> 值来存储数据，大多数情况下可以直接定位它的值，因而访问速度很快。</li><li><code>HashMap</code> 不保证插入的顺序。</li><li>扩容是一个特别耗能的操作，在使用 <code>HashMap</code> 时，最好估算 <code>map</code> 的大小，初始化时给定一个大致的数值，避免进行频繁的扩容。</li><li><code>threshold = capacity * loadFactor;</code> 如果存储元素个数大于 <code>threshold</code>，就要进行扩容，扩容后的容量是之前的两倍。</li><li>默认的负载因子 <code>0.75</code> 是时间和空间之间的一个平衡，一般不建议修改。</li><li><code>HashMap</code> 中 <code>key</code> 和 <code>value</code> 允许为 <code>null</code>，最多允许一条记录的键为 <code>null</code>，允许多条记录的值为 <code>null</code>。</li><li>它是非线程安全的。如果需要线程安全，可以使用 <code>Collections</code> 的 <code>synchronizedMap</code> 方法使 <code>HashMap</code> 具有线程安全的能力，或使用 <code>ConcurrentHashMap</code>。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li>美团技术团队：<a href="https://tech.meituan.com/2016/06/24/java-hashmap.html" target="_blank" rel="noopener">Java8系列之重新认识HashMap</a></li><li>潘威威：<a href="https://blog.csdn.net/panweiwei1994/article/details/77244920" target="_blank" rel="noopener">Java8源码-HashMap</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;HashMap&lt;/code&gt; 在日常开发中非常常用，它基于哈希表实现，以 &lt;code&gt;key-value&lt;/code&gt; 形式存储。本文通过 &lt;code&gt;JDK1.8&lt;/code&gt; 的源码，分析一下 &lt;code&gt;HashMap&lt;/code&gt; 的内部结构和实现原理。&lt;/p&gt;
&lt;h1 id=&quot;HashMap-概述&quot;&gt;&lt;a href=&quot;#HashMap-概述&quot; class=&quot;headerlink&quot; title=&quot;HashMap 概述&quot;&gt;&lt;/a&gt;HashMap 概述&lt;/h1&gt;&lt;p&gt;在 &lt;code&gt;JDK1.7&lt;/code&gt; 之前，&lt;code&gt;HashMap&lt;/code&gt; 底层由数组 + 链表实现，也就是链表散列。当向 &lt;code&gt;HashMap&lt;/code&gt; 中添加一个键值对时，首先计算 &lt;code&gt;key&lt;/code&gt; 的 &lt;code&gt;hash&lt;/code&gt; 值，以此确定插入数组中的位置，但可能会碰撞冲突，将其转换为链表存储。&lt;/p&gt;
&lt;p&gt;而从 &lt;code&gt;JDK1.8&lt;/code&gt; 开始，增加了红黑树，由数组 + 链表 + 红黑树实现，当链表长度超过 &lt;code&gt;8&lt;/code&gt; 时，链表转换为红黑树以提高性能。&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(5)之 List 总结</title>
    <link href="https://blog.timberliu.com/2019/02/23/029_Java%E9%9B%86%E5%90%88%E4%B9%8B%20List%20%E6%80%BB%E7%BB%93/"/>
    <id>https://blog.timberliu.com/2019/02/23/029_Java集合之 List 总结/</id>
    <published>2019-02-22T16:00:00.000Z</published>
    <updated>2019-02-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>前面两篇文章对 <code>ArrayList</code>、<code>LinkedList</code> 的源码进行了分析，这篇文章对 <code>List</code> 做个简单的总结。</p><h1 id="List-接口结构"><a href="#List-接口结构" class="headerlink" title="List 接口结构"></a>List 接口结构</h1><p><code>List</code> 以线性方式存储元素，其中允许存放重复元素，元素有序。主要有以下几个实现类：</p><ul><li><code>ArrayList</code>：随机访问元素效率较高，但增删元素较慢；</li><li><code>LinkedList</code>：增删元素效率较高，但随机访问效率较低；</li><li><code>Vector</code>：与 <code>ArrayList</code>，但它是线程安全的，同步通过 <code>synchronized</code> 实现，效率较低，一般不建议使用；</li><li><code>Stack</code>：是一个先进先出的栈，继承自 <code>Vector</code>；<a id="more"></a></li></ul><p>它的主要结构如下：</p><p><img src="http://media.timberliu.com/image/2019/2/22/List%20%E7%BB%93%E6%9E%84.jpg" width="60%"></p><h1 id="数组与-ArrayList-的区别"><a href="#数组与-ArrayList-的区别" class="headerlink" title="数组与 ArrayList 的区别"></a>数组与 ArrayList 的区别</h1><p>数组与 <code>ArrayList</code> 之间的区别如下：</p><ul><li>数组可以存储基本类型和对象；而 <code>ArrayList</code> 只能存储对象，需要进行拆装箱。所以如果特别关注性能，可以选用数组。</li><li>数组需要指定大小，且不能改变；而 <code>ArrayList</code> 可以指定或不指定初始化容量，且支持自动扩容。所以，如果数据大小已知，并且对数据的操作比较简单，可以使用数组。</li><li><code>ArrayList</code> 最大的优势就是封装了很多操作数组的方法。如果操作比较复杂，可以选用 <code>ArrayList</code>。</li><li>表示多维数组时，用数组更加直观。例如 <code>Object[][]</code>。</li></ul><p>其实一般来说，在普通业务开发中，直接使用 <code>ArrayList</code> 就可以了，相比于损耗一点点性能，换来使用上的方便简单，也是可以接受。</p><p>但如果做的是较底层的开发，如中间件，性能优化等，数组一般会比较好。</p><h1 id="ArrayList-与-LinkedList-的区别"><a href="#ArrayList-与-LinkedList-的区别" class="headerlink" title="ArrayList 与 LinkedList 的区别"></a>ArrayList 与 LinkedList 的区别</h1><p><strong>ArrayList</strong></p><p>优点：<code>ArrayList</code> 底层基于动态数组实现，由于地址连续，按照下标直接计算操作地址，随机访问效率较高。</p><p>缺点：但同样是因为地址连续，在插入和删除数据时，数组需要移动数据，所以插入和删除操作的效率较低。</p><p><strong>LinkedList</strong></p><p>优点：<code>LinkedList</code> 底层基于双向链表实现，由于地址是任意的，所以在创建节点时比较简单，增加和删除操作的效率比较高。另外，它也适用于队列、栈形式的场景。</p><p>缺点：由于 <code>LinkedList</code>  访问元素时需要一个一个地移动指针，所以随机访问的效率较低。</p><p><strong>适用场景</strong></p><p>可以按照如下要求进行选择：</p><ul><li>如果对数据随机访问的操作较多，则选用 <code>ArrayList</code>。</li><li>如果对数据的增加或删除操作较多，则选用 <code>LinkedList</code>。</li></ul><h1 id="ArrayList-与-Vector-的区别"><a href="#ArrayList-与-Vector-的区别" class="headerlink" title="ArrayList 与 Vector 的区别"></a>ArrayList 与 Vector 的区别</h1><p><code>ArrayList</code> 和 <code>Vector</code> 很相似，主要有以下三个区别：</p><ul><li><code>Vector</code> 是线程安全的，而 <code>ArrayList</code> 不是。<code>Vector</code> 中的方法被 <code>synchronized</code> 修饰，效率很低，一般不赞成使用。</li><li>两者都是基于动态数组实现，但是扩容时，两者的增加方式不同。<code>ArrayList</code> 每次扩至 <code>1.5</code> 倍，而 <code>Vector</code> 扩至 <code>2</code> 倍。</li><li><code>Vector</code> 可以设置扩容时的自增容量 <code>capacityIncrement</code>，而 <code>ArrayList</code> 不可以。</li><li><code>ArrayList</code> 支持 <code>Iterator</code> 和 <code>ListIterator</code> 迭代器；而 <code>Vector</code> 除此之外，还支持 <code>Enumeration</code>。</li></ul><p>它们的适用场景如下：</p><ul><li><code>Vector</code> 是线程安全的，而 <code>ArrayList</code> 是非线程安全的。如果在非多线程的情境下，一般采用 <code>ArrayList</code> 效率比较高。由于 <code>Vector</code> 效率较低，如果在多线程环境下，一般使用 <code>CopyOnWriteArrayList</code>。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面两篇文章对 &lt;code&gt;ArrayList&lt;/code&gt;、&lt;code&gt;LinkedList&lt;/code&gt; 的源码进行了分析，这篇文章对 &lt;code&gt;List&lt;/code&gt; 做个简单的总结。&lt;/p&gt;
&lt;h1 id=&quot;List-接口结构&quot;&gt;&lt;a href=&quot;#List-接口结构&quot; class=&quot;headerlink&quot; title=&quot;List 接口结构&quot;&gt;&lt;/a&gt;List 接口结构&lt;/h1&gt;&lt;p&gt;&lt;code&gt;List&lt;/code&gt; 以线性方式存储元素，其中允许存放重复元素，元素有序。主要有以下几个实现类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt;：随机访问元素效率较高，但增删元素较慢；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt;：增删元素效率较高，但随机访问效率较低；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Vector&lt;/code&gt;：与 &lt;code&gt;ArrayList&lt;/code&gt;，但它是线程安全的，同步通过 &lt;code&gt;synchronized&lt;/code&gt; 实现，效率较低，一般不建议使用；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Stack&lt;/code&gt;：是一个先进先出的栈，继承自 &lt;code&gt;Vector&lt;/code&gt;；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(4)之 LinkedList 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/22/028_Java%E9%9B%86%E5%90%88%E4%B9%8B%20LinkedList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/22/028_Java集合之 LinkedList 源码解析/</id>
    <published>2019-02-21T16:00:00.000Z</published>
    <updated>2019-02-21T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>LinkedList</code> 与 <code>ArrayList</code> 同样实现了 <code>List</code> 接口，但它基于双向链表实现，插入和删除操作效率较高，而随机访问效率较低。本文通过源码来分析一下 <code>LinkedList</code> 的实现原理，注意事项，使用场景等，以便能更好地使用它（<code>JDK</code> 版本为 <code>1.8</code>）。</p><p><code>LinkedList</code> 的主要特点如下：</p><ul><li><code>LinkedList</code> 是 <code>List</code> 接口和 <code>Deque</code> 接口的双向链表实现；</li><li><code>LinkedList</code> 实现了列表的所有操作，允许添加 <code>null</code>；<a id="more"></a></li><li><code>LinkedList</code> 不是同步的；</li><li>由 <code>iterator()</code> 和 <code>listIterator()</code> 返回的迭代器是 <code>fail-fast</code> 的。</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>先来看一下 <code>LinkedList</code> 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到 <code>LinkedList</code> 继承或实现了以下类或接口：</p><ul><li><code>AbstractSequentialList</code>：<br><code>AbstractSequentialList</code> 继承自 <code>AbstractList</code>，但 <code>AbstractSequentialList</code> 只支持按次序访问，而不像 <code>AbstractList</code> 那样支持随机访问。</li><li><code>List</code>：：实现了 <code>List</code> 接口，提供了所有可选列表操作。</li><li><code>Deque</code>：代表双端队列，这是 <code>LinkedList</code> 可用作队列或双端队列的原因。</li><li><code>Cloneable</code>：表明其可以被克隆，重写了 <code>clone</code> 方法。</li><li><code>java.io.Serializable</code>：表明该类是可以序列化的。</li></ul><p>但 <code>LinkedList</code> 没有实现 <code>RandomAccess</code>，说明 <code>LinkedList</code> 不支持随机访问，这就是 <code>LinkedList</code> 随机访问效率低的原因之一。</p><p><img src="http://media.timberliu.com/image/2019/2/20/LinkedList%20%E6%A1%86%E6%9E%B6.png" width="60%"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>LinkedList</code> 的属性主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节点个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向头节点的指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向尾节点的指针</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br></pre></td></tr></table></figure><p><code>LinkedList</code> 的内部类 <code>Node</code> 表示链表中的节点，包括一个数据域 <code>item</code>，一个后置指针 <code>next</code>，一个前置指针 <code>prev</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p><code>LinkedList</code> 中提供了两种构造方法：</p><p><strong>构造空链表</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用给定 collection 构造链表</strong></p><p>构造方法中，先构造一个空链表，再把指定集合 <code>collection</code> 中的所有元素都添加到 <code>LinkedList</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="操作链表的底层方法"><a href="#操作链表的底层方法" class="headerlink" title="操作链表的底层方法"></a>操作链表的底层方法</h1><p>下面是几个操作链表的底层方法：</p><h2 id="linkFirst-方法"><a href="#linkFirst-方法" class="headerlink" title="linkFirst 方法"></a>linkFirst 方法</h2><p>该方法用于在链表头添加元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使节点 f 指向原来的头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="comment">// 新建节点 Node，前驱指针指向 null，后置指针指向原来的头节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);</span><br><span class="line">    <span class="comment">// 头指针 first 指向新的头节点 newNode</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果原来的头节点为 null，则更新尾指针</span></span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则使原来的头节点 f 的前驱指针指向新的头节点 newNode</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="linkLast-方法"><a href="#linkLast-方法" class="headerlink" title="linkLast 方法"></a>linkLast 方法</h2><p>该方法用于在链表尾部添加元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使节点 l 指向原来的尾节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="comment">// 新建节点 Node，前驱指针指向 l，后置指针指向 null</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 尾指针 last 指向新的尾节点 newNode</span></span><br><span class="line">    last = newNode;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果原来的头节点为 null，则更新头指针</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则使原来的尾节点 l 的后置指针指向新的尾节点 newNode</span></span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="linkBefore-方法"><a href="#linkBefore-方法" class="headerlink" title="linkBefore 方法"></a>linkBefore 方法</h2><p>该方法用于在指定节点 <code>succ</code> 之前添加元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得指定节点 succ 的前驱节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">    <span class="comment">// 新建节点 newNode，前置指针指向 pred，后置指针指向 succ</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">    <span class="comment">// succ 的前置指针指向 newNode</span></span><br><span class="line">    succ.prev = newNode;</span><br><span class="line">    <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果指定节点的前驱节点为 null，则将 newNode 置为头节点</span></span><br><span class="line">        first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则更新 pred 的后置节点</span></span><br><span class="line">        pred.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlinkFirst-方法"><a href="#unlinkFirst-方法" class="headerlink" title="unlinkFirst 方法"></a>unlinkFirst 方法</h2><p>该方法用于删除头节点，并返回头节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存头节点的值</span></span><br><span class="line">    <span class="keyword">final</span> E element = f.item;</span><br><span class="line">    <span class="comment">// 保存头节点的下一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">    <span class="comment">// 头节点的值置为 null</span></span><br><span class="line">    f.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 头节点的后置指针置为 null</span></span><br><span class="line">    f.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 将头节点置为 next</span></span><br><span class="line">    first = next;</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果 next 为 null，将尾节点置为 null</span></span><br><span class="line">        last = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则将 next 的前驱指针指向 null</span></span><br><span class="line">        next.prev = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlinkLast-方法"><a href="#unlinkLast-方法" class="headerlink" title="unlinkLast 方法"></a>unlinkLast 方法</h2><p>该方法用于删除尾节点，并返回尾节点的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存尾节点的值</span></span><br><span class="line">    <span class="keyword">final</span> E element = l.item;</span><br><span class="line">    <span class="comment">// 保存尾节点的前一个节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">    <span class="comment">// 尾节点的值置为 null</span></span><br><span class="line">    l.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 尾节点的前驱指针指向 null</span></span><br><span class="line">    l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">    <span class="comment">// 将尾节点置为 prev</span></span><br><span class="line">    last = prev;</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">// 如果 prev 为 null，将头节点置为 null</span></span><br><span class="line">        first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则将 prev 的后置指针指向 null</span></span><br><span class="line">        prev.next = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unlink-方法"><a href="#unlink-方法" class="headerlink" title="unlink 方法"></a>unlink 方法</h2><p>该方法用于删除指定的节点 <code>x</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保存指定节点的值、前驱节点、后置节点</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果前驱节点为 null，表示删除的是头节点，则将 first 指向为 next</span></span><br><span class="line">        first = next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将 prev 的后置指针指向 next，x 的前置指针指向 null</span></span><br><span class="line">        prev.next = next;</span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果后置节点为 null，表示删除的是尾节点，则将 last 指向 prev</span></span><br><span class="line">        last = prev;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则将 next 的前置指针指向 prev，x 的后置指针指向 null</span></span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x 的值置为 null</span></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="基本链表方法"><a href="#基本链表方法" class="headerlink" title="基本链表方法"></a>基本链表方法</h1><h2 id="add-E-方法"><a href="#add-E-方法" class="headerlink" title="add(E) 方法"></a>add(E) 方法</h2><p><code>add</code> 方法在链表的末尾添加指定的元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove-Object-方法"><a href="#remove-Object-方法" class="headerlink" title="remove(Object) 方法"></a>remove(Object) 方法</h2><p><code>remove</code> 方法用于在删除链表中出现的第一个指定的元素 <code>o</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 o 为 null，遍历链表，删除第一个值为 null 的节点，返回 true</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则删除第一个值为 o 的节点。如果链表中存在 o，就返回 true。</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addAll-int-Collection-lt-extends-E-gt-方法"><a href="#addAll-int-Collection-lt-extends-E-gt-方法" class="headerlink" title="addAll(int, Collection&lt;? extends E&gt;) 方法"></a>addAll(int, Collection&lt;? extends E&gt;) 方法</h2><p><code>addAll</code> 方法将给定的 <code>collection</code> 集合插入到从 <code>index</code> 位置开始的 <code>List</code> 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查插入到位置是否合法</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 c 转换为数组</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)   <span class="comment">// 如果 c 为空，那么就返回 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使 pred 指向插入点前面的节点，succ 指向插入点后面（pred 的下一个）节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历数组，逐个将元素插入到插入点</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回索引为 index 位置的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="comment">// 如果 index 小于链表的一半，则从表头开始遍历</span></span><br><span class="line">        Node&lt;E&gt; x = first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            x = x.next;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则从链表尾开始遍历</span></span><br><span class="line">        Node&lt;E&gt; x = last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">            x = x.prev;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addAll</code> 方法在链表中间插入元素原理图如下：</p><p><img src="http://media.timberliu.com/image/2019/2/21/LinkedList%23addAll%28%29.jpg" width="60%"></p><h2 id="add-int-E-方法"><a href="#add-int-E-方法" class="headerlink" title="add(int, E) 方法"></a>add(int, E) 方法</h2><p>此 <code>add</code> 方法用于在 <code>List</code> 中索引为 <code>index</code> 位置插入元素 <code>element</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (index == size)</span><br><span class="line">        <span class="comment">// 如果 index 等于 size，则插入到链表尾</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 否则，插入到索引为 index 位置之前</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="set-int-E-方法"><a href="#set-int-E-方法" class="headerlink" title="set(int, E) 方法"></a>set(int, E) 方法</h2><p><code>set</code> 方法用给定的元素 <code>element</code> 代替 <code>List</code> 中索引为 <code>index</code> 位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 返回索引为 index 位置的节点</span></span><br><span class="line">    Node&lt;E&gt; x = node(index);</span><br><span class="line">    E oldVal = x.item;</span><br><span class="line">    x.item = element;</span><br><span class="line">    <span class="keyword">return</span> oldVal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="get-int-方法"><a href="#get-int-方法" class="headerlink" title="get(int) 方法"></a>get(int) 方法</h2><p><code>get</code> 方法会返回 <code>List</code> 中指定位置 <code>index</code> 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="indexOf-Ojbect-方法"><a href="#indexOf-Ojbect-方法" class="headerlink" title="indexOf(Ojbect) 方法"></a>indexOf(Ojbect) 方法</h2><p><code>index</code> 方法返回 <code>List</code> 中指定元素第一次出现的下标。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 o 为 null，遍历链表，查找第一个为 null 的元素，返回 index</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则查找第一个为 Object 的元素，返回 index</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="getFirst-getLast-方法"><a href="#getFirst-getLast-方法" class="headerlink" title="getFirst/getLast 方法"></a>getFirst/getLast 方法</h2><p><code>getFirst</code> 方法返回链表中第一个元素，而 <code>getLast</code> 方法返回链表中最后一个元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="removeFirst-removeLast-方法"><a href="#removeFirst-removeLast-方法" class="headerlink" title="removeFirst/removeLast 方法"></a>removeFirst/removeLast 方法</h2><p><code>removeFirst</code> 方法从 <code>list</code> 中删除第一个元素，并返回它；而 <code>removeLast</code> 方法从 <code>list</code> 中删除最后一个元素，并返回它。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="addFirst-addLast-方法"><a href="#addFirst-addLast-方法" class="headerlink" title="addFirst/addLast 方法"></a>addFirst/addLast 方法</h2><p><code>addFirst</code> 方法在链表头插入指定元素；<code>addLast</code> 方法在链表尾插入指定元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkFirst(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="队列方法"><a href="#队列方法" class="headerlink" title="队列方法"></a>队列方法</h1><h2 id="peek-element-方法"><a href="#peek-element-方法" class="headerlink" title="peek/element 方法"></a>peek/element 方法</h2><p><code>peek/element</code> 方法都是返回队列的队首元素。但是，如果队列为空，<code>peek</code> 方法返回 <code>null</code>，而 <code>element</code> 方法会抛出 <code>NoSuchElementException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll-remove-方法"><a href="#poll-remove-方法" class="headerlink" title="poll/remove 方法"></a>poll/remove 方法</h2><p><code>poll/remvoe</code> 方法都是删除队列的队首元素，并返回。但是如果队列为空，<code>poll</code> 方法会返回空，而 <code>remove</code> 方法会抛出 <code>NoSuchElementException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="offer-方法"><a href="#offer-方法" class="headerlink" title="offer 方法"></a>offer 方法</h2><p><code>offer</code> 方法在队列的队尾处添加指定元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="双端队列方法"><a href="#双端队列方法" class="headerlink" title="双端队列方法"></a>双端队列方法</h1><h2 id="offerFirst-offerLast-方法"><a href="#offerFirst-offerLast-方法" class="headerlink" title="offerFirst/offerLast 方法"></a>offerFirst/offerLast 方法</h2><p><code>offerFirst</code> 方法在队列的队首添加元素；而 <code>offerLast</code> 方法在队列的队尾添加元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offerLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addLast(e);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="peekFirst-peekLast-方法"><a href="#peekFirst-peekLast-方法" class="headerlink" title="peekFirst/peekLast 方法"></a>peekFirst/peekLast 方法</h2><p><code>peekFirst</code> 方法会返回队列的队首元素，但不删除。如果队列为空，会返回 <code>null</code>。</p><p><code>peekLast</code> 方法会返回队列的队尾元素，但不删除。如果队列为空，会返回 <code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pollFirst-pollLast-方法"><a href="#pollFirst-pollLast-方法" class="headerlink" title="pollFirst/pollLast 方法"></a>pollFirst/pollLast 方法</h2><p><code>pollFirst</code> 方法会删除队列的队首元素，并返回。如果队列为空，则返回 <code>null</code>。</p><p><code>pollLast</code> 方法会删除队列的队尾元素，并返回。如果队列为空，则返回 <code>null</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkFirst(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈方法"><a href="#栈方法" class="headerlink" title="栈方法"></a>栈方法</h1><p><code>push</code> 方法将指定元素压入到栈顶。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    addFirst(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>pop</code> 方法从栈顶弹出元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 与 &lt;code&gt;ArrayList&lt;/code&gt; 同样实现了 &lt;code&gt;List&lt;/code&gt; 接口，但它基于双向链表实现，插入和删除操作效率较高，而随机访问效率较低。本文通过源码来分析一下 &lt;code&gt;LinkedList&lt;/code&gt; 的实现原理，注意事项，使用场景等，以便能更好地使用它（&lt;code&gt;JDK&lt;/code&gt; 版本为 &lt;code&gt;1.8&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;LinkedList&lt;/code&gt; 的主要特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 是 &lt;code&gt;List&lt;/code&gt; 接口和 &lt;code&gt;Deque&lt;/code&gt; 接口的双向链表实现；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;LinkedList&lt;/code&gt; 实现了列表的所有操作，允许添加 &lt;code&gt;null&lt;/code&gt;；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(3)之 ArrayList 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/21/027_Java%E9%9B%86%E5%90%88%E4%B9%8B%20ArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/21/027_Java集合之 ArrayList 源码解析/</id>
    <published>2019-02-20T16:00:00.000Z</published>
    <updated>2019-02-20T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>ArrayList</code> 在日常开发中非常常用，它是 <code>List</code> 接口的可变长数组的实现，提供了添加、修改、删除、遍历等功能。本文通过源码来分析一下 <code>ArrayList</code> 的实现原理，注意事项，使用场景等（<code>JDK</code> 版本为 <code>1.8</code>）。</p><p><code>ArrayList</code> 的特点如下：</p><ul><li><code>ArrayList</code> 基于数组方式实现，可以自动扩容；但由于扩容比较耗时，所以在初始化 <code>ArrayList</code> 时最好预判一下初始化容量；</li><li><code>ArrayList</code> 中允许插入 <code>null</code> 元素；<a id="more"></a></li><li>由于实现了 <code>Serializable</code> 接口，重写了 <code>writeObject</code> 和 <code>readObject</code> 方法，所以 <code>ArrayList</code> 支持序列化和反序列化；</li><li><code>ArrayList</code> 不是同步的；</li><li><code>ArrayList</code>的 <code>iterator</code> 和 <code>listIterator</code>方法返回的迭代器是 <code>fail-fast</code> 的。</li></ul><h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>首先，来看一下 <code>ArrayList</code> 的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>可以看到 <code>ArrayList</code> 继承或实现了以下类或接口：</p><ul><li><code>AbstractList</code> ：继承了 <code>AbstractList</code>。<code>AbstractList</code> 提供了 <code>List</code> 接口的骨干实现，以最大限度地减少（如 <code>ArrayList</code>）实现 <code>List</code> 所需的工作。</li><li><code>List</code>：实现了 <code>List</code> 接口。提供了所有可选列表操作。</li><li><code>RandomAccess</code>：表明 <code>ArrayList</code> 支持随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。</li><li><code>Cloneable</code>：表明其可以被克隆，重写了 <code>clone</code> 方法。</li><li><code>java.io.Serializable</code>：表明该类支持序列化。</li></ul><p>下面是 <code>ArrayList</code> 的类结构层次图：</p><p><img src="http://media.timberliu.com/image/2019/2/20/ArrayList%20%E6%A1%86%E6%9E%B6.png" width="60%"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p><code>ArrayList</code> 的属性主要有：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化 id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8683452581122892189L</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定 ArrayList 的容量为 0 时，返回该空数组 </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果调用默认构造器（无参构造方法），则返回该空数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 存储当前元素的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData; </span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList 的大小（包含的元素数目）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配给数组的最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>除此之外，还有一个从 <code>AbstarctList</code> 继承的 <code>modCount</code> 属性，它代表 <code>ArrayList</code> 集合的修改次数。在遍历集合时，如果 <code>modCount</code> 被更改，就会抛出 <code>ConcurrentModificationExceptioin</code> 异常。</p><h1 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h1><p>在 <code>ArrayList</code> 中，提供了三种构造方法：</p><p><strong>默认构造方法</strong></p><p>不传入参数的默认构造方法会构造一个初始容量为 <code>10</code> 的空列表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>指定容量</strong></p><p>这个构造方法会构造一个指定初始化容量为 <code>initialCapacity</code> 的空 <code>ArrayList</code>。如果指定初始化容量为负，则会抛出 <code>IllegalArgumentException</code> 异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用给定 collection 构造数组</strong></p><p>这个方法会构造一个包含指定 <code>collection</code> 的元素的列表，这些元素是按照该 <code>collection</code> 的迭代器返回它们的顺序排列的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断 elementData 是否为 Object[] 类型</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用空数组代替</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里首先会将传入的 <code>elementData</code> 转换为数组，然后使用 <code>Arrays.copyOf</code> 方法将元素拷贝到 <code>elementData</code> 数组中。</p><h1 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h1><p><code>ArrayList</code> 的主要方法如下：</p><h2 id="get-int-index-方法"><a href="#get-int-index-方法" class="headerlink" title="get(int index) 方法"></a>get(int index) 方法</h2><p><code>get</code> 方法用于返回 <code>list</code> 中索引为 <code>index</code> 的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法中首先检查索引，如果索引超过数组的长度，则会抛出 <code>IndexOutOfBoundsException</code> 异常。</p><p>然后使用 <code>elementData</code> 方法获取元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>ArrayList</code> 底层由数组实现，通过数组下标获取元素，它的时间复杂度为 <code>O(1)</code>。</p><h2 id="add-E-e-方法"><a href="#add-E-e-方法" class="headerlink" title="add(E e) 方法"></a>add(E e) 方法</h2><p><code>add</code> 方法用于在 <code>list</code> 的末尾添加指定的元素 <code>e</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>); </span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，首先是 <code>ensureCapacityInternal(size + 1)</code> 方法，这个方法对数组容量进行检查，如果不够则进行扩容，只供内部使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>扩容方法 <code>grow</code>，会保证至少能存储 <code>minCapacity</code> 个元素。实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，扩容后的容量按照如下方式计算：</p><ul><li>第一次扩容，使用 <code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code> 公式，将容量增加一半；</li><li>如果容量还是小于 <code>minCapacity</code>，就将容量扩充为 <code>minCapacity</code>；</li><li>如果容量大于 <code>MAX_ARRAY_SIZE</code>，就将容量扩充为 <code>Integer.MAX_VALUE</code>。</li></ul><p>最后，使用 <code>Arrays.copyOf</code> 方法将元素拷贝到新数组中即可。</p><h2 id="add-index-element-方法"><a href="#add-index-element-方法" class="headerlink" title="add(index, element) 方法"></a>add(index, element) 方法</h2><p>这个 <code>add</code> 方法用于在 <code>list</code> 中指定的位置插入元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法首先会对指定的位置 <code>index</code> 进行检查，如果越界，就会抛出 <code>IndexOutOfBoundsException</code> 异常。然后使用 <code>ensureCapacityInternal</code> 方法判断容量并进行扩容。</p><p>然后，使用 <code>System.arraycopy()</code> 方法将索引为 <code>index</code> 位置之后的元素向后移动一位，再将 <code>index</code> 位置赋值为 <code>element</code>。</p><h2 id="remove-index-方法"><a href="#remove-index-方法" class="headerlink" title="remove(index) 方法"></a>remove(index) 方法</h2><p><code>remove</code> 方法用于删除 <code>list</code> 中指定索引 <code>index</code> 位置的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先使用 <code>rangeCheck</code> 方法检查 <code>index</code> 是否越界，然后修改 <code>modCount</code>，表示修改次数加一。再使用 <code>elementData</code> 方法获取 <code>index</code> 位置的元素，方便稍后返回。</p><p>使用 <code>size-index-1</code> 计算左移的位数，再使用 <code>System.arraycopy()</code> 方法向左移动一位，也就表示删除了该元素。最后将 <code>--size</code> 位置的元素置为 <code>null</code>，避免对象游离，使 <code>JVM</code> 回收。</p><h1 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h1><p>迭代器提供了一种方法来访问集合中的元素。<code>Array</code> 类中的 <code>iterator()</code> 方法用来从容器对象中返回一个指向 <code>list</code> 开始处的迭代器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>Itr</code> 类实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// 下一个要返回的元素的索引</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// 上一个被返回的元素的索引，如果没有返回 -1</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">        checkForComodification();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">            cursor = lastRet;</span><br><span class="line">            lastRet = -<span class="number">1</span>;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">    &#125;</span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Itr</code> 类的主要方法如下：</p><ul><li><code>next()</code>：获取序列中的下个元素；</li><li><code>hasNext()</code>：检查序列中是否还有下一个元素；</li><li><code>remove()</code>：将迭代器最近返回的一个元素删除。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 在日常开发中非常常用，它是 &lt;code&gt;List&lt;/code&gt; 接口的可变长数组的实现，提供了添加、修改、删除、遍历等功能。本文通过源码来分析一下 &lt;code&gt;ArrayList&lt;/code&gt; 的实现原理，注意事项，使用场景等（&lt;code&gt;JDK&lt;/code&gt; 版本为 &lt;code&gt;1.8&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ArrayList&lt;/code&gt; 的特点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 基于数组方式实现，可以自动扩容；但由于扩容比较耗时，所以在初始化 &lt;code&gt;ArrayList&lt;/code&gt; 时最好预判一下初始化容量；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ArrayList&lt;/code&gt; 中允许插入 &lt;code&gt;null&lt;/code&gt; 元素；&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合之 Collections 源码解析</title>
    <link href="https://blog.timberliu.com/2019/02/20/026_Java%E9%9B%86%E5%90%88%E4%B9%8B%20Collections%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>https://blog.timberliu.com/2019/02/20/026_Java集合之 Collections 源码解析/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>Java</code> 集合框架中，有两个经常使用的工具类：<code>Collections</code> 和 <code>Arrays</code>。<code>Collections</code> 用来操作集合，而 <code>Arrays</code> 用来操作数组。这篇文章就来分析一个 <code>Collections</code> 类。<a id="more"></a></p><p>网上查了一下，有两篇文章写得很好，本篇文章基本就是对它们的整理。</p><ul><li><a href="https://blog.csdn.net/u011240877/article/details/78348578#" target="_blank" rel="noopener">Java 常用工具类 Collections 源码分析</a></li><li><a href="https://www.jianshu.com/p/51ce612db017" target="_blank" rel="noopener">Java1.8-Collections源码解析</a></li></ul><h1 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort 方法"></a>sort 方法</h1><p><code>Collections</code> 有两个 <code>sort</code> 方法，第一个方法要求 <code>List</code> 中的对象必须要实现 <code>Comparable</code> 接口；而第二个方法则不要求实现 <code>Comparable</code> 接口，但可以使用自定义的比较器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    list.sort(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span> </span>&#123;</span><br><span class="line">    list.sort(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但两者底层实现都是通过 <code>List</code> 接口的默认方法 <code>sort</code>。首先将 <code>List</code> 对象转换成数组，然后使用 <code>Arrays.sort</code> 方法排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = <span class="keyword">this</span>.toArray();</span><br><span class="line">    Arrays.sort(a, (Comparator) c);</span><br><span class="line">    ListIterator&lt;E&gt; i = <span class="keyword">this</span>.listIterator();</span><br><span class="line">    <span class="keyword">for</span> (Object e : a) &#123;</span><br><span class="line">        i.next();</span><br><span class="line">        i.set((E) e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对 <code>Arrays.sort</code> 方法稍后进行详细分析。</p><h1 id="binarySearach-方法"><a href="#binarySearach-方法" class="headerlink" title="binarySearach 方法"></a>binarySearach 方法</h1><p>二分查找需要集合已经有序，如果没有排序那也就没有意义。同样地，<code>Collections</code> 也有两个 <code>binarySearach</code> 方法，这里只看一下实现了 <code>Comparable</code> 接口的对象的二分查找方法。对于指定比较器的算法其实是一样的，区别在于比较的标准不同。</p><p><code>binarySearach</code> 方法中，如果 <code>List</code> 支持随机访问，或者小于二分查找的阈值 <code>BINARYSEARCH_THRESHOLD(5000)</code>，则调用 <code>indexedBinarySearch</code>，否则调用 <code>iteratorBinarySearch</code>，借助迭代器来访问.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</span><br><span class="line">        <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先来看一下 <code>indexedBinarySearch</code> 方法，由于支持随机访问，所以查找的平均时间复杂度为 <code>O(logn)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">indexedBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// 无符号右移，相当于除 2</span></span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = list.get(mid); <span class="comment">// get 时间复杂度为 O(1)</span></span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>iteratorBinarySearch</code> 方法，不能支持随机访问，就需要使用迭代器保存之前访问的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">int</span> <span class="title">iteratorBinarySearch</span><span class="params">(List&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; list, T key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = list.size()-<span class="number">1</span>;</span><br><span class="line">    ListIterator&lt;? extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; i = list.listIterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> T&gt; midVal = get(i, mid);</span><br><span class="line">        <span class="keyword">int</span> cmp = midVal.compareTo(key);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid; <span class="comment">// key found</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -(low + <span class="number">1</span>);  <span class="comment">// key not found</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">get</span><span class="params">(ListIterator&lt;? extends T&gt; i, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    T obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = i.nextIndex();</span><br><span class="line">    <span class="keyword">if</span> (pos &lt;= index) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            obj = i.next();</span><br><span class="line">        &#125; <span class="keyword">while</span> (pos++ &lt; index);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            obj = i.previous();</span><br><span class="line">        &#125; <span class="keyword">while</span> (--pos &gt; index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Collections.get()</code> 方法，每次查找中间点都需要移动指针。所以时间复杂度会达到 <code>O(n)</code>。</p><h1 id="reverse-方法"><a href="#reverse-方法" class="headerlink" title="reverse 方法"></a>reverse 方法</h1><p>下面来看一下 <code>reverse</code> 反转列表的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; REVERSE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</span><br><span class="line">            swap(list, i, j);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ListIterator fwd = list.listIterator();</span><br><span class="line">        ListIterator rev = list.listIterator(size);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=list.size()&gt;&gt;<span class="number">1</span>; i&lt;mid; i++) &#123;</span><br><span class="line">            Object tmp = fwd.next();</span><br><span class="line">            fwd.set(rev.previous());</span><br><span class="line">            rev.set(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List l = list;</span><br><span class="line">    l.set(i, l.set(j, l.get(i)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，同样的这里判断是否支持随机访问，或 <code>list</code> 小于反转的阈值 <code>REVERSE_THRESHOLD</code>。</p><p>如果支持随机访问，则先交换第一个和最后一个元素，然后第二个和倒数第二个元素，一直到中间位置。这里的 <code>swap</code> 交换很巧妙：</p><ol><li>使用 <code>l.get(i)</code> 得到 <code>i</code> 位置的元素；</li><li>使用 <code>l.set(j, l.get(i))</code> 将 <code>i</code> 位置的元素设置到 <code>j</code> 位置；</li><li>由于 set 方法会返回设置之前的元素，所以整体的 <code>l.set(···)</code> 会将 <code>j</code> 位置的元素设置到 <code>i</code> 位置；</li></ol><p>如果不支持随机访问，就是用两个迭代器，一个从头开始，一个从尾开始，交换元素，一直到中间位置。</p><p><code>Collections</code> 中的 <code>reverse</code> 方法在反转列表时，是交换对象中的值。对于链表，还有另外一种实现，是直接交换链表中的结点。</p><h1 id="shuffle-方法"><a href="#shuffle-方法" class="headerlink" title="shuffle 方法"></a>shuffle 方法</h1><p>下面来看一下 <code>shuffle</code> 打乱列表中元素的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list, Random rnd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size &lt; SHUFFLE_THRESHOLD || list <span class="keyword">instanceof</span> RandomAccess) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Object arr[] = list.toArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Shuffle array</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</span><br><span class="line">            swap(arr, i-<span class="number">1</span>, rnd.nextInt(i));</span><br><span class="line"></span><br><span class="line">        ListIterator it = list.listIterator();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            it.next();</span><br><span class="line">            it.set(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，这里判断是否 <code>list</code> 支持随机访问，或者 <code>list</code> 小于 <code>SHUFFLE_THRESHOLD</code>。</p><p>如果支持随机访问，就使用 <code>random</code> 生成一个小于 <code>i</code> 的值，使用 <code>swap</code> 方法随机交换元素。</p><p>如果不支持，首先将 <code>list</code> 转换成数组，然后遍历数组随机交换元素，最后又遍历把打乱的元素写回列表。</p><h1 id="rotate-方法"><a href="#rotate-方法" class="headerlink" title="rotate 方法"></a>rotate 方法</h1><p>下面来看一下 <code>rotate</code> 旋转方法，也就是对集合中的元素进行右移，可以指定移动的距离 <code>distance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size() &lt; ROTATE_THRESHOLD)</span><br><span class="line">        rotate1(list, distance);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rotate2(list, distance);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样地，这里判断 <code>list</code> 支持随机访问，或者 <code>list</code> 小于 <code>ROTATE_THRESHOLD</code>。如果支持随机访问，就调用 <code>rotate1</code>，否则就调用 <code>rotate2</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">rotate1</span><span class="params">(List&lt;T&gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    distance = distance % size;</span><br><span class="line">    <span class="keyword">if</span> (distance &lt; <span class="number">0</span>)</span><br><span class="line">        distance += size;</span><br><span class="line">    <span class="keyword">if</span> (distance == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> cycleStart = <span class="number">0</span>, nMoved = <span class="number">0</span>; nMoved != size; cycleStart++) &#123;</span><br><span class="line">        T displaced = list.get(cycleStart);</span><br><span class="line">        <span class="keyword">int</span> i = cycleStart;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            i += distance;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">                i -= size;</span><br><span class="line">            displaced = list.set(i, displaced);</span><br><span class="line">            nMoved ++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (i != cycleStart);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于 <code>rotate2</code> 方法，则借助于反转方法 <code>reverse</code> 来进行操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rotate2</span><span class="params">(List&lt;?&gt; list, <span class="keyword">int</span> distance)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = list.size();</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =  -distance % size;</span><br><span class="line">    <span class="keyword">if</span> (mid &lt; <span class="number">0</span>)</span><br><span class="line">        mid += size;</span><br><span class="line">    <span class="keyword">if</span> (mid == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    reverse(list.subList(<span class="number">0</span>, mid));</span><br><span class="line">    reverse(list.subList(mid, size));</span><br><span class="line">    reverse(list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里三个 <code>reverse</code> 方法非常巧妙，比如要对 <code>[1,2,3,4,5,6,7,8,9]</code> 进行 <code>3</code> 位旋转，则我们旋转的方式可以是：先对前 <code>size-3</code> 位进行反转，然后再对后 <code>3</code> 位进行反转，最后整体再进行反转就可以实现旋转的操作了。</p><p>其中，<code>mid</code> 的值就是确定要前后反转的中间值。我们用一张图来看一下就明白了：</p><p><img src="http://media.timberliu.com/image/2019/2/20/Collections%23reverse%20%E5%8F%8D%E8%BD%AC.jpg" width="50%"></p><h1 id="unmodifiable-方法"><a href="#unmodifiable-方法" class="headerlink" title="unmodifiable 方法"></a>unmodifiable 方法</h1><p><code>Collections</code> 提供了一系列以 <code>unmodifiable</code> 开头的方法，用来在原集合基础上生成一个不可变的集合。例如 <code>unmodifiableCollection</code>、<code>unmodifiableList</code>、<code>unmodifiableMap</code> 等。</p><p>看一下 <code>Collections.unmodifiableCollection(c)</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Collection&lt;T&gt; <span class="title">unmodifiableCollection</span><span class="params">(Collection&lt;? extends T&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UnmodifiableCollection&lt;&gt;(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以返回一个容器的包装类，这个包装类的添加、替换、删除等修改操作都会抛出异常 <code>UnsupportedOperationException</code>。例如 <code>UnmodifiableCollection</code> 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h1 id="synchronized-方法"><a href="#synchronized-方法" class="headerlink" title="synchronized 方法"></a>synchronized 方法</h1><p><code>Collections</code> 也提供了一系列以 <code>synchronized</code> 开头的方法，用来将原集合转成一个线程安全的集合。例如 <code>synchronizedList</code>，<code>synchronizedMap</code> 等。</p><p>看一下 <code>synchronizedList</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">synchronizedList</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (list <span class="keyword">instanceof</span> RandomAccess ?</span><br><span class="line">            <span class="keyword">new</span> SynchronizedRandomAccessList&lt;&gt;(list) :</span><br><span class="line">            <span class="keyword">new</span> SynchronizedList&lt;&gt;(list));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它可以返回一个容器的包装类 <code>SynchronizedRandomAccessList</code> 或 <code>SynchronizedList</code>，这个包装类的添加、替换、删除等操作都使用了 <code>synchronized</code> 关键字。例如 <code>SynchronizedList</code> 类中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.get(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.set(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;list.add(index, element);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> list.remove(index);&#125;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>几乎所有方法都使用了 <code>synchronized</code> 关键字，这样得到的集合在并发环境下效率不是很高。</p><h1 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h1><p>当然，<code>Collections</code> 类中还有很多方法：</p><ul><li>以 <code>checked</code> 开头的方法：获取动态类型检查的集合；</li><li><code>frequency</code> 方法：用于获取某一个元素在集合中出现的次数，并且可以统计 <code>null</code>；</li><li><code>fill()</code> 方法：用于使用指定的元素替换列表中的所有元素；</li><li><code>min()/max()</code> 方法：求集合中的最大最小值；</li><li><code>indexOfSubList</code>、<code>lastIndexOfSubList</code> 方法：查找子列表最早出现或最后出现的索引；</li><li><code>replaceAll</code> 方法：替换集合中的某一个元素为新的元素，可以替换 <code>null</code> 元素；</li><li><code>copy</code> 方法：将原集合中元素拷贝到另一个集合中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 &lt;code&gt;Java&lt;/code&gt; 集合框架中，有两个经常使用的工具类：&lt;code&gt;Collections&lt;/code&gt; 和 &lt;code&gt;Arrays&lt;/code&gt;。&lt;code&gt;Collections&lt;/code&gt; 用来操作集合，而 &lt;code&gt;Arrays&lt;/code&gt; 用来操作数组。这篇文章就来分析一个 &lt;code&gt;Collections&lt;/code&gt; 类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(2)之 Iterator 迭代器</title>
    <link href="https://blog.timberliu.com/2019/02/20/025_Java%E9%9B%86%E5%90%88%E4%B9%8B%20Iterator%20%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>https://blog.timberliu.com/2019/02/20/025_Java集合之 Iterator 迭代器/</id>
    <published>2019-02-19T16:00:00.000Z</published>
    <updated>2019-02-19T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Iterator-与-ListIterator"><a href="#Iterator-与-ListIterator" class="headerlink" title="Iterator 与 ListIterator"></a>Iterator 与 ListIterator</h1><p>凡是实现 <code>Collection</code> 接口的集合类都有一个 <code>iterator</code> 方法，会返回一个实现了 <code>Iterator</code> 接口的对象，用于遍历集合。<code>Iterator</code> 接口主要有三个方法，分别是 <code>hasNext</code>、<code>next</code>、<code>remove</code> 方法。</p><p><code>ListIterator</code> 继承自 <code>Iterator</code>，专门用于实现 <code>List</code> 接口对象，除了 <code>Iterator</code> 接口的方法外，还有其他几个方法。</p><p>基于顺序存储集合的 <code>Iterator</code> 可以直接按位置访问数据。基于链式存储集合的 <code>Iterator</code>，一般都是需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。<a id="more"></a></p><p><code>Iterator</code> 与 <code>ListIterator</code> 的区别：</p><ul><li><code>Iterator</code> 可用于遍历 <code>Set</code>、<code>List</code>；<code>ListIterator</code> 只可用于遍历 <code>List</code>。</li><li><code>Iterator</code> 只能向后遍历；<code>ListIterator</code> 可向前或向后遍历。</li><li><code>ListIterator</code> 实现了 <code>Iterator</code> 的接口，并增加了<br><code>add</code>、<code>set</code>、<code>hasPrevious</code>、<code>previous</code>、<code>previousIndex</code>、<code>nextIndex</code> 方法。</li></ul><h1 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h1><p>快速失败机制（<code>fail—fast</code>）就是在使用迭代器遍历一个集合对象时，如果遍历过程中对集合进行修改（增删改），则会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>例如以下代码，就会抛出 <code>ConcurrentModificationException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"abc"</span>);</span><br><span class="line">stringList.add(<span class="string">"def"</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; iterator = stringList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    stringList.add(<span class="string">"ghi"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看 <code>ArrayList</code> 源码，就可以知道为什么会抛出异常。原因是在 <code>ArrayList</code> 类的内部类迭代器 <code>Itr</code> 中有一个 <code>expectedModCount</code> 变量。在 <code>AbstracList</code> 抽象类有一个 <code>modCount</code> 变量，集合在被遍历期间如果内容发生变化，就会改变 <code>modCount</code> 的值。每当迭代器使用 <code>next()</code> 遍历下一个元素之前，都会检测 <code>modCount</code> 变量是否等于 <code>expectedmodCount</code> ，如果相等就继续遍历；否则就会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：这里异常的抛出条件是检测到 <code>modCount != expectedmodCount</code>。如果集合发生变化时将 <code>modCount</code> 的值又刚好设置为 <code>expectedmodCount</code>，那么就不会抛出异常。因此，不能依赖于这个异常是否抛出而进行并发操作，这个异常只建议使用于检测并发修改的 <code>bug</code>。</p><p>在 <code>java.util</code> 包下的集合类都采用快速失败机制，所以在多线程下，不能发生并发修改，也就是在迭代过程中不能被修改。</p><h1 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h1><p>采用安全失败机制（<code>fail—safe</code>）的集合类，在遍历集合时不是直接访问原有集合，而是先将原有集合的内容复制一份，然后在拷贝的集合上进行遍历。</p><p>由于是对拷贝的集合进行遍历，所以在遍历过程中对原集合的修改并不会被迭代器检测到，所以不会抛出 <code>ConcurrentModificationException</code> 异常。</p><p>虽然基于拷贝内容的安全失败机制避免了 <code>ConcurrentModificationException</code>，但是迭代器并不能访问到修改后的内容，而仍然是开始遍历那一刻拿到的集合拷贝。</p><p>在 <code>java.util.concurrent</code> 包下的集合都采用安全失败机制，所以可以在多线程场景下进行并发使用和修改操作。</p><h1 id="如何在遍历集合的同时删除元素"><a href="#如何在遍历集合的同时删除元素" class="headerlink" title="如何在遍历集合的同时删除元素"></a>如何在遍历集合的同时删除元素</h1><p>在遍历集合时，正确的删除方式有以下几种：</p><p><strong>普通 for 循环从后往前遍历</strong></p><p>使用普通 <code>for</code> 循环，如果从后往前遍历，则可以避免元素移动的影响。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; stringList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(<span class="string">"abc"</span>);</span><br><span class="line">stringList.add(<span class="string">"def"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; stringList.size(); i++) &#123;</span><br><span class="line">    String str = stringList.get(i);</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"abc"</span>.equals(str)) &#123;</span><br><span class="line">        stringList.remove(str);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>foreach 删除后跳出循环</strong></p><p>在使用 <code>foreach</code> 迭代器遍历集合时，在删除元素后使用 break 跳出循环，则不会触发 <code>fail-fast</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String str : stringList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"abc"</span>.equals(str)) &#123;</span><br><span class="line">        stringList.remove(str);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用迭代器自带的 remove 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;String&gt; iterator = stringList.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String str = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"abc"</span>.equals(str)) &#123;</span><br><span class="line">        iterator.remove();  <span class="comment">// 这里是 iterator，而不是 stringList</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Enumeration"><a href="#Enumeration" class="headerlink" title="Enumeration"></a>Enumeration</h1><p><code>Enumeration</code> 是 <code>JDK1.0</code> 引入的接口，为集合提供遍历的接口，使用它的集合包括 <code>Vector</code>、<code>HashTable</code> 等。<code>Enumeration</code> 迭代器不支持 <code>fail-fast</code> 机制。</p><p>它只有两个接口方法：<code>hasMoreElements</code>、<code>nextElement</code> 用来判断是否有元素和获取元素，但不能对数据进行修改。</p><p>但需要注意的是 <code>Enumeration</code> 迭代器只能遍历 <code>Vector</code>、<code>HashTable</code> 这种古老的集合，因此通常情况下不要使用。</p><h1 id="Java中遍历-Map-的几种方式"><a href="#Java中遍历-Map-的几种方式" class="headerlink" title="Java中遍历 Map 的几种方式"></a>Java中遍历 Map 的几种方式</h1><p><strong>方法一 在 for-each 循环中使用 entries 来遍历</strong></p><p>这是最常见的，并且在大多数情况下也是最可取的遍历方式，在键和值都需要时使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();  </span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果遍历一个空 <code>map</code> 对象，<code>for-each</code> 循环将抛出 <code>NullPointerException</code>，因此在遍历前应该检查是否为空引用。</p><p><strong>方法二 在 for-each 循环中遍历 keys 或 values</strong></p><p>如果只需要 <code>map</code> 中的键或者值，可以通过 <code>keySet</code> 或 <code>values</code> 来实现遍历，而不是用 <code>entrySet</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();  </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 map 中的键  </span></span><br><span class="line"><span class="keyword">for</span> (Integer key : map.keySet()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + key);  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 map 中的值  </span></span><br><span class="line"><span class="keyword">for</span> (Integer value : map.values()) &#123;  </span><br><span class="line">    System.out.println(<span class="string">"Value = "</span> + value);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法比 <code>entrySet</code> 遍历在性能上稍好，而且代码更加干净。</p><p><strong>方法三 使用 Iterator 遍历</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer, Integer&gt;();  </span><br><span class="line"></span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator();  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span> (entries.hasNext()) &#123;  </span><br><span class="line">    Map.Entry&lt;Integer, Integer&gt; entry = entries.next();  </span><br><span class="line">    System.out.println(<span class="string">"Key = "</span> + entry.getKey() + <span class="string">", Value = "</span> + entry.getValue());  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式看起来冗余却有其优点所在，可以在遍历时调用 <code>iterator.remove()</code> 来删除 <code>entries</code>，另两个方法则不能。</p><p>从性能方面看，该方法类同于 <code>for-each</code> 遍历（即方法二）的性能。</p><p><strong>总结</strong></p><ul><li>如果仅需要键（<code>keys</code>）或值（<code>values</code>），则使用方法二；</li><li>如果需要在遍历时删除 <code>entries</code>，则使用方法三；</li><li>如果键值都需要，则使用方法一。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Iterator-与-ListIterator&quot;&gt;&lt;a href=&quot;#Iterator-与-ListIterator&quot; class=&quot;headerlink&quot; title=&quot;Iterator 与 ListIterator&quot;&gt;&lt;/a&gt;Iterator 与 ListIterator&lt;/h1&gt;&lt;p&gt;凡是实现 &lt;code&gt;Collection&lt;/code&gt; 接口的集合类都有一个 &lt;code&gt;iterator&lt;/code&gt; 方法，会返回一个实现了 &lt;code&gt;Iterator&lt;/code&gt; 接口的对象，用于遍历集合。&lt;code&gt;Iterator&lt;/code&gt; 接口主要有三个方法，分别是 &lt;code&gt;hasNext&lt;/code&gt;、&lt;code&gt;next&lt;/code&gt;、&lt;code&gt;remove&lt;/code&gt; 方法。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ListIterator&lt;/code&gt; 继承自 &lt;code&gt;Iterator&lt;/code&gt;，专门用于实现 &lt;code&gt;List&lt;/code&gt; 接口对象，除了 &lt;code&gt;Iterator&lt;/code&gt; 接口的方法外，还有其他几个方法。&lt;/p&gt;
&lt;p&gt;基于顺序存储集合的 &lt;code&gt;Iterator&lt;/code&gt; 可以直接按位置访问数据。基于链式存储集合的 &lt;code&gt;Iterator&lt;/code&gt;，一般都是需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。&lt;/p&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 集合(1)之 总体架构</title>
    <link href="https://blog.timberliu.com/2019/02/19/024_Java%E9%9B%86%E5%90%88%E4%B9%8B%20%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>https://blog.timberliu.com/2019/02/19/024_Java集合之 总体架构/</id>
    <published>2019-02-18T16:00:00.000Z</published>
    <updated>2019-02-18T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p><code>Java</code> 提供了一个丰富的集合类，包含了常用的数据结构和算法等。使用 <code>Java</code> 集合的优点部分如下：</p><ul><li>降低开发的成本：通过提供的核心集合类，使程序员更专注地实现程序的核心功能，而不用自己去实现自己的集合类；</li><li>提高代码的质量：集合框架提供了许多经过严格测试的、高性能、高质量的数据结构和算法，大大提高了程序的质量；</li><li>促进软件的复用性：只要符合标准集合接口的新数据结构和算法本质上都是可以复用的。<a id="more"></a></li></ul><p>在集合的接口和实现中大量使用了泛型，它为集合提供了一个可以容纳的对象类型，如果添加其他类型的元素，在编译时就会出错，这避免了在运行时出现类型转换异常。泛型也使得代码更加整洁，因为不需要显式地编写类型转换操作，编译器会帮我们实现。</p><p><code>Java</code> 整个集合框架图如下：</p><p><img src="http://media.timberliu.com/image/2019/2/19/Java%20%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.jpg" width="90%"></p><p>可以看到，这个框图主要有两个主干：<code>Collection</code> 和 <code>Map</code>。</p><ul><li><code>Collection</code>：它是一个接口，提供了对集合对象进行基本操作的通用接口方法，有很多具体的实现和继承，它被分为三大分支：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</li><li><code>Map</code>：它是由一系列键值对组成的集合，提供了 <code>key</code> 到 <code>Value</code> 的映射。</li></ul><p>除此之外，还有 <code>Iterator</code> 迭代器，<code>Collections</code> 和 <code>Arrays</code> 工具类，<code>Comparator</code> 比较器等。</p><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><p><code>List</code> 是一个有序列表，用特定的插入顺序来维护元素顺序。可以对列表中元素的插入位置进行控制，同时可以根据元素的索引访问元素。实现 <code>List</code> 接口的主要有 <code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code> 等。</p><p><strong>ArrayList</strong></p><p><code>ArrayList</code> 是一个动态数组，在随机访问元素时性能较高，但插入和删除元素效率较低。<code>ArrayList</code> 都有一个初始容量，代表了数组的大小，在 <code>ArrayList</code> 快满时，会进行扩容操作，每次增长 <code>1.5</code> 倍大小。但 <code>ArrayList</code> 是非同步的，在多线程场景下不要使用。</p><p><strong>LinkedList</strong></p><p><code>LinkedList</code> 是一个双向链表，由于实现方式不同，它不支持随机访问，但很容易在列表中间进行插入和删除操作。与 <code>ArrayList</code> 一样，<code>LinkedList</code> 也是非同步的。</p><p><strong>Vector</strong></p><p><code>Vector</code> 与 <code>ArrayList</code> 类似，基于动态数组实现，但 <code>Vector</code> 是同步的。它的操作与 <code>ArrayList</code> 几乎一样。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><p><code>Map</code> 是由一系列键值对组成的集合，提供了 <code>key</code> 到 <code>Value</code> 的映射。实现 <code>Map</code> 接口的有：<code>HashMap</code>、<code>TreeMap</code>、<code>HashTable</code>、<code>EnumMap</code> 等。</p><p><strong>HashMap</strong></p><p><code>HashMap</code> 以哈希表数据结构实现，查询对象时通过哈希函数将元素的哈希地址转换成数组索引，在出现碰撞冲突时，则使用链表的形式存储哈希地址相同的元素，在 <code>JDK8</code> 后，链表过长后会转换为红黑树。<code>HashMap</code> 存储和查询效率较高，但需要考虑哈希函数、碰撞冲突等问题。</p><p><strong>TreeMap</strong></p><p><code>TreeMap</code> 实现了 <code>SortedMap</code> 接口，内部以红黑树数据结构实现，其中键以某种排序规则排序，排序规则也可以通过 <code>Comparator</code> 比较器指定。</p><p><strong>HashTable</strong></p><p><code>HashTable</code> 也是以哈希表数据结构实现，遇到冲突时采用链表的形式。类似于 <code>HashMap</code>，但它的同步的。</p><p><strong>EnumMap</strong></p><p><code>EnumMap</code> 是将枚举类型作为键值的 <code>Map</code>。由于键的数量相对固定，所以在内部用一个数组存储对应值。通常来说，效率高于 <code>HashMap</code>。</p><h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><p><code>Set</code> 是一个不包括重复元素的集合，存入的元素没有顺序。内部通过 <code>Map</code> 实现，<code>Set</code> 里存储的值对应的是 <code>Map</code> 中的键，键对应的值是不变的，指向一个常量。实现 <code>Set</code> 接口的集合有：<code>HashSet</code>、<code>TreeSet</code>、<code>EnumSet</code> 等。</p><p><strong>HashSet</strong></p><p><code>HashSet</code> 底层基于 <code>HashMap</code> 实现，它内部元素的顺序是由哈希码来决定的，所以它不保证 <code>Set</code> 的迭代顺序。可以放入 <code>null</code>，但只能放入一个。</p><p><strong>TreeSet</strong></p><p>与 <code>HashSet</code> 类似，它是基于 <code>TreeMap</code> 实现，以某种排序规则排序。它是使用元素的自然顺序排序，或根据创建 <code>Set</code> 时提供的 <code>Comparator</code> 进行排序。但不允许存入 <code>null</code> 值。</p><p><strong>EnumSet</strong></p><p><code>EnumSet</code> 基于 <code>EnumMap</code> 实现，是枚举专用的 <code>Set</code>，其中所有元素都是枚举类型。</p><h1 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h1><p><code>Queue</code> 通常是指先进先出的队列，也不允许随机访问队列中的元素。而 <code>Deque</code> 接口是 <code>Queue</code> 的子接口，它代表一个双端队列。</p><p><strong>ArrayDeque</strong></p><p><code>ArrayDeque</code> 是基于有首尾指针的数组（环形缓冲区）实现的双端队列，它只能从首尾取出或插入元素。底层由数组实现，可以指定容量，默认容量为 <code>16</code>，并根据添加元素个数，动态扩展。</p><p><strong>PriorityQueue</strong></p><p><code>PriorityQueue</code> 是一个优先级队列，它使用自然顺序或者制定的比较器来排序。队列的头是按指定排序方式的最小元素。</p><h1 id="Comparator-和-Comparable"><a href="#Comparator-和-Comparable" class="headerlink" title="Comparator 和 Comparable"></a>Comparator 和 Comparable</h1><p><code>Comparator</code> 和 <code>Comparable</code> 是两个接口，都可以用来对对象进行比较。</p><ul><li><code>Comparable</code> 接口用于当前对象和其他对象进行比较。它有一个 <code>compareTo</code> 方法，该方法只有一个参数。返回值为 <code>int</code>，大于 <code>0</code> 表示当前对象大于参数对象；小于 <code>0</code> 表示当前对象小于参数对象；等于 <code>0</code> 表示两者相等。</li><li><code>Comparator</code> 是一个比较器接口，用于对传入的两个对象进行比较。它有一个 <code>compare</code> 方法，该方法有两个参数。</li></ul><p>例如，对一组 <code>Student</code> 对象进行排序，分别使用 <code>Comparable</code> 和 <code>Comparator</code> 接口实现功能。</p><p><strong>Comparable</strong></p><p><code>Comparable</code> 接口实现在对象类的内部，之后对象就变成了一个可以比较大小的对象，也就可以用来排序了。</p><p>首先 <code>Student</code> 类需要实现 <code>Comparable</code> 接口，重写其 <code>compareTo</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Student</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// setter、getter、toString</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Student another)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="keyword">this</span>.name.compareTo(another.name);</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = <span class="keyword">this</span>.age - another.age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后利用 <code>List</code> 接口的 <code>sort(Comparator&lt;? super E&gt; c)</code> 默认方法，或者 <code>Collections</code> 工具类的 <code>sort(List&lt;T&gt; list)</code> 方法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Student&gt; students = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"a"</span>, <span class="number">4</span>));</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"d"</span>, <span class="number">2</span>));</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"c"</span>, <span class="number">5</span>));</span><br><span class="line">    students.add(<span class="keyword">new</span> Student(<span class="string">"c"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    students.sort(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// Collections.sort(students);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Student student : students) &#123;</span><br><span class="line">        System.out.println(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Comparator</strong></p><p><code>Comparator</code> 实现在对象类的外部，此时对象类的结构不需要有任何变化。</p><p>然后另外定义一个比较器类，实现 <code>Comparator</code> 接口并重写其 <code>compare</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Person</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> flag = o1.getName().compareTo(o2.getName());</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>) &#123;</span><br><span class="line">            flag = o1.getAge() - o2.getAge();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后利用 <code>List</code> 接口的 <code>sort(Comparator&lt;? super E&gt; c)</code> 方法，或者 <code>Collections</code> 工具类的 <code>sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)</code> 方法进行排序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"a"</span>, <span class="number">4</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"d"</span>, <span class="number">2</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>, <span class="number">5</span>));</span><br><span class="line">    persons.add(<span class="keyword">new</span> Person(<span class="string">"c"</span>, <span class="number">3</span>));</span><br><span class="line"></span><br><span class="line">    persons.sort(<span class="keyword">new</span> PersonComparator());</span><br><span class="line">    <span class="comment">// Collections.sort(persons, new PersonComparator());</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Person person : persons) &#123;</span><br><span class="line">        System.out.println(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;集合框架&quot;&gt;&lt;a href=&quot;#集合框架&quot; class=&quot;headerlink&quot; title=&quot;集合框架&quot;&gt;&lt;/a&gt;集合框架&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 提供了一个丰富的集合类，包含了常用的数据结构和算法等。使用 &lt;code&gt;Java&lt;/code&gt; 集合的优点部分如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;降低开发的成本：通过提供的核心集合类，使程序员更专注地实现程序的核心功能，而不用自己去实现自己的集合类；&lt;/li&gt;
&lt;li&gt;提高代码的质量：集合框架提供了许多经过严格测试的、高性能、高质量的数据结构和算法，大大提高了程序的质量；&lt;/li&gt;
&lt;li&gt;促进软件的复用性：只要符合标准集合接口的新数据结构和算法本质上都是可以复用的。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java集合" scheme="https://blog.timberliu.com/categories/Java%E9%9B%86%E5%90%88/"/>
    
    
      <category term="Java集合" scheme="https://blog.timberliu.com/tags/Java%E9%9B%86%E5%90%88/"/>
    
  </entry>
  
  <entry>
    <title>Java 反射与动态代理</title>
    <link href="https://blog.timberliu.com/2019/02/18/023_Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>https://blog.timberliu.com/2019/02/18/023_Java 反射与动态代理/</id>
    <published>2019-02-17T16:00:00.000Z</published>
    <updated>2019-02-17T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。</p><p>一般来说，<code>Java</code> 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。<a id="more"></a></p><h1 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h1><p>反射机制指的是程序在运行时自省（<code>introspect</code>，即能够获取自身信息）的能力。在 <code>Java</code> 中，只要给定类的完全限定名，就可以通过反射直接操作类或对象。它主要有以下几个作用：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时判断任意一个类具有的成员变量和方法；</li><li>在运行时调用任意一个对象的方法；</li><li>在运行时构造任意一个类的对象；</li></ul><p>可以看到，反射提高了程序的灵活性和扩展性。但同时降低了代码的可读性和维护性；又因为反射涉及到动态类型，无法执行某些虚拟机优化，所以代码的执行性能也降低；另外，可以访问任意成员变量和方法，也破坏了封装性。一般来说，在业务代码中应尽量避免使用反射，但必须能理解中间件或框架中的反射代码。</p><p>反射的应用场景非常多。例如，对象序列化，动态代理，<code>JDBC</code> 的 <code>Class.forName()</code>，<code>RPC</code> 框架，<code>Spring</code> 的 <code>IOC/DI</code>。</p><h1 id="Class-类"><a href="#Class-类" class="headerlink" title="Class 类"></a>Class 类</h1><p><code>Java</code> 的 <code>Class</code> 类是反射机制的基础，包含了被装入到 JVM 中的类（包括类和接口）的信息。每个类（型）都有一个 <code>Class</code> 对象，也就是说每当编写并编译了一个新类，就会产生一个 <code>Class</code> 对象，被保存在一个同名的 <code>.class</code> 文件中。</p><p>所有的类都是在对其第一次使用时，动态加载到 <code>JVM</code> 中的。当运行程序时，类加载器会首先检查这个类的 <code>class</code> 对象是否已经加载，如果没有加载，类加载器就会根据类名查找 <code>.class</code> 文件，并将其 <code>Class</code> 对象载入。</p><p>获取某一个类所对应的 <code>Class</code> 对象有三种方法：</p><p>1). 根据对象的 <code>getClass()</code> 方法获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">Class c = user.getClass();</span><br></pre></td></tr></table></figure><p>2). 根据 <code>Class</code> 的静态方法 <code>forName()</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = Class.forName(<span class="string">"com.timber.User"</span>);</span><br></pre></td></tr></table></figure><p>3). 根据类名 <code>.class</code> 获取：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class;</span><br></pre></td></tr></table></figure><p>对于基本类型来说，它们的包装类型拥有一个名为 <code>TYPE</code> 的 <code>final</code> 静态字段，指向该基本类型对应的 <code>Class</code> 对象。例如，<code>Integer.TYPE</code> 指向 <code>int.class</code>。</p><p>对于数组类型来说，可以使用 <code>类名 + [].class</code> 来访问 <code>Class</code> 对象。例如，<code>int[].class</code>。</p><h1 id="使用反射创建对象"><a href="#使用反射创建对象" class="headerlink" title="使用反射创建对象"></a>使用反射创建对象</h1><p>在 <code>Java</code> 中创建对象主要有四种方式：</p><ul><li>通过 <code>new</code> 关键字创建；</li><li>使用反射；</li><li>使用 <code>clone</code> 方法；</li><li>使用反序列化；</li></ul><p><strong>使用反射</strong></p><p><code>Java</code> 中使用反射创建对象主要有两种方法：</p><p>1). 使用 <code>Class</code> 类的 <code>newInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">方法一：</span><br><span class="line">Class&lt;?&gt; userClass = Class.forName(<span class="string">"com.timber.User"</span>);  <span class="comment">// 给定类的完全限定名</span></span><br><span class="line">User user = (User) userClass.newInstance();</span><br><span class="line"></span><br><span class="line">方法二：</span><br><span class="line">User user = User.class.newInstance();</span><br></pre></td></tr></table></figure><p>2). 使用 <code>Constructor</code> 类的 <code>newInstance</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;User&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = constructor.newInstance();</span><br><span class="line"></span><br><span class="line">Constructor&lt;?&gt; constructor = User.class.getConstructor();</span><br><span class="line">User user = (User) constructor.newInstance();</span><br></pre></td></tr></table></figure><p>事实上，<code>Class</code> 的 <code>newInstance</code> 方法内部就是调用 <code>Constructor</code> 的 <code>newInstance</code> 方法。如下为 <code>Class</code> 类的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">()</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException </span>&#123;</span><br><span class="line">    Constructor&lt;T&gt; tmpConstructor = cachedConstructor;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tmpConstructor.newInstance((Object[])<span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        Unsafe.getUnsafe().throwException(e.getTargetException());</span><br><span class="line">        <span class="comment">// Not reached</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用反射功能"><a href="#使用反射功能" class="headerlink" title="使用反射功能"></a>使用反射功能</h1><p>在得到 <code>Class</code> 对象后，可以正式使用反射功能了。除了使用 <code>newInstance()</code> 生成类的实例，还有以下几项： </p><p>1). 使用 <code>isInstance(Object o)</code> 来判断一个对象是否该类的实例，等同于 <code>instanceof</code> 关键字：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class c = User.class.newInstance();</span><br><span class="line"><span class="keyword">boolean</span> b = c.isInstance(user);</span><br></pre></td></tr></table></figure><p>2). 使用 <code>Array.newInstance(Class c, int size)</code> 来构造该类型的数组：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = Array.newInstance(<span class="keyword">int</span>[].class, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>3). 使用 <code>getFields()/getConstructors()/getMethods()</code> 来访问该类的成员。需要注意，方法名中带 <code>Declared</code> 的不会返回父类的成员，但是会返回私有成员；而不带 <code>Declared</code> 的则相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Method[] methods = c.getMethods();</span><br><span class="line">Method[] methods = c.getDeclaredMethods();</span><br></pre></td></tr></table></figure><p>当获得类成员之后，可以进一步做如下操作：</p><ul><li>使用 <code>Constructor/Field/Method.setAccessible()</code> 来修改访问限制</li><li>使用 <code>Constructor.newInstance(Object[])</code> 来生成该类的实例</li><li>使用 <code>Field.set/get(Object)</code> 来访问字段值</li><li>使用 <code>Method.invoke(Object, Object[])</code> 来调用方法</li></ul><p>实例：在泛型为 <code>Integer</code> 的 <code>ArrayList</code> 中存放一个 <code>String</code> 类型的对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; listClass = list.getClass();</span><br><span class="line">        Method method = listClass.getMethod(<span class="string">"add"</span>, Object.class);</span><br><span class="line">        method.invoke(list, <span class="string">"test"</span>);</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="反射调用的开销"><a href="#反射调用的开销" class="headerlink" title="反射调用的开销"></a>反射调用的开销</h1><p>在前面的方法中，<code>Class.forName</code> 会调用本地方法，<code>Class.getMethod()</code> 会遍历该类的共有方法，如果找不到，还会遍历父类的私有方法，所以它们的操作都很费时。另外，<code>Method.getMethods()</code> 等方法还会返回查找结果的一份拷贝。</p><p>在实践中，应该避免在热点代码中使用 <code>Method.getMethods()</code> 和 <code>Method.getDeclaredMethods()</code> 方法。并且往往会缓存 <code>Class.forName()</code> 和 <code>Method.getMethod()</code> 的结果。</p><p>在反射调用时会带来不少性能开销，主要原因有三个：</p><ul><li>由于 <code>Method.invoke</code> 是一个变长参数方法，在调用时会生成一个 <code>Object</code> 数组</li><li>由于 <code>Object</code> 数组不能存储基本类型，所以会对基本类型进行自动装箱、拆箱</li><li>如果拥有多个不同的反射调用，就会对应多个 <code>GeneratedMethodAccessor</code>，可能由于 <code>JVM</code> 调用点的类型 <code>profile</code> 无法同时记住多个类，而没有被内联</li></ul><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>代理是基本的设计模式之一。它可以通过访问代理对象来完成对目标对象的访问，在不修改原对象的情况下扩充其功能。可以分为静态代理和动态代理两种。</p><p>静态代理，就是代理类由程序员自己编写，代理模式中的所有对象在编译期就已经确定。下面是一个简单的例子，首先定义一个接口和其实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"目标对象"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是代理模式中的目标对象和目标对象的接口，接下来定义代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> UserService target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserServiceProxy</span><span class="params">(UserService target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用目标对象之前"</span>);</span><br><span class="line">        target.say();</span><br><span class="line">        System.out.println(<span class="string">"调用目标对象之后"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面就是一个代理类，它同样实现了目标对象的接口，并重写了 say 方法。下面是一个测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标对象</span></span><br><span class="line">        UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        <span class="comment">// 代理对象</span></span><br><span class="line">        UserService proxy = <span class="keyword">new</span> UserServiceProxy(target);</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用目标对象之前</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 调用目标对象之后</span></span><br></pre></td></tr></table></figure><p>静态代理也存在一些局限，例如，需要程序员手写很多代码，并且当需要代理的类中方法比较多，或者同时需要代理多个对象时，实现会很复杂。</p><h1 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h1><p>动态代理中的代理类是在运行期动态生成的。在 <code>Java</code> 中，动态代理有两种方式：</p><p>1). <code>JDK</code> 接口 + 反射方式</p><p>这种方式主要通过 <code>java.lang.reflect</code> 包中的 <code>Proxy</code> 类和 <code>InvocationHandler</code> 接口实现。由于是 <code>JDK</code> 本身支持，可能比 <code>cglib</code> 更加可靠，代码实现也比较简单。<br>但是它有一个限制，就是代理对象必须实现一个或多个接口。</p><p>2). <code>cglib</code> 继承 + <code>asm</code> 方式</p><p><code>cglib</code> 是一个第三方代码生成类库，通过在运行时动态生成一个子类对象来实现，它底层通过一个小而快字节码处理框架 <code>asm</code>，转换字节码来生成新的类。这种方式无需实现接口，达到了代理类无侵入。但是无法代理 <code>final</code> 类和父类的 <code>static/final</code> 方法。</p><p><code>cglib</code> 虽然性能较高，但是它需要对 <code>JVM</code> 内部结构包括 <code>Class</code> 文件格式和指令集很熟悉，所以不鼓励使用。</p><p><code>Java</code> 的动态代理最主要的用途就是应用在各种框架中。例如，<code>RPC</code> 框架，<code>Spring</code> 中的 <code>AOP</code>，<code>Servlet</code> 的过滤器、拦截器。像 <code>Mybatis</code> 的分页插件，<code>Spring AOP</code> 中类似日志、事务、权限、性能监控等都用到了动态代理，以在不同模块的特定阶段实现某些功能。</p><h1 id="两种实现方法"><a href="#两种实现方法" class="headerlink" title="两种实现方法"></a>两种实现方法</h1><p>1). <code>JDK</code> 动态代理</p><p>目标对象的接口和实现和静态代理中一样，下面定义调用处理器类，它需要实现 <code>IovacationHandler</code> 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入目标对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JDKInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用前:"</span> + method.getName());</span><br><span class="line">        <span class="comment">// 将请求转发给目标对象，并传入相应的参数</span></span><br><span class="line">        Object result = method.invoke(target, args);</span><br><span class="line">        System.out.println(<span class="string">"调用后:"</span> + method.getName());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入类加载器、希望该代理类实现的接口类数组、调用处理器，构造代理类</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),</span><br><span class="line">                target.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDKProxyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService target = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        JDKInvocationHandler handler = <span class="keyword">new</span> JDKInvocationHandler(target);</span><br><span class="line">        UserService proxy = (UserService) handler.getProxy();</span><br><span class="line">        proxy.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用前:say</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 调用后:say</span></span><br></pre></td></tr></table></figure><p>2). <code>Cglib</code> 动态代理</p><p>目标对象和之前的一致，下面定义代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(Class c)</span> </span>&#123;</span><br><span class="line">        enhancer.setSuperclass(c);</span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开事务"</span>);</span><br><span class="line">        Object retVal = methodProxy.invokeSuper(o, objects);</span><br><span class="line">        System.out.println(<span class="string">"关闭事务"</span>);</span><br><span class="line">        <span class="keyword">return</span> retVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CglibProxy proxy = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        UserServiceImpl proxyImpl = (UserServiceImpl) proxy.getProxy(UserServiceImpl.class);</span><br><span class="line">        proxyImpl.say();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开事务</span></span><br><span class="line"><span class="comment">// 目标对象</span></span><br><span class="line"><span class="comment">// 关闭事务</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。&lt;/p&gt;
&lt;p&gt;一般来说，&lt;code&gt;Java&lt;/code&gt; 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 泛型、枚举、注解</title>
    <link href="https://blog.timberliu.com/2019/02/17/022_%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.timberliu.com/2019/02/17/022_泛型、枚举、注解/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2019-02-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-泛型"><a href="#Java-泛型" class="headerlink" title="Java 泛型"></a>Java 泛型</h1><p><code>Java</code> 泛型是 <code>JDK5</code> 中引入的一个特性，允许在定义类和接口时使用类型参数。声明的类型参数在使用时用具体的类型来替换。最主要的应用就是在集合类框架中。</p><p>泛型最大的好处就是可以提高代码的复用性。例如，<code>List</code> 接口，可以将 <code>String</code>、<code>Integer</code> 等多种类型放入到 <code>List</code> 中。<a id="more"></a></p><h1 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h1><p>不同语言中，编译器处理泛型有两种方式：</p><ul><li><code>Code Specilization</code>。在实例化一个泛型类或泛型方法时，都会产生一个新的目标代码(字节码或二进制代码)。在 <code>C++</code> 和 <code>C#</code> 中就使用这种机制，但是会导致代码膨胀。基于这种方法实现的泛型也称为真实泛型。 </li><li><code>Code Sharing</code>。每个泛型类只生成唯一的一份目标代码，该类的所有实例都映射到这份目标代码，在需要时执行类型检查和类型转换。基于这种方法实现的泛型也称为伪泛型。 </li></ul><p>在 <code>Java</code> 中，它只在程序源码中存在，在编译后的字节码文件中，已经被替换为原生类型，并在相应地方插入了强制转型代码。所以说，<code>Java</code> 的泛型仅是一种语法糖，它的实现方法就称为类型擦除。</p><p>类型擦除指的是通过类型参数合并，将泛型参数实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并在必要时添加类型检查和类型转换的方法。</p><p>例如，下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"timber"</span>);</span><br><span class="line">    System.out.println(map.get(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap();</span><br><span class="line">    map.put(<span class="string">"name"</span>, <span class="string">"timber"</span>);</span><br><span class="line">    System.out.println((String) map.get(<span class="string">"name"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="类型擦除的问题"><a href="#类型擦除的问题" class="headerlink" title="类型擦除的问题"></a>类型擦除的问题</h1><p>如果泛型遇到重载，可能会遇到问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"List&lt;String&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(List&lt;Integer&gt; list)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"List&lt;Integer&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，参数类型看起来不同，是重载方法。但这段代码是编译通不过的。在编译后，参数 <code>List&lt;Integer&gt;</code> 和 <code>List&lt;String&gt;</code> 在类型擦除后都变成了 <code>List</code>，导致方法特性签名一样。</p><h1 id="泛型限定通配符"><a href="#泛型限定通配符" class="headerlink" title="泛型限定通配符"></a>泛型限定通配符</h1><p>限定通配符用于对泛型进行限制，在初始化时就必须使用限定内的类型，否则会导致编译错误。有两种限定通配符：</p><ul><li><code>&lt;? extends T&gt;</code>：设定泛型类型的上边界，保证泛型类型必须是 <code>T</code> 的子类；</li><li><code>&lt;? super T&gt;</code>：设定泛型类型的下边界，包装泛型类型必须是 <code>T</code> 的父类。</li></ul><p>在使用时可根据 <code>PECS</code> 原则判断：</p><ul><li>如果要从集合中读取类型 <code>T</code> 的数据，但不写入，可以使用 <code>&lt;? extends T&gt;</code> 的通配符（<code>Producer Extends</code>）。</li><li>如果要从集合中写入类型 <code>T</code> 的数据，但不读取，可以使用 <code>&lt;? super T&gt;</code> 通配符（<code>Consumer super</code>）。</li><li>如果既要写入又要读取，那就不要使用任何通配符。</li></ul><p>非限定通配符 <code>&lt;?&gt;</code> 表示可以用任意泛型类型来替代。</p><h1 id="List、List-lt-gt-、List"><a href="#List、List-lt-gt-、List" class="headerlink" title="List、List&lt;?&gt;、List"></a>List、List&lt;?&gt;、List<object></object></h1><ul><li><code>List</code>：在编译时编译器不会对 <code>List</code> 进行类型安全检查；可以把任何带参数的类型传递给 <code>List</code>；</li><li><code>List&lt;?&gt;</code>：未知类型的 <code>List</code>，可以把任何带参数的类型传递给 <code>List</code>；</li><li><code>List&lt;Object&gt;</code>：任意类型的 <code>List</code>，在编译时编译器会对 <code>List&lt;?&gt;</code> 进行类型安全检查；不能把任何带参数的类型传递给 <code>List&lt;Object&gt;</code>；</li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举（<code>enum</code>）从 <code>JDK1.5</code> 引入，是指由一组固定的常量组成合法的类型。由关键字 <code>enum</code> 来定义一个枚举。例如：</p><p><code>Java</code> 中的枚举类型有以下特点：</p><ul><li>使用关键字 <code>enum</code> 和类型名称</li><li>一串允许的值</li><li>枚举可以单独定义在一个 <code>Java</code> 类中，也可以嵌在其它 <code>Java</code> 类中</li><li>枚举可以实现一个或多个接口（Interface）</li><li>可以定义新的变量和方法</li><li>可以定义根据具体枚举值而相异的类</li></ul><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;  </span><br><span class="line">    RED(<span class="string">"红色"</span>, <span class="number">1</span>), </span><br><span class="line">    GREEN(<span class="string">"绿色"</span>, <span class="number">2</span>), </span><br><span class="line">    BLANK(<span class="string">"白色"</span>, <span class="number">3</span>), </span><br><span class="line">    YELLO(<span class="string">"黄色"</span>, <span class="number">4</span>);  </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">(String name, <span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">for</span> (Color c : Color.values()) &#123;  </span><br><span class="line">            <span class="keyword">if</span> (c.getIndex() == index) &#123;  </span><br><span class="line">                <span class="keyword">return</span> c.name;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> index;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIndex</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.index = index;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="枚举是如何实现的"><a href="#枚举是如何实现的" class="headerlink" title="枚举是如何实现的"></a>枚举是如何实现的</h1><p><code>enum</code> 关键字也是 <code>Java</code> 提供的一个语法糖。如果对刚才的这个枚举：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Season &#123;</span><br><span class="line">    SPRING,SUMMER,AUTUMN,WINTER;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>jad Season.class</code> 进行反编译，看它是如何实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> timberliu.enum0;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Season</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Season[] values() &#123;</span><br><span class="line">        <span class="keyword">return</span> (Season[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Season <span class="title">valueOf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Season)Enum.valueOf(timberliu/enum0/Season, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Season</span><span class="params">(String s, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SPRING;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season SUMMER;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season AUTUMN;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Season WINTER;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Season $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SPRING = <span class="keyword">new</span> Season(<span class="string">"SPRING"</span>, <span class="number">0</span>);</span><br><span class="line">        SUMMER = <span class="keyword">new</span> Season(<span class="string">"SUMMER"</span>, <span class="number">1</span>);</span><br><span class="line">        AUTUMN = <span class="keyword">new</span> Season(<span class="string">"AUTUMN"</span>, <span class="number">2</span>);</span><br><span class="line">        WINTER = <span class="keyword">new</span> Season(<span class="string">"WINTER"</span>, <span class="number">3</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Season[] &#123;</span><br><span class="line">            SPRING, SUMMER, AUTUMN, WINTER</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>public final class Season extends Enum</code> 说明该类是继承 <code>Enum</code>，同时 <code>final</code> 也说明该类不能被继承。</p><p>四个变量 <code>SPRING</code>、<code>SUMMER</code>、<code>AUTUMN</code>、<code>WINTER</code> 都是 <code>static final</code> 的，通过 <code>static</code> 进行初始化。而 <code>static</code> 类型的属性在类加载时就被初始化，所以创建一个 <code>enum</code> 类型是线程安全的。</p><h1 id="Enum-源码"><a href="#Enum-源码" class="headerlink" title="Enum 源码"></a>Enum 源码</h1><p><code>Enum</code> 类是 <code>java.lang</code> 包中一个类，是 <code>Java</code> 中所有枚举类型的公共基类。</p><p><strong>定义</strong></p><p>首先看以下 <code>Enum</code> 类的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Enum</span>&lt;<span class="title">E</span> <span class="keyword">extends</span> <span class="title">Enum</span>&lt;<span class="title">E</span>&gt;&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">E</span>&gt;, <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure><p>可以看到，它是一个抽象类，由于抽象类不能被实例化，所以在程序中不能使用 <code>new</code> 关键字来声明一个 <code>Enum</code>。</p><p>从之前反编译的代码可以看到，在使用 <code>enum</code> 关键字定义一个枚举时，编译时默认继承 <code>Enum</code> 类，并加上 <code>final</code> 声明，故枚举无法继承。</p><p><code>Enum</code> 类实现了 <code>Serializable</code> 接口，可以序列化。实现了 Comparable 接口，可以进行比较，默认情况下只有同类型的 <code>enum</code> 可以比较。</p><p><code>E extends Enum&lt;E&gt;</code> 表示一个继承了 <code>Enum&lt;E&gt;</code> 类型的枚举类型，<code>Enum&lt;E extends Enum&lt;E&gt;&gt;</code> 就是一个 <code>Enum</code> 只接受一个 <code>Enum</code> 或者它的子类作为参数。</p><p><strong>成员变量</strong></p><p>在 <code>Enum</code> 中，有两个成员变量，一个是名字(<code>name</code>)，一个是序号(<code>ordinal</code>)。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">name</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> ordinal;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">ordinal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>序号是一个枚举常量，表示在枚举中的位置，从 <code>0</code> 开始，依次递增。</p><p><strong>构造器</strong></p><p>在 <code>Enum</code> 类中只有一个保护类型的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Enum</span><span class="params">(String name, <span class="keyword">int</span> ordinal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.ordinal = ordinal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面反编译的代码中 <code>super(s, i);</code> 就是调用 <code>Enum</code> 类中的这个保护类型的构造函数来初始化 <code>name</code> 和 <code>ordinal</code>。</p><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><p><code>Java</code> 注解，也叫元数据，一种代码级别的说明。在 <code>JDK1.5</code> 之后引入，可以声明在类、方法、字段、方法、方法参数等前面，用来对元素进行说明注释。</p><p>元注解就是用来定义其他注解的注解。元注解主要以下四个：</p><ul><li><code>@Target</code>：表示该注解可以用于什么地方，可能的值在枚举类 <code>ElementType</code> 中；</li><li><code>@Retention</code>：表示在什么级别保存该注解信息，可能的值在 <code>RetentionPolicy</code> 中；</li><li><code>@Documented</code>：将此注解包含在 <code>javadoc</code> 中；</li><li><code>@Inherited</code>：允许子类继承父类。</li></ul><p>自定义注解就是通过元注解定义出来的注解。除了元注解外，其他都是自定义注解。例如常见的 <code>Override</code>、<code>Autowrited</code> 等。</p><h1 id="如何自定义注解"><a href="#如何自定义注解" class="headerlink" title="如何自定义注解"></a>如何自定义注解</h1><p>在 <code>Java</code> 中，注解的定义和接口差不多，但增加了一个 <code>@</code> 符号，即 <code>@interface</code>。代码中可以定义成员变量，用于描述信息。也可以添加默认值。</p><p>然后还要在注解上面添加元注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType类中的常量值)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy=RUNTIME)</span><br><span class="line">[<span class="meta">@Documented</span>]</span><br><span class="line">[<span class="meta">@Inherited</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> 注解名 &#123;</span><br><span class="line">    返回类型 方法名() <span class="keyword">default</span> 默认值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Spring-中常用的注解"><a href="#Spring-中常用的注解" class="headerlink" title="Spring 中常用的注解"></a>Spring 中常用的注解</h1><ul><li><code>@Component</code>：泛指组件，当组件不好归类时，可以使用这个注解进行标注；</li><li><code>@Service</code>：用于标注业务层组件；</li><li><code>@Controller</code>：用于标注控制层组件；</li><li><code>@Repository</code>：用于标注数据访问层组件；</li><li><code>@AutoWried</code>：默认按类型装配；可结合 <code>@qualifier</code> 注解按名称装配；</li><li><code>@RequestMapping</code>：用于将 <code>HTTP</code> 请求映射到 <code>Controller</code> 的处理方法上；</li><li><code>@PathVariable</code>：用于将 <code>URL</code> 中占位符的参数绑定到 <code>Controller</code> 处理方法的参数上;</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-泛型&quot;&gt;&lt;a href=&quot;#Java-泛型&quot; class=&quot;headerlink&quot; title=&quot;Java 泛型&quot;&gt;&lt;/a&gt;Java 泛型&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Java&lt;/code&gt; 泛型是 &lt;code&gt;JDK5&lt;/code&gt; 中引入的一个特性，允许在定义类和接口时使用类型参数。声明的类型参数在使用时用具体的类型来替换。最主要的应用就是在集合类框架中。&lt;/p&gt;
&lt;p&gt;泛型最大的好处就是可以提高代码的复用性。例如，&lt;code&gt;List&lt;/code&gt; 接口，可以将 &lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Integer&lt;/code&gt; 等多种类型放入到 &lt;code&gt;List&lt;/code&gt; 中。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>序列化与反序列化</title>
    <link href="https://blog.timberliu.com/2019/02/17/021_%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://blog.timberliu.com/2019/02/17/021_序列化与反序列化/</id>
    <published>2019-02-16T16:00:00.000Z</published>
    <updated>2019-02-16T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h1><p>序列化(<code>Serialization</code>)是将对象转换为可传输的格式的过程，一般是以字节码或 <code>XML</code> 格式传输。而反序列化是将字节码或 <code>XML</code> 码编码格式还原为完全相等的对象的过程。</p><p>对象序列化机制也是一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并在需要时将这个字节数组通过反序列化的方式再转换成对象，如此可以很容易地在对象和字节数组之间进行转换。</p><p>除了持久化时用到序列化之外，当在网络中传输对象、使用 <code>RMI</code> 和 <code>RPC</code> 时，都会用到对象序列化。<a id="more"></a></p><h1 id="如何序列化"><a href="#如何序列化" class="headerlink" title="如何序列化"></a>如何序列化</h1><p>Java 中提供了一套方便的 API 来支持，将对象进行序列化和反序列化。其中包括以下接口和类：</p><ul><li><code>java.io.Serializable</code></li><li><code>java.io.Externalizable</code></li><li><code>ObjectOutputStream</code></li><li><code>ObjectInputStream</code></li><li><code>ObjectOutput</code></li><li><code>ObjectInput</code></li></ul><h2 id="ObjectInput-和-ObjectOutput-接口"><a href="#ObjectInput-和-ObjectOutput-接口" class="headerlink" title="ObjectInput 和 ObjectOutput 接口"></a>ObjectInput 和 ObjectOutput 接口</h2><p><strong>ObjectInput</strong></p><p><code>ObjectInput</code> 接口扩展自 <code>DataInput</code> 接口以包含对象的读操作。</p><p><code>DataInput</code> 接口用于从二进制流中读取字节，并根据所有 <code>Java</code> 基本类型数据进行重构。同时还提供根据 <code>UTF-8</code> 修改版格式的数据重构 <code>String</code> 的工具。</p><p>对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (<code>end of file</code>)，则将抛出 <code>EOFException</code>（<code>IOException</code> 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 <code>IOException</code> 而不是 <code>EOFException</code>。尤其是，在输入流已关闭的情况下，将抛出 <code>IOException</code>。</p><p><strong>ObjectOutput</strong></p><p><code>ObjectOutput</code> 扩展 <code>DataOutput</code> 接口以包含对象的写入操作。</p><p><code>DataOutput</code> 接口用于将数据从任意 <code>Java</code> 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 <code>String</code> 转换成 <code>UTF-8</code> 修改版格式并写入所得到的系列字节的工具。</p><p>对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 <code>IOException</code>。</p><h2 id="ObjectInputStream-和-ObjectOutputStream-类"><a href="#ObjectInputStream-和-ObjectOutputStream-类" class="headerlink" title="ObjectInputStream 和 ObjectOutputStream 类"></a>ObjectInputStream 和 ObjectOutputStream 类</h2><p>通过 <code>ObjectOutputStream</code> 和 <code>ObjectInputStream</code> 可以对对象进行序列化及反序列化。一般使用 <code>ObjectOutputStream</code> 的 <code>writeObject</code> 方法把一个对象进行持久化，再使用 <code>ObjectInputStream</code> 的 <code>readObject</code> 从持久化存储中把对象读取出来。</p><h2 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h2><p>Java 中，只要类实现 <code>java.io.Serializable</code> 接口就表示可以被序列化。没有实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。</p><p>当试图对一个对象进行序列化的时候，如果遇到不支持 <code>Serializable</code> 接口的对象。在此情况下，将抛出 <code>NotSerializableException</code>。</p><p>如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该实现 <code>java.io.Serializable</code> 接口。</p><p>举个栗子，下面是一个实现了 <code>java.io.Serializable</code> 接口的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User1</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个 <code>User1</code> 对象进行序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerializableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User1 user = <span class="keyword">new</span> User1();</span><br><span class="line">        user.setName(<span class="string">"timber"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(<span class="string">"before: "</span> + user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write Obj to File</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>));</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    oos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read Obj from File</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">            User1 newUser = (User1) ois.readObject();</span><br><span class="line">            System.out.println(<span class="string">"after: "</span> + newUser);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ois.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">before: User1&#123;name=<span class="string">'timber'</span>, age=<span class="number">20</span>&#125;</span><br><span class="line">after: User1&#123;name=<span class="string">'timber'</span>, age=<span class="number">20</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="Externalizable-接口"><a href="#Externalizable-接口" class="headerlink" title="Externalizable 接口"></a>Externalizable 接口</h2><p>除了 <code>Serializable</code> 之外， <code>Java</code> 中还提供了另一个序列化接口 <code>Externalizable</code> 来自定义序列化和反序列化策略。该接口中定义了抽象方法：<code>writeExternal</code> 与 <code>readExternal</code> 方法。当使用 <code>Externalizable</code> 进行序列化和反序列化时需要实现这两个方法。</p><p>如果在这两个方法中没有定义序列化实现细节，进行序列化和反序列化后得到的对象的所有属性的值都变成了默认值。也就是说之前的那个对象的状态并没有被持久化下来。</p><p>另外，若使用 <code>Externalizable</code> 接口进行序列化，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 <code>Externalizable</code> 接口的类必须要提供一个 <code>public</code> 的无参的构造器。</p><p>下面是一个实现 <code>Externalizable</code> 接口的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User2</span> <span class="keyword">implements</span> <span class="title">Externalizable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeExternal</span><span class="params">(ObjectOutput out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        out.writeObject(name);</span><br><span class="line">        out.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readExternal</span><span class="params">(ObjectInput in)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        name = (String) in.readObject();</span><br><span class="line">        age = in.readInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User1&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对这个 <code>User2</code> 对象进行序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalizableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        User2 user = <span class="keyword">new</span> User2();</span><br><span class="line">        user.setName(<span class="string">"timber"</span>);</span><br><span class="line">        user.setAge(<span class="number">20</span>);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Write Obj to file</span></span><br><span class="line">        <span class="keyword">try</span> (ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"tempFile"</span>))) &#123;</span><br><span class="line">            oos.writeObject(user);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Read Obj from file</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"tempFile"</span>);</span><br><span class="line">        User2 user2 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> (ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file))) &#123;</span><br><span class="line">            user2 = (User2) ois.readObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="transient-关键字"><a href="#transient-关键字" class="headerlink" title="transient 关键字"></a>transient 关键字</h2><p><code>transient</code> 关键字可以控制变量的序列化。如果在变量声明前加上该关键字，可以阻止该变量被序列化。在被反序列化时，<code>transient</code> 变量的值被设为初始值，如 <code>int</code> 类型是 <code>0</code>，引用类型是 <code>null</code>。</p><h2 id="序列化ID"><a href="#序列化ID" class="headerlink" title="序列化ID"></a>序列化ID</h2><p>虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 <code>ID</code> 是否一致（就是 <code>private static final long serialVersionUID</code>)。</p><p>序列化 <code>ID</code> 一般有两种生成策略：</p><ul><li>一种是固定的 <code>1L</code>。如果没有特殊需求，就是用默认的 <code>1L</code> 就可以；</li><li>一种是随机生成一个不重复的 <code>long</code> 类型数据。有时可通过改变序列化 <code>ID</code> 可以用来限制某些用户的使用。</li></ul><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>在 <code>Java</code> 序列化保存对象时，会将其状态保存为一组字节，在需要时将这些字节封装成对象。这里的状态指的是对象的成员变量，也就是说不会保存类中的静态变量。</p><h2 id="Serializable接口为空？"><a href="#Serializable接口为空？" class="headerlink" title="Serializable接口为空？"></a>Serializable接口为空？</h2><p><code>Serializable</code> 虽只是一个空接口。但底层实现中，在序列化操作时，会判断要被序列化的类是否是 <code>Enum</code>、<code>Array</code> 和 <code>Serializable</code> 类型，如果不是则直接抛出 <code>NotSerializableException</code>。以此来保证只有实现了该接口的方法才能进行序列化与反序列化。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;序列化与反序列化&quot;&gt;&lt;a href=&quot;#序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化&quot;&gt;&lt;/a&gt;序列化与反序列化&lt;/h1&gt;&lt;p&gt;序列化(&lt;code&gt;Serialization&lt;/code&gt;)是将对象转换为可传输的格式的过程，一般是以字节码或 &lt;code&gt;XML&lt;/code&gt; 格式传输。而反序列化是将字节码或 &lt;code&gt;XML&lt;/code&gt; 码编码格式还原为完全相等的对象的过程。&lt;/p&gt;
&lt;p&gt;对象序列化机制也是一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并在需要时将这个字节数组通过反序列化的方式再转换成对象，如此可以很容易地在对象和字节数组之间进行转换。&lt;/p&gt;
&lt;p&gt;除了持久化时用到序列化之外，当在网络中传输对象、使用 &lt;code&gt;RMI&lt;/code&gt; 和 &lt;code&gt;RPC&lt;/code&gt; 时，都会用到对象序列化。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>String 源码阅读</title>
    <link href="https://blog.timberliu.com/2019/02/16/020_String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>https://blog.timberliu.com/2019/02/16/020_String源码阅读/</id>
    <published>2019-02-15T16:00:00.000Z</published>
    <updated>2019-02-15T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文基于 JDK1.8，在其他版本中会有不同。</p></blockquote><h1 id="定义及属性"><a href="#定义及属性" class="headerlink" title="定义及属性"></a>定义及属性</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br></pre></td></tr></table></figure><p><code>String</code> 类被 <code>final</code> 修饰，表示不可变。实现了 <code>Serializable</code>, <code>Comparable&lt;String&gt;</code>, <code>CharSequence</code> 接口。<a id="more"></a></p><ul><li><code>value[]</code>：<code>String</code> 类底层通过 <code>final</code> 类型的 <code>char</code> 数组实现，用于存储字符串内容；</li><li><code>hash</code>：用于缓存当前字符串的 <code>hashcode</code> 值，默认为 <code>0</code>；</li></ul><h1 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h1><p><code>String</code> 类中重载的构造器很多，其中比较常用的有：</p><h2 id="字符串构造"><a href="#字符串构造" class="headerlink" title="字符串构造"></a>字符串构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用一个 <code>String</code> 类型的对象来初始化 <code>String</code>。实现中直接将源 <code>String</code> 的 <code>value</code> 和 <code>hash</code> 两个属性直接赋值给目标 <code>String</code>。</p><p>可以看出，新创建的 <code>String</code> 对象是传入的参数 <code>String</code> 的一个副本。除非确实需要显式得赋值一个字符串对象，否则没有必要使用此构造器来创建一个 <code>String</code> 对象。</p><h2 id="字符数组构造"><a href="#字符数组构造" class="headerlink" title="字符数组构造"></a>字符数组构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// check bounds</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以使用一个 <code>char</code> 数组来创建一个 <code>String</code>，实现中通过 <code>Array.copyOf</code> 或 <code>Array.copyOfRange</code> 方法，将原有的字符数组中的内容逐一地赋值到新 <code>String</code> 的字符数组中。</p><p>在复制时，即可以复制整个字符数组，也可以通过 <code>offset</code> 和 <code>count</code> 两个参数来复制字符数组的一部分。</p><h2 id="字节数组构造"><a href="#字节数组构造" class="headerlink" title="字节数组构造"></a>字节数组构造</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"charset"</span>);</span><br><span class="line">    checkBounds(bytes, offset, length);</span><br><span class="line">    <span class="keyword">this</span>.value =  StringCoding.decode(charset, bytes, offset, length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>byte</code> 数组来构造一个 <code>String</code>，需要将 <code>byte</code> 数组转换为 <code>char</code> 数组。由于在网络传输中，经常需要在 <code>byte[]</code>、<code>char[]</code> 和 <code>String</code> 之间相互转化，所以 <code>StringCoding</code> 类提供了一系列重载的构造方法，例如这里的 <code>StringCoding.decode(charset, bytes, offset, length)</code> 方法，它通过指定的 <code>charset</code> 对 <code>byte</code> 数组解码为 <code>unicode</code> 的 <code>char</code> 数组，构造新的 <code>String</code>。</p><p>还有其他几种类似的构造方法，可以选择性地指定编码格式、解码的第一个字节下标、解码的字节数。</p><p>在 <code>StringCoding.decode</code> 方法中，如果没有指定编码格式，则默认使用 <code>ISO-8859-1</code> 格式进行操作。</p><h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><h2 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h2><p><code>equals</code> 方法用于比较当前对象与传入的字符串对象是否相等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果它们是一个对象，肯定为 true</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入的对象必须是 String</span></span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="comment">// 将 Object 强转为 String 类型</span></span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="comment">// 两者的字符序列长度是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 逐一比较两个字符数组的每一个字符</span></span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 只要有一个不等，即返回 false</span></span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>regionMatches</code> 方法用于比较当前对象与传入的字符串对象的指定区域是否相等。但可以传入一个 <code>boolean</code> 值用于指定是否忽略大小写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset,</span></span></span><br><span class="line"><span class="function"><span class="params">        String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = other.value;</span><br><span class="line">    <span class="keyword">int</span> po = ooffset;</span><br><span class="line">    <span class="keyword">if</span> ((ooffset &lt; <span class="number">0</span>) || (toffset &lt; <span class="number">0</span>)</span><br><span class="line">            || (toffset &gt; (<span class="keyword">long</span>)value.length - len)</span><br><span class="line">            || (ooffset &gt; (<span class="keyword">long</span>)other.value.length - len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (len-- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = ta[to++];</span><br><span class="line">        <span class="keyword">char</span> c2 = pa[po++];</span><br><span class="line">        <span class="keyword">if</span> (c1 == c2) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ignoreCase) &#123;</span><br><span class="line">            <span class="comment">// 根据传入的 boolean 值来判断是否分别转换为大写、小写进行比较</span></span><br><span class="line">            <span class="keyword">char</span> u1 = Character.toUpperCase(c1);</span><br><span class="line">            <span class="keyword">char</span> u2 = Character.toUpperCase(c2);</span><br><span class="line">            <span class="keyword">if</span> (u1 == u2) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>compareTo</code> 方法按照字典序比较两个字符串的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 逐一比较每一个字符的大小</span></span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="comment">// 只要有一个能分为大小，即返回</span></span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hashcode"><a href="#hashcode" class="headerlink" title="hashcode"></a>hashcode</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>String</code> 类计算的 <code>hashcode</code> 的公式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>]*<span class="number">31</span>^(n-<span class="number">1</span>) + s[<span class="number">1</span>]*<span class="number">31</span>^(n-<span class="number">2</span>) + ... + s[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="getBytes"><a href="#getBytes" class="headerlink" title="getBytes"></a>getBytes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(Charset charset) &#123;</span><br><span class="line">    <span class="keyword">if</span> (charset == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">return</span> StringCoding.encode(charset, value, <span class="number">0</span>, value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用指定的字符集编码将 <code>String</code> 对象编码成一个 <code>byte</code> 数组。也有不指定编码格式的 <code>getBytes</code> 版本，会默认使用系统的编码方式，例如在中文操作系统中可能使用 <code>GBK</code>，在英文系统中可能使用 <code>IOS-8859-1</code> 格式。</p><h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p><code>indexOf</code> 方法返回指定字符在当前 <code>String</code> 对象第一次出现的索引位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> max = value.length;</span><br><span class="line">    <span class="keyword">if</span> (fromIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        fromIndex = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromIndex &gt;= max) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 一个完整的 Unicode 字符叫代码点 CodePoint，</span></span><br><span class="line">    <span class="comment">// String 对象以 UTF-16 保存 Unicode 字符，需要两个字符表示一个超大字符集的汉字</span></span><br><span class="line">    <span class="comment">// 如果 cd 参数小于 Unicode 补充代码点的最小值 0x010000</span></span><br><span class="line">    <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="comment">// 遍历字符数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromIndex; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前字符等于 ch，则返回索引 i</span></span><br><span class="line">            <span class="keyword">if</span> (value[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> indexOfSupplementary(ch, fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>lastIndexOf</code> 方法返回指定字符在当前 <code>String</code> 对象最后一次出现的索引位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(<span class="keyword">int</span> ch, <span class="keyword">int</span> fromIndex)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">char</span>[] value = <span class="keyword">this</span>.value;</span><br><span class="line">        <span class="keyword">int</span> i = Math.min(fromIndex, value.length - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (value[i] == ch) &#123;</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lastIndexOfSupplementary(ch, fromIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><p><code>replace</code> 方法将当前字符串对象中所有的 <code>oldChar</code> 字符替换为 <code>newChar</code>，返回一个新的 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (oldChar != newChar) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = value.length;</span><br><span class="line">        <span class="keyword">int</span> i = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] val = value; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从索引位置零开始，查找当前字符串中第一次出现字符 oldChar 的索引位置</span></span><br><span class="line">        <span class="keyword">while</span> (++i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (val[i] == oldChar) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; len) &#123;</span><br><span class="line">            <span class="keyword">char</span> buf[] = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">            <span class="comment">// 将 [0,i) 之间的字符直接缓存到 buf 字符数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                buf[j] = val[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 遍历 [i, len - 1] 之间的字符</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; len) &#123;</span><br><span class="line">                <span class="keyword">char</span> c = val[i];</span><br><span class="line">                <span class="comment">// 如果遍历到的字符与 oldChar 相等，则替换，否则保持不变</span></span><br><span class="line">                buf[i] = (c == oldChar) ? newChar : c;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个方法根据给定的正则表达式替换匹配到的第一个或全部的子字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceFirst(replacement);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Pattern.compile(regex).matcher(<span class="keyword">this</span>).replaceAll(replacement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="valueOf-NaN"><a href="#valueOf-NaN" class="headerlink" title="valueOf"></a>valueOf</h2><p><code>copyValueOf</code> 方法将指定的字符数组转换成一个 <code>String</code> 对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">copyValueOf</span><span class="params">(<span class="keyword">char</span> data[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, offset, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>valueOf</code> 方法将六种基本数据类型的变量转换成 <code>String</code> 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Long.toString(l);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Float.toString(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><p>将指定的字符串拼接到当期字符串的末尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> otherLen = str.length();</span><br><span class="line">    <span class="keyword">if</span> (otherLen == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="comment">// 创建一个 len + otherLen 大小的数组，将 value 拷贝过去</span></span><br><span class="line">    <span class="keyword">char</span> buf[] = Arrays.copyOf(value, len + otherLen);</span><br><span class="line">    <span class="comment">// 将 str 中的字符拷贝到 buf 中</span></span><br><span class="line">    str.getChars(buf, len);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buf, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="startsWith"><a href="#startsWith" class="headerlink" title="startsWith"></a>startsWith</h2><p>判断当前字符串从索引位置 <code>toofset</code> 开始是否以指定的前缀字符串开头。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix, <span class="keyword">int</span> toffset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ta[] = value;</span><br><span class="line">    <span class="keyword">int</span> to = toffset;</span><br><span class="line">    <span class="keyword">char</span> pa[] = prefix.value;</span><br><span class="line">    <span class="keyword">int</span> po = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pc = prefix.value.length;</span><br><span class="line">    <span class="keyword">if</span> ((toffset &lt; <span class="number">0</span>) || (toffset &gt; value.length - pc)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (--pc &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ta[to++] != pa[po++]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>判断当前字符串是否以指定的前缀字符串开头或结尾。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startsWith</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(prefix, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">endsWith</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startsWith(suffix, value.length - suffix.value.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h2><p>trim 方法可去掉字符串两端的空格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = value.length;</span><br><span class="line">    <span class="keyword">int</span> st = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] val = value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到第一个不为 ' ' 的下标</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[st] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        st++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到最后一个不为 ' ' 的下标</span></span><br><span class="line">    <span class="keyword">while</span> ((st &lt; len) &amp;&amp; (val[len - <span class="number">1</span>] &lt;= <span class="string">' '</span>)) &#123;</span><br><span class="line">        len--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 substring 方法截取 [st, len] 之间的字符串</span></span><br><span class="line">    <span class="keyword">return</span> ((st &gt; <span class="number">0</span>) || (len &lt; value.length)) ? substring(st, len) : <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回字符串中第 index 个字符</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将 String 转换为 字符数组</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 将 String 按照字符 regex 分为 limit 份</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 转换为大写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toUpperCase</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 转换为小写</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toLowerCase</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本文基于 JDK1.8，在其他版本中会有不同。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;定义及属性&quot;&gt;&lt;a href=&quot;#定义及属性&quot; class=&quot;headerlink&quot; title=&quot;定义及属性&quot;&gt;&lt;/a&gt;定义及属性&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;CharSequence&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 类被 &lt;code&gt;final&lt;/code&gt; 修饰，表示不可变。实现了 &lt;code&gt;Serializable&lt;/code&gt;, &lt;code&gt;Comparable&amp;lt;String&amp;gt;&lt;/code&gt;, &lt;code&gt;CharSequence&lt;/code&gt; 接口。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="源码解读" scheme="https://blog.timberliu.com/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>String 类详解</title>
    <link href="https://blog.timberliu.com/2019/02/15/019_String%E7%B1%BB%E8%AF%A6%E8%A7%A3/"/>
    <id>https://blog.timberliu.com/2019/02/15/019_String类详解/</id>
    <published>2019-02-14T16:00:00.000Z</published>
    <updated>2019-02-14T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h1><p><code>String</code> 对象是不可变（<code>Immutable</code>）的，也就是一旦 <code>String</code> 类实例被创建后，就不能改变其值。这里的不可变指的是引用既不能指向其他对象，而且引用指向的对象的值也不能改变。<a id="more"></a></p><h2 id="为什么不可变"><a href="#为什么不可变" class="headerlink" title="为什么不可变"></a>为什么不可变</h2><p>在 <code>JDK1.6</code> 中，<code>String</code> 类中的成员变量如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The offset is the first index of the storage that is used. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> offset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** The count is the number of characters in the String. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> count;</span><br></pre></td></tr></table></figure><p>在 <code>JDK1.7</code> 中，<code>String</code> 类主要改变了 <code>substring</code> 方法的实现，成员变量剩下了两个：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br></pre></td></tr></table></figure><p>可以看出，<code>String</code> 就是字符数组的封装。在 <code>JDK6</code> 中，<code>value</code> 是一个 <code>char</code> 数组，<code>offset</code> 是 <code>String</code> 对象实际的起始位置，而 <code>count</code> 是所占的个数。在 <code>JDK7</code> 中，<code>value</code> 中的所有字符都属于 <code>String</code> 对象。</p><p><code>value</code>、<code>offset</code> 和 <code>count</code> 这三个变量都是 <code>private final</code> 的，并且没有 <code>setter</code> 方法来修改，所以 <code>String</code> 类外部无法修改 <code>String</code>。所以，一旦初始化后就不能修改，<code>String</code> 对象也就是不可变的。</p><h2 id="真的不可变吗"><a href="#真的不可变吗" class="headerlink" title="真的不可变吗"></a>真的不可变吗</h2><p><code>String</code> 中的 <code>char</code> 数组 <code>value</code> 是 <code>private final</code> 的，被 <code>final</code> 修饰 虽然不能指向其他数组对象，但却可以通过反射修改其指向的数组。</p><p>使用反射可以得到 <code>String</code> 类的 <code>value</code> 属性，修改访问权限，然后就可以对数组内容进行修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String s = <span class="string">"abc"</span>;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">    <span class="comment">// 获取 value 字段</span></span><br><span class="line">    Field field = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line">    <span class="comment">// 修改 value 字段访问权限</span></span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">// 获取 s 对象上 value 属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) field.get(s);</span><br><span class="line">    value[<span class="number">1</span>] = <span class="string">'d'</span>;</span><br><span class="line">    </span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// adc</span></span><br></pre></td></tr></table></figure><p>可以看到，通过反射是可以修改 “不可变” 对象的。</p><h2 id="不可变的优点"><a href="#不可变的优点" class="headerlink" title="不可变的优点"></a>不可变的优点</h2><p><code>String</code> 被设计为不可变的，在 <code>Security</code>、<code>Cache</code>、<code>Thread Safe</code> 方面都有很多优点：</p><ul><li>安全性。<code>String</code> 被广泛地使用在其他 <code>Java</code> 类中充当参数。例如 网络连接、<code>IO</code> 操作、数据库连接等，如果字符串可变，那么可能会导致安全问题。</li><li>字符串常量池。<code>String</code> 类维护了一个运行时常量池，会对创建的字符串进行缓存，如此在使用时更加高效。而这就建立在不可变的基础上，不用担心数据冲突问题。</li><li>缓存 <code>hashcode</code>。<code>Java</code> 中经常用到字符串的哈希值，字符串的不可变能保证其 <code>hashcode</code> 永远保持一致，这样在每次使用一个字符串的 <code>hashcode</code> 时，就不用重新计算一次，也更加高效。</li><li>线程安全性。由于 <code>String</code> 对象不能被改变，所以同一个字符串实例可以被多个线程共享，而不用因为线程安全问题使用同步。</li></ul><h2 id="不可变的缺点"><a href="#不可变的缺点" class="headerlink" title="不可变的缺点"></a>不可变的缺点</h2><p>当然，设计为不可变也会出现一些缺点，例如在类似拼接、裁剪等操作时，都会创建新的 <code>String</code> 对象，如果程序设计不当，便会产生大量无用的字符串对象，耗费时间空间。</p><h1 id="“-”-的实现"><a href="#“-”-的实现" class="headerlink" title="“+” 的实现"></a>“+” 的实现</h1><p>1、对于两个编译期常量(编译期可知)，例如 <code>String s = &quot;a&quot; + &quot;b&quot;</code>，编译器会进行常量折叠，即变成 <code>String s = &quot;ab&quot;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String s1 = "ab";</span></span><br><span class="line"><span class="comment"> * String s2 = "a1";</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s1 = <span class="string">"a"</span> + <span class="string">"b"</span>;</span><br><span class="line">String s2 = <span class="string">"a"</span> + <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>2、对于能够进行优化的(例如 <code>String s = &quot;a&quot; + s1</code> 等)用 <code>StringBuilder</code> 的 <code>append()</code> 方法替代，最后调用 <code>toString()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String s3 = (new StringBuilder()).append("a").append(s1).toString();</span></span><br><span class="line"><span class="comment"> * String s4 = (new StringBuilder()).append(s2).append(s3).toString();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s3 = <span class="string">"a"</span> + s1;</span><br><span class="line">String s4 = s2 + s3;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * String s6 =</span></span><br><span class="line"><span class="comment"> * for (int i = 0; i &lt; 2; i++) &#123;</span></span><br><span class="line"><span class="comment"> *     s6 = (new StringBuilder()).append(s6).append(i).toString();</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String s6 = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    s6 += i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="substring-在-jdk6-和-7-的区别"><a href="#substring-在-jdk6-和-7-的区别" class="headerlink" title="substring 在 jdk6 和 7 的区别"></a>substring 在 jdk6 和 7 的区别</h1><p><code>substring</code> 是一个比较常用的方法，而且在 <code>jdk6</code> 和 <code>jdk7</code> 中的实现不同。<code>substring(int beginIndex, in endIndex)</code> 方法的作用是截取字符串并返回其 <code>[beginIndex, endIndex - 1]</code> 范围内的内容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"abcdef"</span>;</span><br><span class="line">String substring = str.substring(<span class="number">2</span>, <span class="number">4</span>);</span><br><span class="line">System.out.println(substring);</span><br></pre></td></tr></table></figure><p>输出结果为：<code>cd</code>。</p><p><strong>JDK6 中的 substring</strong></p><p>前面说过，在 <code>JDK 6</code> 中，<code>String</code> 类的三个成员变量：<code>char value[]</code>，<code>int offset</code>，<code>int count</code>，三个变量决定了 <code>String</code> 存储的真正的字符数组。</p><p><code>String</code> 中主要相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">int</span> offset, <span class="keyword">int</span> count, <span class="keyword">char</span> value[]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    <span class="keyword">this</span>.count = count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex, <span class="keyword">int</span> endIndex)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 检查边界</span></span><br><span class="line"><span class="keyword">return</span> ((beginIndex == <span class="number">0</span>) &amp;&amp; (endIndex == count)) ? <span class="keyword">this</span> :</span><br><span class="line">    <span class="keyword">new</span> String(offset + beginIndex, endIndex - beginIndex, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用 <code>substring</code> 方法时，会创建一个 <code>String</code> 对象，但 <code>value</code> 引用仍然指向堆中的同一个字符数组。它的内存变化：</p><p><img src="http://media.timberliu.com/image/2019/2/14/jdk6%E7%9A%84substring%E6%96%B9%E6%B3%95.jpeg" width="60%"></p><p>如果字符串很长，在使用 <code>substring</code> 进行切割时只需要很短的一段，就可能导致性能问题.。因为只需要一小段字符串，但是却引用了整个字符串，这个很长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露。</p><p><strong>JDK7 中的 substring</strong></p><p>在 <code>JDK7</code> 中，主要剩下一个 <code>value</code> 变量，它的主要源码如下；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span><span class="params">(<span class="keyword">int</span> beginIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">int</span> subLen = value.length - beginIndex;</span><br><span class="line">    <span class="comment">// 检查边界</span></span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="keyword">this</span> : <span class="keyword">new</span> String(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，<code>JDK 7</code> 中的 <code>subString</code> 方法，使用 <code>new String</code> 创建了一个新字符串，避免对老字符串的引用，从而解决了内存泄露问题。它的内存变化如下：</p><p><img src="http://media.timberliu.com/image/2019/2/14/jdk7%E7%9A%84substring%E6%96%B9%E6%B3%95.jpeg" width="60%"></p><h1 id="StringBuffer、StringBuilder"><a href="#StringBuffer、StringBuilder" class="headerlink" title="StringBuffer、StringBuilder"></a>StringBuffer、StringBuilder</h1><p><strong>String</strong></p><p><code>String</code> 是不可变对象，被声明为 <code>final class</code>，所有属性也都是 <code>final</code> 的。由于其不可变性，类似拼接、裁剪等操作，都会产生一个新的 <code>String</code> 对象，然后指针指向新的 <code>String</code> 对象，如果操作不当，可能会产生大量临时字符串。</p><p>在字符串内容不经常变化的业务场景优先使用 String 类。例如：常量声明、少量的字符串拼接等。</p><p><strong>StringBuffer</strong></p><p><code>StringBuffer</code> 是一个线程安全的可变字符序列。它解决了由于拼接产生太多中间对象的问题，可以用 <code>append</code> 或 <code>add</code> 方法，把字符串添加到字符串的末尾或指定位置。</p><p>它虽然保证了线程安全，也带来了额外的性能开销，所以除非有线程安全的需要，否则还是推荐使用 <code>StringBuilder</code>。</p><p><strong>StringBulider</strong></p><p><code>StringBuilder</code> 在能力与 <code>StringBuffer</code> 没有本质区别，但不保证同步，有效减小了开销。如果可能，在字符串拼接时建议优先使用。</p><p>为了能实现可修改的目的，<code>StringBuffer</code> 和 <code>StringBuilder</code> 底层都是可修改的数组，二者都继承了 <code>AbstarctStringBuilder</code>，包含了基本操作，区别仅在于最终的方法是否加了 <code>synchronized</code>。</p><h1 id="JDK-9-改进"><a href="#JDK-9-改进" class="headerlink" title="JDK 9 改进"></a>JDK 9 改进</h1><p>在 <code>JDK9</code> 之前，<code>String</code> 类内部使用 <code>char</code> 数组来存储数据，但 <code>char</code> 是两个字节大小，这样就造成了一定的浪费。</p><p>在 <code>JDK9</code> 中，引入了 <code>Compact Strings</code> 的设计，对字符串进行改进，将 <code>char</code> 数组改变为 <code>byte</code> 数组加上一个标识编码的 <code>coder</code>，并且对相关字符串操作进行修改。</p><p>成员变量变化如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> coder;</span><br></pre></td></tr></table></figure><p>改进之后，在存储数据时，如果传入 <code>byte</code> 数组，直接赋值就好，如果传入 <code>char</code> 数组，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len, Void sig) &#123;</span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">        <span class="keyword">this</span>.coder = <span class="string">""</span>.coder;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (COMPACT_STRINGS) &#123; <span class="comment">// COMPACT_STRINGS 默认初始化为 true</span></span><br><span class="line">        <span class="keyword">byte</span>[] val = StringUTF16.compress(value, off, len);</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = val;</span><br><span class="line">            <span class="keyword">this</span>.coder = LATIN1;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.coder = UTF16;</span><br><span class="line">    <span class="keyword">this</span>.value = StringUTF16.toBytes(value, off, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>StringUTF16.compress</code> 方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] compress(<span class="keyword">char</span>[] val, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] ret = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">    <span class="keyword">if</span> (compress(val, off, ret, <span class="number">0</span>, len) == len) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">···</span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compress</span><span class="params">(<span class="keyword">char</span>[] src, <span class="keyword">int</span> srcOff, <span class="keyword">byte</span>[] dst, <span class="keyword">int</span> dstOff, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">char</span> c = src[srcOff];</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">0xFF</span>) &#123;</span><br><span class="line">            len = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dst[dstOff] = (<span class="keyword">byte</span>)c;</span><br><span class="line">        srcOff++;</span><br><span class="line">        dstOff++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>for</code> 循环中，如果 <code>char</code> 数组中每一个字符都小于等于 <code>0xFF</code>，那么将 <code>char</code> 转换为 <code>byte</code>，完成构造，其 <code>coder</code> 为 <code>LATIN1</code>。</p><p>而如果存在一个大于 <code>0xFF</code> 的字符，就会跳出循环，最终 <code>StringUTF6.compress</code> 方法返回 <code>null</code>，通过 <code>StringUTF16.toBytes</code> 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] toBytes(<span class="keyword">char</span>[] value, <span class="keyword">int</span> off, <span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="keyword">byte</span>[] val = newBytesFor(len);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        putChar(val, i, value[off]);</span><br><span class="line">        off++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] newBytesFor(<span class="keyword">int</span> len) &#123;</span><br><span class="line">    <span class="comment">// check bound</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">byte</span>[len &lt;&lt; <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@HotSpotIntrinsicCandidate</span></span><br><span class="line"><span class="comment">// intrinsic performs no bounds checks</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putChar</span><span class="params">(<span class="keyword">byte</span>[] val, <span class="keyword">int</span> index, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">assert</span> index &gt;= <span class="number">0</span> &amp;&amp; index &lt; length(val) : <span class="string">"Trusted caller missed bounds check"</span>;</span><br><span class="line">    index &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    val[index++] = (<span class="keyword">byte</span>)(c &gt;&gt; HI_BYTE_SHIFT);</span><br><span class="line">    val[index]   = (<span class="keyword">byte</span>)(c &gt;&gt; LO_BYTE_SHIFT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 <code>newBytesFor</code> 方法 <code>new</code> 一个两倍长度的 <code>byte</code> 数组，在 <code>for</code> 循环中，通过 <code>putChar</code> 方法来填充 <code>byte</code> 数组，将 <code>char</code> 字符分为两部分，存储两个相邻的 <code>byte</code> 数组中。</p><p><code>String</code> 类中方法基本都重新实现了一遍，但对外提供的接口没有改变。重构后，在字符串中所有字符小于 <code>0xFF</code> 时，可以节省一半的内存。</p><h1 id="JDK-11-新特性"><a href="#JDK-11-新特性" class="headerlink" title="JDK 11 新特性"></a>JDK 11 新特性</h1><p><code>JDK 11</code> 中 <code>String</code> 类增加了一系列的字符串处理方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断字符串是否为空白</span></span><br><span class="line">System.out.println(<span class="string">" "</span>.isBlank());              <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首尾空格</span></span><br><span class="line">System.out.println(<span class="string">" Timber "</span>.strip());           <span class="comment">// Timber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除首部空格</span></span><br><span class="line">System.out.println(<span class="string">" Timber"</span>.stripLeading());     <span class="comment">// Timber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除尾部空格</span></span><br><span class="line">System.out.println(<span class="string">"Timber "</span>.stripTrailing());    <span class="comment">// Timber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复字符串</span></span><br><span class="line">System.out.println(<span class="string">"Timber"</span>.repeat(<span class="number">2</span>));           <span class="comment">// TimberTimber</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取字符串中的行数</span></span><br><span class="line">System.out.println(<span class="string">"A\nB\nC"</span>.lines().count());  <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://www.hollischuang.com/archives/1232" target="_blank" rel="noopener">三张图彻底了解JDK 6和JDK 7中substring的原理及区别</a></li><li><a href="https://my.oschina.net/netconst/blog/1542362" target="_blank" rel="noopener">JDK9的String类内部实现变更了！</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;不可变性&quot;&gt;&lt;a href=&quot;#不可变性&quot; class=&quot;headerlink&quot; title=&quot;不可变性&quot;&gt;&lt;/a&gt;不可变性&lt;/h1&gt;&lt;p&gt;&lt;code&gt;String&lt;/code&gt; 对象是不可变（&lt;code&gt;Immutable&lt;/code&gt;）的，也就是一旦 &lt;code&gt;String&lt;/code&gt; 类实例被创建后，就不能改变其值。这里的不可变指的是引用既不能指向其他对象，而且引用指向的对象的值也不能改变。&lt;/p&gt;
    
    </summary>
    
      <category term="Java基础" scheme="https://blog.timberliu.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="https://blog.timberliu.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 Redis + Cookie 实现单点登录</title>
    <link href="https://blog.timberliu.com/2019/02/14/016_mmallv2.0redis+cookie%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/"/>
    <id>https://blog.timberliu.com/2019/02/14/016_mmallv2.0redis+cookie实现单点登录/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>电商项目中，在单服务器时，用户登录时将用户信息设置到 <code>session</code> 中，获取用户信息从 <code>session</code> 中获取，退出时从 <code>session</code> 中删除即可。</p><p>但在搭建 <code>Tomcat</code> 集群后，就需要考虑 <code>Session</code> 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 <code>Redis + Cookie</code> 自己实现，另一种是借助 <code>Spring Session</code> 框架解决。<a id="more"></a></p><h1 id="Redis-Cookie-实现"><a href="#Redis-Cookie-实现" class="headerlink" title="Redis+Cookie 实现"></a>Redis+Cookie 实现</h1><h1 id="单点登录的思路"><a href="#单点登录的思路" class="headerlink" title="单点登录的思路"></a>单点登录的思路</h1><p>用户登录：</p><ul><li>首先验证用户密码是否正确，并返回用户信息；</li><li>使用 <code>uuid</code> 或 <code>session.getId</code> 生成唯一 <code>id(token)</code>，设置到 <code>cookie</code> 中，将其写给客户端；</li><li>将用户信息(<code>user</code> 对象)转换为 <code>json</code> 格式；</li><li>以 <code>key=token</code>，<code>value=(user 的 json 格式)</code>，写到 <code>redis</code> 中，并设置过期时间；</li></ul><p>退出登录：</p><ul><li>用户请求时会携带 <code>cookie</code>，从 <code>cookie</code> 中获取到 <code>token</code>；</li><li>从请求中获取到 <code>cookie</code>，将其过期时间设置为 <code>0</code>，再写入到响应中，即删除了 <code>token</code>；</li><li>再从 <code>redis</code> 中删除 <code>token</code>；</li></ul><p>获取用户信息：</p><ul><li>从请求携带的 <code>cookie</code> 中获取到 <code>token</code>；</li><li>根据 <code>token</code> 在 <code>redis</code> 中查询相应的 <code>user</code> 对象的 <code>json</code> 串；</li><li>将 <code>json</code> 串转换为 <code>user</code> 对象；</li></ul><h1 id="Redis-连接池及工具类"><a href="#Redis-连接池及工具类" class="headerlink" title="Redis 连接池及工具类"></a>Redis 连接池及工具类</h1><p>由于 <code>token</code> 和 <code>user</code> 对象都会存储在 <code>redis</code> 中，所以这里封装一个 <code>redis</code> 的连接池和工具类。</p><p>首先，封装一个 <code>redis</code> 连接池，每次直接从连接池中获取 <code>jedis</code> 实例即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String redisIP = PropertiesUtil.getProperty(<span class="string">"redis.ip"</span>, <span class="string">"192.168.23.130"</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.port"</span>, <span class="string">"6379"</span>));</span><br><span class="line">    <span class="comment">// 最大连接数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.max.total"</span>, <span class="string">"20"</span>));</span><br><span class="line">    <span class="comment">// 最大的 idle 状态的 jedis 实例个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.max.idle"</span>, <span class="string">"10"</span>));</span><br><span class="line">    <span class="comment">// 最小的 idle 状态的 jedis 实例个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty(<span class="string">"redis.min.idle"</span>, <span class="string">"2"</span>));</span><br><span class="line">    <span class="comment">// 在 borrow 一个 jedis 实例时，是否要进行验证操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty(<span class="string">"redis.test.borrow"</span>, <span class="string">"true"</span>));</span><br><span class="line">    <span class="comment">// 在 return 一个 jedis 实例时，是否要进行验证操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty(<span class="string">"redis.test.return"</span>, <span class="string">"true"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        JedisPoolConfig config = <span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line">        config.setMaxTotal(maxTotal);</span><br><span class="line">        config.setMaxIdle(maxIdle);</span><br><span class="line">        config.setMinIdle(minIdle);</span><br><span class="line">        config.setTestOnBorrow(testOnBorrow);</span><br><span class="line">        config.setTestOnReturn(testOnReturn);</span><br><span class="line">        jedisPool = <span class="keyword">new</span> JedisPool(config, redisIP, redisPort, <span class="number">1000</span>*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">returnJedis</span><span class="params">(Jedis jedis)</span> </span>&#123;</span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，再将其封装成一个工具类，基本操作就是从 <code>redis</code> 连接池中获取 <code>jedis</code> 实例，进行 <code>set/get/expire</code> 等操作，然后将其放回到 <code>redis</code> 连接池中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisPoolUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exTime 以秒为单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">expire</span><span class="params">(String key, <span class="keyword">int</span> exTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Long result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.expire(key, exTime);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"expire key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title">del</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        Long result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.del(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"del key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.get(key);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"get key:&#123;&#125;, error"</span>, key, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">set</span><span class="params">(String key, String value)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.set(key, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"set key:&#123;&#125;, value:&#123;&#125;, error"</span>, key, value, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// exTime 以秒为单位</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">setEx</span><span class="params">(String key, String value, <span class="keyword">int</span> exTime)</span> </span>&#123;</span><br><span class="line">        Jedis jedis = <span class="keyword">null</span>;</span><br><span class="line">        String result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            jedis = RedisPool.getJedis();</span><br><span class="line">            result = jedis.setex(key, exTime, value);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">"setex key:&#123;&#125;, value:&#123;&#125;, error"</span>, key, value, e);</span><br><span class="line">        &#125;</span><br><span class="line">        RedisPool.returnJedis(jedis);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="JsonUtil-工具类"><a href="#JsonUtil-工具类" class="headerlink" title="JsonUtil 工具类"></a>JsonUtil 工具类</h1><p>将 <code>user</code> 对象存储在 <code>redis</code> 中，需要转换为 <code>json</code> 格式，从 <code>redis</code> 中获取 <code>user</code> 对象，又需要转换为 <code>user</code> 对象。这里封装一个 <code>json</code> 的工具类。</p><p><code>JsonUtil</code> 工具类主要使用 <code>ObjectMapper</code> 类。</p><ul><li><code>bean</code> 类转换为 <code>String</code> 类型，使用 <code>writerValueAsString</code> 方法。</li><li><code>String</code> 类型转换为 <code>bean</code> 类，使用 <code>readValue</code> 方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// 序列化时将所有字段列入</span></span><br><span class="line">        objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.ALWAYS);</span><br><span class="line">        <span class="comment">// 取消默认将 DATES 转换为 TIMESTAMPS</span></span><br><span class="line">        objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 忽略空 bean 转 json 的错误</span></span><br><span class="line">        objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">// 所有日期样式统一</span></span><br><span class="line">        objectMapper.setDateFormat(<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>));</span><br><span class="line">        <span class="comment">// 忽略 在 json 字符串中存在，在 java 对象中不存在对应属性的情况</span></span><br><span class="line">        objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">obj2Str</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> String ? (String) obj : objectMapper.writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse Object to String error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">String <span class="title">obj2StrPretty</span><span class="params">(T obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj == <span class="keyword">null</span>) &#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> obj <span class="keyword">instanceof</span> String ? (String) obj :</span><br><span class="line">                    objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse Object to String error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, Class&lt;T&gt; clazz)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str) || clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> clazz.equals(String.class) ? (T)str : objectMapper.readValue(str, clazz);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, TypeReference&lt;T&gt; typeReference)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(str) || typeReference == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> typeReference.getType().equals(String.class) ? (T)str : objectMapper.readValue(str, typeReference);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">str2Obj</span><span class="params">(String str, Class&lt;?&gt; collectionClass, Class&lt;?&gt; elementClass)</span> </span>&#123;</span><br><span class="line">        JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClass);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> objectMapper.readValue(str, javaType);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.warn(<span class="string">"Parse String to Object error"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="CookieUtil-工具类"><a href="#CookieUtil-工具类" class="headerlink" title="CookieUtil 工具类"></a>CookieUtil 工具类</h1><p>登录时需要将 <code>token</code> 设置到 <code>cookie</code> 中返回给客户端，退出时需要从 <code>request</code> 中携带的 <code>cookie</code> 中读取 <code>token</code>，设置过期时间后，又将其设置到 <code>cookie</code> 中返回给客户端，获取用户信息时，获取用户信息时，需要从 <code>request</code> 中携带的 <code>cookie</code> 中读取 <code>token</code>，在 <code>redis</code> 中查询后获得 <code>user</code> 对象。这里呢，也封装一个 <code>cookie</code> 的工具类。</p><p>在 <code>CookieUtil</code> 中：</p><ul><li><code>readLoginToken</code> 方法主要从 <code>request</code> 读取 <code>Cookie</code>；</li><li><code>writeLoginToken</code> 方法主要设置 <code>Cookie</code> 对象加到 <code>response</code> 中；</li><li><code>delLoginToken</code> 方法主要从 <code>request</code> 中读取 <code>Cookie</code>，将其 <code>maxAge</code> 设置为 <code>0</code>，再添加到 <code>response</code> 中；</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CookieUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_DOMAIN = <span class="string">".happymmall.com"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String COOKIE_NAME = <span class="string">"mmall_login_token"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">readLoginToken</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                log.info(<span class="string">"read cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123;</span><br><span class="line">                    log.info(<span class="string">"return cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                    <span class="keyword">return</span> cookie.getValue();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeLoginToken</span><span class="params">(HttpServletResponse response, String token)</span> </span>&#123;</span><br><span class="line">        Cookie cookie  = <span class="keyword">new</span> Cookie(COOKIE_NAME, token);</span><br><span class="line">        cookie.setDomain(COOKIE_DOMAIN);</span><br><span class="line">        cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">        <span class="comment">// 防止脚本攻击</span></span><br><span class="line">        cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 单位是秒，如果是 -1，代表永久；</span></span><br><span class="line">        <span class="comment">// 如果 MaxAge 不设置，cookie 不会写入硬盘，而是在内存，只在当前页面有效</span></span><br><span class="line">        cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span> * <span class="number">365</span>);</span><br><span class="line">        log.info(<span class="string">"write cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delLoginToken</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        <span class="keyword">if</span> (cookies != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Cookie cookie : cookies) &#123;</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123;</span><br><span class="line">                    cookie.setDomain(COOKIE_DOMAIN);</span><br><span class="line">                    cookie.setPath(<span class="string">"/"</span>);</span><br><span class="line">                    <span class="comment">// maxAge 设置为 0，表示将其删除</span></span><br><span class="line">                    cookie.setMaxAge(<span class="number">0</span>);</span><br><span class="line">                    log.info(<span class="string">"del cookieName:&#123;&#125;, cookieValue:&#123;&#125;"</span>, cookie.getName(), cookie.getValue());</span><br><span class="line">                    response.addCookie(cookie);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="具体业务"><a href="#具体业务" class="headerlink" title="具体业务"></a>具体业务</h1><p>登录时验证密码后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CookieUtil.writeLoginToken(response, session.getId());</span><br><span class="line">RedisShardedPoolUtil.setEx(session.getId(), JsonUtil.obj2Str(serverResponse.getData()), Const.RedisCacheExtime.REDIS_SESSION_EXTIME);</span><br></pre></td></tr></table></figure><p>退出登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String loginToken = CookieUtil.readLoginToken(request);</span><br><span class="line">CookieUtil.delLoginToken(request, response);</span><br><span class="line">RedisShardedPoolUtil.del(loginToken);</span><br></pre></td></tr></table></figure><p>获取用户信息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String loginToken = CookieUtil.readLoginToken(request);</span><br><span class="line"><span class="keyword">if</span> (StringUtils.isEmpty(loginToken)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"用户未登录，无法获取当前用户信息"</span>);</span><br><span class="line">&#125;</span><br><span class="line">String userJsonStr = RedisShardedPoolUtil.get(loginToken);</span><br><span class="line">User user = JsonUtil.str2Obj(userJsonStr, User.class);</span><br></pre></td></tr></table></figure><h1 id="SessionExpireFilter-过滤器"><a href="#SessionExpireFilter-过滤器" class="headerlink" title="SessionExpireFilter 过滤器"></a>SessionExpireFilter 过滤器</h1><p>另外，在用户登录后，每次操作后，都需要重置 <code>Session</code> 的有效期。可以使用过滤器来实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SessionExpireFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        String loginToken = CookieUtil.readLoginToken(httpServletRequest);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotEmpty(loginToken)) &#123;</span><br><span class="line">            String userJsonStr = RedisShardedPoolUtil.get(loginToken);</span><br><span class="line">            User user = JsonUtil.str2Obj(userJsonStr, User.class);</span><br><span class="line">            <span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;</span><br><span class="line">                RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还需要在 <code>web.xml</code> 文件中进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">mmall</span>.<span class="title">controller</span>.<span class="title">common</span>.<span class="title">SessionExpireFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">sessionExpireFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="此方式的缺陷"><a href="#此方式的缺陷" class="headerlink" title="此方式的缺陷"></a>此方式的缺陷</h1><ul><li><code>redis + cookie</code> 方式实现的单点登录对代码侵入性比较大；</li><li>客户端必须启用 <code>cookie</code>，而有些浏览器不支持 <code>cookie</code>；</li><li><code>Cookie</code> 设置 <code>domain</code> 时必须统一，服务器也必须统一域名方式；</li></ul><h1 id="Spring-Session-实现"><a href="#Spring-Session-实现" class="headerlink" title="Spring Session 实现"></a>Spring Session 实现</h1><p><code>Spring Session</code> 是 <code>Spring</code> 的项目之一，它提供了创建和管理 <code>Server</code> <code>HTTPSession</code> 的方案。并提供了集群 <code>Session</code> 功能，默认采用外置的 <code>Redis</code> 来存储 <code>Session</code> 数据，以此来解决 <code>Session</code> 共享的问题。</p><p><code>Spring Session</code> 可以无侵入式地解决 <code>Session</code> 共享问题，但是不能进行分片。</p><h1 id="Spring-Session-项目集成"><a href="#Spring-Session-项目集成" class="headerlink" title="Spring Session 项目集成"></a>Spring Session 项目集成</h1><p>1、引入 <code>Spring Session pom</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.session&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>2、配置 <code>DelegatingFilterProxy</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">org</span>.<span class="title">springframework</span>.<span class="title">web</span>.<span class="title">filter</span>.<span class="title">DelegatingFilterProxy</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">springSessionRepositoryFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;*.<span class="title">do</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>3、配置 <code>RedisHttpSessionConfiguration</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"redisHttpSessionConfiguration"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxInactiveIntervalInSeconds"</span> value=<span class="string">"1800"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>4、配置 <code>JedisPoolConfig</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"jedisPoolConfig"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"redis.clients.jedis.JedisPoolConfig"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"maxTotal"</span> value=<span class="string">"20"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>5、配置 <code>JedisSessionFactory</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"jedisConnectionFactory"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.data.redis.connection.jedis.JedisConnectionFactory"</span> &gt;</span><br><span class="line">    &lt;property name=<span class="string">"hostName"</span> value=<span class="string">"192.168.23.130"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"port"</span> value=<span class="string">"6379"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"database"</span> value=<span class="string">"0"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"poolConfig"</span> ref=<span class="string">"jedisPoolConfig"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>6、配置 <code>DefaultCookieSerializer</code></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"defaultCookieSerializer"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.springframework.session.web.http.DefaultCookieSerializer"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieName"</span> value=<span class="string">"SESSION_NAME"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"domainName"</span> value=<span class="string">".happymmall.com"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"useHttpOnlyCookie"</span> value=<span class="string">"true"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookiePath"</span> value=<span class="string">"/"</span> /&gt;</span><br><span class="line">    &lt;property name=<span class="string">"cookieMaxAge"</span> value=<span class="string">"31536000"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h1 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h1><p>用户登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.setAttribute(Const.CURRENT_USER, response.getData());</span><br></pre></td></tr></table></figure><p>退出登录时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.removeAttribute(Const.CURRENT_USER);</span><br></pre></td></tr></table></figure><p>获得用户信息时：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = (User) session.getAttribute(Const.CURRENT_USER);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;电商项目中，在单服务器时，用户登录时将用户信息设置到 &lt;code&gt;session&lt;/code&gt; 中，获取用户信息从 &lt;code&gt;session&lt;/code&gt; 中获取，退出时从 &lt;code&gt;session&lt;/code&gt; 中删除即可。&lt;/p&gt;
&lt;p&gt;但在搭建 &lt;code&gt;Tomcat&lt;/code&gt; 集群后，就需要考虑 &lt;code&gt;Session&lt;/code&gt; 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 &lt;code&gt;Redis + Cookie&lt;/code&gt; 自己实现，另一种是借助 &lt;code&gt;Spring Session&lt;/code&gt; 框架解决。&lt;/p&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
  <entry>
    <title>mmall_v2.0 环境搭建</title>
    <link href="https://blog.timberliu.com/2019/02/14/018_mmallv2.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://blog.timberliu.com/2019/02/14/018_mmallv2.0项目环境搭建/</id>
    <published>2019-02-13T16:00:00.000Z</published>
    <updated>2019-02-13T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis-配置与安装"><a href="#Redis-配置与安装" class="headerlink" title="Redis 配置与安装"></a>Redis 配置与安装</h1><p>从官网下载 <code>redis</code> 到 <code>/developer/setup</code> 目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//download.redis.io/releases/redis-4.0.12.tar.gz</span></span><br></pre></td></tr></table></figure><p>然后，将其解压到 <code>/developer</code> 目录下，进入到 <code>redis-4.0.12</code> 目录下，进行编译：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf redis-<span class="number">4.0</span>.12.tar.gz -C ../</span><br><span class="line">cd redis-<span class="number">4.0</span>.12/</span><br><span class="line">make</span><br></pre></td></tr></table></figure><a id="more"></a><p>再将其名修改为 <code>redis-4.0.12_1</code>，另外再拷贝一份为 <code>redis-4.0.12_2</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv redis-<span class="number">4.0</span>.12/ redis-<span class="number">4.0</span>.12_1</span><br><span class="line">cp redis-<span class="number">4.0</span>.12_1/ redis-<span class="number">4.0</span>.12_2/ -R</span><br></pre></td></tr></table></figure><p>然后，修改 <code>redis-4.0.12_2/src/</code> 目录下的 <code>redis.conf</code> 文件，端口修改为 <code>6380</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">port <span class="number">6380</span></span><br></pre></td></tr></table></figure><p>然后，分别进入到 <code>src/</code> 目录下，后台启动 <code>redis</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-server ../redis.conf &amp;</span><br></pre></td></tr></table></figure><h1 id="Tomcat-配置多实例"><a href="#Tomcat-配置多实例" class="headerlink" title="Tomcat 配置多实例"></a>Tomcat 配置多实例</h1><p>在单机部署多应用时，官方不建议复制一个又一份的全部 <code>Tomcat</code> 目录进行多实例的部署，而是按照如下图实现：</p><p><img src="http://media.timberliu.com/image/2019/1/30/Tomcat%E5%8D%95%E6%9C%BA%E5%A4%9A%E5%AE%9E%E4%BE%8B%E9%83%A8%E7%BD%B2.png" width="60%"></p><p><code>CATALINA_HOME</code> 指 <code>Tomcat</code> 的安装路径，包含 <code>bin</code> 和 <code>lib</code> 目录，而 <code>CATALINA_BASE</code> 指实例存放路径，包含 <code>conf</code>、<code>webapps</code>、<code>logs</code> 等目录。</p><p><strong>复制出两个实例</strong></p><p>首先新建两个 <code>tomcat1</code>、<code>tomcat2</code> 文件夹，并把 <code>apache-tomcat-8.5.35</code> 目录下的 <code>conf</code>、<code>webapps</code>、<code>temp</code>、<code>logs</code>、<code>work</code> 五个文件移动到 <code>tomcat1</code> 中，再将其复制一份到 <code>tomcat2</code> 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat1 tomcat2</span><br><span class="line">cd apache-tomcat-<span class="number">8.5</span>.11</span><br><span class="line">mv conf/ webapps/ temp/ logs/ work/ -t ../tomcat1</span><br><span class="line">cp -r ../tomcat1<span class="comment">/* ../tomcat2</span></span><br></pre></td></tr></table></figure><p>结果如下图所示：</p><p><img src="http://media.timberliu.com/image/2019/1/30/%E5%A4%8D%E5%88%B6%E5%87%BA%E4%B8%A4%E4%B8%AA%E5%AE%9E%E4%BE%8B.png" width="80%"></p><p><strong>配置 server.xml 端口</strong></p><p>修改 <code>conf/server.xml</code> 中的三个端口：</p><ul><li><code>Server port</code>：用于监听关闭 <code>Tomcat</code> 的 shutdown 命令，默认为 <code>8005</code></li><li><code>Connector port</code>：用于监听 <code>HTTP</code> 请求，默认为 8080</li><li><code>Connector port</code>（protocol=”AJP/1.3”）：用于监听 <code>AJP</code> 协议上的请求，通常用于整合 <code>Apache Server</code> 等其他 <code>HTTP</code> 服务器，默认为 <code>8009</code></li></ul><p>将 <code>tomcat2</code> 实例的端口分别修改为 <code>8006</code>、<code>8080</code>、<code>8010</code>，并对 <code>webapps/ROOT</code> 下的 <code>index.jsp</code> 首页作相应修改。</p><p><strong>创建启动、关闭脚本</strong></p><p>新建一个 <code>tomcat-shell</code> 文件夹，存放启动和关闭脚本，并赋予其执行权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mkdir tomcat-shell</span><br><span class="line">cd tomcat-shell/</span><br><span class="line">vim start.sh</span><br><span class="line">vim shutdown.sh</span><br><span class="line">chmod u+x start.sh shutdown.sh</span><br></pre></td></tr></table></figure><p>start.sh 脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/developer/$<span class="number">1</span></span><br><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line"></span><br><span class="line">cd $CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">sh startup.sh</span><br></pre></td></tr></table></figure><p>shutdown.sh 脚本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">export CATALINA_BASE=/developer/$<span class="number">1</span></span><br><span class="line">export CATALINA_HOME=/developer/apache-tomcat-<span class="number">8.5</span>.35</span><br><span class="line"></span><br><span class="line">cd $CATALINA_HOME/bin</span><br><span class="line"></span><br><span class="line">sh shutdown.sh</span><br></pre></td></tr></table></figure><p>启动和关闭脚本中，<code>$1</code> 表示执行时的第一个参数。</p><p><strong>启动实例</strong></p><p>执行以下命令，启动两个实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./start.sh tomcat1</span><br><span class="line">./start.sh tomcat2</span><br></pre></td></tr></table></figure><p><img src="http://media.timberliu.com/image/2019/1/30/%E5%AE%9E%E4%BE%8B%E5%90%AF%E5%8A%A8.png" width="80%"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis-配置与安装&quot;&gt;&lt;a href=&quot;#Redis-配置与安装&quot; class=&quot;headerlink&quot; title=&quot;Redis 配置与安装&quot;&gt;&lt;/a&gt;Redis 配置与安装&lt;/h1&gt;&lt;p&gt;从官网下载 &lt;code&gt;redis&lt;/code&gt; 到 &lt;code&gt;/developer/setup&lt;/code&gt; 目录下&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;wget http:&lt;span class=&quot;comment&quot;&gt;//download.redis.io/releases/redis-4.0.12.tar.gz&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，将其解压到 &lt;code&gt;/developer&lt;/code&gt; 目录下，进入到 &lt;code&gt;redis-4.0.12&lt;/code&gt; 目录下，进行编译：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;tar -zxvf redis-&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.12.tar.gz -C ../&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;cd redis-&lt;span class=&quot;number&quot;&gt;4.0&lt;/span&gt;.12/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="项目" scheme="https://blog.timberliu.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="mmall" scheme="https://blog.timberliu.com/tags/mmall/"/>
    
  </entry>
  
</feed>
