<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[基本数据类型]]></title>
    <url>%2F2018%2F11%2F03%2FBasicDateType%2F</url>
    <content type="text"><![CDATA[基本数据类型Java 中有 8 中基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下： Java 中的 char 使用 Unicode 编码，占两个字节。所以在 Unicode 编码中存在的中文，都可以用 char 存储。 在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：Java中，为什么byte类型的取值范围为-128~127?。 浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。Java 中使用 IEEE754 表示法，分为单精度和双精度两种，也就是 float 和 double，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。 包装类型每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别： 默认值不同。基本类型的默认值为 0,false等；而包装类默认为 null 初始化不同。基本类型不需要初始化；而包装类需要 new 存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中 元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法 基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 Java5 提供的一个语法糖。自动装箱就是 Java 自动将原始类型值转换为对应的对象；自动拆箱就是 Java 自动将对象转换为对应的基本类型。例如： 1234public static void main(String[] args) &#123; int i = 1; Integer n = i;&#125; 在反编译后，代码如下： 1234public static void main(String[] args) &#123; int i = 1; Integer n = Integer.valueOf(i);&#125; 可以看到，自动装箱就是调用 Integer 的 valueOf() 方法实现的；而自动拆箱是调用 Integer 的 xxxValue() 方法实现的。 整型的缓存机制Java5 中，Integer 引入了一个新功能来节省内存和提高性能。在使用 Integer.valueOf() 方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。 valueOf() 方法的实现如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 Integer 对象。 IntegerCache 是 Integer 的一个内部类，缓存池的大小默认为 -128~127。最大值可通过 -XX:AutoBoxCacheMax=xxx 修改。这个缓存在 Integer 类第一次被使用时，通过一个 for 循环存储在一个整数数组中。 1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 由于编译器在自动装箱时会调用 valueOf 方法，所以创建多个相同的值时，会引用相同的对象。 123456public static void main(String[] args) &#123; Integer i = 123; Integer j = 123; System.out.println(i == j);&#125;// true 所有的包装类都有类似的缓存机制： ByteCache 可以缓存 Byte 对象 ShortCache 可以缓存 Short 对象 LongCache 可以缓存 Long 对象 CharacterCache 可以缓存 Character 对象 Byte、Short、Long 的缓存范围都是固定的，为 -128~127。而 CharacterCache 的范围为 0~127。除了 Integer，这个范围都不能改变。 高精度类型Java 还提供了两个用于高精度计算的类：BigInteger 和 BigDecimal。 BigInteger 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。 BigDecimal 支持任意精度的定点数。可以用它进行精确的货币运算。 在 Java 中，对于金额的运算和在数据库中的存储，一般有两种方式： 以元为单位。Java 中存储类型为 BigDecimal，在数据库中的存储类型为 number(10, 2)，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。 以分为单位。Java 中存储类型为 Long，在数据库中存储类型为 big int。取整和保留方式如前面一样。 看一下下面的例子： 123456public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);&#125; 在进行金额运算时，使用 BigDecimal 类，并且将 double 转为 string 类型进行运算。在使用 divide 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。 参考资料 Hollis：[译]Java中整型的缓存机制]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象中的一些概念]]></title>
    <url>%2F2018%2F11%2F01%2FObject-orientedConcept%2F</url>
    <content type="text"><![CDATA[this、superthis 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。 还可以用 this 调用构造器。但必须将构造器置于最起始处。123456789101112public class User&#123; private String name; private int age; public User(String name) &#123; this.name = name; &#125; public User(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super 关键字表示如果子类重写了父类的某个方法，可以通过 super 关键字来调用父类的方法实现。 super 也可以用来调用父类的构造器。 123456789101112public class Person&#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void say() &#123; System.out.println(name + &quot;:&quot; + age); &#125;&#125; 12345678910111213141516171819public class Student extends Person &#123; private int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; @Override public void say() &#123; super.say(); System.out.println(name + &quot;:&quot; + age + &quot;,&quot; + score); &#125; public static void main(String[] args) &#123; Student student = new Student(&quot;Timber&quot;, 20, 80); student.say(); &#125;&#125;// Timber:20// Timber:20,80 finalfinal 关键字可用于三种情况：变量、方法和类。 1.变量 对于基本类型时，final 使数值恒定不变；对于引用类型时，final 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。 另外，在参数列表中还可以将参数声明为 final，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。 2.方法 final 方法不可以被重写。 类中所有的 private 方法都隐式地指定为 final，所以 private 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。 3.类 final 类不能被继承，而且 final 类中的所有方法都隐式地被指定为 final，无法覆盖它们。 static当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 static 方法或访问其 static 域。 1.变量 当 static 作用于某个字段时，会改变数据的创建方式，因为 static 字段对每个类只有一份存储空间，存放在方法区中；而非 static 字段则对每个对象都有一个存储空间，存放在堆中。 2.方法 对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 this 关键字。而 static 方法就是没有 this 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 static 方法，实际上这正是 static 方法的主要用途。 3.静态块 Java 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。 123456public Class User &#123; private String name; static &#123; name = &quot;Timber&quot;; &#125;&#125; 这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。 重写与重载1.重写 重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。 1234567891011121314151617class Person &#123; public void doSomething() &#123; System.out.println(&quot;do something&quot;); &#125;&#125; class Student extends Person&#123; @Override public void doSomething() &#123; System.out.println(&quot;studying&quot;); &#125; public static void main(String[] args) &#123; Person person = new Student(); person.doSomething(); &#125;&#125;// studying 上面就是一个重写的例子。重写一般需要注意以下几点： 子类方法的方法签名必须和父类方法相同； 子类方法的返回类型必须小于等于父类的方法； 子类中的访问权限必须大于等于父类的方法； 子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常 不能重写被标识为 final 的方法 重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。 12345678910111213141516public class Person &#123; String s = &quot;person&quot;;&#125;public class Student extends Person &#123; String s = &quot;student&quot;;&#125;public class Test &#123; public static void main(String[] args) &#123; Person a1 = new Student(); System.out.println(&quot;a1.s: &quot; + a1.s); Student a2 = new Student(); System.out.println(&quot;a2.s: &quot; + a2.s); &#125;&#125;// a1.s: person// a2.s: student 2.重载 重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。 123456789class Person&#123; public void doSomething() &#123; System.out.println(&quot;studying&quot;); &#125; public void doSomething(String thing) &#123; System.out.println(&quot;studying &quot; + thing); &#125;&#125; 上面就是一个重载的例子。重载一般需要注意几点： 被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。 根据方法的返回值不能区分重载 重载涉及到基本类型的自动提升时可能会造成混淆。 构造器构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 new 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。 一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 new Person() 创建对象时就会报错。 对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 int 初始化为 0，引用类型初始化为 null 等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。 对象的创建过程如下： 当首次创建类对象，或者类的静态方法/静态域被首次访问时，Java 解释器查找类文件； 然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。 如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 null； 然后执行出现于成员变量定义处的初始化动作； 然后再执行构造器。 多态多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件： 有类继承或接口实现 子类要重写父类的方法 父类的引用指向子类的对象 根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 平台]]></title>
    <url>%2F2018%2F10%2F30%2FTheJavaPlatform%2F</url>
    <content type="text"><![CDATA[Java 是一种面向对象的语言，最显著的特性有两个方面： 跨平台特性。也就是“编译一次，到处运行”（Compile once, run anywhere)，能够非常容易地获得跨平台能力； 垃圾回收机制。Java 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。 解释型语言 先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：C/C++ 等。 解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：Java、python 等。 严格来说，传统的 Java 是解释型语言，但加入了 JIT、AOT 编译器后，让 Java 也拥有了编译型语言的特性。它总共有三种执行的方式： Java 源代码首先经过 Javac 编译成 .class 文件，然后： 解释执行：.class文件经过 JVM 内嵌的解释器解释执行。 编译执行：即时编译器（Just In Time 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热） 编译执行: Java 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成） Java 与 C++ 的区别Java 和 C++ 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：C++ 是编译型语言，Java 是解释型语言。 二者主要区别如下： - Java C++ 语言类型 解释型 编译型 平台相关性 跨平台 平台相关的 语言 纯粹的面向对象语言 既支持面向对象也支持面向过程 数字类型 在所有平台上基本类型有标准的范围限制和字节长度 对数字类型有标准的范围限制但字节长度跟具体实现有关 参数传递 只有值传递它的引用可以理解为安全指针 有值传递和引用传递 内存管理 自动垃圾回收 需要显示的内存管理，支持析构函数 继承与实现 支持多重继承 只允许单继承，但可以多实现 操作符 不支持操作符重载仅对 String 有两个内置的加法运算 支持操作符重载 JDK、JRE、JVM下图是 Oracle 官方文档中的 JDK、JRE、JVM 三者间的关系： 三者详细： JDK：Java Development Kit（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。 JRE: Java Runtime Enviroment（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。 JVM：Java Virtual Machine（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。 跨平台特性Java 的跨平台特性与 Java 虚拟机的存在密不可分。其实 Java 语言本身与其他编程语言没有特别大的差异，并不是说 Java 语言可以跨平台，而是在不同的平台都有可以让 Java 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 JDK，安装 JDK 也就有了 Java 的运行环境。 简单来说，Java 首先通过 javac 编译器将源码编译为字节码 .class 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 JVM 会可以根据不同的平台，使用不同的 JVM 映射规则，生成对应的机器码，让其与操作系统无关。所以 Java 才有了“编译一次，到处运行”的效果。 Java 平台对于 Java 平台，有很多个方面可以谈： Java 语言特性：面向对象特性、泛型、Lamdba 等 基础类库：集合、IO/NIO、网络、并发等基础类库 JVM：类加载机制、垃圾回收、常用工具 Java 生态：JavaEE、Spring、Maven、Hadoop 等 下图是总结的一个蓝图：]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的运算]]></title>
    <url>%2F2018%2F10%2F30%2FJavaOperation%2F</url>
    <content type="text"><![CDATA[值传递与引用传递先来看一下值传递与引用传递的概念： 值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。 引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。 那么 Java 中到底是值传递还是引用传递？先来看下面的例子： 123456789101112public static void change(int j) &#123; j = 2; System.out.println("change: j = " + j);&#125;public static void main(String[] args) &#123; int i = 1; change(i); System.out.println("main: i = " + i);&#125;// change: j = 2// main: i = 1 可以看到，change 方法内部并没有改变实际参数的值，那么 Java 就是值传递吗？再来看下面的例子： 1234567891011121314public static void change(User user) &#123; user.setAge(21); System.out.println("change: " + user);&#125;public static void main(String[] args) &#123; User user = new User(); user.setName("Timber"); user.setAge(20); change(user); System.out.println("main: " + user);&#125;// change: User&#123;name='Timber', age=21&#125;// main: User&#123;name='Timber', age=21&#125; 可以看到，实际参数的值被改变了，那么 Java 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子： 123456789101112public static void change(String name2) &#123; name2 = &quot;TimberLiu&quot;; System.out.println(&quot;change: &quot; + name2);&#125;public static void main(String[] args) &#123; String name1 = &quot;Timber&quot;; change(name1); System.out.println(&quot;main: &quot; + name1);&#125;// change: TimberLiu// main: Timber 可以看到，实际参数的值又被改变了，这又作何解释呢？ Java 的值传递其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 传递参数时是否会进行拷贝，创建一个副本。 再来看一下上面的第二个例子，是如何传递的呢？ 可以看到，当把 user 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？ 12345678910111213141516public static void change(User user2) &#123; user2 = new User(); user2.setName(&quot;TimberLiu&quot;); user2.setAge(21); System.out.println(&quot;change:&quot; + user2);&#125;public static void main(String[] args) &#123; User user1 = new User(); user1.setName(&quot;Timber&quot;); user1.setAge(20); change(user1); System.out.println(&quot;main: &quot; + user1);&#125;// change: User&#123;name=&apos;TimberLiu&apos;, age=21&#125;// main: User&#123;name=&apos;Timber&apos;, age=20&#125; 这个过程发生了什么呢？看下图： 可以看到，这里把 user1 传递给 change 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 change 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 user2 的修改并不会影响到 user1 中的内容。 所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。 那么，为什么上面在传递 String 对象和 User 对象结果不一样呢？这是因为 String 类型是不可变的，在赋值 name2 = &quot;TimberLiu&quot; 时，会重新创建一个 String，而并没有修改实际参数的值。 所以，Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用。 类型转换Java 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下： 在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。 另外，在对基本数据进行运算时，所有 byte、short、char 类型的值都会自动被提升为 int。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。 在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子： 123456789public class Overflow &#123; public static void main(String[] args) &#123; int big = Integer.MAX_VALUE; System.out.println(&quot;big = &quot; + big); System.out.println(&quot;bigger = &quot; + (big + 1)); &#125;&#125;// big = 2147483647// bigger = -2147483648 switch 对 String 的支持switch 原本只支持整型，而 byte、short、char 可以转换为 int 型，所以也可以使用。但从 Java7 开始，在 switch 条件判断语句中也可以使用 String 类型了。 123456789101112public void decompile(String str) &#123; switch(str) &#123; case &quot;aaa&quot;: System.out.println(&quot;aaa&quot;); break; case &quot;bbb&quot;: System.out.println(&quot;bbb&quot;); break; default: System.out.println(&quot;other&quot;); &#125;&#125; 在反编译后，可以看到： 12345678910111213141516171819202122232425public void decompile(String str) &#123; byte var3 = -1; switch(str.hashCode()) &#123; case 96321: if (str.equals(&quot;aaa&quot;)) &#123; var3 = 0; &#125; break; case 97314: if (str.equals(&quot;bbb&quot;)) &#123; var3 = 1; &#125; &#125; switch(var3) &#123; case 0: System.out.println(&quot;aaa&quot;); break; case 1: System.out.println(&quot;bbb&quot;); break; default: System.out.println(&quot;other&quot;); &#125; &#125; 可以看到，String 的 switch 还是比较的 byte 类型。先声明了一个 byte 类型，然后通过 hashCode 和 equals 两个方法先后进行比较来赋予 byte 变量不同的值，最后 switch 来执行不同的代码。这里在 hash 之后再进行 equals 判断是有必要的，因为 hash 可能发生碰撞。 参考资料 Hollis：为什么说Java中只有值传递 SEU_Calvin：Java技术——Java中的参数传值方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解面向对象思想]]></title>
    <url>%2F2018%2F10%2F28%2FObject-orientedThought%2F</url>
    <content type="text"><![CDATA[学习 Java 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。 Java 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 Java 平台又该如何理解？今天就来学习一下。 面向对象思想所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。 而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。 在面向对象程序设计中会创建抽象数据类型，也就是类（class），它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。 三大特征封装封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。 Java 用三个关键字在类内设定边界：public、protected、private，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。 继承代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 private，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。 另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写（overriding）。 那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。 多态在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。 在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。 五大设计原则面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。 单一职责（Single Responsibility）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。 开关封闭（Open-Closed）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。 里氏替换（Liskov Substitution）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。 接口隔离（Interface-Segregation）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。 依赖倒置（Dependency Inversion）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。 对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。 参考资料 《Java 编程思想》 Hollis：牢记面向对象五个基本原则 十四期_李光：面向对象与面向过程的本质的区别]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
