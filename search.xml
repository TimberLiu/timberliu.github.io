<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java 并发之 Lock 与 AQS 同步器]]></title>
    <url>%2F2019%2F04%2F12%2F037_Lock%20%E4%B8%8E%20AQS%20%E5%90%8C%E6%AD%A5%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Lock 接口在 Java5 之前，只能使用 synchronized 关键字来实现锁。它使用起来比较简单，但是有一些局限性： 无法中断一个正在等待获取锁的线程； 无法在请求获取一个锁时等待一段时间。 而在 Java5 中，并发包中增加了 Lock 接口及其实现类，它的功能与 synchronized 类似，需要进行显示地获取和释放锁，但是却提供了很多 synchronized 不具有的特性。举一个例子： 1234567Lock lock = new ReentrantLock();lock.lock();try &#123; //&#125; finally &#123; lock.unlock();&#125; 注意的是获取锁的 lock 方法应该写在 try 块之外，因为如果写在 try 块中，获取锁时发生了异常，抛出异常的同时也会导致锁无故释放，而不是等到执行 finally 语句时才释放锁。 在 Lock 接口中，定义了锁获取和释放的基本操作，包括可中断的获取锁、超时获取锁等特性： 123456789101112131415161718192021public interface Lock &#123; // 获取锁 void lock(); // 可中断地获取锁，即获取锁时，其他线程可以中断当前线程 void lockInterruptibly() throws InterruptedException; // 尝试获取锁，调用后会立即返回，能获取就返回 true，否则返回 false boolean tryLock(); // 在给定时间内可中断地尝试获取锁 boolean tryLock(long time, TimeUnit unit) throws InterruptedException; // 释放锁 void unlock(); // 返回一个绑定到该 Lock 实例上的 Condition // 只有当前线程持有了锁，才能调用 await 方法，await 方法的调用将会自动释放锁 Condition newCondition();&#125; Lock 接口的主要实现就是 ReentrantLock。而 Lock 接口的实现基本都是通过内部实现了一个同步器 AQS 的子类来实现线程访问控制的。 AQS同步器 AbstractQueuedSynchronizer，是用来构建锁或其他同步组件的基础框架。它使用一个 int 成员变量表示同步状态，通过内置的 FIFO 同步队列来完成线程获取资源时的排队等待工作。 在自定义同步组件时，推荐定义一个静态内部类，使其继承自同步器 AQS 并实现它的抽象方法来管理同步状态，在实现抽象方法时，对同步状态的管理可以使用同步器提供的三个方法。 12345678910111213141516private volatile int state;// 获取当前同步状态protected final int getState() &#123; return state;&#125;// 设置当前同步状态protected final void setState(int newState) &#123; state = newState;&#125;// 使用 CAS 设置当前状态，保证原子性protected final boolean compareAndSetState(int expect, int update) &#123; return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125; 同步器是实现同步组件的关，它们二者的关系如下： 同步组件是面向使用者的，定义了使用者与同步组件交互的接口，隐藏了实现细节； 同步器面向的是同步组件的实现者，它简化了同步组件的实现方式。 同步器的接口同步器是基于模板方法模式的。使用者需要继承同步器并重写指定的方法。而可重写的方法主要有： 方法名 描述 tryAcquire 独占式获取同步状态 tryRelease 独占式释放同步状态 tryAcquireShared 共享式获取同步状态 tryReleaseShared 共享式释放同步状态 isHeldExclusively 判断同步器是否被线程独占 随后将同步器组合到自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法会调用使用者重写的方法。 可调用的模板方法主要有三类：独占式获取与释放同步状态、共享式获取与释放状态、以及查询同步队列中的等待线程情况。下文会介绍它们，并简单分析其实现原理。 同步队列同步器内部使用一个 FIFO 同步队列来管理同步状态，在线程获取同步状态失败时，同步器会将当前线程与等待状态等信息构造成一个节点，将其加入到同步队列中，同时会阻塞当前线程。当释放同步状态时，则会唤醒队列中首节点的线程，使其再次尝试获取同步状态。 同步队列中的节点的主要属性有： 12345678910111213static final class Node &#123; // 等待状态 volatile int waitStatus; // 前驱节点，在入队时被赋值 volatile Node prev; // 后继节点， volatile Node next; // 加入节点的线程，该线程获取到同步状态 volatile Thread thread;&#125; 等待状态 waitStatus 的取值主要有： 123456789101112131415// 同步队列中等待的线程等待超时或被中断，需要取消等待，之后节点的状态将不会再改变static final int CANCELLED = 1;// 后继节点的线程处于等待状态// 当前节点的线程释放或取消同步状态时，会唤醒它的后继节点static final int SIGNAL = -1; // 节点目前在等待队列中// 当节点被唤醒时，从等待队列转移到同步队列中，尝试获取同步状态static final int CONDITION = -2;// 共享式同步状态被传播给其他节点static final int PROPAGATE = -3;//初始化 waitStatus 值为 0 同步器中包含两个引用，分别指向同步队列的首节点和尾节点： 12345// 头节点，惰性初始化private transient volatile Node head;// 尾节点，惰性初始化private transient volatile Node tail; 当线程无法获取同步状态，会将该线程构造成一个节点加入同步队列中，使用 addWaiter 方法: 1234567891011121314private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); // 快速尝试 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 如果快速尝试添加尾节点失败，则调用 enq 方法通过死循环来保证节点的正确添加： 123456789101112131415private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // 如果未初始化，则会先初始化，再继续尝试 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 而这个过程可能会有多个线程同时执行，所以必须要保证线程安全，提供了基于 CAS 的设置尾节点的方法： 123private final boolean compareAndSetTail(Node expect, Node update) &#123; return unsafe.compareAndSwapObject(this, tailOffset, expect, update);&#125; 同步队列中，首节点是获取同步状态成功的节点，线程在释放同步状态时，会唤醒后继节点，后继节点成功获取同步状态时将自己设置为首节点，由于只有一个线程能获取到同步状态，所以设置头节点的方法不需要 CAS 方法保证： 12345private void setHead(Node node) &#123; head = node; node.thread = null; node.prev = null;&#125; 独占式获取与释放独占式获取与释放同步状态主要有四个模板方法，分别是： 方法名 描述 void acquire(int arg) 独占式获取同步状态 void acquireInterruptibly(int arg) 可响应中断的独占式获取同步状态 boolean tryAcquireNanos(int arg, long nanos) 可响应中断的独占式超时获取同步状态 boolean release(int arg) 独占式释放同步状态 独占式获取acquire 方法可以获取同步状态，该方法为独占式获取，不可中断，也就是如果线程获取同步状态失败，加入到同步队列中，后续对线程进行中断操作，线程并不会被移除。 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; acquire 方法中，首先调用 tryAcquire 方法尝试获取同步状态，该方法由自定义组件自己实现。如果获取失败，调用 addWaiter 方法将当前线程加入到同步队列末尾。最后调用 acquiredQueued 方法通过死循环的方式来获取同步状态： 123456789101112131415161718192021final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 该方法中，通过死循环的方式来获取同步状态，并且只有前驱节点是头节点时，才能够尝试获取同步状态，这样做就是为了保持 FIFO 同步队列原则，即先加入到同步队列中的线程先尝试获取同步状态。 另外，在自旋时首先会调用 shouldParkAfterFailedAcquire 方法判断是否应该被阻塞： 1234567891011121314151617private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) // 前驱节点状态为 SIGNAL ，则当前节点可以被阻塞 return true; if (ws &gt; 0) &#123; // 前驱节点处于取消状态，也就是超时或被中断，需要从同步队列中删除 do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; // 否则，将当前节点设置为 SIGNAL，不会阻塞 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 该方法主要是根据前驱节点的 waitStatus 来判断当前节点的线程，如果当前节点应该被阻塞，则会调用 parkAndCheckInterrupt 方法阻塞： 1234private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 该方法调用 LockSupport.park() 方法阻塞当前线程，并返回当前线程的中断状态。 可中断式获取acquireInterruptibly 方法以可响应中断的方式获取同步状态，其中调用 tryAcquire 方法失败后，会调用 doAcquireInterruptibly 方法自旋式获取。 1234567public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; doAcquireInterruptibly 方法与普通地独占式获取同步状态非常类似，只是不再使用 interrupt 标志，而是直接抛出 InterruptedException 异常。 超时可中断式获取tryAcquireNanos 方法可以超时获取同步状态，即在指定时间内可中断地获取同步状态。 1234567public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125; 该方法首先调用 tryAcquire 方法尝试获取同步状态，如果获取失败，则会调用 doAcquireNanos 方法： 123456789101112131415161718192021222324252627282930313233private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; // 计算总的超时时间 final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; // 剩余的超时时间 nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L) return false; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) // 如果超时时间大于 临界值，则会阻塞线程，否则快速自旋 LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 该方法中，首先计算出超时的最终时间，然后将当前节点加入到同步队列中。 然后自旋进行判断，如果当前节点为头节点，则会调用 tryAcquire 方法尝试获取同步状态；否则重新计算超时时间，如果 nanosTimeout 小于 0，则获取失败。否则继续判断超时时间是否大于 spinForTimeoutThreshold 临界值，如果大于表示时间较长，调用 LockSupport.parkNanos 使线程阻塞。 如果时间较短，则直接进入自旋过程，继续判断。另外，还会判断线程是否被中断。 独占式释放release 方法用来释放同步状态，该方法释放了同步状态后，会唤醒后继节点，使其重新尝试获取同步状态。 123456789public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 该方法中，首先调用 tryRelease 方法尝试释放同步状态，该方法由自定义同步组件自己实现。然后调用 unparkSuccessor 方法来唤醒后继节点： 123456789101112131415161718private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) // 节点状态设置为 0 compareAndSetWaitStatus(node, ws, 0); Node s = node.next; // 如果后继节点超时或者被中断 if (s == null || s.waitStatus &gt; 0) &#123; s = null; // 从 tail 向前，找最靠近 head 的可用节点 for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 该方法首先找到一个可用的 waitStatus 值大于 0 的节点，然后调用 LockSupport.unpark 方法唤醒该线程。 共享式获取与释放共享式与独占式最大的区别就是同一时刻有多个线程同时获取到同步状态。 共享式获取与释放同步状态主要有四个模板方法，分别是： 方法名 描述 acquireShared(int arg) 共享式获取同步状态 acquireSharedInterruptibly(int arg) 可响应中断的共享式获取同步状态 tryAcquireSharedNanos(int arg, long anos) 可响应中断的共享式超时获取同步状态 releaseShared(int arg) 共享式释放同步状态 共享式获取acquireShared 方法可以共享式地获取同步状态： 1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125; 该方法中，首先调用 tryAcquireShared 方法尝试获取同步状态，如果返回值大于等于 0，则表示获取成功。否则获取失败，则会调用 doAcquireShared 方法： 1234567891011121314151617181920212223242526272829private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; // 获取前驱节点 final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; // 大于等于 0，表示获取成功 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 首先以共享节点加入到等待队列中，然后以死循环的方式进行判断，如果当前节点的前驱节点为头节点，则调用 doAcquireShared 方法尝试获取同步状态，直到其返回值大于等于 0。 可响应中断、超时获取的共享式获取同步状态与之前类似，这里也就不多介绍。 共享式释放releaseShared 方法用于共享式释放同步状态， 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125; 该方法首先调用 tryReleaseShared 尝试释放同步状态，如果释放失败，则会调用 doReleaseShared 方法； 123456789101112131415161718private void doReleaseShared() &#123; for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 该方法中在释放同步状态时，由于有多个线程，需要保证线程安全。首先，如果后继节点的线程需要唤醒，则将当前节点的状态设置为 0，然后调用 unparkSuccessor 方法唤醒后继节点。 参考资料 方腾飞：《Java并发编程的艺术》 【死磕Java并发】—–J.U.C之AQS：AQS简介]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发之 Java 内存模型]]></title>
    <url>%2F2019%2F03%2F03%2F035_Java%20%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[为什么要有内存模型计算机的 CPU 和内存之间一直有一个核心矛盾，就是它们之间的运算速度有好几个数量级的差距，为了平衡它们的差异，主要做了以下： CPU 增加了高速缓存，以均衡与内存的速度差异； 操作系统增加了进程、线程，以分时复用 CPU，均衡 CPU 与 I/O 设备的差异； 编译器优化指令执行次序，使得缓存能得到更加充分的利用。 虽然高速缓存很好地解决了处理器与内存的速度矛盾，但是又出现了一个新的问题。在多核处理机中，每个处理器都有自己的高速缓存，它们共享同一主内存。当多个处理器的任务涉及到同一块主内存区域时，可能导致缓存的数据不一致的情况，这就是可见性问题，可见性是指一个线程对共享变量的修改，另外一个线程能够立刻看到。 操作系统基于线程来进行任务调度。高级语言的一条语句往往需要多条指令完成，但是任务切换可以发生在任何一条 CPU 指令后，在多线程环境下这就可能导致数据与预期的不一致，即原子性问题。原子性是指一个或多个操作在 CPU 执行过程中不被中断。 编译器的指令重排序优化同样不能保证最终的结果与预期的一致。这里的重排序会满足以下两个条件： as-if-serial：在单线程环境下不管怎么重排序，不能改变程序运行的结果。 数据依赖性：存在数据依赖关系的不能重排序。 需要注意的是：虽然重排序不会影响单线程环境的执行结果，但是会破坏多线程的执行语义。也就是有序性问题，有序性指的是程序按照代码的先后顺序（逻辑先后）执行。 所以，JVM 试图虚拟机定义了一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各层硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果，也就是解决以上三个问题。 Java 内存模型Java 内存模型主要是为了定义程序中各个变量的访问规则，此处的变量指的是实例字段、静态字段和构成数组对象的元素等共享变量。 Java 内存模型规定了所有的变量都存储在主内存中。每个线程还有自己的工作内存，其中保存了该线程使用的变量的主内存副本拷贝，线程对变量的所有操作必须在工作内存中进行。不同线程之间也无法直接访问对方工作内存中的变量，线程之间的变量值传递需要通过主内存来完成。 线程、工作内存、主内存三者的关系如下： 内存间交互操作对于主内存与工作内存之间交互的实现细节，Java 内存模型中定义了 8 种操作来实现，虚拟机实现时必须保证这些操作是原子性的。 read（读取）：把一个变量的值从主内存传输到工作内存中； load（载入）：把 read 操作从主内存得到的变量放入工作内存的变量副本中； use（使用）；把工作内存中一个变量的值传递给执行引擎； assign（使用）：把一个从执行引擎接收到的值赋给工作内存的变量； store（存储）：把工作内存中一个变量的值传送到主内存中； write（写入）：把 store 操作从工作内存中得到的变量放入主内存的变量中。 volatile 型变量关键字 volatile 是 JVM 提供的轻量级的同步机制。当一个变量被定义为 volatile 后，它可以保证内存的可见性。 使用 volatile 还可以禁止指令重排序优化。它是 Java 编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。 内存屏障（Memory Barrier）是一组处理器指令，用于实现对内存访问操作的顺序限制。在重排序时不能把后面的指令重排序到内存屏障之前的位置。 原子性、可见性、有序性Java 内存模型保证了并发的三个特性：原子性、可见性、有序性，下面学习一下哪些操作实现了这三个特性： 原子性Java 内存模型保证了内存间交互的 8 个操作的原子性，但对于 64 位的数据类型（long 和 double），允许虚拟机的实现可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。但目前虚拟机几乎都把 64 位数据的读写操纵作为原子性来对待。也就是说可以认为基本类型的读写访问是具备原子性的。 JMM 还提供了 lock 和 unlock 操作来保证更大范围的原子性，尽管虚拟机并未将其开放给用户，但可使用 monitorenter 和 monitorexit 字节码指令来隐式地使用这两个操作，对应到 Java 代码中就是 synchronized 关键字，所以 synchronized 同步块也是原子性的。 可见性主要有三种方式实现可见性： volatile：volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。 synchronized：对同步块加锁解锁，在执行 unlock 操作前必须把此变量值同步到主内存中。 final：被 final 关键字修饰的字段在构造器中一旦初始化完成，并且没有发生 this 引用逃逸（其它线程可能通过引用访问到初始化了一半的对象），那么其它线程就能看见 final 字段的值。 有序性Java 中有两种方式保证线程之间操作的有序性； volatile 关键字通过添加内存屏障的方式来禁止指令重排。 通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，即让线程串行地执行同步代码。 Happends-Before 原则前面说的保证并发安全的定义实践起来比较麻烦，有一个等效判断原则——Happens-Before 原则，来确定一个访问在并发环境下是否安全。 Happens-Before 的含义就是前面一个操作的结果对后续操作是可见的。要想保证执行操作 B 的线程看到线程 A 的结果，那么 A 和 B 之间必须满足 Happens-Before 原则。如果两个操作之间缺乏 Happens-Before 原则，那么 JVM 就可以对它们任意地重排序，那么就会产生数据竞争问题。 Happens-Before 原则包括： 程序顺序规则：一个线程内按照控制流顺序，前面的操作 Happens-Before 于后面的操作。 管程锁定规则：一个 unlock 操作 Happens-Before 于后面对同一个锁的 lock 操作。 volatile 变量规则：对一个 volatile 变量的写操作 Happens-Before 于对该变量的读操作。 线程启动规则：Thread 对象的 start 方法 Happens-Before 于此线程的每一个动作。 线程终止规则：线程中的所有操作都 Happens-Before 于对该线程的终止检测，可通过 Thread.join 方法结束，或 Thread.isAlive 方法的返回值，检测到线程已经终止执行。 线程中断规则：对线程 interrupt 方法的调用 Happens-Before 于被中断线程的代码检测到中断事件的发生。 对象终结规则：一个对象的初始化完成 Happens-Before 于它的 finalize 方法的开始。 传递性：如果操作 A Happens-Before 于操作 B，操作 B Happens-Before 于操作 C，那么操作 A 就 Happens-Before 于操作 C。 参考资料 《深入理解 Java 虚拟机》 CyC2018：CS-Notes / Java 并发]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 并发之深入分析 synchronized 关键字]]></title>
    <url>%2F2019%2F03%2F03%2F036_%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90%20synchronized%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[synchronized 概述synchronized 关键字提供了一种独占式的加锁方式，用来控制多个线程对共享资源的互斥访问。它可以保证在同一时刻只有一个线程在执行该段代码，同时它还可以保证共享变量的内存可见性。 互斥性：同一时刻只允许一个线程持有某个对象锁，一次实现对共享资源的互斥访问。 可见性：确保在锁释放前，对共享变量做的修改，对随后获得该锁的另一个线程是可见的。 synchronized 的获取和释放锁由 JVM 实现，用户不需要显示的获取和释放锁，非常方便。但是当线程尝试获取锁的时候，如果获取不到锁该线程会一直阻塞。 在早期版本中，synchronized 是一个重量级锁，效率低下。但从 JDK1.6 开始，从 JVM 层面对 synchronized 引入了各种锁优化技术，例如：自旋锁、适应性自旋锁、锁消除、锁粗化、轻量级锁和偏向锁等，大大减少了锁操作的开销。 使用方式使用 synchronized 实现同步有同步方法块、同步方两种方式。 同步方法块作用于代码块时，括号中可以是指定的对象，也可以是 Class 对象。 123456// 锁的是指定的对象实例public void test1 ()&#123; synchronized(this) &#123; // ··· &#125;&#125; 123456// 锁定是指定的类对象public void test2 ()&#123; synchronized(Test.class) &#123; // ··· &#125;&#125; 同步方法作用于方法时，锁的是当前的对象实例。 123public synchronized void test3()&#123; // ···&#125; 作用于静态方法，锁的是类对象。 123public synchronized static void test4()&#123; // ···&#125; 原理基础HotSpot 对象头 HotSpot 虚拟机的对象头分为两部分信息： Mark Word：用于存放对象自身的运行时数据，如哈希码、GC 分代年龄、锁类型、锁标志位等信息，这部分数据在 32 位和 64 位虚拟机中分别为 32 和 64 bit。它是实现轻量级锁和偏向锁的关键。 Class Metadata Address：用于存储指向方法区对象类型数据的指针，如果是数组，还会有一个额外的部分用于存放数组长度。 Mark Word 被设计为一个非固定的数据结构以便存储更多的信息，它会根据对象的状态复用自己的存储空间。例如，在 32 位的 HotSpot 虚拟机中,各种状态下对象的存储内容如下： Monitor 每个 Java 对象都有一个 Monitor 对象与之关联，它被称为管程（监视器锁），前面的表格中，锁状态为重量级锁时，指针就指向 Monitor 对象的起始地址。当一个 Monitor 被某个线程持有后，便处于锁定状态。在 HotSpot 虚拟机的源码实现中，ObjectMonitor 对象相关属性有： _count：计数器； _owner：指向持有 ObjectMonitor 对象的线程； _WaitSet：等待池； _EntryList：锁池； 多个线程访问同步代码时，首先会进入 _EntryList 锁池中被阻塞，当线程获取到对象的 Monitor 后，就会把 _owner 指向当前线程，同时 Monitor 中的 _count 计数器加一。如果线程调用 wait 方法，_owner 就被恢复为 null，_count 计数器减一，同时该线程就会进入 _WaitSet 等待池中。 当线程执行完毕，将对应的变量复位，以便其他线程获取 Monitor 锁。 四种状态 synchronized 有四种状态：无锁、偏向锁、轻量级锁和重量级锁。随着对锁的竞争逐渐激烈，锁的状态进行升级。 synchronized 实现原理同步方法块1234567public class SynchronizedTest &#123; public void test1() &#123; synchronized (this) &#123; // ··· &#125; &#125;&#125; 使用 javap -c -v 对 SynchronizedTest.class 进行反汇编： 可以看到，在同步代码块的开始位置插入 monitorenter 指令，在结束位置插入 monitorexit 指令，而且必须保证每一个 monitorenter 都有一个 monitorexit 与之对应。 synchronized 便是通过 Monitor 获取锁的。当线程执行到 monitorenter 指令时，将会尝试获取 Monitor 所有权。当计数器为 0，则成功获取；获取后将锁计数器置为 1。在执行 monitorexit 指令时，将锁计数器置为 0。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。 同步方法12345public class SynchronizedTest &#123; public synchronized void test1() &#123; // ··· &#125;&#125; 使用 javap -c -v 对 SynchronizedTest.class 进行反汇编： 可以看到，被同步的方法也仅是被翻译成普通的方法调用和返回指令。在 JVM 字节码层面并没有任何特别的指令来实现 synchronized 修饰的方法。 但是在 Class 文件的方法表中将方法的 flags 字段中的 ACC_SYNCHRONIZED 标志位置为 1，表示该方法是同步方法。在执行方法时，线程就会持有 Monitor 对象。 底层优化JDK1.6 对锁引入了大量的优化，如自旋锁、自适应自旋锁、锁消除、锁粗化、轻量级锁、偏向锁等技术来减少锁操作的开销。 自旋锁和自适应自旋在实现同步互斥时，如果获取锁失败，就会使当前线程阻塞，但线程的挂起和恢复都需要在内核态和用户态之间转换，对系统的性能影响很大。许多情况下共享数据的锁定状态持续时间不会很长，切换线程不值得。 自旋锁就是让线程在请求共享数据的锁时执行一个忙循环（自旋），如果能够很快获得锁，就避免其进入阻塞状态。 自旋等待虽然避免了线程切换的开销，但它要求多处理器，而且要占用处理器时间。如果锁占用时间过长，那么反而会消耗更多的资源。因此，对自旋等待的时间必须进行限制，另外自旋的次数也不能过多，默认为 10 次，可使用 -XX:PreBlockSpin 参数修改。 JDK1.6 中引入了自适应的自旋锁，它的自旋时间由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。 锁消除锁消除是指虚拟机的即时编译器在运行时，如果代码要求同步，但检测发现不可能存在共享数据竞争时，那么就进行锁消除。 锁消除主要根据逃逸分析，如果判断在一段代码中，堆上的所有数据都不会逃逸出去，那就可以将它们认为是线程私有的，也就无须进行同步加锁。 锁粗化如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁也是出现循环体中，那么即使没有数据竞争，频繁地加锁解锁也会导致不必须的性能消耗。 锁粗化指的就是如果虚拟机探测到这样的情况，那就将加锁同步的范围扩展（粗化）到整个操作序列的外部。 偏向锁偏向锁是在无竞争的情况下消除整个同步，也就是减少同一线程获取锁的代价。它的思想是这个锁会偏向于第一个获得它的线程，如果接下来该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。 当锁对象第一次被线程获取时，锁进入偏向模式，同时 Mard Word 的结构也变为偏向锁结构。锁标志位为“01”，同时使用 CAS 操作把获取到这个锁的线程的 ID 记录在对象的 Mark Word 中，如果 CAS 操作成功，这个线程以后每次进入这个锁相关的同步块时，都可以不用再进行任何同步操作。 不适用于锁竞争比较激烈的多线程场合。 当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束。根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定状态或者轻量级锁状态。 轻量级锁轻量级锁是相对于使用操作系统互斥量实现的传统锁而言的。偏向锁运行在一个线程进入同步块时，如果有第二个线程加入锁竞争，则偏向锁就会升级为轻量级锁。它适用于线程交替执行的场景。 在代码进入同步块时，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机将先在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前 Mark Word 的拷贝。如下图，左侧是一个线程的虚拟机栈，右侧是一个锁对象： 然后，虚拟机将使用 CAS 操作尝试将对象的 Mark Word 更新为指向 Lock Record 的指针，并将 Lock Record 里的 owner 指针指向对象的 Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象的 Mark Word 的锁标志位转变为“00”，即表示对象处于轻量级锁定状态。多线程堆栈和对象头的状态如下： 如果这个更新操作失败了，虚拟机首先会检查对象的 Mark Word 是否指向当前线程的栈帧，如果已指向则说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，如果没有指向则说明这个锁对象已经被其他对象抢占了。 如果有两条以上的线程争用同一个锁，那轻量级锁就要膨胀为重量级锁，锁标志变为“10”，Mark Word 中存储的就是指向重量级锁的指针，后面等待锁的线程也要进入阻塞状态。 对于绝大部分的锁，在整个同步周期内都是不存在竞争的。如果没有竞争，轻量级锁使用 CAS 操作避免了重量级锁使用互斥量的开销，提升了程序同步的性能。 偏向锁、轻量级锁的状态转化及对象 Mark Word 的关系如下： 参考资料 《深入理解 Java 虚拟机》 CyC2018：CS-Notes / Java 并发 Hollis：深入理解多线程（三）—— Java的对象头]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 JVM 之 类加载机制]]></title>
    <url>%2F2019%2F03%2F02%2F034_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[Java 源程序经过编译器编译后，会生成 Class 文件。文件中描述的各种信息都需要加载到虚拟机中才能运行和使用。那么虚拟机如何加载这些数据呢？这就是这篇文章要学习的内容——类加载机制。 类加载概述类加载机制，就是 JVM 将描述类的数据从 Class 文件加载到内存中，并对数据进行校验、转换解析和初始化，最终会形成可以被 JVM 直接使用的 Java 类型。 类被从加载，到卸载会经历如下七个生命周期： 其中加载、验证、准备、初始化和卸载这五个阶段的顺序的确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后再开始。 类加载的时机类加载在何时开始，Java 虚拟机规范并没有明确规定。但是对初始化阶段，则是严格规定了有且只有五种情况必须立即对类进行初始化： 遇到 new、getstatic、putstatic 或 invokestatic 四条字节码指令时，如果类没有被初始化，则需要先进行初始化。它们对应的代码场景分别是： new：使用 new 关键在实例化对象时； getstatic：读取一个类的静态字段； putstatic：设置一个类的静态字段； invokestatic：调用一个类的静态方法时； 使用 java.lang.reflect 包中的方法对类进行反射调用时，如果类没有被初始化，则需要先进行初始化。 当初始化一个类时，如果其父类还没有被初始化，则需要先对其父类进行初始化。 当虚拟机启动时，需要指定一个要执行的主类（包含 main 方法的类），虚拟机会先初始化这个主类。 当使用 JDK1.7 的动态语言支持时，如果一个 java.lang.invoke.MehodHandle 实例最后的解析结果 REF_getStatic、REF_getStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄对应的类没有进行初始化，则需要先进行初始化。 类加载的过程下面详细学习一下类加载的全过程，也就是加载、验证、准备、解析和初始化五个阶段。 加载加载阶段，JVM 需要完成以下事情： 通过一个类的全限定名来获取定义此类的二进制字节流。 将字节流所代表的静态存储结构转换为方法区的运行时的数据结构。 在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。 加载完成后，二进制字节流按照 JVM 所需的格式存储在方法区之中，方法区中的数据存储格式由 JVM 具体的实现中定义。然后在内存中实例化一个 java.lang.Class 类的对象，这个对象将作为程序访问方法区中的数据的外部接口。 验证验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成 4 个阶段的检验动作，其中第一个阶段是基于二进制字节流进行的，之后进入内存的方法区中存储；而后三个阶段是基于方法区的存储结构进行的： 文件格式验证：验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理。例如：是否以魔数 0xCAFEBABE 开头、主次版本号是否在当前虚拟机的处理范围之内、常量池中的常量是否有不被支持的类型等。 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。例如：这个类是否有父类，这个类的父类是否继承了不允许被继承的类( final 类)。 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。对方法体进行校验分析，保证被校验方法的安全性。 符号引用验证：在解析阶段发生。对类自身以外的信息进行匹配性校验，例如符号引用中通过字符串描述的全限定名是否能找到对应的类等。 验证阶段非常重要，但不是必须的，因为它对程序运行期没有影响。 准备准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。该阶段有需要注意以下几点： 这个阶段进行内存分配的仅包括类变量(static)，而不包括实例变量。 这里所设置的初始值通常情况下是数据类型默认的零值(如 0、0L、null、false 等）。 如果类字段的字段属性表中存在 ConstantValue 属性，即同时被 final 和 static 修饰，那么在准备阶段变量就会被初始化为 ConstValue 属性所指定的值。 解析解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 符号引用与直接应用区别如下： 符号引用：以一组符号来描述引用的目标，可以是任何形式的字面量。 直接引用：可以是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。 解析动作，主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符 7 类符号引用进行。 初始化在准备阶段，变量已经被赋过一次系统要求的初始值。而在初始化阶段，则按照程序去初始化类变量，或者说，初始化阶段是执行类构造器 &lt;clinit&gt;() 方法。 &lt;clinit&gt; 方法运行的特点和细节如下： &lt;clinit&gt; 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。收集的顺序是语句在源文件中出现的顺序决定，静态语句块只能访问定义在静态语句块之前的变量。定义在它之后的变量，在之前的静态语句块可以赋值，但不能访问。 虚拟机会保证子类的 &lt;clinit&gt; 方法执行之前，父类的 clinit 方法已执行完毕。 执行接口的 &lt;clinit&gt; 方法不需要先执行父接口的 &lt;clinit&gt; 方法。 类加载器加载阶段的“通过一个类的全限定类名来获取此类的二进制字节流”这个动作放到 JVM 外部实现，以便让应用程序自己决定如何获取所需的类。这个模块称为“类加载器”。 类加载器除了用于实现类的加载动作，还用来比较两个类是否“相等”。这里的相等指的是：只有两个类是由同一个类加载器的前提下，两个类来源于同一 Class 文件，被同一个虚拟机加载，两个类才相等。 这里的“相等”，包括： 代表类的 Class 对象的 equals() 方法； isAssignableFrom() 方法； isInstance() 方法； 使用 instanceof 关键字对对象所属关系判断； 双亲委派模型层次关系Java 程序一般会使用三种系统提供的类加载器：启动类加载器、扩展类加载器和应用程序加载器（HotSpot 虚拟机）。它们的层次关系如下图： 这种层次关系，称为类加载器的双亲委派模型。其中除了顶层的启动类加载器之外，其余的类加载器都应该有自己的父类加载器。子类加载器和父类加载器不是以继承关系来实现，而是通过组合关系来复用父加载器的代码。 三种类加载器如下： 启动类加载器（Bootstrap ClassLoader）：使用 C++ 语言实现，是虚拟机自身的一部分。这个类加载器负责加载 JVM 启动所需要的类（&lt;JAVA_HOME&gt;\lib 或 -Xbootclasspath 目录下的类库）。 扩展类加载器（Extension ClassLoader）：除了启动类加载器外，其他类加载器都由 Java 实现，独立于虚拟机外部。它负责加载 &lt;JAVA_HOME&gt;\lib\ext 目录，或者被 java.ext.dirs 系统变量指定的路径中的类库。开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）：这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器。 使用双亲委派模型组织类加载器之间的关系，使得 Java 类随着它的类加载器一起具备了带有优先级的层次关系，而不会出现关系混乱的类加载器。 工作过程双亲委派模型的工作过程如下： 如果一个类加载器收到类加载的请求，它首先从自己的加载类缓存中，查询该类是否已经被加载，如果已经加载则直接返回原来已经加载的类。 如果没有加载，则会委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到顶层的启动类加载器。 只有当父加载器无法完成这个加载请求，即它的搜索范围中没有找到所需的类时，子加载器才会尝试自己去加载。 如果一个类加载器加载类后，会将其放入自己的缓存中，以便下次有加载请求的时候直接返回。 优先使用父 ClassLoader 加载类主要有以下两个好处： 共享功能：可以避免重复加载，当父加载器已经加载了该类时，就不需要子类再次加载，一些顶层的类被 ClassLoader 加载过就会缓存在内存里，以后用到时都不需要重新加载。 隔离功能：为了安全性，避免用户自己编写的类替换 Java 的一些核心类，比如 String ，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛 java.lang.ClassCastException。 双亲委派模型的实现双亲委派模型的代码都集中在在 java.lang.ClassLoader 的 loadClass 方法中： 123456789101112131415161718192021222324252627282930protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123; synchronized (getClassLoadingLock(name)) &#123; Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; long t0 = System.nanoTime(); try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; &#125; if (c == null) &#123; long t1 = System.nanoTime(); c = findClass(name); sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125;&#125; 可以看到在 loadClass 方法的加载过程如下： 首先检查请求的类是否已经被加载。 如果没有调用，则调用父加载器的 loadClass 方法。 如果父加载器为空，则默认使用启动类加载器加载。 如果父加载器加载失败，抛出 ClassNotFoundException 异常，再调用自己的 findClass 方法进行加载。 破坏双亲委派模型双亲委派模型仅是 Java 推荐的类加载器实现方式。大部分的类加载器也都遵循这个模型，双亲委派模型主要出现过 3 次被破坏的情况。 第一次破坏是发生在双亲委派模型出现之前。为了向前兼容 JDK1.0 就存在的类加载器和抽象类 java.lang.ClassLoader，在 JDK1.2 后的 java.lang.ClassLoader 添加了一个新的 protected 方法 findClass()。 第二次破坏是由模型自身的缺陷导致的。用户代码总是调用基础类，但是上层类加载器加载的基础类不能调用回用户的代码。Java 中引入了线程上下文类加载器，可以使用这个线程上下文类加载器请求子类加载器去完成类加载的动作。 第三次破坏是由于用户对程序的动态性的追求导致的。例如 OSGI 实现模块化热部署，在 OSGI 环境下，类加载器不再是双亲委派模型中的树形结构，而是发展为网状结构。 参考资料 指 · 间：探秘 JVM：类加载机制 芋道源码：《精尽 Java【虚拟机】面试题》]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 JVM 之 垃圾收集器]]></title>
    <url>%2F2019%2F02%2F26%2F033_%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[上一篇文章中学习了 JVM 的垃圾回收机制，和内存分配和回收策略。不过这都是一些理论知识，这篇文章中会学习一下 HotSpot 虚拟机中的垃圾收集器，这都是垃圾回收理论的具体实现。 垃圾收集器HotSpot 虚拟机中有多种收集器，不同的收集器特点也不同，各年代使用的收集器也可以根据应用的特点和要求进行组合。 Serial 收集器Serial 收集器是一个单线程的收集器，它不仅只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，而且在垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 Serial 收集器是 HotSpot 虚拟机在运行 Client 模式下的默认新生代收集器。在垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。 但它也有优点，与其他收集器的单线程相比，由于没有现成交互的开销，专心做垃圾收集，所以其简单而高效； 可以使用 -XX:UseSerialGC 参数选择使用 Serial 收集器，此时年轻代采用 Serail，老年代采用 Serial Old。 ParNew 收集器ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾回收外，其他几乎一样。 它是许多运行在 Server 模式下的虚拟机首选的新生代收集器，一个很重要的原因是除了 Serial 收集器外，只有 ParNew 收集器与 CMS 收集器配合工作。垃圾收集时，年轻代使用“复制”算法，老年代使用“标记-整理”算法。 ParNew 收集器默认开启的线程数与 CPU 的数量相同，可以使用 -XX:ParallelGCThreas 参数来限制垃圾收集的线程数。使用 -XX:UseParNewGC 参数来使用 ParNew 收集器。 Parallel Scavenge 收集器Parallel Scavenge 收集器是新生代收集器，也是使用复制算法的多线程收集器。与其他收集器不同的是，它关注的是达到一个可控制的吞吐量，吞吐量 = 运行代码时间 / （运行代码时间 + 垃圾收集时间）。 Parallel Scanenge 收集器提供了两个参数用于精确控制吞吐量。第一个是控制最大垃圾收停顿时间的 -XX:MaxGCPauseMillis 参数。它允许是一个大于 0 的毫秒数，收集器将尽可能保证内存回收时间不超过设定值。这个参数也不是越小越好，GC 停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的。 第二个是直接设置吞吐量大小的 -XX:GCTimeRatio 参数。它允许是一个大于 0 且小于 100 的整数，就是垃圾收集时间占总时间的比率。 另外，Parallel Scavenge 收集器拥有自适应调节机制，它不需要手工指定新生代的大小（-Xmn）、Eden 与 Survivor 区的比例（-XX:SurvivorRatio）、晋升老年代对象大小 -XX:PretenureSizeThreshold 等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整参数以提供最合适的停顿时间及最大的吞吐量。可使用 -XX:UseAdaptiveSizePolicy 参数来开启。 Serial Old 收集器Serial Old 是 Serial 收集器的老年代版本，是一个单线程收集器，使用“标记-整理算法”。 Parallel Old 收集器Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和“标记-整理”算法。如果新生代选择了 Parallel Scavenge 收集器，老年代只能选择 Serial Old 收集器。 CMS 收集器CMS(Concurrent Mark Sweep) 是一种以获取最短停顿时间为目标的收集器，使用“标记-清除”算法。如果应用重视响应速度，希望停顿时间最短，就可以选择 CMS 收集器。 它的运作过程可分为 4 个步骤： 初始标记：仅仅标记 GC Roots 能直接关联到的对象，速度很快，需要 Stop the world。 并发标记：进行 GC Roots Tracing 过程。 重新标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。 并发清除。 CMS 的主要优点是并发收集、低停顿。但也有三个缺点： 对 CPU 资源非常敏感。并发阶段虽不会导致用户线程停顿，但会因为占用资源而导致程序变慢，总吞吐量降低。 无法处理浮动垃圾，也就是在标记过程后，清除阶段产生但当次收集中不能处理的垃圾，可能出现 Concurrent Mode Failure 失败而导致另一次 Full FC 的产生。 CMS 基于标记-清除算法，收集结束时会产生大量空间碎片。碎片过多时，无法找到足够的连续空间来分配大对象，不得不提前出发一次 Full GC。 可以使用 -XX:UseConcMarkSweepGC 参数来选择 CMS 收集器。 G1 收集器G1(Garbage-First) 是一款面向服务端应用的垃圾收集器。它的特点如下： 并行与并发：充分利用多 CPU、多核环境，使用多个 CPU 来缩短停顿的时间，部分需要其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器可通过并发的方式让 Java 程序继续执行。 分代收集：G1 收集器能独立管理整个 GC 堆，并且能采用不同的方式处理不同时期的对象。 空间整合：G1 收集器从整体来看，基于“标记-整理”算法实现；从局部来看，基于“复制”算法实现。 可预测的停顿：G1 能明确指定垃圾收集的限制时间。 使用 G1 收集器时，将 Java 堆划分为多个大小相等的区域 Region。G1 跟踪各个 Region 的回收价值和成本（回收获得空间及回收时间），后台会维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region。它通过使用 Remembered Set 来避免全堆扫描。 G1 收集器的运行步骤可分为： 初始标记：仅仅标记一下 GC Roots 直接能关联到的对象，需要停顿，但耗时很短。 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，但可并发执行。 最终标记：修正并发标记期间因用户程序运行而导致标记产生变动的对象的标记记录。 筛选回收：对各个 Region 的回收价值和成本进行排序，根据指定的 GC 停顿时间制定回收计划。 常用收集器组合HotSpot 虚拟机中包含了七种垃圾收集器，如下图： 它们的组合说明如下： 新生代收集器 年老代收集器 说明 Serial Serial Old 都是单线程，GC 时会暂停所有应用线程。使用 -XX:+UseSerialGC 选项来开启 Serial CMS + Serial Old CMS 是并发 GC，不需要暂停所有应用线程。当 CMS 进行 GC 失败时，会自动使用 Serial Old 策略进行 GC使用 -XX:+UseConcMarkSweepGC 选项来开启 ParNew CMS ParNew 是 Serial 的并行版本，可以指定 GC 线程数默认 GC 线程数为 CPU 的数量 ParNew Serial Old 使用 -XX:+UseParNewGC 选项来开启 Parallel Scavenge Serial Old Parallel Scavenge 策略关注吞吐量，适用于后台持久运行的应用程序使用 -XX:+UseParallelGC 选项来开启 Parallel Scavenge Parallel Old Parallel Old 是 Serial Old 的并行版本使用 -XX:+UseParallelOldGC 选项来开启 G1GC G1GC -XX:+UseG1GC #开启-XX:MaxGCPauseMillis #暂停时间目标 参考资料 雨点的名字：【JVM虚拟机】（3）—垃圾回收器]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 JVM 之 垃圾回收机制]]></title>
    <url>%2F2019%2F02%2F25%2F032_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[虽然内存的分配和回收技术已相当成熟，但如果需要排查内存溢出、内存泄露问题，或者要求高并发、高性能时，就需要对垃圾的回收进行监控和调节，以更好优化系统提高性能。 对象存活判定Java 内存结构中，程序计数器、虚拟机栈、本地方法栈等随着线程而生，随线程而灭，不需要考虑内存回收问题。而 Java 堆和方法区则不同，它们的内存分配是动态的，只有在运行期间才能知道会创建哪些对象，垃圾回收关注的就是这两部分。 垃圾回收首先需要判断哪些对象还存活着，主要有引用计数和可达性分析两种算法。 引用计数算法它的原理如下：给对象添加一个引用计数器，每当有一个地方引用它时，计时器值就加 1；当引用失效时，计数器值就减 1；如果计数器为 0，对象就不可能再被使用。 引用计数算法虽然实现简单、判定效率较高。但它很难解决对象之间循环引用的问题。 例如两个对象相互引用，实际上两个对象都不会再访问，但因为相互引用着对方，导致它们的计数器值都不为 0，于是引用技术算法无法通过 GC 收集器回收它们。 可达性分析算法它的原理如下：通过一系列称为 GC Roots 的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明对象是不可用的。 Java 中，可作为 GC Roots 的对象包括如下几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象； 方法区中类静态属性引用的对象； 方法区中常量引用的对象； 本地方法栈中 JNI( Native 方法) 引用的对象。 引用类型可以看到，对象回收判定算法判断对象是否存活都与引用有关。从 JDK1.2 开始，引用分为四种类型，用来实现不同的功能，它们的引用强度也依次递减。 强引用（Strong Reference） 平时使用的引用就是强引用。只要强引用还存在，该对象永远不会被回收。 可以通过将对象设置为 null，使其被回收。 软引用（Soft Reference） 用于描述一些还有用但并非必需的对象。当系统内存空间不足时，会回收这些软引用指向的对象。它通过 SoftReference 类来实现软引用。 可以用来实现高速缓存。 弱引用（Weak Reference） 用来描绘非必需对象。被弱引用指向的对象只能生存到下一次垃圾回收之前。只要垃圾收集器运行，弱引用指向的对象就会被回收。它通过 WeakReference 类来实现弱引用。 虚引用（Phantom Reference） 虚引用和没有引用没有任何区别。一个对象是否有虚引用，不会影响其生存时间，也无法通过虚引用获取对象实例。它通过 PhantomReference 来实现虚引用。必须和引用队列 ReferenceQueue 联合使用。 为一个对象设置虚引用的唯一目的是该对象被垃圾收集器回收前会收到一条系统通知。 回收方法区方法区，或者说 HotSpot 虚拟机中的永久代，进行垃圾回收的效率一般比较低。回收主要包括两部分内容：废弃常量和无用的类。 判断一个常量是否是废弃常量比较简单，与回收 Java 堆中的对象类似。而判定一个类是否是无用的类需要满足三个条件： 该类所有的实例都已经被回收； 加载该类的 ClassLoader 已经被回收； 该类对象的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 垃圾收集算法标记-清除算法（Mark-Sweep）标记-清除算法分为两个标记和清除阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。标记过程也就是对象存活判定算法。 它是最基础的收集算法，主要有两个缺点： 效率问题：标记和清除两个过程的效率都不高。 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。 复制算法（Copying）复制算法将可用内存分为大小相等的两块，每次只使用其中的一块。在一块内存用完后，将仍存活的对象赋值到另一块上面，再把已使用过的内存一次清理掉。 复制算法的优缺点如下： 优点：每次对半个分区进行内存回收，内存分配时也不用考虑内存碎片等情况，实现简单，运行高效。 缺点：可使用的内存缩小为一半，代价较大。 标记-整理算法（Mark-compact）标记-整理算法分为标记和整理两个阶段，标记阶段和“标记-清除算法”一样，但在整理阶段，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。 标记-整理算法的优缺点如下： 避免了空间碎片，空间利用率较高。 效率不高，标记和清除过程的效率较低。 分代算法（Generational Collection）分代算法根据对象存活周期将内存划分为几块。一般是将 Java 对分为新生代和老年代，根据各个年代的特点采用适当的收集算法。 新生代中，每次垃圾收集时只有少量对象存活，选择复制算法；老年代中，对象存活率较高、没有额外空间进行分配，使用“标记-清理”或“标记-整理”算法。 为了对不同生命周期的对象采用不同的回收算法，所以垃圾收集器都采用分代收集算法，将堆分为新生代和老年代。 &emsp;&emsp; 内存分配和回收策略新生代新生代主要用来存放新创建的对象，一般占堆 1/3 的空间。由于很多对象生命周期很短，每次 Minor GC 后只有少量对象存活，所以选用复制算法。 新生代又被分为一块较大的 Eden 区和两块较小的大小相等的 Survivor 区，使用 from 和 to 来分别指代两个 Survivor 区。HotSpot 虚拟机默认 Eden 和两块 Survivor 的大小比例为 8:1:1。每次只会使用 Eden 和其中一块 Survivor 区为对象服务，所以总是有一块 Survivor 区是空闲的，新生代实际可用的内存空间也就为 90%。 通常，对象会分配在 Eden 区中，当 Eden 区无法在分配对象时，JVM 便会触发一次 Minor GC，将存活下来的对象复制到 from 指向的 Survivor 区中。 当 from 指向的 Survivor 区也无法分配时，对 Eden 和 from 指向的 Survivor 区执行 Minor GC，将存活下来的对象复制到 to 指向的 Survivor 区中，然后交换 from 和 to 指针，使 to 指向的 Survivor 区为空，以保证下次 Minor GC 有复制的空闲空间。 老年代老年代用于存放大对象，或年龄超过一定程度的对象。一般占据堆 2/3 的空间。 如果对象需要大量连续的内存空间，例如很长的字符串及数组，这些对象会直接分配在老年代，以避免在 Eden 区及两个 Survivor 区之间发生大量的内存复制。 虚拟机为每个对象定义了一个对象年龄计数器，如果对象分配在 Eden 区，在经过一次 Minor GC 后仍然存活，之后移动到 Survivor 空间中，将其年龄设置为 1。对象在 Survivor 区中每经过一次 Minor GC，年龄就增加一次，当它的年龄增加到一定程度（默认为 15）时，也会被晋升到老年代中。 如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 区的一半，年龄大于或等于该年龄的对象就可以直接进入老年代。 老年代的对象一般都比较稳定，Major GC 不会频繁执行。Major GC 采用标记—清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时较长，而且会产生内存碎片。 三种清理方式Minor GC(Young GC) 指发生在新生代的垃圾收集动作。当 Eden 区没有足够的空间分配时，就会触发一次 Minor GC。由于 Java 对象大多生命周期较短，所以 Minor GC 非常频繁，一般回收速度也比较快。 Major GC 指发生在老年代的垃圾收集动作，在进行 Major GC 前，一般都会进行至少一次 Minor GC。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。 Full GC 指回收整个新生代和老年代的垃圾收集动作。成本较高，对系统性能产生影响。FULL GC 的时候会 STOP THE WORD。 它的触发条件主要有： 在执行 Minor GC 之前，如果老年代最大可用的连续空间小于历次晋升到老生代对象的平均大小，则触发一次 Full GC 。 大对象直接进入老年代，或从年轻代晋升上来的老对象，在老年代尝试分配内存，但老年代内存空间不够时。 显式调用 System.gc() 方法时。 参考资料 雨点的名字：【JVM虚拟机】（2）—GC 算法与种类 Nutty：JVM的新生代、老年代、MinorGC、MajorGC]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解 JVM 之 JVM 内存结构]]></title>
    <url>%2F2019%2F02%2F25%2F031_JVM%20%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[Java 虚拟机在运行 Java 程序 时，把它所管理的内存划分为若干个不同的数据区域，主要包括以下五个部分：程序计数器、Java 堆、Java 虚拟机栈、方法区和本地方法栈。 JVM 内存结构程序计数器程序计数器是当前线程所执行的字节码的行号指示器，它会指出下一条将要执行的指令的地址，字节码解释器就是通过改变计数器的值来选取程序接下来执行的操作。 程序计数器是线程私有的一小块内存，每条线程都要有一个独立的程序计数器，以使线程切换后恢复到正确的执行位置。 如果线程正在执行 Java 方法，则计数器记录的是正在执行的虚拟机字节码指令的地址 如果执行 native 方法，则计数器为空 它也是唯一一个不会出现 OutOfMemoryError 的内存区域。 Java 虚拟机栈与程序计数器一样，Java 虚拟机栈也是线程私有的，在线程创建时 Java 栈会被创建，每个方法在在执行的同时都会创建一个栈帧，用于存放局部变量表，操作数栈，动态链接，方法出口等信息。每一个方法从调用直至执行完成，都对应着一个栈帧在虚拟机栈中入栈到出栈的过程。 一般所谓的“栈”，指的是虚拟机栈中局部变量表部分，其中存放了各种基本数据类型( 8 种)，对象引用(reference 类型) 和 returnAddress 类型。局部变量表所需的空间在编译期就已经确定并完成分配，在方法运行期间不会被改变。 Java 虚拟栈中可能出现两种异常： StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError：虚拟机栈扩展时无法申请到足够的内存 本地方法栈本地方法栈与 Java 虚拟机栈的作用类似，区别是 Java 虚拟机栈为虚拟机执行 Java 方法服务，而本地方法栈为虚拟机执行 Native 方法服务。有的虚拟机（例如 HotSpot 虚拟机）直接把本地方法栈和 Java 虚拟机栈合并在一起。 本地方法栈也可能会抛出 StackOverflowError 和 OutOfMemoryError 异常。 Java 堆Java 堆是是虚拟机中最主要的内存区域。它为线程共享，在虚拟机启动时创建，几乎所有的对象实例都存储在 Java 堆中。 Java 堆也被称作 &quot;GC&quot; 堆。从内存回收角度看，可分为新生代和老年代。而新生代又可分为 Eden 区、From Survivor 区、To Survivor 区等。 Java 堆的实现，既可以实现为固定的，也可以是扩展的。当前虚拟机都按照可扩展来实现，通过 -Xmx 和 -Xms 控制堆大小。 如果堆中没有内存并且也无法再扩展时，会抛出 OutOfMemeoryError 异常。 方法区方法区与 Java 堆一样，为线程共享。用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据。也叫作 Non-Heap（非堆）。 如果方法区无法满足内存分配需求，会抛出 OutOfMemoryError 异常。 运行时常量池运行时常量池是方法区的一部分。Class 文件中的常量池用于编译期生成的各种字面量和符号引用，这部分内容在类加载后被存入运行时常量池。 动态性是运行时常量池相对于 Class 文件常量池的一个重要特征，即不要求常量一定只有编译期才能产生，运行期间也可能将新的常量放入池中。 运行时常量池受到方法区内存的限制，如果常量池无法再申请内存，就会抛出 OutOfMemoryError 异常。 直接内存直接内存并不由 JVM 管理，它是利用 Native 函数库在 Java 堆外申请分配的内存区域，可以避免在 Java 堆和 Native 堆中复制数据以提高性能。 例如 NIO 中的 DirectByteBuffer 就可以作为这块内存的引用进行操作直接内存。 永久代与元空间有时会看到方法区被称为永久代，其实两者有着本质的区别。方法区是 JVM 规范中的定义，而永久代是 JVM 规范的一种实现，并且只有在 HotSpot 虚拟机中如此，其他虚拟机中没有永久代的说法。 在 JDK1.6 之前，HotSpot 虚拟机把 GC 分代收集扩展至方法区，或者说使用永久代实现方法区。不过永久代有 -XX:MaxPermSize 的上限，很容易遇到内存溢出问题。 所以在 JDK1.7 中，将部分数据已经转移 Java Heap 或 Native Heap 中，例如：将原本放在永久代中的字符串池和类的静态变量移出到 Java Heap 中，将符号引用转移到 Native Heap 中。但永久代仍然存在，并没有移除。 在 JDK1.8 中，取消了永久代，代替为元空间实现，它也是 JVM 规范中方法区的一种实现。不过它与永久代最大的不同是：元空间并不在虚拟机中，而是将元空间放到本地内存中。所以默认情况下，它只受本地内存的限制，可以通过 -XX:MetaspaceSize 参数设置初始空间大小，默认没有最大空间限制。 常见的 OOM 及原因Java 中的 OOM 指的就是 java.lang.OutOfMemoryError 异常。主要有以下几种： java.lang.OutOfMemoryError:Java heap space Java 堆中主要用于存放各种对象实例。当堆中没有足够的空间分配给新对象时，或者说达到了堆空间设置的最大空间限制，则会抛出此异常。 引起内存溢出的原因主要有： 流量访问量大，超过设置的堆空间大小； 内存泄露，不能被回收的对象消耗过多堆空间； java.lang.OutOfMemoryError:Permgen space 在 JDK7 中，HotSpot 虚拟机使用永久代实现方法区，永久代较小，而且回收效率较低，很容易出现内存溢出。 因此，JDK8 取消了永久代，使用元空间来实现方法区，存放在本地内存中。 java.lang.OutOfMemoryError:Metaspace 方法区主要存储类的元信息，HotSpot 元数据区。当元空间没有足够的空间分配给加载的类时，会抛出此异常。 引起元数据区空间不足的原因主要有： 加载的类太多，常见于 jsp 页面过多时； 元空间被实现在堆外，主要受到进程本身的内存限制，一般很难出现溢出。 参考资料 Hollis：JVM内存结构 VS Java内存模型 VS Java对象模型 liuxiaopeng：Java8内存模型—永久代(PermGen)和元空间(Metaspace)]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合(6)之 HashMap 源码解析]]></title>
    <url>%2F2019%2F02%2F24%2F030_Java%E9%9B%86%E5%90%88%E4%B9%8B%20HashMap%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HashMap 在日常开发中非常常用，它基于哈希表实现，以 key-value 形式存储。本文通过 JDK1.8 的源码，分析一下 HashMap 的内部结构和实现原理。 HashMap 概述在 JDK1.7 之前，HashMap 底层由数组 + 链表实现，也就是链表散列。当向 HashMap 中添加一个键值对时，首先计算 key 的 hash 值，以此确定插入数组中的位置，但可能会碰撞冲突，将其转换为链表存储。 而从 JDK1.8 开始，增加了红黑树，由数组 + 链表 + 红黑树实现，当链表长度超过 8 时，链表转换为红黑树以提高性能。它的存储方式如下： 定义属性静态常量HashMap 的几个静态常量如下： 12345678910111213141516171819202122public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 默认初始容量为 16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量为 2^30 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认负载因子为 0.75 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 默认链表中元素大于 8 时转为红黑树 static final int TREEIFY_THRESHOLD = 8; // 扩容时，链表中元素小于这个值就会还原为链表 static final int UNTREEIFY_THRESHOLD = 6; // 数组的容量大于 64 时才允许被树形化 static final int MIN_TREEIFY_CAPACITY = 64; ···&#125; 重要变量下面是 HashMap 中几个重要的变量： 123456transient Node&lt;K,V&gt;[] table; // 存储元素数组transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; // 缓存 entry 返回的 Set transient int size; // 键值对个数transient int modCount; // 内部结构修改次数int threshold; // 临界值final float loadFactor; // 负载因子 Node&lt;K,V&gt;[] table Node&lt;K,V&gt;[] table 数组用来存储具体的元素，是 HashMap 底层数组和链表的组成元素。在第一次使用时初始化(默认初始化容量为 16)，并在必要的时候进行扩容。 一般来说，由于素数导致冲突的概率较小，所以哈希表数组大小为素数。但 Java 的 HashMap 中采用非常规设计，数组的长度总是 2 的 n 次方，这样做可以在取模和扩容时做优化，同时也能减少碰撞冲突。 Node 是 HashMap 的一个内部类，实现了 Map.Entry 接口，本质上就是一个映射（键值对）。它的实现如下： 1234567891011121314151617181920212223242526272829static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; // 用来定位数组索引位置 final K key; // 键 V value; // 值 Node&lt;K,V&gt; next; // 指向链表的下一个结点 Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; ··· &#125; public final K getKey() &#123; ··· &#125; public final V getValue() &#123; ··· &#125; public final String toString() &#123; ··· &#125; // 重写了 hashCode 和 equals 方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; ··· &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125; entrySet entrySet 用于缓存 entrySet() 方法返回的 Set。后面会详细分析。 size size 是 HashMap 中键值对的数量。注意，键值对的数量 size 和哈希表数组的长度 capacity不同。 modCount modCount 用于记录 HashMap 内部结构发生变化的次数，用于使用迭代器遍历集合时修改内部结构，而快速失败。需要注意的是，这里指的是结构发生变化，例如增加或删除一个键值对或者扩容，但是修改键值对的值不属于结构变化。 threshold 和 loadFactor threshold 是 HashMap 能容纳的最大键值对个数，loadFactor 是负载因子，默认为 0.75。有如下等式(capacity 是数组容量)： 1234567891011121314151617181920212223242526272829threshold = capacity * loadFactor;``` 可以得出，在数组长度定义好之后，负载因子越大，所能容纳键值对越多。如果存储元素个数大于 `threshold`，就要进行扩容，扩容后的容量是之前的两倍。**TreeNode**当链表长度超过 `8`（阈值）时，将链表转换为红黑树存储，以提高查找的效率。下面是 `TreeNode` 的定义：```javastatic final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父节点 TreeNode&lt;K,V&gt; left; //左子树 TreeNode&lt;K,V&gt; right; //右子树 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; //颜色属性 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 返回当前节点的根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125; ······&#125; 构造方法HashMap 主要提供了四种构造方法： 1). 构造一个默认初始容量 16 和默认加载因子 0.75 的空 HashMap。 123public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; &#125; 2). 构造一个指定的初始容量和默认加载因子 0.75 的空 HashMap。 123public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125; 3). 构造一个指定的初始容量和加载因子的空 HashMap。 12345public HashMap(int initialCapacity, float loadFactor) &#123; // check this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125; 4). 使用给定的 map 构造一个新 HashMap。 1234567891011121314151617181920212223242526272829public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125;``` # 基本方法`HashMap` 内部功能实现很多，这里主要从 `hash` 方法、`put` 方法、`get` 方法、`resize` 方法和 `entrySet` 方法进行分析。## hash 方法 `HashMap` 中，增删改查都需要用 `hash` 算法来计算元素在数组中的位置，所以 `hash` 算法是否均匀高效，对性能影响很大。看一下它的实现：```javastatic final int hash(Object key) &#123; int h; // 优化了高位运算算法 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;// tab[i = (n - 1) &amp; hash] 取模final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; ··· if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); ···&#125; hash 算法计算对象的保存位置，分为三步：取 key 的 hashCode 值、高位运算、取模运算。 由于取模元素消耗较大，HashMap 中用了一个很巧妙的方法，利用的就是底层数组长度总是 2的 n 次方。通过 hash &amp; (table.length - 1) 就可以得到对象的保存位置，相较于对 length 取模效率更高。 JDK1.8 中优化了高位运算的算法，通过 hashCode 的高 16 位异或低 16 位实现。下面举例说明，n 为 table 的长度： put 方法来看一下 HashMap 的 put 方法： 1234public V put(K key, V value) &#123; // 调用 hash 计算 key 的哈希值 return putVal(hash(key), key, value, false, true);&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // 如果 table 为空或长度为 0，则调用 resize 进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // 根据 key 的 hash 计算数组索引值，如果当前位置为 null，则直接创建新节点插入 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; // table[i] 不为空 Node&lt;K,V&gt; e; K k; // 如果 table[i] 的首元素和传入的 key 相等（hashCode 和 equals），则直接覆盖，这里容许 key 和 value 为 null if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; // 判断 table[i] 是否为 treeNode，即 table[i] 是否为红黑树，如果是则在树中插入 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 否则遍历链表 else &#123; for (int binCount = 0; ; ++binCount) &#123; // 如果 key 不存在 if ((e = p.next) == null) &#123; // 则新建一个结点 p.next = newNode(hash, key, value, null); // 如果长度大于8，则转为红黑树处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; // 如果 key 已经存在，则直接覆盖 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; // 内部结构发生变化 ++modCount; // 如果超过最大容量就扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null;&#125; 下面是 put 方法的几个步骤：： 判断哈希表数组 table[] 为空或者长度为 0，如果是则调用 resize() 进行扩容； 通过 hash &amp; (table.length - 1) 计算插入的数组索引值，如果当前位置为 null，则直接创建节点插入 判断 table[i] 的首个元素是否和 key 相等（hashCode 和 equals），如果相等则直接覆盖 value； 判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对； 否则遍历链表，如果 key 不存在，则直接创建节点插入，并判断链表长度是否大于 8，如果是红黑树则转为红黑树处理；如果遍历中发现 key 已经存在，则直接覆盖即可； 插入成功后，判断实际存在键值对是否超过了最大容量，如果是则进行扩容； HashMap 的 put 方法可以通过下图理解： get 方法来看一下 HashMap 的 get 方法： 12345public V get(Object key) &#123; Node&lt;K,V&gt; e; // 调用 getNode 方法，如果通过 key 获取的 Node 为 null，则返回 null；否则返回 node.value return (e = getNode(hash(key), key)) == null ? null : e.value;&#125; 123456789101112131415161718192021222324final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; // 如果数组不为空，数组长度大于 0 // 通过 hash &amp; (length - 1) 计算数组的索引值，并且对应的位置不为 null if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 如果桶中第一个元素与 key 相等，则直接返回 if (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; // 如果当前桶是红黑树，则转换处理 if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 否则，遍历链表处理 do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; resize 方法下面来分析一下 resize 方法的源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889final Node&lt;K,V&gt;[] resize() &#123; // 保存原先的数组、容量、临界值 Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; // 如果扩容前容量 &gt; 0 if (oldCap &gt; 0) &#123; // 如果数组大小已经达到最大 2^30，则修改阈值为最大值 2^31-1，以后也就不会再扩容 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 如果没有超过最大值，就扩充为原来的 2 倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; &#125; else if (oldThr &gt; 0) // 如果扩容前容量 &lt;= 0，旧临界值 &gt; 0 // 将数组的新容量设置为 旧数组扩容的临界值 newCap = oldThr; else &#123; // 容量 &lt;= 0，旧临界值 &lt;= 0 // 否则设置为默认值 newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的临界值 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; // 创建新的 table，容量为 newCap @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 遍历旧哈希表的每个桶，将旧哈希表中的桶复制到新的哈希表中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; // 如果旧桶中只有一个 node if (e.next == null) // 则将 oldTab[j] 放入新哈希表中 e.hash &amp; (newCap - 1) 的位置 newTab[e.hash &amp; (newCap - 1)] = e; // 如果旧桶中为红黑树，则转换处理 else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; // 将下标不变的节点组织成一条链表 Node&lt;K,V&gt; hiHead = null, hiTail = null; // 将下标增加 oldCapaciry 的节点组织成另一条链表 Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; // 原索引 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; // 原索引 + oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到新数组中 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引 + oldCap 放到新数组中 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; resize 方法在扩容时，由于每次数组的长度变为原先的 2 倍，所以元素要么在原位置，要么在“原始位置 + 原数组长度”的位置。通过计算 e.hash &amp; oldCap 来判断是否需要移动。 看下图，n 为 table 的长度，图 (a) 为扩容前的 key1 和 key2 确定索引位置的示例，图 (b) 为扩容后的 key1 和 key2 确定索引位置的示例，其中 key1(hash1) 是 key1 对应的哈希与高位运算的结果： 元素在重新计算 hash 后，因为 n 变为 2 倍，那么 n - 1 的 mask 的范围(红色)在高位多 1bit，因此新的 index 就会这样变化： 因此，在扩容时，只需看看原来的 hash 值新增的 bit 位是 1 还是 0，如果是 0，索引不变，否则变成 “原索引 + oldCapacity“，可以看看下图 16 扩充为 32 的示意图： entrySet 方法HashMap 的一种遍历方式就是使用 entrySet 方法返回的迭代器进行遍历。先来看一下 entrySet 方法： 1234public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123; Set&lt;Map.Entry&lt;K,V&gt;&gt; es; return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;&#125; 可以看到，如果缓存 map 中键值对的 Set 不为 null，则直接返回，否则会创建一个 EntrySet 对象。 EntrySet 类的 iterator 方法会返回一个 EntryIterator 迭代器对象，另外还有两个迭代器 KeyIterator、ValueIterator： 12345678910111213final class EntryIterator extends HashIterator implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; &#123; public final Map.Entry&lt;K,V&gt; next() &#123; return nextNode(); &#125;&#125;final class KeyIterator extends HashIterator implements Iterator&lt;K&gt; &#123; public final K next() &#123; return nextNode().key; &#125;&#125;final class ValueIterator extends HashIterator implements Iterator&lt;V&gt; &#123; public final V next() &#123; return nextNode().value; &#125;&#125; 它们三个都继承自 HashIterator，分别用于键遍历、值遍历、键值对遍历，它们都重写了 Iterator 的 next 方法，其中调用了 HashIterator 的 nextNode 方法。 而 HashIterator 是一个抽象类，实现了迭代器的大部分方法： 1234567891011121314151617181920212223242526272829303132333435abstract class HashIterator &#123; Node&lt;K,V&gt; next; // next entry to return Node&lt;K,V&gt; current; // current entry int expectedModCount; // for fast-fail int index; // current slot HashIterator() &#123; expectedModCount = modCount; Node&lt;K,V&gt;[] t = table; current = next = null; index = 0; if (t != null &amp;&amp; size &gt; 0) &#123; // advance to first entry do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; &#125; public final boolean hasNext() &#123; return next != null; &#125; final Node&lt;K,V&gt; nextNode() &#123; Node&lt;K,V&gt;[] t; Node&lt;K,V&gt; e = next; if (modCount != expectedModCount) throw new ConcurrentModificationException(); if (e == null) throw new NoSuchElementException(); if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) &#123; do &#123;&#125; while (index &lt; t.length &amp;&amp; (next = t[index++]) == null); &#125; return e; &#125; public final void remove() &#123; ··· &#125;&#125; 可以看出 HashIterator 迭代器的默认构造器中，将 current 设置为 null，然后循环在数组中查找不为 null 的桶， 让 next 指向第一个桶中的第一个节点 Node。 在遍历时，next 方法会调用 nextNode() 方法，这个方法首先把 next 赋给 e 以稍后返回，并把 e 赋给 current。然后判断 next 是否为空，如果不为空，返回 e 即可。 如果为空，就在数组中继续查找不为空的桶，找到后退出循环，最后返回 e。这样就能都遍历出来了。 小结HashMap 的特点主要有： HashMap 根据键的 hashCode 值来存储数据，大多数情况下可以直接定位它的值，因而访问速度很快。 HashMap 不保证插入的顺序。 扩容是一个特别耗能的操作，在使用 HashMap 时，最好估算 map 的大小，初始化时给定一个大致的数值，避免进行频繁的扩容。 threshold = capacity * loadFactor; 如果存储元素个数大于 threshold，就要进行扩容，扩容后的容量是之前的两倍。 默认的负载因子 0.75 是时间和空间之间的一个平衡，一般不建议修改。 HashMap 中 key 和 value 允许为 null，最多允许一条记录的键为 null，允许多条记录的值为 null。 它是非线程安全的。如果需要线程安全，可以使用 Collections 的 synchronizedMap 方法使 HashMap 具有线程安全的能力，或使用 ConcurrentHashMap。 参考资料 美团技术团队：Java8系列之重新认识HashMap 潘威威：Java8源码-HashMap]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合(5)之 List 总结]]></title>
    <url>%2F2019%2F02%2F23%2F029_Java%E9%9B%86%E5%90%88%E4%B9%8B%20List%20%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[前面两篇文章对 ArrayList、LinkedList 的源码进行了分析，这篇文章对 List 做个简单的总结。 List 接口结构List 以线性方式存储元素，其中允许存放重复元素，元素有序。主要有以下几个实现类： ArrayList：随机访问元素效率较高，但增删元素较慢； LinkedList：增删元素效率较高，但随机访问效率较低； Vector：与 ArrayList，但它是线程安全的，同步通过 synchronized 实现，效率较低，一般不建议使用； Stack：是一个先进先出的栈，继承自 Vector； 它的主要结构如下： 数组与 ArrayList 的区别数组与 ArrayList 之间的区别如下： 数组可以存储基本类型和对象；而 ArrayList 只能存储对象，需要进行拆装箱。所以如果特别关注性能，可以选用数组。 数组需要指定大小，且不能改变；而 ArrayList 可以指定或不指定初始化容量，且支持自动扩容。所以，如果数据大小已知，并且对数据的操作比较简单，可以使用数组。 ArrayList 最大的优势就是封装了很多操作数组的方法。如果操作比较复杂，可以选用 ArrayList。 表示多维数组时，用数组更加直观。例如 Object[][]。 其实一般来说，在普通业务开发中，直接使用 ArrayList 就可以了，相比于损耗一点点性能，换来使用上的方便简单，也是可以接受。 但如果做的是较底层的开发，如中间件，性能优化等，数组一般会比较好。 ArrayList 与 LinkedList 的区别ArrayList 优点：ArrayList 底层基于动态数组实现，由于地址连续，按照下标直接计算操作地址，随机访问效率较高。 缺点：但同样是因为地址连续，在插入和删除数据时，数组需要移动数据，所以插入和删除操作的效率较低。 LinkedList 优点：LinkedList 底层基于双向链表实现，由于地址是任意的，所以在创建节点时比较简单，增加和删除操作的效率比较高。另外，它也适用于队列、栈形式的场景。 缺点：由于 LinkedList 访问元素时需要一个一个地移动指针，所以随机访问的效率较低。 适用场景 可以按照如下要求进行选择： 如果对数据随机访问的操作较多，则选用 ArrayList。 如果对数据的增加或删除操作较多，则选用 LinkedList。 ArrayList 与 Vector 的区别ArrayList 和 Vector 很相似，主要有以下三个区别： Vector 是线程安全的，而 ArrayList 不是。Vector 中的方法被 synchronized 修饰，效率很低，一般不赞成使用。 两者都是基于动态数组实现，但是扩容时，两者的增加方式不同。ArrayList 每次扩至 1.5 倍，而 Vector 扩至 2 倍。 Vector 可以设置扩容时的自增容量 capacityIncrement，而 ArrayList 不可以。 ArrayList 支持 Iterator 和 ListIterator 迭代器；而 Vector 除此之外，还支持 Enumeration。 它们的适用场景如下： Vector 是线程安全的，而 ArrayList 是非线程安全的。如果在非多线程的情境下，一般采用 ArrayList 效率比较高。由于 Vector 效率较低，如果在多线程环境下，一般使用 CopyOnWriteArrayList。]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合(4)之 LinkedList 源码解析]]></title>
    <url>%2F2019%2F02%2F22%2F028_Java%E9%9B%86%E5%90%88%E4%B9%8B%20LinkedList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[LinkedList 与 ArrayList 同样实现了 List 接口，但它基于双向链表实现，插入和删除操作效率较高，而随机访问效率较低。本文通过源码来分析一下 LinkedList 的实现原理，注意事项，使用场景等，以便能更好地使用它（JDK 版本为 1.8）。 LinkedList 的主要特点如下： LinkedList 是 List 接口和 Deque 接口的双向链表实现； LinkedList 实现了列表的所有操作，允许添加 null； LinkedList 不是同步的； 由 iterator() 和 listIterator() 返回的迭代器是 fail-fast 的。 定义先来看一下 LinkedList 的定义： 123public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable 可以看到 LinkedList 继承或实现了以下类或接口： AbstractSequentialList：AbstractSequentialList 继承自 AbstractList，但 AbstractSequentialList 只支持按次序访问，而不像 AbstractList 那样支持随机访问。 List：：实现了 List 接口，提供了所有可选列表操作。 Deque：代表双端队列，这是 LinkedList 可用作队列或双端队列的原因。 Cloneable：表明其可以被克隆，重写了 clone 方法。 java.io.Serializable：表明该类是可以序列化的。 但 LinkedList 没有实现 RandomAccess，说明 LinkedList 不支持随机访问，这就是 LinkedList 随机访问效率低的原因之一。 属性LinkedList 的属性主要有： 12345678// 节点个数transient int size = 0;// 指向头节点的指针transient Node&lt;E&gt; first;// 指向尾节点的指针transient Node&lt;E&gt; last; LinkedList 的内部类 Node 表示链表中的节点，包括一个数据域 item，一个后置指针 next，一个前置指针 prev。 1234567891011private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 构造方法LinkedList 中提供了两种构造方法： 构造空链表 12public LinkedList() &#123;&#125; 使用给定 collection 构造链表 构造方法中，先构造一个空链表，再把指定集合 collection 中的所有元素都添加到 LinkedList 中。 1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 操作链表的底层方法下面是几个操作链表的底层方法： linkFirst 方法该方法用于在链表头添加元素 e。 12345678910111213141516private void linkFirst(E e) &#123; // 使节点 f 指向原来的头节点 final Node&lt;E&gt; f = first; // 新建节点 Node，前驱指针指向 null，后置指针指向原来的头节点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 头指针 first 指向新的头节点 newNode first = newNode; if (f == null) // 如果原来的头节点为 null，则更新尾指针 last = newNode; else // 否则使原来的头节点 f 的前驱指针指向新的头节点 newNode f.prev = newNode; size++; modCount++;&#125; linkLast 方法该方法用于在链表尾部添加元素 e。 12345678910111213141516void linkLast(E e) &#123; // 使节点 l 指向原来的尾节点 final Node&lt;E&gt; l = last; // 新建节点 Node，前驱指针指向 l，后置指针指向 null final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); // 尾指针 last 指向新的尾节点 newNode last = newNode; if (l == null) // 如果原来的头节点为 null，则更新头指针 first = newNode; else // 否则使原来的尾节点 l 的后置指针指向新的尾节点 newNode l.next = newNode; size++; modCount++;&#125; linkBefore 方法该方法用于在指定节点 succ 之前添加元素 e。 12345678910111213141516void linkBefore(E e, Node&lt;E&gt; succ) &#123; // 获得指定节点 succ 的前驱节点 final Node&lt;E&gt; pred = succ.prev; // 新建节点 newNode，前置指针指向 pred，后置指针指向 succ final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); // succ 的前置指针指向 newNode succ.prev = newNode; if (pred == null) // 如果指定节点的前驱节点为 null，则将 newNode 置为头节点 first = newNode; else // 否则更新 pred 的后置节点 pred.next = newNode; size++; modCount++;&#125; unlinkFirst 方法该方法用于删除头节点，并返回头节点的值。 123456789101112131415161718192021private E unlinkFirst(Node&lt;E&gt; f) &#123; // 保存头节点的值 final E element = f.item; // 保存头节点的下一个节点 final Node&lt;E&gt; next = f.next; // 头节点的值置为 null f.item = null; // 头节点的后置指针置为 null f.next = null; // 将头节点置为 next first = next; if (next == null) // 如果 next 为 null，将尾节点置为 null last = null; else // 否则将 next 的前驱指针指向 null next.prev = null; size--; modCount++; return element;&#125; unlinkLast 方法该方法用于删除尾节点，并返回尾节点的值。 123456789101112131415161718192021private E unlinkLast(Node&lt;E&gt; l) &#123; // 保存尾节点的值 final E element = l.item; // 保存尾节点的前一个节点 final Node&lt;E&gt; prev = l.prev; // 尾节点的值置为 null l.item = null; // 尾节点的前驱指针指向 null l.prev = null; // help GC // 将尾节点置为 prev last = prev; if (prev == null) // 如果 prev 为 null，将头节点置为 null first = null; else // 否则将 prev 的后置指针指向 null prev.next = null; size--; modCount++; return element;&#125; unlink 方法该方法用于删除指定的节点 x。 123456789101112131415161718192021222324252627282930E unlink(Node&lt;E&gt; x) &#123; // 保存指定节点的值、前驱节点、后置节点 final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; // 如果前驱节点为 null，表示删除的是头节点，则将 first 指向为 next first = next; &#125; else &#123; // 否则将 prev 的后置指针指向 next，x 的前置指针指向 null prev.next = next; x.prev = null; &#125; if (next == null) &#123; // 如果后置节点为 null，表示删除的是尾节点，则将 last 指向 prev last = prev; &#125; else &#123; // 否则将 next 的前置指针指向 prev，x 的后置指针指向 null next.prev = prev; x.next = null; &#125; // x 的值置为 null x.item = null; size--; modCount++; return element;&#125; 基本链表方法add(E) 方法add 方法在链表的末尾添加指定的元素 e。 1234public boolean add(E e) &#123; linkLast(e); return true;&#125; remove(Object) 方法remove 方法用于在删除链表中出现的第一个指定的元素 o。 1234567891011121314151617181920public boolean remove(Object o) &#123; if (o == null) &#123; // 如果 o 为 null，遍历链表，删除第一个值为 null 的节点，返回 true for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; // 否则删除第一个值为 o 的节点。如果链表中存在 o，就返回 true。 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false;&#125; addAll(int, Collection&lt;? extends E&gt;) 方法addAll 方法将给定的 collection 集合插入到从 index 位置开始的 List 中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 检查插入到位置是否合法 checkPositionIndex(index); // 将 c 转换为数组 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) // 如果 c 为空，那么就返回 false return false; // 使 pred 指向插入点前面的节点，succ 指向插入点后面（pred 的下一个）节点 Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; // 遍历数组，逐个将元素插入到插入点 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125;// 返回索引为 index 位置的节点Node&lt;E&gt; node(int index) &#123; if (index &lt; (size &gt;&gt; 1)) &#123; // 如果 index 小于链表的一半，则从表头开始遍历 Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; // 否则从链表尾开始遍历 Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125; addAll 方法在链表中间插入元素原理图如下： add(int, E) 方法此 add 方法用于在 List 中索引为 index 位置插入元素 element。 12345678910public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) // 如果 index 等于 size，则插入到链表尾 linkLast(element); else // 否则，插入到索引为 index 位置之前 linkBefore(element, node(index));&#125; set(int, E) 方法set 方法用给定的元素 element 代替 List 中索引为 index 位置的元素。 12345678public E set(int index, E element) &#123; checkElementIndex(index); // 返回索引为 index 位置的节点 Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal;&#125; get(int) 方法get 方法会返回 List 中指定位置 index 的元素。 1234public E get(int index) &#123; checkElementIndex(index); return node(index).item;&#125; indexOf(Ojbect) 方法index 方法返回 List 中指定元素第一次出现的下标。 12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; // 如果 o 为 null，遍历链表，查找第一个为 null 的元素，返回 index for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; // 否则查找第一个为 Object 的元素，返回 index for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125; getFirst/getLast 方法getFirst 方法返回链表中第一个元素，而 getLast 方法返回链表中最后一个元素。 12345678910111213public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; removeFirst/removeLast 方法removeFirst 方法从 list 中删除第一个元素，并返回它；而 removeLast 方法从 list 中删除最后一个元素，并返回它。 12345678910111213public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125; addFirst/addLast 方法addFirst 方法在链表头插入指定元素；addLast 方法在链表尾插入指定元素。 1234567public void addFirst(E e) &#123; linkFirst(e);&#125;public void addLast(E e) &#123; linkLast(e);&#125; 队列方法peek/element 方法peek/element 方法都是返回队列的队首元素。但是，如果队列为空，peek 方法返回 null，而 element 方法会抛出 NoSuchElementException。 12345678public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E element() &#123; return getFirst();&#125; poll/remove 方法poll/remvoe 方法都是删除队列的队首元素，并返回。但是如果队列为空，poll 方法会返回空，而 remove 方法会抛出 NoSuchElementException 异常。 12345678public E poll() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;public E remove() &#123; return removeFirst();&#125; offer 方法offer 方法在队列的队尾处添加指定元素。 123public boolean offer(E e) &#123; return add(e);&#125; 双端队列方法offerFirst/offerLast 方法offerFirst 方法在队列的队首添加元素；而 offerLast 方法在队列的队尾添加元素。 123456789public boolean offerFirst(E e) &#123; addFirst(e); return true;&#125;public boolean offerLast(E e) &#123; addLast(e); return true;&#125; peekFirst/peekLast 方法peekFirst 方法会返回队列的队首元素，但不删除。如果队列为空，会返回 null。 peekLast 方法会返回队列的队尾元素，但不删除。如果队列为空，会返回 null。 123456789public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125; pollFirst/pollLast 方法pollFirst 方法会删除队列的队首元素，并返回。如果队列为空，则返回 null。 pollLast 方法会删除队列的队尾元素，并返回。如果队列为空，则返回 null。 123456789public E pollFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : unlinkFirst(f);&#125;public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125; 栈方法push 方法将指定元素压入到栈顶。 123public void push(E e) &#123; addFirst(e);&#125; pop 方法从栈顶弹出元素。 123public E pop() &#123; return removeFirst();&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合(3)之 ArrayList 源码解析]]></title>
    <url>%2F2019%2F02%2F21%2F027_Java%E9%9B%86%E5%90%88%E4%B9%8B%20ArrayList%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ArrayList 在日常开发中非常常用，它是 List 接口的可变长数组的实现，提供了添加、修改、删除、遍历等功能。本文通过源码来分析一下 ArrayList 的实现原理，注意事项，使用场景等（JDK 版本为 1.8）。 ArrayList 的特点如下： ArrayList 基于数组方式实现，可以自动扩容；但由于扩容比较耗时，所以在初始化 ArrayList 时最好预判一下初始化容量； ArrayList 中允许插入 null 元素； 由于实现了 Serializable 接口，重写了 writeObject 和 readObject 方法，所以 ArrayList 支持序列化和反序列化； ArrayList 不是同步的； ArrayList的 iterator 和 listIterator方法返回的迭代器是 fail-fast 的。 定义首先，来看一下 ArrayList 的定义： 12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 可以看到 ArrayList 继承或实现了以下类或接口： AbstractList ：继承了 AbstractList。AbstractList 提供了 List 接口的骨干实现，以最大限度地减少（如 ArrayList）实现 List 所需的工作。 List：实现了 List 接口。提供了所有可选列表操作。 RandomAccess：表明 ArrayList 支持随机访问。此接口的主要目的是允许一般的算法更改其行为，从而在将其应用到随机或连续访问列表时能提供良好的性能。 Cloneable：表明其可以被克隆，重写了 clone 方法。 java.io.Serializable：表明该类支持序列化。 下面是 ArrayList 的类结构层次图： 属性ArrayList 的属性主要有： 1234567891011121314151617181920// 序列化 idprivate static final long serialVersionUID = 8683452581122892189L;// 默认初始化容量private static final int DEFAULT_CAPACITY = 10;// 指定 ArrayList 的容量为 0 时，返回该空数组 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;// 如果调用默认构造器（无参构造方法），则返回该空数组private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;// 存储当前元素的数组transient Object[] elementData; // ArrayList 的大小（包含的元素数目）private int size;// 分配给数组的最大长度private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 除此之外，还有一个从 AbstarctList 继承的 modCount 属性，它代表 ArrayList 集合的修改次数。在遍历集合时，如果 modCount 被更改，就会抛出 ConcurrentModificationExceptioin 异常。 构造方法在 ArrayList 中，提供了三种构造方法： 默认构造方法 不传入参数的默认构造方法会构造一个初始容量为 10 的空列表。 123public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 指定容量 这个构造方法会构造一个指定初始化容量为 initialCapacity 的空 ArrayList。如果指定初始化容量为负，则会抛出 IllegalArgumentException 异常。 12345678910public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 使用给定 collection 构造数组 这个方法会构造一个包含指定 collection 的元素的列表，这些元素是按照该 collection 的迭代器返回它们的顺序排列的。 1234567891011public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // 判断 elementData 是否为 Object[] 类型 if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 使用空数组代替 this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 这里首先会将传入的 elementData 转换为数组，然后使用 Arrays.copyOf 方法将元素拷贝到 elementData 数组中。 基本方法ArrayList 的主要方法如下： get(int index) 方法get 方法用于返回 list 中索引为 index 的元素。 1234public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125; 方法中首先检查索引，如果索引超过数组的长度，则会抛出 IndexOutOfBoundsException 异常。 然后使用 elementData 方法获取元素： 123E elementData(int index) &#123; return (E) elementData[index];&#125; 由于 ArrayList 底层由数组实现，通过数组下标获取元素，它的时间复杂度为 O(1)。 add(E e) 方法add 方法用于在 list 的末尾添加指定的元素 e。 12345public boolean add(E e) &#123; ensureCapacityInternal(size + 1); elementData[size++] = e; return true;&#125; 可以看到，首先是 ensureCapacityInternal(size + 1) 方法，这个方法对数组容量进行检查，如果不够则进行扩容，只供内部使用。 123456789101112131415161718private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 扩容方法 grow，会保证至少能存储 minCapacity 个元素。实现如下： 12345678910111213141516171819private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 可以看到，扩容后的容量按照如下方式计算： 第一次扩容，使用 newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); 公式，将容量增加一半； 如果容量还是小于 minCapacity，就将容量扩充为 minCapacity； 如果容量大于 MAX_ARRAY_SIZE，就将容量扩充为 Integer.MAX_VALUE。 最后，使用 Arrays.copyOf 方法将元素拷贝到新数组中即可。 add(index, element) 方法这个 add 方法用于在 list 中指定的位置插入元素。 123456789public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125; 这个方法首先会对指定的位置 index 进行检查，如果越界，就会抛出 IndexOutOfBoundsException 异常。然后使用 ensureCapacityInternal 方法判断容量并进行扩容。 然后，使用 System.arraycopy() 方法将索引为 index 位置之后的元素向后移动一位，再将 index 位置赋值为 element。 remove(index) 方法remove 方法用于删除 list 中指定索引 index 位置的元素。 1234567891011121314public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue;&#125; 首先使用 rangeCheck 方法检查 index 是否越界，然后修改 modCount，表示修改次数加一。再使用 elementData 方法获取 index 位置的元素，方便稍后返回。 使用 size-index-1 计算左移的位数，再使用 System.arraycopy() 方法向左移动一位，也就表示删除了该元素。最后将 --size 位置的元素置为 null，避免对象游离，使 JVM 回收。 Iterator 迭代器迭代器提供了一种方法来访问集合中的元素。Array 类中的 iterator() 方法用来从容器对象中返回一个指向 list 开始处的迭代器。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 这里的 Itr 类实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 下一个要返回的元素的索引 int lastRet = -1; // 上一个被返回的元素的索引，如果没有返回 -1 int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings("unchecked") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; ···&#125; Itr 类的主要方法如下： next()：获取序列中的下个元素； hasNext()：检查序列中是否还有下一个元素； remove()：将迭代器最近返回的一个元素删除。]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合之 Collections 源码解析]]></title>
    <url>%2F2019%2F02%2F20%2F026_Java%E9%9B%86%E5%90%88%E4%B9%8B%20Collections%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[在 Java 集合框架中，有两个经常使用的工具类：Collections 和 Arrays。Collections 用来操作集合，而 Arrays 用来操作数组。这篇文章就来分析一个 Collections 类。 网上查了一下，有两篇文章写得很好，本篇文章基本就是对它们的整理。 Java 常用工具类 Collections 源码分析 Java1.8-Collections源码解析 sort 方法Collections 有两个 sort 方法，第一个方法要求 List 中的对象必须要实现 Comparable 接口；而第二个方法则不要求实现 Comparable 接口，但可以使用自定义的比较器。 123456public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) &#123; list.sort(null);&#125;public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c);&#125; 但两者底层实现都是通过 List 接口的默认方法 sort。首先将 List 对象转换成数组，然后使用 Arrays.sort 方法排序。 123456789default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 对 Arrays.sort 方法稍后进行详细分析。 binarySearach 方法二分查找需要集合已经有序，如果没有排序那也就没有意义。同样地，Collections 也有两个 binarySearach 方法，这里只看一下实现了 Comparable 接口的对象的二分查找方法。对于指定比较器的算法其实是一样的，区别在于比较的标准不同。 binarySearach 方法中，如果 List 支持随机访问，或者小于二分查找的阈值 BINARYSEARCH_THRESHOLD(5000)，则调用 indexedBinarySearch，否则调用 iteratorBinarySearch，借助迭代器来访问. 123456public static &lt;T&gt; int binarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; if (list instanceof RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD) return Collections.indexedBinarySearch(list, key); else return Collections.iteratorBinarySearch(list, key);&#125; 先来看一下 indexedBinarySearch 方法，由于支持随机访问，所以查找的平均时间复杂度为 O(logn)： 123456789101112131415161718private static &lt;T&gt; int indexedBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; int low = 0; int high = list.size()-1; while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; // 无符号右移，相当于除 2 Comparable&lt;? super T&gt; midVal = list.get(mid); // get 时间复杂度为 O(1) int cmp = midVal.compareTo(key); if (cmp &lt; 0) low = mid + 1; else if (cmp &gt; 0) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found&#125; 而对于 iteratorBinarySearch 方法，不能支持随机访问，就需要使用迭代器保存之前访问的位置。 12345678910111213141516171819202122232425262728293031323334private static &lt;T&gt; int iteratorBinarySearch(List&lt;? extends Comparable&lt;? super T&gt;&gt; list, T key) &#123; int low = 0; int high = list.size()-1; ListIterator&lt;? extends Comparable&lt;? super T&gt;&gt; i = list.listIterator(); while (low &lt;= high) &#123; int mid = (low + high) &gt;&gt;&gt; 1; Comparable&lt;? super T&gt; midVal = get(i, mid); int cmp = midVal.compareTo(key); if (cmp &lt; 0) low = mid + 1; else if (cmp &gt; 0) high = mid - 1; else return mid; // key found &#125; return -(low + 1); // key not found&#125;private static &lt;T&gt; T get(ListIterator&lt;? extends T&gt; i, int index) &#123; T obj = null; int pos = i.nextIndex(); if (pos &lt;= index) &#123; do &#123; obj = i.next(); &#125; while (pos++ &lt; index); &#125; else &#123; do &#123; obj = i.previous(); &#125; while (--pos &gt; index); &#125; return obj;&#125; Collections.get() 方法，每次查找中间点都需要移动指针。所以时间复杂度会达到 O(n)。 reverse 方法下面来看一下 reverse 反转列表的方法： 1234567891011121314151617181920public static void reverse(List&lt;?&gt; list) &#123; int size = list.size(); if (size &lt; REVERSE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=0, mid=size&gt;&gt;1, j=size-1; i&lt;mid; i++, j--) swap(list, i, j); &#125; else &#123; ListIterator fwd = list.listIterator(); ListIterator rev = list.listIterator(size); for (int i=0, mid=list.size()&gt;&gt;1; i&lt;mid; i++) &#123; Object tmp = fwd.next(); fwd.set(rev.previous()); rev.set(tmp); &#125; &#125;&#125;public static void swap(List&lt;?&gt; list, int i, int j) &#123; final List l = list; l.set(i, l.set(j, l.get(i)));&#125; 可以看到，同样的这里判断是否支持随机访问，或 list 小于反转的阈值 REVERSE_THRESHOLD。 如果支持随机访问，则先交换第一个和最后一个元素，然后第二个和倒数第二个元素，一直到中间位置。这里的 swap 交换很巧妙： 使用 l.get(i) 得到 i 位置的元素； 使用 l.set(j, l.get(i)) 将 i 位置的元素设置到 j 位置； 由于 set 方法会返回设置之前的元素，所以整体的 l.set(···) 会将 j 位置的元素设置到 i 位置； 如果不支持随机访问，就是用两个迭代器，一个从头开始，一个从尾开始，交换元素，一直到中间位置。 Collections 中的 reverse 方法在反转列表时，是交换对象中的值。对于链表，还有另外一种实现，是直接交换链表中的结点。 shuffle 方法下面来看一下 shuffle 打乱列表中元素的方法： 12345678910111213141516171819public static void shuffle(List&lt;?&gt; list, Random rnd) &#123; int size = list.size(); if (size &lt; SHUFFLE_THRESHOLD || list instanceof RandomAccess) &#123; for (int i=size; i&gt;1; i--) swap(list, i-1, rnd.nextInt(i)); &#125; else &#123; Object arr[] = list.toArray(); // Shuffle array for (int i=size; i&gt;1; i--) swap(arr, i-1, rnd.nextInt(i)); ListIterator it = list.listIterator(); for (int i=0; i&lt;arr.length; i++) &#123; it.next(); it.set(arr[i]); &#125; &#125;&#125; 同样地，这里判断是否 list 支持随机访问，或者 list 小于 SHUFFLE_THRESHOLD。 如果支持随机访问，就使用 random 生成一个小于 i 的值，使用 swap 方法随机交换元素。 如果不支持，首先将 list 转换成数组，然后遍历数组随机交换元素，最后又遍历把打乱的元素写回列表。 rotate 方法下面来看一下 rotate 旋转方法，也就是对集合中的元素进行右移，可以指定移动的距离 distance。 123456public static void rotate(List&lt;?&gt; list, int distance) &#123; if (list instanceof RandomAccess || list.size() &lt; ROTATE_THRESHOLD) rotate1(list, distance); else rotate2(list, distance);&#125; 同样地，这里判断 list 支持随机访问，或者 list 小于 ROTATE_THRESHOLD。如果支持随机访问，就调用 rotate1，否则就调用 rotate2。 12345678910111213141516171819202122private static &lt;T&gt; void rotate1(List&lt;T&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; distance = distance % size; if (distance &lt; 0) distance += size; if (distance == 0) return; for (int cycleStart = 0, nMoved = 0; nMoved != size; cycleStart++) &#123; T displaced = list.get(cycleStart); int i = cycleStart; do &#123; i += distance; if (i &gt;= size) i -= size; displaced = list.set(i, displaced); nMoved ++; &#125; while (i != cycleStart); &#125;&#125; 而对于 rotate2 方法，则借助于反转方法 reverse 来进行操作。 1234567891011121314private static void rotate2(List&lt;?&gt; list, int distance) &#123; int size = list.size(); if (size == 0) return; int mid = -distance % size; if (mid &lt; 0) mid += size; if (mid == 0) return; reverse(list.subList(0, mid)); reverse(list.subList(mid, size)); reverse(list);&#125; 这里三个 reverse 方法非常巧妙，比如要对 [1,2,3,4,5,6,7,8,9] 进行 3 位旋转，则我们旋转的方式可以是：先对前 size-3 位进行反转，然后再对后 3 位进行反转，最后整体再进行反转就可以实现旋转的操作了。 其中，mid 的值就是确定要前后反转的中间值。我们用一张图来看一下就明白了： unmodifiable 方法Collections 提供了一系列以 unmodifiable 开头的方法，用来在原集合基础上生成一个不可变的集合。例如 unmodifiableCollection、unmodifiableList、unmodifiableMap 等。 看一下 Collections.unmodifiableCollection(c) 方法: 123public static &lt;T&gt; Collection&lt;T&gt; unmodifiableCollection(Collection&lt;? extends T&gt; c) &#123; return new UnmodifiableCollection&lt;&gt;(c);&#125; 它可以返回一个容器的包装类，这个包装类的添加、替换、删除等修改操作都会抛出异常 UnsupportedOperationException。例如 UnmodifiableCollection 类中的方法： 12345678···public boolean add(E e) &#123; throw new UnsupportedOperationException();&#125;public boolean remove(Object o) &#123; throw new UnsupportedOperationException();&#125;··· synchronized 方法Collections 也提供了一系列以 synchronized 开头的方法，用来将原集合转成一个线程安全的集合。例如 synchronizedList，synchronizedMap 等。 看一下 synchronizedList 方法： 12345public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list) : new SynchronizedList&lt;&gt;(list));&#125; 它可以返回一个容器的包装类 SynchronizedRandomAccessList 或 SynchronizedList，这个包装类的添加、替换、删除等操作都使用了 synchronized 关键字。例如 SynchronizedList 类中的方法： 1234567891011121314···public E get(int index) &#123; synchronized (mutex) &#123;return list.get(index);&#125;&#125;public E set(int index, E element) &#123; synchronized (mutex) &#123;return list.set(index, element);&#125;&#125;public void add(int index, E element) &#123; synchronized (mutex) &#123;list.add(index, element);&#125;&#125;public E remove(int index) &#123; synchronized (mutex) &#123;return list.remove(index);&#125;&#125;··· 几乎所有方法都使用了 synchronized 关键字，这样得到的集合在并发环境下效率不是很高。 其他方法当然，Collections 类中还有很多方法： 以 checked 开头的方法：获取动态类型检查的集合； frequency 方法：用于获取某一个元素在集合中出现的次数，并且可以统计 null； fill() 方法：用于使用指定的元素替换列表中的所有元素； min()/max() 方法：求集合中的最大最小值； indexOfSubList、lastIndexOfSubList 方法：查找子列表最早出现或最后出现的索引； replaceAll 方法：替换集合中的某一个元素为新的元素，可以替换 null 元素； copy 方法：将原集合中元素拷贝到另一个集合中。]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>源码解读</tag>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合(2)之 Iterator 迭代器]]></title>
    <url>%2F2019%2F02%2F20%2F025_Java%E9%9B%86%E5%90%88%E4%B9%8B%20Iterator%20%E8%BF%AD%E4%BB%A3%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Iterator 与 ListIterator凡是实现 Collection 接口的集合类都有一个 iterator 方法，会返回一个实现了 Iterator 接口的对象，用于遍历集合。Iterator 接口主要有三个方法，分别是 hasNext、next、remove 方法。 ListIterator 继承自 Iterator，专门用于实现 List 接口对象，除了 Iterator 接口的方法外，还有其他几个方法。 基于顺序存储集合的 Iterator 可以直接按位置访问数据。基于链式存储集合的 Iterator，一般都是需要保存当前遍历的位置，然后根据当前位置来向前或者向后移动指针。 Iterator 与 ListIterator 的区别： Iterator 可用于遍历 Set、List；ListIterator 只可用于遍历 List。 Iterator 只能向后遍历；ListIterator 可向前或向后遍历。 ListIterator 实现了 Iterator 的接口，并增加了add、set、hasPrevious、previous、previousIndex、nextIndex 方法。 快速失败（fail—fast）快速失败机制（fail—fast）就是在使用迭代器遍历一个集合对象时，如果遍历过程中对集合进行修改（增删改），则会抛出 ConcurrentModificationException 异常。 例如以下代码，就会抛出 ConcurrentModificationException： 123456789List&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("abc");stringList.add("def");Iterator&lt;String&gt; iterator = stringList.iterator();while (iterator.hasNext()) &#123; System.out.println(iterator.next()); stringList.add("ghi");&#125; 查看 ArrayList 源码，就可以知道为什么会抛出异常。原因是在 ArrayList 类的内部类迭代器 Itr 中有一个 expectedModCount 变量。在 AbstracList 抽象类有一个 modCount 变量，集合在被遍历期间如果内容发生变化，就会改变 modCount 的值。每当迭代器使用 next() 遍历下一个元素之前，都会检测 modCount 变量是否等于 expectedmodCount ，如果相等就继续遍历；否则就会抛出异常。 1234final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException();&#125; 注意：这里异常的抛出条件是检测到 modCount != expectedmodCount。如果集合发生变化时将 modCount 的值又刚好设置为 expectedmodCount，那么就不会抛出异常。因此，不能依赖于这个异常是否抛出而进行并发操作，这个异常只建议使用于检测并发修改的 bug。 在 java.util 包下的集合类都采用快速失败机制，所以在多线程下，不能发生并发修改，也就是在迭代过程中不能被修改。 安全失败（fail—safe）采用安全失败机制（fail—safe）的集合类，在遍历集合时不是直接访问原有集合，而是先将原有集合的内容复制一份，然后在拷贝的集合上进行遍历。 由于是对拷贝的集合进行遍历，所以在遍历过程中对原集合的修改并不会被迭代器检测到，所以不会抛出 ConcurrentModificationException 异常。 虽然基于拷贝内容的安全失败机制避免了 ConcurrentModificationException，但是迭代器并不能访问到修改后的内容，而仍然是开始遍历那一刻拿到的集合拷贝。 在 java.util.concurrent 包下的集合都采用安全失败机制，所以可以在多线程场景下进行并发使用和修改操作。 如何在遍历集合的同时删除元素在遍历集合时，正确的删除方式有以下几种： 普通 for 循环从后往前遍历 使用普通 for 循环，如果从后往前遍历，则可以避免元素移动的影响。 1234567891011ArrayList&lt;String&gt; stringList = new ArrayList&lt;&gt;();stringList.add("abc");stringList.add("def");for (int i = 0;i &lt; stringList.size(); i++) &#123; String str = stringList.get(i); if ("abc".equals(str)) &#123; stringList.remove(str); break; &#125;&#125; foreach 删除后跳出循环 在使用 foreach 迭代器遍历集合时，在删除元素后使用 break 跳出循环，则不会触发 fail-fast。 123456for (String str : stringList) &#123; if ("abc".equals(str)) &#123; stringList.remove(str); break; &#125;&#125; 使用迭代器自带的 remove 方法 12345678Iterator&lt;String&gt; iterator = stringList.iterator();while (iterator.hasNext()) &#123; String str = iterator.next(); if ("abc".equals(str)) &#123; iterator.remove(); // 这里是 iterator，而不是 stringList break; &#125;&#125; EnumerationEnumeration 是 JDK1.0 引入的接口，为集合提供遍历的接口，使用它的集合包括 Vector、HashTable 等。Enumeration 迭代器不支持 fail-fast 机制。 它只有两个接口方法：hasMoreElements、nextElement 用来判断是否有元素和获取元素，但不能对数据进行修改。 但需要注意的是 Enumeration 迭代器只能遍历 Vector、HashTable 这种古老的集合，因此通常情况下不要使用。 Java中遍历 Map 的几种方式方法一 在 for-each 循环中使用 entries 来遍历 这是最常见的，并且在大多数情况下也是最可取的遍历方式，在键和值都需要时使用。 1234Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) &#123; System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); &#125; 注意：如果遍历一个空 map 对象，for-each 循环将抛出 NullPointerException，因此在遍历前应该检查是否为空引用。 方法二 在 for-each 循环中遍历 keys 或 values 如果只需要 map 中的键或者值，可以通过 keySet 或 values 来实现遍历，而不是用 entrySet。 1234567891011Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); //遍历 map 中的键 for (Integer key : map.keySet()) &#123; System.out.println("Key = " + key); &#125; //遍历 map 中的值 for (Integer value : map.values()) &#123; System.out.println("Value = " + value); &#125; 该方法比 entrySet 遍历在性能上稍好，而且代码更加干净。 方法三 使用 Iterator 遍历 12345678Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); Iterator&lt;Map.Entry&lt;Integer, Integer&gt;&gt; entries = map.entrySet().iterator(); while (entries.hasNext()) &#123; Map.Entry&lt;Integer, Integer&gt; entry = entries.next(); System.out.println("Key = " + entry.getKey() + ", Value = " + entry.getValue()); &#125; 这种方式看起来冗余却有其优点所在，可以在遍历时调用 iterator.remove() 来删除 entries，另两个方法则不能。 从性能方面看，该方法类同于 for-each 遍历（即方法二）的性能。 总结 如果仅需要键（keys）或值（values），则使用方法二； 如果需要在遍历时删除 entries，则使用方法三； 如果键值都需要，则使用方法一。]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 集合(1)之 总体架构]]></title>
    <url>%2F2019%2F02%2F19%2F024_Java%E9%9B%86%E5%90%88%E4%B9%8B%20%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84%2F</url>
    <content type="text"><![CDATA[集合框架Java 提供了一个丰富的集合类，包含了常用的数据结构和算法等。使用 Java 集合的优点部分如下： 降低开发的成本：通过提供的核心集合类，使程序员更专注地实现程序的核心功能，而不用自己去实现自己的集合类； 提高代码的质量：集合框架提供了许多经过严格测试的、高性能、高质量的数据结构和算法，大大提高了程序的质量； 促进软件的复用性：只要符合标准集合接口的新数据结构和算法本质上都是可以复用的。 在集合的接口和实现中大量使用了泛型，它为集合提供了一个可以容纳的对象类型，如果添加其他类型的元素，在编译时就会出错，这避免了在运行时出现类型转换异常。泛型也使得代码更加整洁，因为不需要显式地编写类型转换操作，编译器会帮我们实现。 Java 整个集合框架图如下： 可以看到，这个框图主要有两个主干：Collection 和 Map。 Collection：它是一个接口，提供了对集合对象进行基本操作的通用接口方法，有很多具体的实现和继承，它被分为三大分支：List、Set 和 Queue。 Map：它是由一系列键值对组成的集合，提供了 key 到 Value 的映射。 除此之外，还有 Iterator 迭代器，Collections 和 Arrays 工具类，Comparator 比较器等。 ListList 是一个有序列表，用特定的插入顺序来维护元素顺序。可以对列表中元素的插入位置进行控制，同时可以根据元素的索引访问元素。实现 List 接口的主要有 ArrayList、LinkedList、Vector 等。 ArrayList ArrayList 是一个动态数组，在随机访问元素时性能较高，但插入和删除元素效率较低。ArrayList 都有一个初始容量，代表了数组的大小，在 ArrayList 快满时，会进行扩容操作，每次增长 1.5 倍大小。但 ArrayList 是非同步的，在多线程场景下不要使用。 LinkedList LinkedList 是一个双向链表，由于实现方式不同，它不支持随机访问，但很容易在列表中间进行插入和删除操作。与 ArrayList 一样，LinkedList 也是非同步的。 Vector Vector 与 ArrayList 类似，基于动态数组实现，但 Vector 是同步的。它的操作与 ArrayList 几乎一样。 MapMap 是由一系列键值对组成的集合，提供了 key 到 Value 的映射。实现 Map 接口的有：HashMap、TreeMap、HashTable、EnumMap 等。 HashMap HashMap 以哈希表数据结构实现，查询对象时通过哈希函数将元素的哈希地址转换成数组索引，在出现碰撞冲突时，则使用链表的形式存储哈希地址相同的元素，在 JDK8 后，链表过长后会转换为红黑树。HashMap 存储和查询效率较高，但需要考虑哈希函数、碰撞冲突等问题。 TreeMap TreeMap 实现了 SortedMap 接口，内部以红黑树数据结构实现，其中键以某种排序规则排序，排序规则也可以通过 Comparator 比较器指定。 HashTable HashTable 也是以哈希表数据结构实现，遇到冲突时采用链表的形式。类似于 HashMap，但它的同步的。 EnumMap EnumMap 是将枚举类型作为键值的 Map。由于键的数量相对固定，所以在内部用一个数组存储对应值。通常来说，效率高于 HashMap。 SetSet 是一个不包括重复元素的集合，存入的元素没有顺序。内部通过 Map 实现，Set 里存储的值对应的是 Map 中的键，键对应的值是不变的，指向一个常量。实现 Set 接口的集合有：HashSet、TreeSet、EnumSet 等。 HashSet HashSet 底层基于 HashMap 实现，它内部元素的顺序是由哈希码来决定的，所以它不保证 Set 的迭代顺序。可以放入 null，但只能放入一个。 TreeSet 与 HashSet 类似，它是基于 TreeMap 实现，以某种排序规则排序。它是使用元素的自然顺序排序，或根据创建 Set 时提供的 Comparator 进行排序。但不允许存入 null 值。 EnumSet EnumSet 基于 EnumMap 实现，是枚举专用的 Set，其中所有元素都是枚举类型。 QueueQueue 通常是指先进先出的队列，也不允许随机访问队列中的元素。而 Deque 接口是 Queue 的子接口，它代表一个双端队列。 ArrayDeque ArrayDeque 是基于有首尾指针的数组（环形缓冲区）实现的双端队列，它只能从首尾取出或插入元素。底层由数组实现，可以指定容量，默认容量为 16，并根据添加元素个数，动态扩展。 PriorityQueue PriorityQueue 是一个优先级队列，它使用自然顺序或者制定的比较器来排序。队列的头是按指定排序方式的最小元素。 Comparator 和 ComparableComparator 和 Comparable 是两个接口，都可以用来对对象进行比较。 Comparable 接口用于当前对象和其他对象进行比较。它有一个 compareTo 方法，该方法只有一个参数。返回值为 int，大于 0 表示当前对象大于参数对象；小于 0 表示当前对象小于参数对象；等于 0 表示两者相等。 Comparator 是一个比较器接口，用于对传入的两个对象进行比较。它有一个 compare 方法，该方法有两个参数。 例如，对一组 Student 对象进行排序，分别使用 Comparable 和 Comparator 接口实现功能。 Comparable Comparable 接口实现在对象类的内部，之后对象就变成了一个可以比较大小的对象，也就可以用来排序了。 首先 Student 类需要实现 Comparable 接口，重写其 compareTo 方法： 12345678910111213141516public class Student implements Comparable&lt;Student&gt; &#123; private String name; private int age; // setter、getter、toString @Override public int compareTo(Student another) &#123; int flag = this.name.compareTo(another.name); if(flag == 0) &#123; flag = this.age - another.age; &#125; return flag; &#125;&#125; 然后利用 List 接口的 sort(Comparator&lt;? super E&gt; c) 默认方法，或者 Collections 工具类的 sort(List&lt;T&gt; list) 方法进行排序： 1234567891011121314public static void main(String[] args) &#123; List&lt;Student&gt; students = new ArrayList&lt;&gt;(); students.add(new Student("a", 4)); students.add(new Student("d", 2)); students.add(new Student("c", 5)); students.add(new Student("c", 3)); students.sort(null); // Collections.sort(students); for (Student student : students) &#123; System.out.println(student); &#125;&#125; Comparator Comparator 实现在对象类的外部，此时对象类的结构不需要有任何变化。 然后另外定义一个比较器类，实现 Comparator 接口并重写其 compare 方法： 1234567891011class PersonComparator implements Comparator&lt;Person&gt; &#123; @Override public int compare(Person o1, Person o2) &#123; int flag = o1.getName().compareTo(o2.getName()); if(flag == 0) &#123; flag = o1.getAge() - o2.getAge(); &#125; return flag; &#125;&#125; 然后利用 List 接口的 sort(Comparator&lt;? super E&gt; c) 方法，或者 Collections 工具类的 sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) 方法进行排序： 1234567891011121314public static void main(String[] args) &#123; List&lt;Person&gt; persons = new ArrayList&lt;&gt;(); persons.add(new Person("a", 4)); persons.add(new Person("d", 2)); persons.add(new Person("c", 5)); persons.add(new Person("c", 3)); persons.sort(new PersonComparator()); // Collections.sort(persons, new PersonComparator()); for (Person person : persons) &#123; System.out.println(person); &#125;&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>Java集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 反射与动态代理]]></title>
    <url>%2F2019%2F02%2F18%2F023_Java%20%E5%8F%8D%E5%B0%84%E4%B8%8E%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[编程语言有多种分类角度，其中一种就是动态类型语言和静态类型语言，简单区分就是静态类型语言在编译期进行类型检查，而动态类型语言在运行时进行类型检查。注意，这和动态语言、静态语言区分角度不同。 一般来说，Java 属于静态类型语言，但因为提供了类似反射等机制，也具备了部分动态类型语言的能力。今天就来介绍一下反射机制。 什么是反射反射机制指的是程序在运行时自省（introspect，即能够获取自身信息）的能力。在 Java 中，只要给定类的完全限定名，就可以通过反射直接操作类或对象。它主要有以下几个作用： 在运行时判断任意一个对象所属的类； 在运行时判断任意一个类具有的成员变量和方法； 在运行时调用任意一个对象的方法； 在运行时构造任意一个类的对象； 可以看到，反射提高了程序的灵活性和扩展性。但同时降低了代码的可读性和维护性；又因为反射涉及到动态类型，无法执行某些虚拟机优化，所以代码的执行性能也降低；另外，可以访问任意成员变量和方法，也破坏了封装性。一般来说，在业务代码中应尽量避免使用反射，但必须能理解中间件或框架中的反射代码。 反射的应用场景非常多。例如，对象序列化，动态代理，JDBC 的 Class.forName()，RPC 框架，Spring 的 IOC/DI。 Class 类Java 的 Class 类是反射机制的基础，包含了被装入到 JVM 中的类（包括类和接口）的信息。每个类（型）都有一个 Class 对象，也就是说每当编写并编译了一个新类，就会产生一个 Class 对象，被保存在一个同名的 .class 文件中。 所有的类都是在对其第一次使用时，动态加载到 JVM 中的。当运行程序时，类加载器会首先检查这个类的 class 对象是否已经加载，如果没有加载，类加载器就会根据类名查找 .class 文件，并将其 Class 对象载入。 获取某一个类所对应的 Class 对象有三种方法： 1). 根据对象的 getClass() 方法获取： 12User user = new User();Class c = user.getClass(); 2). 根据 Class 的静态方法 forName() 获取： 1Class c = Class.forName("com.timber.User"); 3). 根据类名 .class 获取： 1Class c = User.class; 对于基本类型来说，它们的包装类型拥有一个名为 TYPE 的 final 静态字段，指向该基本类型对应的 Class 对象。例如，Integer.TYPE 指向 int.class。 对于数组类型来说，可以使用 类名 + [].class 来访问 Class 对象。例如，int[].class。 使用反射创建对象在 Java 中创建对象主要有四种方式： 通过 new 关键字创建； 使用反射； 使用 clone 方法； 使用反序列化； 使用反射 Java 中使用反射创建对象主要有两种方法： 1). 使用 Class 类的 newInstance 方法 123456方法一：Class&lt;?&gt; userClass = Class.forName("com.timber.User"); // 给定类的完全限定名User user = (User) userClass.newInstance();方法二：User user = User.class.newInstance(); 2). 使用 Constructor 类的 newInstance 方法 12345Constructor&lt;User&gt; constructor = User.class.getConstructor();User user = constructor.newInstance();Constructor&lt;?&gt; constructor = User.class.getConstructor();User user = (User) constructor.newInstance(); 事实上，Class 的 newInstance 方法内部就是调用 Constructor 的 newInstance 方法。如下为 Class 类的源码： 1234567891011@CallerSensitivepublic T newInstance() throws InstantiationException, IllegalAccessException &#123; Constructor&lt;T&gt; tmpConstructor = cachedConstructor; try &#123; return tmpConstructor.newInstance((Object[])null); &#125; catch (InvocationTargetException e) &#123; Unsafe.getUnsafe().throwException(e.getTargetException()); // Not reached return null; &#125;&#125; 使用反射功能在得到 Class 对象后，可以正式使用反射功能了。除了使用 newInstance() 生成类的实例，还有以下几项： 1). 使用 isInstance(Object o) 来判断一个对象是否该类的实例，等同于 instanceof 关键字： 12Class c = User.class.newInstance();boolean b = c.isInstance(user); 2). 使用 Array.newInstance(Class c, int size) 来构造该类型的数组： 1int[] arr = Array.newInstance(int[].class, 3); 3). 使用 getFields()/getConstructors()/getMethods() 来访问该类的成员。需要注意，方法名中带 Declared 的不会返回父类的成员，但是会返回私有成员；而不带 Declared 的则相反。 12Method[] methods = c.getMethods();Method[] methods = c.getDeclaredMethods(); 当获得类成员之后，可以进一步做如下操作： 使用 Constructor/Field/Method.setAccessible() 来修改访问限制 使用 Constructor.newInstance(Object[]) 来生成该类的实例 使用 Field.set/get(Object) 来访问字段值 使用 Method.invoke(Object, Object[]) 来调用方法 实例：在泛型为 Integer 的 ArrayList 中存放一个 String 类型的对象： 1234567891011public void test() &#123; try &#123; List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); Class&lt;?&gt; listClass = list.getClass(); Method method = listClass.getMethod("add", Object.class); method.invoke(list, "test"); System.out.println(list.get(0)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;&#125; 反射调用的开销在前面的方法中，Class.forName 会调用本地方法，Class.getMethod() 会遍历该类的共有方法，如果找不到，还会遍历父类的私有方法，所以它们的操作都很费时。另外，Method.getMethods() 等方法还会返回查找结果的一份拷贝。 在实践中，应该避免在热点代码中使用 Method.getMethods() 和 Method.getDeclaredMethods() 方法。并且往往会缓存 Class.forName() 和 Method.getMethod() 的结果。 在反射调用时会带来不少性能开销，主要原因有三个： 由于 Method.invoke 是一个变长参数方法，在调用时会生成一个 Object 数组 由于 Object 数组不能存储基本类型，所以会对基本类型进行自动装箱、拆箱 如果拥有多个不同的反射调用，就会对应多个 GeneratedMethodAccessor，可能由于 JVM 调用点的类型 profile 无法同时记住多个类，而没有被内联 静态代理代理是基本的设计模式之一。它可以通过访问代理对象来完成对目标对象的访问，在不修改原对象的情况下扩充其功能。可以分为静态代理和动态代理两种。 静态代理，就是代理类由程序员自己编写，代理模式中的所有对象在编译期就已经确定。下面是一个简单的例子，首先定义一个接口和其实现： 12345678910public interface UserService &#123; void say();&#125;public class UserServiceImpl implements UserService &#123; @Override public void say() &#123; System.out.println("目标对象"); &#125;&#125; 这就是代理模式中的目标对象和目标对象的接口，接下来定义代理对象： 1234567891011121314public class UserServiceProxy implements UserService &#123; private UserService target; public UserServiceProxy(UserService target) &#123; this.target = target; &#125; @Override public void say() &#123; System.out.println("调用目标对象之前"); target.say(); System.out.println("调用目标对象之后"); &#125;&#125; 上面就是一个代理类，它同样实现了目标对象的接口，并重写了 say 方法。下面是一个测试类： 12345678910111213public class ProxyTest &#123; public static void main(String[] args) &#123; // 目标对象 UserService target = new UserServiceImpl(); // 代理对象 UserService proxy = new UserServiceProxy(target); proxy.say(); &#125;&#125;// 调用目标对象之前// 目标对象// 调用目标对象之后 静态代理也存在一些局限，例如，需要程序员手写很多代码，并且当需要代理的类中方法比较多，或者同时需要代理多个对象时，实现会很复杂。 动态代理动态代理中的代理类是在运行期动态生成的。在 Java 中，动态代理有两种方式： 1). JDK 接口 + 反射方式 这种方式主要通过 java.lang.reflect 包中的 Proxy 类和 InvocationHandler 接口实现。由于是 JDK 本身支持，可能比 cglib 更加可靠，代码实现也比较简单。但是它有一个限制，就是代理对象必须实现一个或多个接口。 2). cglib 继承 + asm 方式 cglib 是一个第三方代码生成类库，通过在运行时动态生成一个子类对象来实现，它底层通过一个小而快字节码处理框架 asm，转换字节码来生成新的类。这种方式无需实现接口，达到了代理类无侵入。但是无法代理 final 类和父类的 static/final 方法。 cglib 虽然性能较高，但是它需要对 JVM 内部结构包括 Class 文件格式和指令集很熟悉，所以不鼓励使用。 Java 的动态代理最主要的用途就是应用在各种框架中。例如，RPC 框架，Spring 中的 AOP，Servlet 的过滤器、拦截器。像 Mybatis 的分页插件，Spring AOP 中类似日志、事务、权限、性能监控等都用到了动态代理，以在不同模块的特定阶段实现某些功能。 两种实现方法1). JDK 动态代理 目标对象的接口和实现和静态代理中一样，下面定义调用处理器类，它需要实现 IovacationHandler 接口： 123456789101112131415161718192021222324252627public class JDKInvocationHandler implements InvocationHandler &#123; private Object target; // 传入目标对象 public JDKInvocationHandler(Object target) &#123; super(); this.target = target; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("调用前:" + method.getName()); // 将请求转发给目标对象，并传入相应的参数 Object result = method.invoke(target, args); System.out.println("调用后:" + method.getName()); return result; &#125; public Object getProxy() &#123; // 传入类加载器、希望该代理类实现的接口类数组、调用处理器，构造代理类 return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), target.getClass().getInterfaces(), this); &#125;&#125; 下面是测试类： 123456789101112public class JDKProxyTest &#123; public static void main(String[] args) &#123; UserService target = new UserServiceImpl(); JDKInvocationHandler handler = new JDKInvocationHandler(target); UserService proxy = (UserService) handler.getProxy(); proxy.say(); &#125;&#125;// 调用前:say// 目标对象// 调用后:say 2). Cglib 动态代理 目标对象和之前的一致，下面定义代理类： 123456789101112131415161718public class CglibProxy implements MethodInterceptor &#123; private Enhancer enhancer = new Enhancer(); public Object getProxy(Class c) &#123; enhancer.setSuperclass(c); enhancer.setCallback(this); return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("打开事务"); Object retVal = methodProxy.invokeSuper(o, objects); System.out.println("关闭事务"); return retVal; &#125;&#125; 下面是测试类： 1234567891011public class CglibTest &#123; public static void main(String[] args) &#123; CglibProxy proxy = new CglibProxy(); UserServiceImpl proxyImpl = (UserServiceImpl) proxy.getProxy(UserServiceImpl.class); proxyImpl.say(); &#125;&#125;// 打开事务// 目标对象// 关闭事务]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 泛型、枚举、注解]]></title>
    <url>%2F2019%2F02%2F17%2F022_%E6%B3%9B%E5%9E%8B%E3%80%81%E6%9E%9A%E4%B8%BE%E3%80%81%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java 泛型Java 泛型是 JDK5 中引入的一个特性，允许在定义类和接口时使用类型参数。声明的类型参数在使用时用具体的类型来替换。最主要的应用就是在集合类框架中。 泛型最大的好处就是可以提高代码的复用性。例如，List 接口，可以将 String、Integer 等多种类型放入到 List 中。 类型擦除不同语言中，编译器处理泛型有两种方式： Code Specilization。在实例化一个泛型类或泛型方法时，都会产生一个新的目标代码(字节码或二进制代码)。在 C++ 和 C# 中就使用这种机制，但是会导致代码膨胀。基于这种方法实现的泛型也称为真实泛型。 Code Sharing。每个泛型类只生成唯一的一份目标代码，该类的所有实例都映射到这份目标代码，在需要时执行类型检查和类型转换。基于这种方法实现的泛型也称为伪泛型。 在 Java 中，它只在程序源码中存在，在编译后的字节码文件中，已经被替换为原生类型，并在相应地方插入了强制转型代码。所以说，Java 的泛型仅是一种语法糖，它的实现方法就称为类型擦除。 类型擦除指的是通过类型参数合并，将泛型参数实例关联到同一份字节码上。编译器只为泛型类型生成一份字节码，并将实例关联到这份字节码上。类型擦除的关键在于从泛型类型中清除类型参数的相关信息，并在必要时添加类型检查和类型转换的方法。 例如，下面这段代码： 12345public static void main(String[] args) &#123; Map&lt;String, String&gt; map = new HashMap&lt;&gt;(); map.put("name", "timber"); System.out.println(map.get("name"));&#125; 反编译后为： 12345public static void main(String[] args) &#123; Map map = new HashMap(); map.put("name", "timber"); System.out.println((String) map.get("name"));&#125; 类型擦除的问题如果泛型遇到重载，可能会遇到问题。 12345678public class GenericTest &#123; public void test(List&lt;String&gt; list) &#123; System.out.println("List&lt;String&gt;"); &#125; public void test(List&lt;Integer&gt; list) &#123; System.out.println("List&lt;Integer&gt;"); &#125;&#125; 上面这段代码，参数类型看起来不同，是重载方法。但这段代码是编译通不过的。在编译后，参数 List&lt;Integer&gt; 和 List&lt;String&gt; 在类型擦除后都变成了 List，导致方法特性签名一样。 泛型限定通配符限定通配符用于对泛型进行限制，在初始化时就必须使用限定内的类型，否则会导致编译错误。有两种限定通配符： &lt;? extends T&gt;：设定泛型类型的上边界，保证泛型类型必须是 T 的子类； &lt;? super T&gt;：设定泛型类型的下边界，包装泛型类型必须是 T 的父类。 在使用时可根据 PECS 原则判断： 如果要从集合中读取类型 T 的数据，但不写入，可以使用 &lt;? extends T&gt; 的通配符（Producer Extends）。 如果要从集合中写入类型 T 的数据，但不读取，可以使用 &lt;? super T&gt; 通配符（Consumer super）。 如果既要写入又要读取，那就不要使用任何通配符。 非限定通配符 &lt;?&gt; 表示可以用任意泛型类型来替代。 List、List&lt;?&gt;、List List：在编译时编译器不会对 List 进行类型安全检查；可以把任何带参数的类型传递给 List； List&lt;?&gt;：未知类型的 List，可以把任何带参数的类型传递给 List； List&lt;Object&gt;：任意类型的 List，在编译时编译器会对 List&lt;?&gt; 进行类型安全检查；不能把任何带参数的类型传递给 List&lt;Object&gt;； 枚举枚举（enum）从 JDK1.5 引入，是指由一组固定的常量组成合法的类型。由关键字 enum 来定义一个枚举。例如： Java 中的枚举类型有以下特点： 使用关键字 enum 和类型名称 一串允许的值 枚举可以单独定义在一个 Java 类中，也可以嵌在其它 Java 类中 枚举可以实现一个或多个接口（Interface） 可以定义新的变量和方法 可以定义根据具体枚举值而相异的类 常见用法1234567891011121314151617181920212223242526272829303132333435public enum Color &#123; RED("红色", 1), GREEN("绿色", 2), BLANK("白色", 3), YELLO("黄色", 4); private String name; private int index; private Color(String name, int index) &#123; this.name = name; this.index = index; &#125; public static String getName(int index) &#123; for (Color c : Color.values()) &#123; if (c.getIndex() == index) &#123; return c.name; &#125; &#125; return null; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getIndex() &#123; return index; &#125; public void setIndex(int index) &#123; this.index = index; &#125; &#125; 枚举是如何实现的enum 关键字也是 Java 提供的一个语法糖。如果对刚才的这个枚举： 123public enum Season &#123; SPRING,SUMMER,AUTUMN,WINTER;&#125; 通过 jad Season.class 进行反编译，看它是如何实现的： 12345678910111213141516171819202122232425262728293031package timberliu.enum0;public final class Season extends Enum &#123; public static Season[] values() &#123; return (Season[])$VALUES.clone(); &#125; public static Season valueOf(String name) &#123; return (Season)Enum.valueOf(timberliu/enum0/Season, name); &#125; private Season(String s, int i) &#123; super(s, i); &#125; public static final Season SPRING; public static final Season SUMMER; public static final Season AUTUMN; public static final Season WINTER; private static final Season $VALUES[]; static &#123; SPRING = new Season("SPRING", 0); SUMMER = new Season("SUMMER", 1); AUTUMN = new Season("AUTUMN", 2); WINTER = new Season("WINTER", 3); $VALUES = (new Season[] &#123; SPRING, SUMMER, AUTUMN, WINTER &#125;); &#125;&#125; 可以看到，public final class Season extends Enum 说明该类是继承 Enum，同时 final 也说明该类不能被继承。 四个变量 SPRING、SUMMER、AUTUMN、WINTER 都是 static final 的，通过 static 进行初始化。而 static 类型的属性在类加载时就被初始化，所以创建一个 enum 类型是线程安全的。 Enum 源码Enum 类是 java.lang 包中一个类，是 Java 中所有枚举类型的公共基类。 定义 首先看以下 Enum 类的定义： 12public abstract class Enum&lt;E extends Enum&lt;E&gt;&gt; implements Comparable&lt;E&gt;, Serializable &#123; 可以看到，它是一个抽象类，由于抽象类不能被实例化，所以在程序中不能使用 new 关键字来声明一个 Enum。 从之前反编译的代码可以看到，在使用 enum 关键字定义一个枚举时，编译时默认继承 Enum 类，并加上 final 声明，故枚举无法继承。 Enum 类实现了 Serializable 接口，可以序列化。实现了 Comparable 接口，可以进行比较，默认情况下只有同类型的 enum 可以比较。 E extends Enum&lt;E&gt; 表示一个继承了 Enum&lt;E&gt; 类型的枚举类型，Enum&lt;E extends Enum&lt;E&gt;&gt; 就是一个 Enum 只接受一个 Enum 或者它的子类作为参数。 成员变量 在 Enum 中，有两个成员变量，一个是名字(name)，一个是序号(ordinal)。 123456789private final String name;public final String name() &#123; return name;&#125;private final int ordinal;public final int ordinal() &#123; return ordinal;&#125; 序号是一个枚举常量，表示在枚举中的位置，从 0 开始，依次递增。 构造器 在 Enum 类中只有一个保护类型的构造函数： 1234protected Enum(String name, int ordinal) &#123; this.name = name; this.ordinal = ordinal;&#125; 在前面反编译的代码中 super(s, i); 就是调用 Enum 类中的这个保护类型的构造函数来初始化 name 和 ordinal。 注解Java 注解，也叫元数据，一种代码级别的说明。在 JDK1.5 之后引入，可以声明在类、方法、字段、方法、方法参数等前面，用来对元素进行说明注释。 元注解就是用来定义其他注解的注解。元注解主要以下四个： @Target：表示该注解可以用于什么地方，可能的值在枚举类 ElementType 中； @Retention：表示在什么级别保存该注解信息，可能的值在 RetentionPolicy 中； @Documented：将此注解包含在 javadoc 中； @Inherited：允许子类继承父类。 自定义注解就是通过元注解定义出来的注解。除了元注解外，其他都是自定义注解。例如常见的 Override、Autowrited 等。 如何自定义注解在 Java 中，注解的定义和接口差不多，但增加了一个 @ 符号，即 @interface。代码中可以定义成员变量，用于描述信息。也可以添加默认值。 然后还要在注解上面添加元注解： 1234567@Target(ElementType类中的常量值)@Retention(RetentionPolicy=RUNTIME)[@Documented][@Inherited]public @interface 注解名 &#123; 返回类型 方法名() default 默认值;&#125; Spring 中常用的注解 @Component：泛指组件，当组件不好归类时，可以使用这个注解进行标注； @Service：用于标注业务层组件； @Controller：用于标注控制层组件； @Repository：用于标注数据访问层组件； @AutoWried：默认按类型装配；可结合 @qualifier 注解按名称装配； @RequestMapping：用于将 HTTP 请求映射到 Controller 的处理方法上； @PathVariable：用于将 URL 中占位符的参数绑定到 Controller 处理方法的参数上;]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化与反序列化]]></title>
    <url>%2F2019%2F02%2F17%2F021_%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化与反序列化序列化(Serialization)是将对象转换为可传输的格式的过程，一般是以字节码或 XML 格式传输。而反序列化是将字节码或 XML 码编码格式还原为完全相等的对象的过程。 对象序列化机制也是一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并在需要时将这个字节数组通过反序列化的方式再转换成对象，如此可以很容易地在对象和字节数组之间进行转换。 除了持久化时用到序列化之外，当在网络中传输对象、使用 RMI 和 RPC 时，都会用到对象序列化。 如何序列化Java 中提供了一套方便的 API 来支持，将对象进行序列化和反序列化。其中包括以下接口和类： java.io.Serializable java.io.Externalizable ObjectOutputStream ObjectInputStream ObjectOutput ObjectInput ObjectInput 和 ObjectOutput 接口ObjectInput ObjectInput 接口扩展自 DataInput 接口以包含对象的读操作。 DataInput 接口用于从二进制流中读取字节，并根据所有 Java 基本类型数据进行重构。同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具。 对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (end of file)，则将抛出 EOFException（IOException 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 IOException 而不是 EOFException。尤其是，在输入流已关闭的情况下，将抛出 IOException。 ObjectOutput ObjectOutput 扩展 DataOutput 接口以包含对象的写入操作。 DataOutput 接口用于将数据从任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具。 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException。 ObjectInputStream 和 ObjectOutputStream 类通过 ObjectOutputStream 和 ObjectInputStream 可以对对象进行序列化及反序列化。一般使用 ObjectOutputStream 的 writeObject 方法把一个对象进行持久化，再使用 ObjectInputStream 的 readObject 从持久化存储中把对象读取出来。 Serializable 接口Java 中，只要类实现 java.io.Serializable 接口就表示可以被序列化。没有实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。 当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException。 如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该实现 java.io.Serializable 接口。 举个栗子，下面是一个实现了 java.io.Serializable 接口的类： 1234567891011121314151617181920212223242526public class User1 implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 对这个 User1 对象进行序列化和反序列化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SerializableTest &#123; public static void main(String[] args) &#123; User1 user = new User1(); user.setName("timber"); user.setAge(20); System.out.println("before: " + user); // Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream("tempFile")); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) &#123; try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Read Obj from File File file = new File("tempFile"); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User1 newUser = (User1) ois.readObject(); System.out.println("after: " + newUser); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; file.delete(); &#125; &#125;&#125; 打印结果为： 12before: User1&#123;name='timber', age=20&#125;after: User1&#123;name='timber', age=20&#125; Externalizable 接口除了 Serializable 之外， Java 中还提供了另一个序列化接口 Externalizable 来自定义序列化和反序列化策略。该接口中定义了抽象方法：writeExternal 与 readExternal 方法。当使用 Externalizable 进行序列化和反序列化时需要实现这两个方法。 如果在这两个方法中没有定义序列化实现细节，进行序列化和反序列化后得到的对象的所有属性的值都变成了默认值。也就是说之前的那个对象的状态并没有被持久化下来。 另外，若使用 Externalizable 接口进行序列化，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 Externalizable 接口的类必须要提供一个 public 的无参的构造器。 下面是一个实现 Externalizable 接口的类： 1234567891011121314151617181920212223242526272829303132333435363738public class User2 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeInt(age); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); age = in.readInt(); &#125; @Override public String toString() &#123; return "User1&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125; 对这个 User2 对象进行序列化和反序列化： 1234567891011121314151617181920212223242526public class ExternalizableTest &#123; public static void main(String[] args) &#123; User2 user = new User2(); user.setName("timber"); user.setAge(20); System.out.println(user); //Write Obj to file try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("tempFile"))) &#123; oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //Read Obj from file File file = new File("tempFile"); User2 user2 = null; try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) &#123; user2 = (User2) ois.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(user2); &#125;&#125; 相关知识transient 关键字transient 关键字可以控制变量的序列化。如果在变量声明前加上该关键字，可以阻止该变量被序列化。在被反序列化时，transient 变量的值被设为初始值，如 int 类型是 0，引用类型是 null。 序列化ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID)。 序列化 ID 一般有两种生成策略： 一种是固定的 1L。如果没有特殊需求，就是用默认的 1L 就可以； 一种是随机生成一个不重复的 long 类型数据。有时可通过改变序列化 ID 可以用来限制某些用户的使用。 静态变量在 Java 序列化保存对象时，会将其状态保存为一组字节，在需要时将这些字节封装成对象。这里的状态指的是对象的成员变量，也就是说不会保存类中的静态变量。 Serializable接口为空？Serializable 虽只是一个空接口。但底层实现中，在序列化操作时，会判断要被序列化的类是否是 Enum、Array 和 Serializable 类型，如果不是则直接抛出 NotSerializableException。以此来保证只有实现了该接口的方法才能进行序列化与反序列化。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 源码阅读]]></title>
    <url>%2F2019%2F02%2F16%2F020_String%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[本文基于 JDK1.8，在其他版本中会有不同。 定义及属性12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String 类被 final 修饰，表示不可变。实现了 Serializable, Comparable&lt;String&gt;, CharSequence 接口。 value[]：String 类底层通过 final 类型的 char 数组实现，用于存储字符串内容； hash：用于缓存当前字符串的 hashcode 值，默认为 0； 构造器String 类中重载的构造器很多，其中比较常用的有： 字符串构造1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 用一个 String 类型的对象来初始化 String。实现中直接将源 String 的 value 和 hash 两个属性直接赋值给目标 String。 可以看出，新创建的 String 对象是传入的参数 String 的一个副本。除非确实需要显式得赋值一个字符串对象，否则没有必要使用此构造器来创建一个 String 对象。 字符数组构造12345678public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;public String(char value[], int offset, int count) &#123; // check bounds this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 也可以使用一个 char 数组来创建一个 String，实现中通过 Array.copyOf 或 Array.copyOfRange 方法，将原有的字符数组中的内容逐一地赋值到新 String 的字符数组中。 在复制时，即可以复制整个字符数组，也可以通过 offset 和 count 两个参数来复制字符数组的一部分。 字节数组构造123456public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException("charset"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length);&#125; 使用 byte 数组来构造一个 String，需要将 byte 数组转换为 char 数组。由于在网络传输中，经常需要在 byte[]、char[] 和 String 之间相互转化，所以 StringCoding 类提供了一系列重载的构造方法，例如这里的 StringCoding.decode(charset, bytes, offset, length) 方法，它通过指定的 charset 对 byte 数组解码为 unicode 的 char 数组，构造新的 String。 还有其他几种类似的构造方法，可以选择性地指定编码格式、解码的第一个字节下标、解码的字节数。 在 StringCoding.decode 方法中，如果没有指定编码格式，则默认使用 ISO-8859-1 格式进行操作。 常用方法比较方法equals 方法用于比较当前对象与传入的字符串对象是否相等。 123456789101112131415161718192021222324252627public boolean equals(Object anObject) &#123; // 如果它们是一个对象，肯定为 true if (this == anObject) &#123; return true; &#125; // 传入的对象必须是 String if (anObject instanceof String) &#123; // 将 Object 强转为 String 类型 String anotherString = (String)anObject; int n = value.length; // 两者的字符序列长度是否相等 if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; // 逐一比较两个字符数组的每一个字符 while (n-- != 0) &#123; // 只要有一个不等，即返回 false if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; regionMatches 方法用于比较当前对象与传入的字符串对象的指定区域是否相等。但可以传入一个 boolean 值用于指定是否忽略大小写。 1234567891011121314151617181920212223242526272829303132public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // 根据传入的 boolean 值来判断是否分别转换为大写、小写进行比较 char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true;&#125; compareTo 方法按照字典序比较两个字符串的大小。 1234567891011121314151617181920public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; // 逐一比较每一个字符的大小 while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; // 只要有一个能分为大小，即返回 return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; hashcode123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; String 类计算的 hashcode 的公式如下： 1s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] getBytes1234public byte[] getBytes(Charset charset) &#123; if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length);&#125; 使用指定的字符集编码将 String 对象编码成一个 byte 数组。也有不指定编码格式的 getBytes 版本，会默认使用系统的编码方式，例如在中文操作系统中可能使用 GBK，在英文系统中可能使用 IOS-8859-1 格式。 indexOfindexOf 方法返回指定字符在当前 String 对象第一次出现的索引位置。 123456789101112131415161718192021222324public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; return -1; &#125; // 一个完整的 Unicode 字符叫代码点 CodePoint， // String 对象以 UTF-16 保存 Unicode 字符，需要两个字符表示一个超大字符集的汉字 // 如果 cd 参数小于 Unicode 补充代码点的最小值 0x010000 if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; final char[] value = this.value; // 遍历字符数组 for (int i = fromIndex; i &lt; max; i++) &#123; // 如果当前字符等于 ch，则返回索引 i if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125;&#125; lastIndexOf 方法返回指定字符在当前 String 对象最后一次出现的索引位置。 1234567891011121314public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125;&#125; replacereplace 方法将当前字符串对象中所有的 oldChar 字符替换为 newChar，返回一个新的 String 对象。 123456789101112131415161718192021222324252627282930public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; // 从索引位置零开始，查找当前字符串中第一次出现字符 oldChar 的索引位置 while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; // 将 [0,i) 之间的字符直接缓存到 buf 字符数组中 for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; // 遍历 [i, len - 1] 之间的字符 while (i &lt; len) &#123; char c = val[i]; // 如果遍历到的字符与 oldChar 相等，则替换，否则保持不变 buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true); &#125; &#125; return this;&#125; 两个方法根据给定的正则表达式替换匹配到的第一个或全部的子字符串。 1234567public String replaceFirst(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceFirst(replacement);&#125;public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement);&#125; valueOfcopyValueOf 方法将指定的字符数组转换成一个 String 对象。 123public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125; valueOf 方法将六种基本数据类型的变量转换成 String 类型。 123456789101112131415161718192021222324public static String valueOf(boolean b) &#123; return b ? "true" : "false";&#125;public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true);&#125;public static String valueOf(int i) &#123; return Integer.toString(i);&#125;public static String valueOf(long l) &#123; return Long.toString(l);&#125;public static String valueOf(float f) &#123; return Float.toString(f);&#125;public static String valueOf(double d) &#123; return Double.toString(d);&#125; concat将指定的字符串拼接到当期字符串的末尾。 123456789101112public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; // 创建一个 len + otherLen 大小的数组，将 value 拷贝过去 char buf[] = Arrays.copyOf(value, len + otherLen); // 将 str 中的字符拷贝到 buf 中 str.getChars(buf, len); return new String(buf, true);&#125; startsWith判断当前字符串从索引位置 toofset 开始是否以指定的前缀字符串开头。 12345678910111213141516public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true;&#125; 判断当前字符串是否以指定的前缀字符串开头或结尾。 1234567public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0);&#125;public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length);&#125; trimtrim 方法可去掉字符串两端的空格。 12345678910111213141516public String trim() &#123; int len = value.length; int st = 0; char[] val = value; // 找到第一个不为 ' ' 的下标 while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; // 找到最后一个不为 ' ' 的下标 while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; // 调用 substring 方法截取 [st, len] 之间的字符串 return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; 其他方法1234567891011121314// 返回字符串中第 index 个字符public char charAt(int index) // 将 String 转换为 字符数组public char[] toCharArray() // 将 String 按照字符 regex 分为 limit 份public String[] split(String regex, int limit)// 转换为大写public String toUpperCase()// 转换为小写public String toLowerCase()]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
        <tag>源码解读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 类详解]]></title>
    <url>%2F2019%2F02%2F15%2F019_String%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[不可变性String 对象是不可变（Immutable）的，也就是一旦 String 类实例被创建后，就不能改变其值。这里的不可变指的是引用既不能指向其他对象，而且引用指向的对象的值也不能改变。 为什么不可变在 JDK1.6 中，String 类中的成员变量如下： 1234567891011public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; 在 JDK1.7 中，String 类主要改变了 substring 方法的实现，成员变量剩下了两个： 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 可以看出，String 就是字符数组的封装。在 JDK6 中，value 是一个 char 数组，offset 是 String 对象实际的起始位置，而 count 是所占的个数。在 JDK7 中，value 中的所有字符都属于 String 对象。 value、offset 和 count 这三个变量都是 private final 的，并且没有 setter 方法来修改，所以 String 类外部无法修改 String。所以，一旦初始化后就不能修改，String 对象也就是不可变的。 真的不可变吗String 中的 char 数组 value 是 private final 的，被 final 修饰 虽然不能指向其他数组对象，但却可以通过反射修改其指向的数组。 使用反射可以得到 String 类的 value 属性，修改访问权限，然后就可以对数组内容进行修改。 123456789101112131415public static void main(String[] args) throws Exception &#123; String s = "abc"; System.out.println(s); // 获取 value 字段 Field field = String.class.getDeclaredField("value"); // 修改 value 字段访问权限 field.setAccessible(true); // 获取 s 对象上 value 属性的值 char[] value = (char[]) field.get(s); value[1] = 'd'; System.out.println(s);&#125;// abc// adc 可以看到，通过反射是可以修改 “不可变” 对象的。 不可变的优点String 被设计为不可变的，在 Security、Cache、Thread Safe 方面都有很多优点： 安全性。String 被广泛地使用在其他 Java 类中充当参数。例如 网络连接、IO 操作、数据库连接等，如果字符串可变，那么可能会导致安全问题。 字符串常量池。String 类维护了一个运行时常量池，会对创建的字符串进行缓存，如此在使用时更加高效。而这就建立在不可变的基础上，不用担心数据冲突问题。 缓存 hashcode。Java 中经常用到字符串的哈希值，字符串的不可变能保证其 hashcode 永远保持一致，这样在每次使用一个字符串的 hashcode 时，就不用重新计算一次，也更加高效。 线程安全性。由于 String 对象不能被改变，所以同一个字符串实例可以被多个线程共享，而不用因为线程安全问题使用同步。 不可变的缺点当然，设计为不可变也会出现一些缺点，例如在类似拼接、裁剪等操作时，都会创建新的 String 对象，如果程序设计不当，便会产生大量无用的字符串对象，耗费时间空间。 “+” 的实现1、对于两个编译期常量(编译期可知)，例如 String s = &quot;a&quot; + &quot;b&quot;，编译器会进行常量折叠，即变成 String s = &quot;ab&quot;： 123456/** * String s1 = "ab"; * String s2 = "a1"; */String s1 = "a" + "b";String s2 = "a" + 1; 2、对于能够进行优化的(例如 String s = &quot;a&quot; + s1 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 1234567891011121314151617/** * String s3 = (new StringBuilder()).append("a").append(s1).toString(); * String s4 = (new StringBuilder()).append(s2).append(s3).toString(); */String s3 = "a" + s1;String s4 = s2 + s3;/** * String s6 = * for (int i = 0; i &lt; 2; i++) &#123; * s6 = (new StringBuilder()).append(s6).append(i).toString(); * &#125; */String s6 = "";for (int i = 0; i &lt; 2; i++) &#123; s6 += i;&#125; substring 在 jdk6 和 7 的区别substring 是一个比较常用的方法，而且在 jdk6 和 jdk7 中的实现不同。substring(int beginIndex, in endIndex) 方法的作用是截取字符串并返回其 [beginIndex, endIndex - 1] 范围内的内容。 123String str = "abcdef";String substring = str.substring(2, 4);System.out.println(substring); 输出结果为：cd。 JDK6 中的 substring 前面说过，在 JDK 6 中，String 类的三个成员变量：char value[]，int offset，int count，三个变量决定了 String 存储的真正的字符数组。 String 中主要相关源码如下： 1234567891011String(int offset, int count, char value[]) &#123; this.value = value; this.offset = offset; this.count = count;&#125;public String substring(int beginIndex, int endIndex) &#123; // 检查边界 return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125; 当调用 substring 方法时，会创建一个 String 对象，但 value 引用仍然指向堆中的同一个字符数组。它的内存变化： 如果字符串很长，在使用 substring 进行切割时只需要很短的一段，就可能导致性能问题.。因为只需要一小段字符串，但是却引用了整个字符串，这个很长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露。 JDK7 中的 substring 在 JDK7 中，主要剩下一个 value 变量，它的主要源码如下； 1234567891011public String(char value[], int offset, int count) &#123; // 检查边界 this.value = Arrays.copyOfRange(value, offset, offset+count);&#125;public String substring(int beginIndex) &#123; // 检查边界 int subLen = value.length - beginIndex; // 检查边界 return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 可以看到，JDK 7 中的 subString 方法，使用 new String 创建了一个新字符串，避免对老字符串的引用，从而解决了内存泄露问题。它的内存变化如下： StringBuffer、StringBuilderString String 是不可变对象，被声明为 final class，所有属性也都是 final 的。由于其不可变性，类似拼接、裁剪等操作，都会产生一个新的 String 对象，然后指针指向新的 String 对象，如果操作不当，可能会产生大量临时字符串。 在字符串内容不经常变化的业务场景优先使用 String 类。例如：常量声明、少量的字符串拼接等。 StringBuffer StringBuffer 是一个线程安全的可变字符序列。它解决了由于拼接产生太多中间对象的问题，可以用 append 或 add 方法，把字符串添加到字符串的末尾或指定位置。 它虽然保证了线程安全，也带来了额外的性能开销，所以除非有线程安全的需要，否则还是推荐使用 StringBuilder。 StringBulider StringBuilder 在能力与 StringBuffer 没有本质区别，但不保证同步，有效减小了开销。如果可能，在字符串拼接时建议优先使用。 为了能实现可修改的目的，StringBuffer 和 StringBuilder 底层都是可修改的数组，二者都继承了 AbstarctStringBuilder，包含了基本操作，区别仅在于最终的方法是否加了 synchronized。 JDK 9 改进在 JDK9 之前，String 类内部使用 char 数组来存储数据，但 char 是两个字节大小，这样就造成了一定的浪费。 在 JDK9 中，引入了 Compact Strings 的设计，对字符串进行改进，将 char 数组改变为 byte 数组加上一个标识编码的 coder，并且对相关字符串操作进行修改。 成员变量变化如下： 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; @Stable private final byte[] value; private final byte coder; 改进之后，在存储数据时，如果传入 byte 数组，直接赋值就好，如果传入 char 数组，其源码如下： 1234567891011121314151617String(char[] value, int off, int len, Void sig) &#123; if (len == 0) &#123; this.value = "".value; this.coder = "".coder; return; &#125; if (COMPACT_STRINGS) &#123; // COMPACT_STRINGS 默认初始化为 true byte[] val = StringUTF16.compress(value, off, len); if (val != null) &#123; this.value = val; this.coder = LATIN1; return; &#125; &#125; this.coder = UTF16; this.value = StringUTF16.toBytes(value, off, len);&#125; 其中，StringUTF16.compress 方法实现如下： 12345678910111213141516171819202122public static byte[] compress(char[] val, int off, int len) &#123; byte[] ret = new byte[len]; if (compress(val, off, ret, 0, len) == len) &#123; return ret; &#125; return null;&#125;···@HotSpotIntrinsicCandidatepublic static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; char c = src[srcOff]; if (c &gt; 0xFF) &#123; len = 0; break; &#125; dst[dstOff] = (byte)c; srcOff++; dstOff++; &#125; return len;&#125; 在 for 循环中，如果 char 数组中每一个字符都小于等于 0xFF，那么将 char 转换为 byte，完成构造，其 coder 为 LATIN1。 而如果存在一个大于 0xFF 的字符，就会跳出循环，最终 StringUTF6.compress 方法返回 null，通过 StringUTF16.toBytes 方法: 1234567891011121314151617181920212223@HotSpotIntrinsicCandidatepublic static byte[] toBytes(char[] value, int off, int len) &#123; byte[] val = newBytesFor(len); for (int i = 0; i &lt; len; i++) &#123; putChar(val, i, value[off]); off++; &#125; return val;&#125;public static byte[] newBytesFor(int len) &#123; // check bound return new byte[len &lt;&lt; 1];&#125;@HotSpotIntrinsicCandidate// intrinsic performs no bounds checksstatic void putChar(byte[] val, int index, int c) &#123; assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT);&#125; 通过 newBytesFor 方法 new 一个两倍长度的 byte 数组，在 for 循环中，通过 putChar 方法来填充 byte 数组，将 char 字符分为两部分，存储两个相邻的 byte 数组中。 String 类中方法基本都重新实现了一遍，但对外提供的接口没有改变。重构后，在字符串中所有字符小于 0xFF 时，可以节省一半的内存。 JDK 11 新特性JDK 11 中 String 类增加了一系列的字符串处理方法： 1234567891011121314151617// 判断字符串是否为空白System.out.println(" ".isBlank()); // true// 去除首尾空格System.out.println(" Timber ".strip()); // Timber// 去除首部空格System.out.println(" Timber".stripLeading()); // Timber// 去除尾部空格System.out.println("Timber ".stripTrailing()); // Timber// 重复字符串System.out.println("Timber".repeat(2)); // TimberTimber// 获取字符串中的行数System.out.println("A\nB\nC".lines().count()); // 3 参考资料 三张图彻底了解JDK 6和JDK 7中substring的原理及区别 JDK9的String类内部实现变更了！]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v2.0 分布式锁实现定时关单]]></title>
    <url>%2F2019%2F02%2F14%2F017_mmallv2.0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9A%E6%97%B6%E5%85%B3%E5%8D%95%2F</url>
    <content type="text"><![CDATA[在电商项目中，用户购买商品在生成订单后，一定时间内如果没有付款，应该将订单关闭。这里，主要用 Spring Schedule和分布式锁来实现，而分布式锁也分别用 Redis 命令原生实现和 Redisson 框架两种方式。 Spring Schedule 介绍Spring Schedule 是一个任务调度框架，用于定时任务调度等。主要通过 @Scheduled 注解来创建定时任务，可通过 cron 表达式来指定任务特定的执行时间。 Cron 表达式Cron 表达式是一个字符串，由 6 或 7 个字段组成，对应为 秒、分、时、日、月、周、年(可选)。 允许的值和特殊字符 字段名 允许的值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 月内第几天 1-31 , - * / ? L W C 月 1-12 或 JAN-DEC , - * / 周内第几天 1-7 或 SUN-SAT , - * / ? L C # 年(可选) 留空，1970-2099 , - * / 特殊字符的含义 *：匹配任意值，例如秒域为 * 表示每秒都会触发事件； ?: 只能在月内第几天和周内第几天两个域使用，用于执行不明确的值。当两个域之一被指定值后，为避免冲突，需要将另一个的值设为 ?； -: 指定一个范围，例如分域为 3-6，表示从 3 分到 6 分钟每分钟触发一次； / : 指定增量，表示起始时间开始触发，然后每隔固定时间触发一次，例如分域为 5/15，则意味着 5 分、20 分、35 分、50 分，分别触发一次； ,：指定几个可选值。例如在分域使用 5,15，则意味着在 5 和 20 分各触发一次； L : 表示最后，只能出现在周内第几天和月内第几天域，表示一月的最后一天，或一周的最后一天。如果在周内第几天域前加上数字，表示一月的最后一个第几天。例如 5L 表示一个月的最后一个周五； W : 指定有效工作日(周一到周五)，只能在月内第几天域使用，系统将在离指定日期的最近的有效工作日触发。注意一点，W 的最近寻找不会跨过月份； LW : 两个字符可以连用，表示一月的最后一个工作日，即最后一个星期五。 # : 指定一月的周内第几天，只能出现在月内第几天域。例如在 2#3，表示一月的第三个星期一(2 表示周一，3 表示第三周)。 C：可以在月内第几天和周内第几天使用。 举例 1234567891011"0 1 * * * *" 表示每小时1分0秒执行一次"*/20 * * * * *" 表示每20秒执行一次"0 0 9-12 * * *" 表示每天9，10，11，12点执行一次"0 0/20 9-12 * * *" 表示每天9点到12点，每20分钟执行一次"0 0 9-12 * * 2-6" 表示每周一至周五，9点到12点的0分0秒执行一次"0 0 0 1 4 ?" 表示4月1日0时0分0秒执行一次 实现定时任务首先，在 applicationContext.xml 文件中配置： 1&lt;task:annotation-driven/&gt; 开启定时任务。注意，导入约束时导入的是 http://www.springframework.org/schema/task。 然后，创建定时关闭订单的 task： 123456789101112131415@Component@Slf4jpublic class CloseOrderTask &#123; @Autowired private IOrderService iOrderService; @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV1() &#123; log.info("关闭订单定时任务启动"); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour", "1")); iOrderService.closeOrder(hour); log.info("关闭订单定时任务结束"); &#125;&#125; 表示每隔一分钟就查看是否有超过一个小时的订单未付款，如果有则进行关闭。IOrderServiceImpl 的 closeOrder 方法如下： 1234567891011121314151617181920@Overridepublic void closeOrder(int hour) &#123; Date closeDateTime = DateUtils.addHours(new Date(), -hour); List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(), DateTimeUtil.dateToStr(closeDateTime)); for (Order order : orderList) &#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo()); for (OrderItem orderItem : orderItemList) &#123; Integer stock = productMapper.selectStockByProductId(orderItem.getId()); if (stock == null) &#123; continue; &#125; Product product = new Product(); product.setId(orderItem.getProductId()); product.setStock(stock + orderItem.getQuantity()); productMapper.updateByPrimaryKeySelective(product); &#125; orderMapper.closeOrderByOrderId(order.getId()); log.info("关闭订单OrderNo：&#123;&#125;", order.getOrderNo()); &#125;&#125; 主要逻辑是，首先查询超过一个小时的订单列表，然后对列表中的每一条订单，根据订单号查询商品列表，对每一件商品的库存进行更新，最后，对订单的状态进行修改，即意味着删除。 如此，定时关闭一定时间内未付款的订单的 v1 版本就完成了。但是在 tomcat 集群环境下，每次只需要一台机器执行即可，不用每台机器都执行；而且，多台机器同时执行也容易造成数据错乱。所以，这就需要使用分布式锁来进行保证。 Redis 命令实现分布式锁Redis 命令下面是其中会用到的一下 Redis 命令： 1).setnx key value SET if Not eXists 的简称。如果键不存在，则将键 key 的值设置为 value。否则如果键已经存在，则不做任何操作。 设置成功时返回 1，设置失败时返回 0。 2).getset key value 将键 key 的值设为 value，并返回键 key 在被设置之前的旧值。 如果键 key 存在旧值，则会返回。否则如果不存在旧值，也就是键 key 在设置之前并不存在，则返回 nil。 3).expire key seconds 为给定的键 key 设置生存时间，当 key 的生存时间为 0(过期) 时，它会被自动删除。 4).del key [key...] 删除给定的一个或多个 key。 Redis 分布式锁Redis 分布式锁原理 Redis 分布式锁的流程图如下: 它的主要原理是：首先，通过 setnx 存入一个 lockkey，如果设置成功，也就是获取锁成功，就为锁设置一个有效期，然后执行业务，之后将 lockkey 删除，最后将锁释放。如果设置失败，也就是获取锁失败，则直接结束。 这里使用 setnx 命令，开始时 Redis 中不存在 lockkey，setnx(lockkey) 就会返回 1，表示本台机器获取到了锁，可以定时执行业务。而其他机器在有效期内获取锁时，lockkey 已经存在，就会返回 0，表示没有获取到锁，其他机器正在执行业务。 构建分布式任务调度 利用 Spring Schedule + Redis 分布式锁构建分布式任务调度，方法 closeOrderTaskV2 版本如下： 12345678910111213141516171819202122232425@Scheduled(cron = "0 */1 * * * ?")public void closeOrderTaskV2() &#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout", "5000")); // 获取锁 Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout)); if (setnxResult != null &amp;&amp; setnxResult.intValue() == 1) &#123; // 如果返回值是 1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; else &#123; log.info("没有获取到分布式锁：&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; log.info("关闭订单定时任务结束");&#125;private void closeOrder(String lockName) &#123; // 修改存活时间 RedisShardedPoolUtil.expire(lockName, 5); log.info("获取&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour", "2")); iOrderService.closeOrder(hour); // 删除 key RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());&#125; 缺点 如果某台 tomcat 机器成功获取到锁，但在为锁设置有效期之前，tomcat 机器意外关闭，这时就会产生死锁。 可以在 CloseOrderTask 中添加一个 delLock 方法，在销毁之前删除分布式锁： 1234@PreDestroypublic void delLock() &#123; RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);&#125; 但如果直接 kill 掉 tomcat 进程，仍然不会调用这个方法，从而产生死锁。 Redis 分布式锁双重防死锁Redis 分布式锁优化原理 Redis 分布式锁优化后的流程图如下: 它的原理是：同样首先通过 setnx 存入一个 lockkey，如果设置成功，同之前一样。否则，通过 get 获得之前设置的 currentTime + timeout，判断 lockValeA 是否不为 null，并且 currentTime 大于 lockValueA，即分布式锁是否过期。 如果过期，通过 getset 将 lockkey 对应的 value 设置为 currentTime + timeout，并得到之前的旧值 lockValueB，判断 lockValueB 是否为 null，即 lockkey 是否还存在，或者 lockValueA 是否等于 lockValueB，即在这个过程中锁没有改变。如果条件满足，则表示获取锁成功，同 setnx 获取锁成功一样。 如果锁没有过期，则表示获取锁失败，直接结束。在 getset 后，如果 lockValueB 不为空，即 lockkey 仍然存在，或者锁被改变了，也表示获取锁失败，直接结束。 构建分布式任务调度 利用 Spring Schedule + Redis 分布式锁构建分布式任务调度，方法 closeOrderTaskV3 版本如下： 123456789101112131415161718192021222324252627@Scheduled(cron = "0 */1 * * * ?")public void closeOrderTaskV3() &#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout", "5000")); // 获取锁 Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout)); if (setnxResult != null &amp;&amp; setnxResult.intValue() == 1) &#123; // 如果返回值是 1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; else &#123; // 未获取到锁，继续判断时间戳，看锁是否过期 String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); if (lockValueStr != null &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr)) &#123; // 锁过期，重置并获取锁 String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout)); if (getSetResult == null || (getSetResult != null &amp;&amp; StringUtils.equals(lockValueStr, getSetResult))) &#123; closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; else &#123; log.info("没有获取到分布式锁：&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125; else &#123; log.info("没有获取到分布式锁：&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125; log.info("关闭订单定时任务结束");&#125; Redisson 实现分布式锁Redisson 是架设在 Redis 上的一个 Java 驻内存数据网格，它在基于 NIO 的 Netty 框架上，充分地利用了 Redis 键值数据库提供的一系列优势。 将 Redisson 集成到项目中，只需要在 pom.xml 文件需要添加 redisson 和 jackson-dataformat-avro 的依赖。 Redisson 初始化类 1234567891011121314151617181920212223public class RedissonManager &#123; private Config config = new Config(); private Redisson redisson; private static String redis1IP = PropertiesUtil.getProperty("redis1.ip", "192.168.23.130"); private static Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty("redis1.port", "6379")); @PostConstruct public void init() &#123; try &#123; config.useSingleServer().setAddress(redis1IP + ":" + redis1Port); redisson = (Redisson) Redisson.create(config); log.info("初始化 Redisson 结束"); &#125; catch (Exception e) &#123; log.error("初始化 Redisson 失败", e); &#125; &#125; public Redisson getRedisson() &#123; return redisson; &#125;&#125; 这里使用单服务器模式，在传入地址时采用 ip:port 格式。 任务调度 v4 版本 tryLock 方法在获取锁时，三个参数分别为：尝试获取锁最多等待的时间、获取锁后自动释放的时间、时间单元。 1234567891011121314151617181920212223@Scheduled(cron = "0 */1 * * * ?")public void closeOrderTaskV4() &#123; RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); boolean locked = false; try &#123; if(locked = lock.tryLock(0, 5, TimeUnit.SECONDS)) &#123; log.info("Redisson 获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour", "2")); iOrderService.closeOrder(hour); &#125; else &#123; log.info("Redisson 没有获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; log.error("Redisson 获取分布式锁异常", e); &#125; finally &#123; if (!locked) &#123; return; &#125; lock.unlock(); log.info("Redisson 释放分布式锁"); &#125;&#125; 这里 tryLock 方法在获取锁之后，如果后续的执行业务时间小于 1 秒，而另外的 tomcat 在等待 1 秒后，又能重新获取锁，就会出现两个进程都获得锁的情况。 所以，应该将 waitTime 设置为 0（waitTime 时间小于业务执行时间）。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v2.0 环境搭建]]></title>
    <url>%2F2019%2F02%2F14%2F018_mmallv2.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Redis 配置与安装从官网下载 redis 到 /developer/setup 目录下 1wget http://download.redis.io/releases/redis-4.0.12.tar.gz 然后，将其解压到 /developer 目录下，进入到 redis-4.0.12 目录下，进行编译： 123tar -zxvf redis-4.0.12.tar.gz -C ../cd redis-4.0.12/make 再将其名修改为 redis-4.0.12_1，另外再拷贝一份为 redis-4.0.12_2： 12mv redis-4.0.12/ redis-4.0.12_1cp redis-4.0.12_1/ redis-4.0.12_2/ -R 然后，修改 redis-4.0.12_2/src/ 目录下的 redis.conf 文件，端口修改为 6380： 1port 6380 然后，分别进入到 src/ 目录下，后台启动 redis： 1./redis-server ../redis.conf &amp; Tomcat 配置多实例在单机部署多应用时，官方不建议复制一个又一份的全部 Tomcat 目录进行多实例的部署，而是按照如下图实现： CATALINA_HOME 指 Tomcat 的安装路径，包含 bin 和 lib 目录，而 CATALINA_BASE 指实例存放路径，包含 conf、webapps、logs 等目录。 复制出两个实例 首先新建两个 tomcat1、tomcat2 文件夹，并把 apache-tomcat-8.5.35 目录下的 conf、webapps、temp、logs、work 五个文件移动到 tomcat1 中，再将其复制一份到 tomcat2 中： 1234mkdir tomcat1 tomcat2cd apache-tomcat-8.5.11mv conf/ webapps/ temp/ logs/ work/ -t ../tomcat1cp -r ../tomcat1/* ../tomcat2 结果如下图所示： 配置 server.xml 端口 修改 conf/server.xml 中的三个端口： Server port：用于监听关闭 Tomcat 的 shutdown 命令，默认为 8005 Connector port：用于监听 HTTP 请求，默认为 8080 Connector port（protocol=”AJP/1.3”）：用于监听 AJP 协议上的请求，通常用于整合 Apache Server 等其他 HTTP 服务器，默认为 8009 将 tomcat2 实例的端口分别修改为 8006、8080、8010，并对 webapps/ROOT 下的 index.jsp 首页作相应修改。 创建启动、关闭脚本 新建一个 tomcat-shell 文件夹，存放启动和关闭脚本，并赋予其执行权限： 12345mkdir tomcat-shellcd tomcat-shell/vim start.shvim shutdown.shchmod u+x start.sh shutdown.sh start.sh 脚本如下： 12345678#!/bin/bashexport CATALINA_BASE=/developer/$1export CATALINA_HOME=/developer/apache-tomcat-8.5.35cd $CATALINA_HOME/binsh startup.sh shutdown.sh 脚本如下： 12345678#!/bin/bashexport CATALINA_BASE=/developer/$1export CATALINA_HOME=/developer/apache-tomcat-8.5.35cd $CATALINA_HOME/binsh shutdown.sh 启动和关闭脚本中，$1 表示执行时的第一个参数。 启动实例 执行以下命令，启动两个实例： 12./start.sh tomcat1./start.sh tomcat2]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v2.0 Redis + Cookie 实现单点登录]]></title>
    <url>%2F2019%2F02%2F14%2F016_mmallv2.0redis%2Bcookie%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[电商项目中，在单服务器时，用户登录时将用户信息设置到 session 中，获取用户信息从 session 中获取，退出时从 session 中删除即可。 但在搭建 Tomcat 集群后，就需要考虑 Session 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 Redis + Cookie 自己实现，另一种是借助 Spring Session 框架解决。 Redis+Cookie 实现单点登录的思路用户登录： 首先验证用户密码是否正确，并返回用户信息； 使用 uuid 或 session.getId 生成唯一 id(token)，设置到 cookie 中，将其写给客户端； 将用户信息(user 对象)转换为 json 格式； 以 key=token，value=(user 的 json 格式)，写到 redis 中，并设置过期时间； 退出登录： 用户请求时会携带 cookie，从 cookie 中获取到 token； 从请求中获取到 cookie，将其过期时间设置为 0，再写入到响应中，即删除了 token； 再从 redis 中删除 token； 获取用户信息： 从请求携带的 cookie 中获取到 token； 根据 token 在 redis 中查询相应的 user 对象的 json 串； 将 json 串转换为 user 对象； Redis 连接池及工具类由于 token 和 user 对象都会存储在 redis 中，所以这里封装一个 redis 的连接池和工具类。 首先，封装一个 redis 连接池，每次直接从连接池中获取 jedis 实例即可。 12345678910111213141516171819202122232425262728293031323334public class RedisPool &#123; private static JedisPool jedisPool; private static String redisIP = PropertiesUtil.getProperty("redis.ip", "192.168.23.130"); private static Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty("redis.port", "6379")); // 最大连接数 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total", "20")); // 最大的 idle 状态的 jedis 实例个数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle", "10")); // 最小的 idle 状态的 jedis 实例个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle", "2")); // 在 borrow 一个 jedis 实例时，是否要进行验证操作 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow", "true")); // 在 return 一个 jedis 实例时，是否要进行验证操作 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return", "true")); static &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); jedisPool = new JedisPool(config, redisIP, redisPort, 1000*2); &#125; public static Jedis getJedis() &#123; return jedisPool.getResource(); &#125; public static void returnJedis(Jedis jedis) &#123; jedis.close(); &#125;&#125; 然后，再将其封装成一个工具类，基本操作就是从 redis 连接池中获取 jedis 实例，进行 set/get/expire 等操作，然后将其放回到 redis 连接池中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Slf4jpublic class RedisPoolUtil &#123; // exTime 以秒为单位 public static Long expire(String key, int exTime) &#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.expire(key, exTime); &#125; catch (Exception e) &#123; log.error("expire key:&#123;&#125;, error", key, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; public static Long del(String key) &#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.del(key); &#125; catch (Exception e) &#123; log.error("del key:&#123;&#125;, error", key, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; public static String get(String key) &#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.get(key); &#125; catch (Exception e) &#123; log.error("get key:&#123;&#125;, error", key, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; public static String set(String key, String value) &#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.set(key, value); &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125;, value:&#123;&#125;, error", key, value, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; // exTime 以秒为单位 public static String setEx(String key, String value, int exTime) &#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.setex(key, exTime, value); &#125; catch (Exception e) &#123; log.error("setex key:&#123;&#125;, value:&#123;&#125;, error", key, value, e); &#125; RedisPool.returnJedis(jedis); return result; &#125;&#125; JsonUtil 工具类将 user 对象存储在 redis 中，需要转换为 json 格式，从 redis 中获取 user 对象，又需要转换为 user 对象。这里封装一个 json 的工具类。 JsonUtil 工具类主要使用 ObjectMapper 类。 bean 类转换为 String 类型，使用 writerValueAsString 方法。 String 类型转换为 bean 类，使用 readValue 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Slf4jpublic class JsonUtil &#123; private static ObjectMapper objectMapper = new ObjectMapper(); static &#123; // 序列化时将所有字段列入 objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.ALWAYS); // 取消默认将 DATES 转换为 TIMESTAMPS objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false); // 忽略空 bean 转 json 的错误 objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false); // 所有日期样式统一 objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); // 忽略 在 json 字符串中存在，在 java 对象中不存在对应属性的情况 objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); &#125; public static &lt;T&gt; String obj2Str(T obj) &#123; if (obj == null) &#123; return null; &#125; try &#123; return obj instanceof String ? (String) obj : objectMapper.writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error", e); return null; &#125; &#125; public static &lt;T&gt; String obj2StrPretty(T obj) &#123; if (obj == null) &#123; return null; &#125; try &#123; return obj instanceof String ? (String) obj : objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error", e); return null; &#125; &#125; public static &lt;T&gt; T str2Obj(String str, Class&lt;T&gt; clazz) &#123; if (StringUtils.isEmpty(str) || clazz == null) &#123; return null; &#125; try &#123; return clazz.equals(String.class) ? (T)str : objectMapper.readValue(str, clazz); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error", e); return null; &#125; &#125; public static &lt;T&gt; T str2Obj(String str, TypeReference&lt;T&gt; typeReference) &#123; if (StringUtils.isEmpty(str) || typeReference == null) &#123; return null; &#125; try &#123; return typeReference.getType().equals(String.class) ? (T)str : objectMapper.readValue(str, typeReference); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error", e); return null; &#125; &#125; public static &lt;T&gt; T str2Obj(String str, Class&lt;?&gt; collectionClass, Class&lt;?&gt; elementClass) &#123; JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClass); try &#123; return objectMapper.readValue(str, javaType); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error", e); return null; &#125; &#125;&#125; CookieUtil 工具类登录时需要将 token 设置到 cookie 中返回给客户端，退出时需要从 request 中携带的 cookie 中读取 token，设置过期时间后，又将其设置到 cookie 中返回给客户端，获取用户信息时，获取用户信息时，需要从 request 中携带的 cookie 中读取 token，在 redis 中查询后获得 user 对象。这里呢，也封装一个 cookie 的工具类。 在 CookieUtil 中： readLoginToken 方法主要从 request 读取 Cookie； writeLoginToken 方法主要设置 Cookie 对象加到 response 中； delLoginToken 方法主要从 request 中读取 Cookie，将其 maxAge 设置为 0，再添加到 response 中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4jpublic class CookieUtil &#123; private static final String COOKIE_DOMAIN = ".happymmall.com"; private static final String COOKIE_NAME = "mmall_login_token"; public static String readLoginToken(HttpServletRequest request) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; log.info("read cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); if (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123; log.info("return cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); return cookie.getValue(); &#125; &#125; &#125; return null; &#125; public static void writeLoginToken(HttpServletResponse response, String token) &#123; Cookie cookie = new Cookie(COOKIE_NAME, token); cookie.setDomain(COOKIE_DOMAIN); cookie.setPath("/"); // 防止脚本攻击 cookie.setHttpOnly(true); // 单位是秒，如果是 -1，代表永久； // 如果 MaxAge 不设置，cookie 不会写入硬盘，而是在内存，只在当前页面有效 cookie.setMaxAge(60 * 60 * 24 * 365); log.info("write cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); response.addCookie(cookie); &#125; public static void delLoginToken(HttpServletRequest request, HttpServletResponse response) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123; cookie.setDomain(COOKIE_DOMAIN); cookie.setPath("/"); // maxAge 设置为 0，表示将其删除 cookie.setMaxAge(0); log.info("del cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); response.addCookie(cookie); return; &#125; &#125; &#125; &#125;&#125; 具体业务登录时验证密码后： 12CookieUtil.writeLoginToken(response, session.getId());RedisShardedPoolUtil.setEx(session.getId(), JsonUtil.obj2Str(serverResponse.getData()), Const.RedisCacheExtime.REDIS_SESSION_EXTIME); 退出登录时： 123String loginToken = CookieUtil.readLoginToken(request);CookieUtil.delLoginToken(request, response);RedisShardedPoolUtil.del(loginToken); 获取用户信息时： 123456String loginToken = CookieUtil.readLoginToken(request);if (StringUtils.isEmpty(loginToken)) &#123; return ServerResponse.createByErrorMessage("用户未登录，无法获取当前用户信息");&#125;String userJsonStr = RedisShardedPoolUtil.get(loginToken);User user = JsonUtil.str2Obj(userJsonStr, User.class); SessionExpireFilter 过滤器另外，在用户登录后，每次操作后，都需要重置 Session 的有效期。可以使用过滤器来实现。 12345678910111213141516171819202122public class SessionExpireFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String loginToken = CookieUtil.readLoginToken(httpServletRequest); if (StringUtils.isNotEmpty(loginToken)) &#123; String userJsonStr = RedisShardedPoolUtil.get(loginToken); User user = JsonUtil.str2Obj(userJsonStr, User.class); if (user != null) &#123; RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME); &#125; &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 还需要在 web.xml 文件中进行配置： 12345678&lt;filter&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mmall.controller.common.SessionExpireFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 此方式的缺陷 redis + cookie 方式实现的单点登录对代码侵入性比较大； 客户端必须启用 cookie，而有些浏览器不支持 cookie； Cookie 设置 domain 时必须统一，服务器也必须统一域名方式； Spring Session 实现Spring Session 是 Spring 的项目之一，它提供了创建和管理 Server HTTPSession 的方案。并提供了集群 Session 功能，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。 Spring Session 可以无侵入式地解决 Session 共享问题，但是不能进行分片。 Spring Session 项目集成1、引入 Spring Session pom 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2、配置 DelegatingFilterProxy 12345678&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、配置 RedisHttpSessionConfiguration 123&lt;bean id="redisHttpSessionConfiguration" class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"&gt; &lt;property name="maxInactiveIntervalInSeconds" value="1800" /&gt;&lt;/bean&gt; 4、配置 JedisPoolConfig 123&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="20" /&gt;&lt;/bean&gt; 5、配置 JedisSessionFactory 123456&lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="hostName" value="192.168.23.130" /&gt; &lt;property name="port" value="6379" /&gt; &lt;property name="database" value="0" /&gt; &lt;property name="poolConfig" ref="jedisPoolConfig" /&gt;&lt;/bean&gt; 6、配置 DefaultCookieSerializer 1234567&lt;bean id="defaultCookieSerializer" class="org.springframework.session.web.http.DefaultCookieSerializer"&gt; &lt;property name="cookieName" value="SESSION_NAME" /&gt; &lt;property name="domainName" value=".happymmall.com" /&gt; &lt;property name="useHttpOnlyCookie" value="true" /&gt; &lt;property name="cookiePath" value="/" /&gt; &lt;property name="cookieMaxAge" value="31536000" /&gt;&lt;/bean&gt; 业务代码用户登录时： 1session.setAttribute(Const.CURRENT_USER, response.getData()); 退出登录时： 1session.removeAttribute(Const.CURRENT_USER); 获得用户信息时： 1User user = (User) session.getAttribute(Const.CURRENT_USER);]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之环境搭建]]></title>
    <url>%2F2019%2F01%2F29%2F015_mmallv1.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[配置软件源首先，需要进行源配置，可使用阿里云的源，可查看： https://opsx.alibaba.com/mirror 1234561、备份mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo3、生成缓存yum makecache 创建用户并修改密码首先，添加普通用户： 1useradd timberliu 再更改密码： 1passwd timberliu 之后退出重新登录验证。 安装 JDK删除系统自带 jdk 首先，执行以下命令查看自带的 jdk： 1rpm -qa | grep jdk 然后，使用 sudo yum remove xxx 命令进行删除。 下载与安装 首先，在根目录创建一个 developer，再创建一个 setup，用于存放安装包： 1mkdir -p /developer/setup 从 Oracle 官网得到 jdk1.8 的下载地址（可能会改变）： 1https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm 使用 wget 命令安装到 setup 下： 1wget --no-cookie --header "Cookie:oraclelicense=accept-securebackup-cookie" https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm 需要注意的是：在 Oracle 官网下载 rpm 时需要在 wget 后面加上 --no-cookie --header &quot;Cookie:oraclelicense=accept-securebackup-cookie&quot; 接受许可协议。 然后执行下面的命令进行安装： 1rpm -ivh jdk-8u201-linux-x64.rpm 默认会安装到 /usr/java 目录下。 配置环境变量 执行 sudo vim /etc/profile 命令配置环境变量： 123export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 然后，执行 source /etc/profile 使配置生效。使用 java -version，查看是否配置成功： 安装 Tomcat首先，使用 wget 命令从阿里云镜像网站下载 tomcat，到 setup 目录下： 1wget https://mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz 再使用 tar 命令解压缩到 developer 目录下： 1tar -zxvf apache-tomcat-8.5.35.tar.gz -C ../ 再执行 vim /etc/profile 配置环境变量： 12export CATALINA_HOME=/developer/apache-tomcat-8.5.35export PATH=$CATALINA_HOME/bin: 再修改 apache-tomcat-8.5.35 下的 conf/server.xml 文件： 1vim conf/server.xml 修改 8080 端口的 URI 的字符编码为 &quot;UTF-8&quot;： 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt; 最后，启动 tomcat： 1bin/startup.sh 安装 Maven和 tomcat 一样，得到 maven 的下载地址，进行下载： 1wget https://mirrors.aliyun.com/apache/maven/maven-3/3.0.5/binaries/apache-maven-3.0.5-bin.tar.gz 然后，使用 tar 解压缩到 developer 目录下： 1tar -zxvf apache-maven-3.0.5-bin.tar.gz -C ../ 然后，将 maven 配置到环境变量中： 12export MAVEN_HOME=/developer/apache-maven-3.0.5export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin 执行 source /etc/profile 使配置生效。执行 mvn -version 查看是否安装成功。 安装 vsftpd下载与安装 使用 yum 直接执行下面的命令安装： 1yum -y install vsftpd 在根目录下创建 product 目录，再创建 ftpfile 目录，用于存放上传的文件： 1mkdir -p /product/ftpfile 添加匿名用户 首先，添加一个匿名用户： 1useradd ftpuser -d /product/ftpfile -s /sbin/nologin 修改 ftpfile 文件夹的权限，用户组和用户都是 ftpuser： 1chown -R ftpuser.ftpuser ./ftpfile/ 修改 ftpuser 的密码： 1passwd ftpuser 然后，在 etc/vsftpd 下创建 chroot_list 文件，在其中添加用户名，这里就是 ftpuser： 12cd /etc/vsftpd/vim chroot_list 确认安全策略 查看安全策略，确保其中的 SELINUX 为 disabled： 1vim /etc/selinux/config 为避免验证时碰到 550 拒绝访问错误，执行下面的命令： 12[timberliu@iZ2ze222ncoofcesrn22waZ vsftpd]$ sudo setsebool -P ftp_home_dir 1setsebool: SELinux is disabled. 配置 vsftpd.conf 文件 使用 sudo vim vsftpd.conf 命令编辑： 12345678910111213141516local_root=/product/ftpfile#chroot_local_user=YESanon_root=/product/ftpfileuse_localtime=YES#匿名anonymous_enable=NOchroot_local_user=NOchroot_list_enable=YES# (default follows)chroot_list_file=/etc/vsftpd/chroot_list#pasv_enable=YESpasv_min_port=61001pasv_max_port=62000 启动 vsftpd 启动 vsftpd:1systemctl start vsftpd 查看 vsftpd 服务的状态： 1systemctl status vsftpd.service 将其设置开机自启动： 1systemctl enable vsftpd.service 安装 Nginx下载与安装 首先，安装 Nginx 需要依赖的环境： 1yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 使用 wget 命令从官网下载 Nginx： 1wget http://nginx.org/download/nginx-1.14.0.tar.gz 使用 tar 解压缩到 setup 目录： 1tar -zxvf nginx-1.14.0.tar.gz -C ../ 进入 Nginx 目录，分别执行以下命令： 123./configuremakemake install 更改配置 然后，进入到 Nginx 安装目录的 conf下面： 1cd /usr/local/nginx/conf 编辑 nginx.conf 文件： 1vim nginx.conf 在其中添加如下: 1include vhost/*.conf; 然后，在 conf 目录下创建 vhost 文件夹。在 vhost 文件夹中创建 admin.timberliu.com.conf、timberliu.com.conf、s.timberliu.com.conf 和 img.timberliu.com.conf 文件。 在启动 Nginx 后，访问 123.56.9.126，即可看到 Nginx 页面。 安装 MySQL首先，需要删除掉系统自装或以前安装的 mysql： rosten：centos下完全卸载mysql 下载与安装： 近博：Centos6.8通过yum安装mysql5.7Linux社区-xyang81：CentOS7 64位下MySQL5.7安装与配置（YUM） 注意：CentOS 6 和 7 中对于服务的管理也出现不同。CentOS 6 中使用 service 命令进行启动停止服务，使用 chkconfig 命令设置开机自启；而在 CentOS 7 中对所有服务都集中在到 systemctl 中，通过 /usr/lib/systemd/system 下以 .service 结尾的配置文件来管理。 在安装完 MySQL 后，使用 mysql -u root 进入 mysql，通过如下方式修改密码： 12update mysql.user set authentication_string=password('root') where user='root';flush privileges; 然后退出 mysql，重新登录。使用如下命令创建一个新用户 mmall： 1grant usage on *.* to 'username'@'localhost' identified by 'password' with grant option; 然后创建数据库： 12create database `mmall` default character set utf8 COLLATE utf8_genernal_ci;flush privileges; 对新建的用户赋予权限，并刷新权限： 1grant all privileges on mmall.* to 'username'@'localhost' identified by 'password'; 再导入 sql 文件创建表。这里需要先将 sql 文件上传到服务器上，然后使用 source 命令就可以创建表了： 1source /developer/mmall.sql 安装 Git首先，安装 git 环境需要的依赖： 1yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder 再下载 git 的压缩包到 setup 目录下： 1wget https://www.kernel.org/pub/software/scm/git/git-2.11.1.tar.gz 对刚才的包解压缩： 1tar -zxvf git-2.11.1.tar.gz -C ../ 然后进行编译，安装: 123cd /developer/git-2.11.1make prefix=/usr/local/git allmake prefix=/usr/local/git install 打开 vim /etc/profile 配置环境变量： 1export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin:/usr/local/git/bin 执行 source /etc/profile 使之生效。可以使用 git --version 查看版本。 然后，添加用户名和邮箱： 12git config --global user.name "yourusername"git config --global user.email "youremail" 另外，在 linux 和 windows 下换行符不同，这里配置： 1git config --global core.autocrlf false 表示使 git 不要转换换行符。还需要配置： 1git config --global core.quotepath off 表示防止中文乱码问题。然后，设置编码为 utf-8： 1git config --global gui.encoding utf-8 创建密钥，默认即可： 1ssh-keygen -t rsa -C "youremail" 然后，执行下面的命令: 1ssh-add ~/.ssh/id_rsa 如果出现 Could not open a connection to your authentication agent.，则执行 eval，再执行上面的命令： 12eval `ssh-agent`ssh-add ~/.ssh/id_rsa 然后，使用下面的命令获取公钥： 1cat ~/.ssh/id_rsa.pub 将其复制到 github 的 SSH keys 中即可。 防火墙配置在阿里云服务器中，需要配置规则，放行所需端口入方向规则。可以参考这篇文章：aquarius_wing：阿里云服务器上tomcat无法访问的问题 在 CentOS7 下默认使用 firewall 作为防火墙，使用 iptables 需要重新设置一下。在 /etc/sysconfig 目录下没有 iptables 文件，需要执行以下命令进行安装： 1yum -y install iptables-services 然后在 iptables 文件中配置端口如下： 1234567891011121314151617181920212223242526*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT#ssh port -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT#vsftpd-A INPUT -p TCP --dport 61001:62000 -j ACCEPT-A OUTPUT -p TCP --sport 61001:62000 -j ACCEPT-A INPUT -p TCP --dport 20 -j ACCEPT-A OUTPUT -p TCP --sport 20 -j ACCEPT-A INPUT -p TCP --dport 21 -j ACCEPT-A OUTPUT -p TCP --sport 21 -j ACCEPT#nginx-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 保存退出后，执行以下命令启动防火墙: 1systemctl restart iptables.service 然后，设置防火墙开机自启动： 1systemctl enable iptables.service]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之购物车、收货地址、订单模块]]></title>
    <url>%2F2019%2F01%2F28%2F013_mmallv1.0%E8%B4%AD%E7%89%A9%E8%BD%A6%E3%80%81%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E3%80%81%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[购物车模块1、购物车模块中购物车的设计，购物车对象如下： 1234567891011public class CartVo &#123; // 商品集合 private List&lt;CartProductVo&gt; cartProductVoList; // 购物车总价 private BigDecimal cartTotalPrice; // 是否全被选中 private Boolean allChecked; // 图片域名 private String imageHost; // getter/setter 方法&#125; 其中，购物车每一件商品 CartProductVo 对象设计如下： 1234567891011121314151617181920public class CartProductVo &#123; private Integer id; private Integer userId; private Integer productId; // 商品数量 private Integer quantity; private String productName; private String productSubtitle; private String productMainImage; private BigDecimal price; private Integer productStatus; private BigDecimal productTotalPrice; private Integer productStock; // 此商品是否勾选 private Integer productChecked; // 限制数量的一个返回结果 private String limitQuantity; // getter/setter 方法&#125; 2、封装一个高可用的购物车核心方法：获取购物车中所有商品信息 getCartVoLimit() 方法。设计思想如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private CartVo getCartVoLimit(Integer userId) &#123; CartVo cartVo = new CartVo(); // 根据用户 Id 查询购物车信息 List&lt;Cart&gt; cartList = cartMapper.selectCartByUserId(userId); List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList(); BigDecimal cartTotalPrice = new BigDecimal("0"); if (CollectionUtils.isNotEmpty(cartList)) &#123; for (Cart cart : cartList) &#123; CartProductVo cartProductVo = new CartProductVo(); cartProductVo.setId(cart.getId()); cartProductVo.setUserId(cart.getUserId()); cartProductVo.setProductId(cart.getProductId()); Product product = productMapper.selectByPrimaryKey(cart.getProductId()); if (product != null) &#123; cartProductVo.setProductMainImage(product.getMainImage()); cartProductVo.setProductName(product.getName()); cartProductVo.setProductSubtitle(product.getSubtitle()); cartProductVo.setProductStatus(product.getStatus()); cartProductVo.setPrice(product.getPrice()); cartProductVo.setProductStock(product.getStock()); int buyLimitCount = 0; if (product.getStock() &gt;= cart.getQuantity()) &#123; // 库存足够 buyLimitCount = cart.getQuantity(); cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_SECCESS); &#125; else &#123; // 库存不足 buyLimitCount = product.getStock(); cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_FAIL); // 购物车中更新为有效的库存 Cart cartForQuantity = new Cart(); cartForQuantity.setId(cart.getId()); cartForQuantity.setQuantity(buyLimitCount); cartMapper.updateByPrimaryKeySelective(cartForQuantity); &#125; cartProductVo.setQuantity(buyLimitCount); // 计算单件商品总价 cartProductVo.setProductTotalPrice(BigDecimalUtil.mul(product.getPrice().doubleValue(), cartProductVo.getQuantity().doubleValue())); cartProductVo.setProductChecked(cart.getChecked()); &#125; // 如果商品被选中，则相加到购物中总价中 if (cart.getChecked() == Const.Cart.CHECKED) &#123; cartTotalPrice = BigDecimalUtil.add(cartTotalPrice.doubleValue(), cartProductVo.getProductTotalPrice().doubleValue()); &#125; cartProductVoList.add(cartProductVo); &#125; &#125; cartVo.setCartProductVoList(cartProductVoList); cartVo.setAllChecked(getAllCheckedStatus(userId)); cartVo.setCartTotalPrice(cartTotalPrice); cartVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); return cartVo;&#125; 3、对于浮点型在商业运算中丢失精度问题，可以使用 BigDecimal 对象，将参数转为 String 类型进行计算： 123456789101112131415161718192021222324252627public class BigDecimalUtil &#123; public static BigDecimal add(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2); &#125; public static BigDecimal sub(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2); &#125; public static BigDecimal mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2); &#125; public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP); &#125;&#125; 收货地址模块1、Mybatis 自动生成主键、配置和使用 在添加收货地址时，可以自动生成主键，这里指定为 id。1&lt;insert id="insert" parameterType="com.mmall.pojo.Shipping" useGeneratedKeys="true" keyProperty="id"&gt; 然后，就可以使用 shipping.getId() 得到新添加收货地址后的 id。 2、在更新收货地址信息时，为防止横向越权，在 ShippingMapper.xml 文件中，根据用户 Id 和 ShippingId 进行更新： 123456789101112131415&lt;update id="updateByShipping" parameterType="com.mmall.pojo.Shipping"&gt; update mmall_shipping set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; and user_id = #&#123;userId,jdbcType=INTEGER&#125;&lt;/update&gt; 订单模块1、创建订单时需要将订单详情插入到数据库中，可以使用 MyBatis 的批量插入。使用 foreach 标签，集合中每一个对象使用括号括起来，用逗号进行分隔。 123456789101112131415&lt;insert id="batchInsert" parameterType="list"&gt; insert into mmall_order_item (id, user_id, order_no, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values &lt;foreach collection="list" index="index" item="item" separator=","&gt; ( #&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.userId,jdbcType=INTEGER&#125;, #&#123;item.orderNo,jdbcType=BIGINT&#125;, #&#123;item.productId,jdbcType=INTEGER&#125;, #&#123;item.productName,jdbcType=VARCHAR&#125;, #&#123;item.productImage,jdbcType=VARCHAR&#125;, #&#123;item.currentUnitPrice,jdbcType=DECIMAL&#125;, #&#123;item.quantity,jdbcType=INTEGER&#125;, #&#123;item.totalPrice,jdbcType=DECIMAL&#125;, now(), now() ) &lt;/foreach&gt;&lt;/insert&gt; 另外，需要注意的是：Mybatis 批量插入时默认的最大数据量是 1 M，如果超过则会报 PacketTooBigException 异常。可以通过 mysql 安装目录下的 my.ini 文件中，mysqld 段的 max_allowed_packet = 1 M 进行调整； 2、对于产品状态、订单状态、支付平台、支付方式，都使用枚举类表示。如何设计一个实用安全扩展性强大的枚举类？例如，订单状态如下： 1234567891011121314151617181920212223242526public enum OrderStatusEnum &#123; CANCELED(0, "已取消"), NO_PAY(10, "未支付"), PAID(20, "已支付"), SHIPPED(40, "已发货"), ORDER_SUCCESS(50, "订单完成"), ORDER_CLOSED(60, "订单关闭"); private String value; private int code; OrderStatusEnum(int code, String value) &#123; this.code = code; this.value = value; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static OrderStatusEnum codeOf(int code) &#123; for (OrderStatusEnum orderStatusEnum : values()) &#123; if(orderStatusEnum.getCode() == code) &#123; return orderStatusEnum; &#125; &#125; throw new RuntimeException("没有找到对应的枚举"); &#125;&#125; 3、订单号的生成规则，必须唯一严谨。由于这里用户量不多，并发量小，可使用如下方式： 1234private long generateOrderNo() &#123; long currentTime = System.currentTimeMillis(); return currentTime + new Random().nextInt(100);&#125; 这里使用当前时间戳并加上一个 100 以内的随机数生成。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之支付模块]]></title>
    <url>%2F2019%2F01%2F28%2F014_mmallv1.0%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[扫码支付支付流程 在商家发出预下单请求后，支付宝后台会返回二维码信息给用户，然后用户通过支付宝钱包扫码，之后支付宝后台会把支付结果信息返回给商家后台。 扫码支付调用流程 主要的思路如下： 商家系统调用支付宝接口发起预下单请求，获得二维码图片地址；然后通过二维码串生成二维码图片，上传至图片服务器，并将 url 返回给前台； 发起轮询获得支付结果：通过支付时传入的商品订单号查询支付结果； 还可以通过异步通知获得支付结果，注意：一定要对异步通知进行验签，确保通知是支付宝发出的。另外，还要更新数据库中的信息 实现细节预下单请求 首先，创建扫码支付请求 builder，并设置标题、总金额、交易号、回调地址、商品列表集合等请求参数。在创建商品时，可以使用 newInstance方法传入商品 id、名称、单价、数量等信息创建，然后添加到商品列表集合中。 1234567891011121314151617List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;&gt;();List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo, userId);for (OrderItem orderItem : orderItemList) &#123; // 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(), BigDecimalUtil.add(orderItem.getCurrentUnitPrice().doubleValue(), 100.0).longValue(), orderItem.getQuantity()); // 创建好一个商品后添加至商品明细列表 goodsDetailList.add(goods);&#125;AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount) .setOutTradeNo(outTradeNo).setUndiscountableAmount(undiscountableAmount) .setSellerId(sellerId).setBody(body).setOperatorId(operatorId) .setStoreId(storeId).setExtendParams(extendParams).setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) //支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); 然后，使用 Config.init() 加载 zbinfo 配置文件，其中配置了支付宝的支付宝网关名、pid、appid、RSA私钥、公钥等。注意：加载文件一定要在创建 AlipayTradeService 对象之前调用： 1Configs.init("zfbinfo.properties"); 再然后，创建 AlipayTradeService 单例或静态对象： 1AlipayTradeService tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); 最后，使用 tradePrecreate() 方法发起预下单请求： 1AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); 同步订单的二维码串，并生成二维码 首先，判断上一步中 result 的订单状态，如果为 SUCCESS，则表示预下单成功； 12345switch (result.getTradeStatus()) &#123; case SUCCESS: log.info("支付宝预下单成功: )"); ···&#125; 然后，可以使用 result.getResponse() 得到响应对象。再使用 response.getOutTradeNo() 得到订单号，并创建上传到服务器的存放路径。 123AlipayTradePrecreateResponse response = result.getResponse();···String qrPath = String.format(path + "/qr-%s.png", response.getOutTradeNo()); 然后，使用 ZxingUtils.getQRCodeImge() 方法将 getQrCode() 得到的二维码串转换为宽度为 256 的图片存放在 qrPath 下。 1ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); 最后，使用 FtpUtil.uploadFile 方法将图片上传到图片服务器。 123456File targetFile = new File(qrPath);try &#123; FtpUtil.uploadFile(Lists.newArrayList(targetFile));&#125; catch (IOException e) &#123; log.error("上传二维码失败");&#125; 轮询查看交易的状态 这里，主要是到数据库中查询订单信息，判断订单状态即可： 12345Order order = orderMapper.selectByUserIdAndOrderNo(userId, orderNo);···if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode()) &#123; return ServerResponse.createBySuccess();&#125; 异步通知结果 首先，在收到异步通知时，参数以 Map&lt;String, String[]&gt; 的形式封装在 request 中，需要将其转换为 Map&lt;String, String&gt; 形式： 123456789101112Map&lt;String, String&gt; params = Maps.newHashMap();Map&lt;String, String[]&gt; requestParams = request.getParameterMap();for(Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) &#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = ""; for(int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ","; &#125; params.put(name, valueStr);&#125; 然后，对于返回的结果，除了 sign、sign_type 两个参数，其他都需要验签。在源码实现中，已经移除了 sign 参数，只需要移除 sign_type 即可。另外对剩余参数进行 url_encode，并进行字段排序组成待验签字符串，还有将 sign 使用 base64 解码为字节码串也都已实现： 1params.remove("sign_type"); 然后，使用 RSA 验签方法，通过签名字符串、支付宝公钥、字符编码、signType 验证签名。 1boolean alipayRSACheckedV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), "utf-8", Configs.getSignType()); 然后，在服务层中，需要更改订单的支付时间与支付状态： 12345if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)) &#123; order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order);&#125; 最后，再将支付信息添加到支付信息表中： 12345678PayInfo payInfo = new PayInfo();payInfo.setUserId(order.getUserId());payInfo.setOrderNo(orderNo);payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode());payInfo.setPlatformNumber(tradeNo);payInfo.setPlatformStatus(tradeStatus);payInfoMapper.insert(payInfo); NatAPP 内网穿透在支付时，支付宝异步回调需要让回调地址可以被外网访问，可以使用 natapp 进行内网穿透。这里参考文档 NATAPP1分钟快速新手图文教程 即可。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之用户、分类、商品模块]]></title>
    <url>%2F2019%2F01%2F27%2F012_mmallv1.0%E7%94%A8%E6%88%B7%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[项目搭建使用 IDEA 创建项目，并上传到 Github 上。 参考文章：stevennest：IDEA创建项目及上传到github 用户模块在用户模块中，主要包括以下几个功能： 需要注意的问题有以下几点： 1、在忘记密码-检查问题时，使用 UUID 生成唯一标识，存储在缓存中，并将这个标识传递给前端； 12String forgetToken = UUID.randomUUID().toString();TokenCache.setKey(TokenCache.TOKEN_PREFIX + username, forgetToken); 在忘记密码-重置密码时，前端需要携带 token，服务器端需要判断 token 是否过期，并与缓存中的 token 进行对比，以防止横向越权访问。 12345String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX + username);if(StringUtils.equals(forgetToken, token)) &#123; ···&#125; 2、在后台管理模块中，为防止纵向越权，在数据表设计时添加了 role 属性，在登录后台，或修改其数据时，都需要检验该用户的 role。 3、对于密码的存储，使用 MD5 进行加密，并且增加了 Salt 值。 4、在忘记密码-检查问题时，生成的 token 使用 Guava 进行缓存，以 key/value 形式进行存储。缓存使用主要实现如下： 123456789101112private static LoadingCache&lt;String, String&gt; localCache = CacheBuilder.newBuilder() .initialCapacity(1000) // 设置缓存最大值为 10000，如果超过这个值，会使用 LRU 算法进行清除 .maximumSize(10000) // 过期时间，及单位 .expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; @Override public String load(String s) &#123; return "null"; &#125; &#125;); 然后，可通过 set/get 方法设置、并获取值。12345678910public static void setKey(String key, String value) &#123; localCache.put(key, value);&#125;public static String getKey(String key) &#123; ··· value = localCache.get(key); ··· return value;&#125; 5、使用 ServerResponse 高复用响应式对象。其中三个属性如下： 123private int status;private String msg;private T data; 使用 enum 枚举类来表示不同的响应码。主要有四种响应码： 12345678public enum ResponseCode &#123; SUCCESS(0, "SUCCESS"), ERROR(1, "ERROR"), NEED_LOGIN(10, "NEED_LOGIN"), ILLEGAL_ARGUMENT(2, "ILLEGAL_ARGUMENT"); ···&#125; 另外，其中使用了 @JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL) 标记 ServerResponse，表示在序列化对象时，忽略为空的属性，使用了 @JsonIgnore 标记 isSuccess 方法，表示在序列化时，忽略此方法。 6、用户登录信息使用 Session 进行存储。 1session.setAttribute(Const.CURRENT_USER, response.getData()); 7、使用 StringUtils、CollectionUtils 等工具类简化操作。 8、使用 slf4j 的 LoggerFactory 生成 logger 对象，打印日志。 123private static Logger logger = LoggerFactory.getLogger(TokenCache.class);logger.info("···"); 分类管理模块1、在分类管理中，需要用到无限层级的树状数据结构显示分类。可以在设计数据表时添加 parentId 属性，表示其父结点的 Id。另外，如果 parentId 为 0，表示当前结点为根结点分类。 2、在查询子结点分类时，需要用到递归算法。首先，根据前台传来的 id 判断该结点是否存在，如果存在，则添加到 categorySet 中。然后调用 findChildCategory 方法查询子节点分类： 12345Category category = categoryMapper.selectByPrimaryKey(categoryId);if(category != null) &#123; categorySet.add(category);&#125;findChildCategory(categorySet, categoryId); 其中，会根据 parentId 查询与子分类平级的结点得到一个 List 集合。然后遍历此集合，将子分类结点添加到 categroySet，再递归查询子节点。 1234567private void findChildCategory(Set&lt;Category&gt; categorySet, Integer parentId) &#123; List&lt;Category&gt; categoryList = categoryMapper.getChildrenCategoryByParentId(parentId); for (Category category: categoryList) &#123; categorySet.add(category); findChildCategory(categorySet, category.getId()); &#125;&#125; 然后，创建 List 集合，遍历 categorySet，将 category 的 id 添加到 categoryIdList 中，返回给前端。 123456List&lt;Integer&gt; categoryIdList = Lists.newArrayList();if(categoryId != null) &#123; for (Category categoryItem: categorySet) &#123; categoryIdList.add(categoryItem.getId()); &#125;&#125; 3、在存储 category 时，为了防止对象重复，这里使用 Set 进行排重。 1Set&lt;Category&gt; categorySet = Sets.newHashSet(); 另外，Set 中存放的对象 Category 要判断是否相等，这里针对 id，重写了 hashCode 和 equals 方法。 123456789101112@Overridepublic boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (!(o instanceof Category)) &#123; return false; &#125; Category category = (Category) o; return id != null ? id.equals(category.id) : category.id == null;&#125;@Overridepublic int hashCode() &#123; return id != null ? id.hashCode() : 0;&#125; 商品管理模块1、SpringMVC 文件上传使用 FTPClient。在上传文件之前，首先需要连接服务并登陆。另外，还需要设置远程目录、缓存大小、编码格式等。最后，使用 storeFile 方法传入文件名和文件输入流，上传文件。需要注意的是，上传后要关闭输入流和 FtpClient。主要实现如下： 1234567891011121314151617181920212223242526272829303132333435363738private boolean uploadFile(String remotePath, List&lt;File&gt; fileList) throws IOException &#123; boolean uploaded = false; FileInputStream fis = null; boolean isSuccess = connectServer(ip, port, user, password); // 连接服务器 if(isSuccess) &#123; try &#123; ftpClient.changeWorkingDirectory(remotePath); // 远程目录 ftpClient.setBufferSize(1024); // 缓存 ftpClient.setControlEncoding("UTF-8"); // 编码格式 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 文件类型 ftpClient.enterLocalPassiveMode(); for (File fileItem : fileList) &#123; fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(), fis); &#125; uploaded = true; &#125; catch (IOException e) &#123; logger.error("上传文件异常", e); uploaded = false; e.printStackTrace(); &#125; finally &#123; if(fis != null) &#123; fis.close(); &#125; ftpClient.disconnect(); &#125; &#125; return uploaded;&#125;private boolean connectServer(String ip, int port, String user, String password) &#123; boolean isSuccess = false; ftpClient = new FTPClient(); try &#123; ftpClient.connect(ip, port); // 连接服务器 isSuccess = ftpClient.login(user, password); // 登录 &#125; catch (IOException e) &#123; logger.error("连接 FTP 服务器失败", e); &#125; return isSuccess;&#125; 2、使用流来读取 Properties 配置文件，这里使用 java.util.Properties 类的 load 方法来加载 mmall.properties 文件，再使用 getProperty 方法得到配置。主要实现如下： 123456789101112131415161718// 使用静态块来初始化并加载配置文件static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125;&#125;// 然后，可以使用 getProperty 获取public static String getProperty(String key, String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim();&#125; 3、使用 joda-time 处理时间。主要有两种形式：分别为将 String 转为 Date 和将 Date 转为 String。 1234567891011121314// 将 String 转为 Datepublic static Date strToDate(String str, String formatStr) &#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr); DateTime dateTime = dateTimeFormatter.parseDateTime(str); return dateTime.toDate();&#125;// 将 Date 转为 Stringpublic static String dateToStr(Date date, String formatStr) &#123; if(date == null) &#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(formatStr);&#125; 4、对于 dao 层生成的 pojo，在 service 和 controller 层使用时，可能由于其他业务逻辑，已不能满足需求，这时就可以使用 BO（business Object）、VO（view Object） 对象。它是在原有 pojo 对象的基础上另外添加一些属性以满足业务的需求。 项目中，由于业务逻辑还不是特别复杂，所以使用的是简化版本，即 VO(value Object) 对象。 5、使用 MyBatis-PageHelper 分页及动态排序。一般，都需要先设置页数和每页数量。然后创建 PageInfo 对象，设置 List 集合对象。最后将 PageInfo 对象返回即可。 1234PageHelper.startPage(pageNum, pageSize);PageInfo pageInfo = new PageInfo(productList);pageInfo.setList(productListVoList);]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(6)-虚拟内存和文件分配]]></title>
    <url>%2F2019%2F01%2F11%2F011_%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[虚拟内存在逻辑上实现了对内存容量的扩充，既满足了用户的需要，又改善了系统性能。这篇文章总结了虚拟内存的基本概念、实现方式以及几种页面置换算法。最后是几种文件分配方式。 基本概念局部性原理：程序执行时，在一较短时间内，程序的执行仅仅局限于某一部分，其访问的存储空间也局限于某个区域。主要表现在两个方面： 时间局限性：如果某条指令被执行，不久以后该指令可能再次执行；如果某些数据被访问，不久以后该数据可能再次被访问； 空间局限性：如果某段存储单元被访问，其附近的存储单元可能也会被访问。 基于局部性原理，在加载程序时，只需将当前执行所需的部分页面或段装入内存。程序执行时，如果要访问的页面或段不在内存中，则发生缺页中断，于是 OS 利用请求调页功能将相应的页面或段调入内存，继续执行。如果内存已满，则利用置换功能，将内存中暂时不用的页面或段调出到外存，再将所需的页面或段调入内存，使程序继续执行。 虚拟内存是指具有请求调入功能和置换功能，从逻辑上对内存容量进行扩充的一种内存系统。实现方式有三种：请求分页存储管理方式、请求段式存储管理方式和请求段页式存储管理方式。 请求分页存储管理请求分页存储管理是在分页存储管理的基础上，增加请求调页和页面置换功能。它允许用户程序只装入部分页面就启动程序运行。在运行中如果发现所需页面不在内存中，则发出缺页中断，OS 就会将外存中相应的页面调入内存使其继续运行。每次调入和换出的基本单位是长度固定的页面。 请求分页存储管理中的地址转换与分页式相比，在页表项中添加了一些标志位： 状态位：表示该页是否已调入内存。 修改位：表示该页在调入内存后是否被修改过。在置换该页时，判断是否要把它写回外存。 访问位：表示该页在一段时间内被访问的次数。供置换算法在选择换出页面时参考。 外存地址：表示该页在外存上的地址。 请求分页存储管理系统中，在进行地址转换时，首先在快表中查找要访问的页。如果找到，便修改页表项中的访问位，供置换算法选择换出页面时参考。如果是写指令，还需要将修改位置为 1，表示该页在调入内存后被修改过。然后利用页表项中的物理块号和页内地址，得到物理地址。 如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位来判断该页是否调入内存。如果该页已调入，则应将该页的页表项写入快表；如果该页没有调入内存，则应该产生缺页中断，操作系统从外存中找到缺失的页面。 如果内存已满，则利用置换算法选择一页换出，如果该页被修改过，则需要将该页写回到外存中。最后将缺页从外存换入到内存中，继续运行程序。 页面置换算法最优算法（Optimal） 置换在未来最长时间内不再被访问的页面。这只是一种理想情况，只能用来评价其他置换算法的性能。 先进先出算法（FIFO） 选择进入内存时间最长的页面进行置换。在实现时维护一个所有已调入内存的页面的链表，按照进入内存的先后次序排序，链首最早，链尾最进。在出现缺页时，选择链首的页面进行置换，将新页面添加到链尾。 这种算法实现简单。但调出的页面可能会经常访问，性能较差，一般和其他算法结合使用。 最近最久未使用算法（LRU） 选择最长时间没有使用的页面进行置换。它依据的是如果某个页面长时间没有被访问，则在将来一段时间可能还不会访问。 在实现时维护一个按最近一次访问时间排序的链表，链表首是刚使用过的页面，链表尾是最久未使用的页面。在访问页面时，找到相应的页面，将其移动到链表首；在出现缺页时，删除链表尾节点，将新页面添加到链表首。 这种算法是最优算法的一种近似，但实现起来仍然比较复杂。 时钟算法（Clock） 也称为最近未使用算法（NRU）。在实现时，在页表项中增加一个访问位，表示过去一段时间内是否被访问过，初始时都置为 0，另外将页面组织成环形链表，添加一条指针指向最先被调入内存的页面。 当访问某页面时，将其访问项置为 1。在出现缺页异常时，从指针处开始查找，如果页面没有被访问过，即访问项为 0，则进行置换；如果被访问过，则将访问项置为 0，暂不换出，再将指针指向下一个页面继续查找，直到找到可以置换的页面。 最少使用算法（LFU） 置换最近一段时间访问次数最少的页面。在实现时，对每个页面设置一个访问计数，在访问页面时，对访问计数加 1；在出现缺页异常时，置换访问计数最少的页面。 文件分配文件分配实际上是如何表示分配给一个文件的数据块的位置和顺序。主要有以下几种分配方式：连续分配、链式分配和索引分配。 连续分配 使用连续的若干个数据块来存储文件。它在文件控制块中记录起始第一个数据块的位置和长度。 采用连续分配方式，读取文件的顺序访问和随机访问效率较高，但是剩余的碎片难以利用，另外文件长度增长也比较复杂。 链式分配 将文件以数据块链表的形式存储。文件控制块中包含了第一个数据块和最后一个数据块的指针。 链式分配方式在创建、增大、缩小文件时比较容易，而且没有碎片，但是不能实现真正的随机访问，另外一个数据块被破坏，后面的数据块就都丢了。 索引分配 为每个文件创建一个索引数据块，索引数据块中存储了指向文件数据块的指针列表，文件控制块中包含了指向索引数据块的指针。 这种实现在创建文件、增大、缩小文件时比较容易，也没有碎片，也支持随机访问。但是在文件很小时，存储索引开销相对较大，在文件很大时，需要增加额外的索引快。 UFS（Unix File System） UFS 的多级索引分配：在文件控制块中，如果数据块小于 10，采用直接索引；如果大于 10 块，第 11 块开始采用一级间接索引，它先指向一个索引块，索引块中再指向实际的数据块。如果数据块大到一定程度，会采用二级间接索引，依次类推。 多级索引分配方式大大提高了文件大小的限制阈值，可以动态分配数据块，文件扩展很容易，对于小文件开销较小，对于大文件使用间接索引也比较合理。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(5)-内存管理]]></title>
    <url>%2F2019%2F01%2F11%2F010_%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。 连续内存分配在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。 动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。 内存管理方式为实现动态分区分配，系统必须对空闲的内存进行管理，主要有两种方法：位图法和空闲区链表。 位图法 使用位图方法时，内存可能被划分为小到几个字或大到几千个字节的分配单元。每个分配单元对应位图中的一位，0 表示空闲，1 表示占用。 位图的缺点是如果想要调入一个占 k 个分配单元的进程，必须搜索位图，找出有 k 个连续 0 的串。查找位图中指定长度的连续 0 串的操作很耗时。 空闲区链表法 链表法是维护一个已分配内存段和空闲内存段的链表。链表的结点包括一个进程，或两个进程间的一块空闲区。 内存分配算法在将程序加载入内存时，需要按照一定的算法，从位图或空闲链表中选择分区分配给进程。 首次适配(first fit) 首次适配算法要求空闲区链表按照地址递增的顺序排序。在分配内存时，沿着链表进行搜索，直到找到一个足够大的分区，将其分为两部分，一部分供进程使用，一部分形成新的空闲区。 它的实现比较简单，但是低地址部分不断被划分，会留下许多小空闲分区。 下次适配(next fit) 下次适配算法和首次适配算法类似，只是不再像首次适配算法那样每次都从头开始，而是从上次找到的空闲分区的下一个空闲分区开始搜索。 最佳适配(best fit) 最佳适配算法要求将空闲分区按照其容量大小进行排序。在分配内存时，查找一个能满足要求、又是最小的的空闲分区，分配给进程。 这种算法的缺点是分区在每次分配后的剩余部分总是最小的，会留下许多难以利用的碎片。 最差适配(worst fit) 最差适配算法在分配内存时，总是选择一个最大的空闲分区，划分为两部分，一部分给进程使用，另一部分形成新的空闲分区。 最差适配算法使得剩下的空闲分区不至于产生太小的碎片；但是这样容易破坏大的空闲分区，后续难以找到大的分区。 快速适配(quick fit) 快速适配算法是将空闲分区按照其容量进行分类，为每一类相同容量的空闲分区单独维护一个链表。同时，设立一张管理索引表，表中每一项对应一种空闲分区类型。 快速适配算法的缺点是在进程被终止或换出释放分区时，有效地合并分区非常耗时。 非连续内存分配在非连续分配时，根据所分配地址空间的基本单位不同，可将其分为分页存储管理、分段存储管理、段页式存储管理三种方式。 分页存储管理在分页存储管理方式中，把用户程序的地址空间划分为若干个固定大小的页。典型的页面大小为 1KB。相应地，也将内存空闲分为若干个物理块，页和块大小相同，这样可以将用户程序的任一页放入任一物理快中实现非连续分配。 分页地址中的地址结构为： 地址长度为 32 位，其中 0~11 位为页内地址，即每页的大小为 4KB；12~31 位为页号，最多允许有 1M 页。 系统为每一个进程建立了一张页表，它负责逻辑页号到物理块号之间的地址转换。每一个页面对应一个页表项，记录了相应页在内存中对应的物理块号。 在 CPU 中设置一个页表基址寄存器，存储着页表的起始地址和页表的长度。 在进行地址转换时，首先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问地址已超过进程的地址空间，产生越界中断。如果没有发生越界中断，则将页表始址与页号和页表项长度的乘积相加，得到该页表项在页表中的位置，于是可从中得到该页的物理块号，最后根据物理块号和页内地址便可得到物理地址。 分页式存储管理方式主要有两个缺点： 性能问题：访问一个内存单元需要两次内存访问，第一次访问获取页表项，第二次访问才访问数据。（快表） 如果每页太小，页表可能会非常大，较难找到连续的大内存空间。（多级页表） 页表改进快表 为提高地址转换速度，可在地址转换机构中增加一个可并行查询的缓冲寄存器，称为快表。 在进行地址转换时，首先将页号与快表中的所有页号进行比较，如果其中有与此相匹配的页号，便可直接从快表中读出该页所对应的物理块号。如果在快表中没有对应的页表项，则还需要去访问内存中的页表，在找到物理块号后，得到要访问的物理地址。另外，还要将此页表项存入到快表中。如果快表已满，则需要找到一个合适的页表项，将其换出。 两级页表或多级页表 两级页表或多级页表的方法，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。同样，建立一张外层页表，每个页表项中记录了页表层面的物理块号。 在进行地址变换时，需要增加一个外层页表寄存器，用于存放外层页表的起始地址。利用外层页表始址和逻辑地址中的外层页号找到指定页表分页的始址，再利用外层页内地址找到指定的页表项，从中得到该页在内存的物理块号，最终得到物理地址。访问一次内存单元一共需要 3 次内存访问。 分段式存储管理在分段式存储管理方式中，进程的地址空间被划分为若干个段，例如主代码段、子模块代码段、堆栈段、初始化数据段、符号表等。每个段都从 0 开始编址，采用连续的地址空间，各段的长度也并不相等。 分段地址中的地址结构如下： 该地址结构中，允许一个进程最多有 64K 个段，每个段的最大长度为 64KB。 系统为每个进程建立了一张段表，用于实现从逻辑段到物理内存区的映射。每个段在表中占有一个表项，其中记录了该段在内存中的基址和段的长度。 系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址转换时，首先将段号与段表长度进行比较。如果段号大于段表长度，则访问越界。 如果没有越界，则根据段表的始址和该段的段号，得到该段对应段表项的位置，从中读出该段在内存的起始地址。再检查段内地址是否超过该段的段长。如果超过，同样产生越界中断；否则将该段的基址和段内地址相加，最后得到要访问的内存地址。 分页式和分段式比较 采用分页存储是为了提高内存的利用率；采用分段是为了更好地满足用户的需要。 分页存储中，页面的大小由系统决定，而且大小固定；分段存储中，段的长度由用户程序决定。 分页存储中，页表中主要存储物理块号；分段存储中，段表中主要存储段基址和段长。 段页式存储管理段页式存储是分段和分页的结合，先将用户程序分为若干个段，再把每个段分成若干个页。段页式的地址结构为段号、段内页号和页内地址三部分。 为实现地址转换，系统中需要同时设置段表和页表。不过这里的段表中存储的是页表始址和段长。 在进行地址转换时，首先将段号与段长进行比较，如果段号小于段长表示未越界，于是利用段表始址和段号求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号来获得对应页的页表项位置，从中读出该页所在的物理块号，再利用块号和页内地址来得到物理地址。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(4)--死锁]]></title>
    <url>%2F2019%2F01%2F10%2F009_%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁概念在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。 死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。 出现死锁的四个必要条件： 互斥。在任何时刻一个资源只能被一个进程使用。 拥有和请求。已经得到某个资源的进程可以再请求新的资源； 不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放； 循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。 对于死锁，有四种处理的策略：1. 忽略；2. 预防死锁；3. 避免死锁；4. 检测死锁并恢复。 死锁预防预防是指通过破坏死锁产生的四个必要条件的一个或多个，以避免发生死锁。 破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源； 破坏拥有和请求：有两种方案： 已拥有资源的进程不能再去请求其他资源。一种实现方法是要求进程在开始执行前请求需要的所有资源。 要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源。 破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占； 破坏循环等待：有两种方案： 一种方法是保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源； 另一种方法是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源。 死锁避免死锁避免是利用一些事先已知的信息，在分配资源时判断是否会出现死锁，如果不会出现死锁才会分配资源。 而判断是否会出现死锁就是看是否能找到一个安全序列，系统能按照这个安全序列，也就是进程的推进顺序为每个进程分配其所需资源，直到满足每个进程所需的资源，使每个进程都能顺序执行。 银行家算法为实现银行家算法，进程在进入系统时，要求进程声明需要资源的最大数目，但不能超过系统能提供的最大资源数目。当一个进程请求资源时，需要确定是否有足够资源分配给该进程，如果有，再检查在分配资源后，系统是否安全。 假定线程数量为 n，资源类型数量为 m，银行家算法的数据结构如下： Max (总需求量)：n*m 矩阵，表示进程 Ti 最多请求 Max[i, j] 个类型为 Rj 的资源； Available (剩余空闲量)：长度为 m 的向量，表示当前有 Available[i] 个类型 Rj 的可用资源； Allocation (已分配量)：n*m 矩阵，表示进程 Ti 当前分配了 Allocation[i, j] 个类型为 Rj 的资源； Need (未来需要量)：n*m 矩阵，表示进程 Ti 未来需要 Need[i, j] 个类型为 Rj 资源； 可以得出它们满足等式：Need[i, j] = Max[i, j] - Allocation[i, j]。 银行家算法的核心部分，安全状态的判断如下： 创建长度为 m 的向量 Work，表示当前资源剩余量，并进行初始化：Work = Avaiable; 在未运行的进程中寻找未来需要量 Need[i] 比当前可用量 Work 小的进程 Ti，如果找到则继续执行 3，否则转 4； 执行 Work = Work + Allocation[j]; ，将资源分配给进程 Ti 运行完毕后，回收其资源。转 2： 如果资源可以分配给所有进程，则系统处于安全状态； 如此完整的银行家算法如下：首先进行初始化，Request_i 表示进程 Ti 的资源请求向量，Request_i[j] 表示进程 Ti 请求资源 Rj 的实例。然后循环判断： 如果 Request_i &lt;= Need[i]，转到 2。否则拒绝资源请求，因为进程已经超过最大要求； 如果 Request_i &lt;= Available，转到 3。否则进程 Ti 必须等待，因为现在可用资源不足； 通过安全状态判断来确定是否分配资源给 Ti，如果安全则分配，否则拒绝 Ti 的资源请求。 死锁检测和恢复可以允许系统进入死锁状态，但会维护一个系统的资源分配图，定期调用死锁检测算法来检测途中是否存在死锁，检测到死锁发生后，采取死锁恢复算法进行恢复。 死锁检测方法如下： 在资源分配图中，找到不会阻塞又不独立的进程结点，使该进程获得其所需资源并运行，运行完毕后，再释放其所占有的全部资源。也就是消去该进程结点的请求边和分配边。 使用上面的算法进行一系列简化，若能消去所有边，则表示不会出现死锁，否则会出现死锁。 在检测死锁时，可以采用两种方法： 抢占资源。从一个或多个进程中抢占资源分配给死锁进程。 终止进程。可以终止所有的死锁进程；也可以按照某种顺序，逐个终止进程，释放其占有资源，直到死锁解除。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(3)--进程的同步和通信方式]]></title>
    <url>%2F2019%2F01%2F08%2F008_%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间同步基本概念为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。 对于同步机制，需要遵循以下四个规则： 空闲则入：没有进程在临界区时，任何进程可以进入； 忙则等待：有进程在临界区时，其他进程均不能进入临界区； 有限等待：等待进入临界区的进程不能无限期等待； 让权等待（可选）：不能进入临界区的进程，应该释放 CPU，如转换到阻塞态； 信号量信号量机制（semaphore）是一种协调共享资源访问的方法。信号量由一个变量 semaphore 和两个原子操作组成，信号量只能通过 P 和 V 操作来完成，而且 P和 V 操作都是原子操作。 将信号量表示如下： 1234typedef struct &#123; int value; struct process_control_block *list;&#125; semaphore; 相应的 P(wait) 操作和 V(signal) 操作如下实现： 123456789101112wait(semaphore *S) &#123; S-&gt;value--; if(S-&gt;value &lt; 0) &#123; block(S-&gt;list); &#125;&#125;signal(semaphore *S) &#123; S-&gt;value++; if(S-&gt;value &lt;= 0) &#123; wakeup(S-&gt;list); &#125;&#125; 信号量可分为两类：互斥信号量，信号量大小为为 0 或 1，用来实现进程的互斥访问；资源信号量，信号量大小为资源数，用来表示系统资源数目。 资源信号量 代表资源信号量时，S-&gt;value 初值表示系统资源的数目，P 操作意味着进程请求一个资源，于是系统中可分配的资源数减一，如果 S-&gt;value &lt; 0，表示该类资源已分配完毕，因此阻塞该进程，并插入信号量链表 S-&gt;list 中。小于 0 时，S-&gt;value 的绝对值表示该信号量链表中阻塞的进程数。 V 操作表示进程释放一个资源，于是系统中可分配的资源数加一，如果增加一后仍然 S-&gt;value &lt;= 0，表示该信号量链表中仍然有阻塞的进程，因此调用 wakeup，将 S-&gt;list 中的第一个进程唤醒。 互斥信号量 代表互斥信号量时，S-&gt;value 初值为 1，表示只允许一个进程访问该资源。 利用信号量实现两个进程互斥描述如下： 123456semaphore mutex = 1;P() &#123; wait(mutex); 临界区； signal(mutex);&#125; 当 mutex = 1 时，表示两个进程都没有进入临界区，当 mutex = 0 时，表示一个进程进入临界区运行；当 mutex = -1 时，表示一个进程进入临界区运行，另一个进程被阻塞在信号量队列中。 管程管程采用面向对象思想，将表示共享资源的数据结构及相关的操作，包括同步机制，都集中并封装到一起。所有进程都只能通过管程间接访问临界资源，而管程只允许一个进程进入并执行操作，从而实现进程互斥。 12345678910111213Monitor monitor_name &#123; share variable declarations; condition declarations; public: void P1(···) &#123; ··· &#125; &#123; initialization code; &#125;&#125; 管程中设置了多个条件变量，表示多个进程被阻塞或挂起的条件，条件变量的形式为 condition x, y;，它也是一种抽象数据类型，每个变量保存了一条链表，记录因该条件而阻塞的进程，与条件变量相关的两个操作：condition.cwait 和 condition.csignal。 condition.cwait：正在调用管程的进程因 condition 条件需要被阻塞，则调用 condition.cwait 将自己插入到 condition 的等待队列中，并释放管程。此时其他进程可以使用该管程。 condition.csignal：正在调用管程的进程发现 condition 条件发生变化，则调用 condition.csignal 唤醒一个因 condition 条件而阻塞的进程。如果没有阻塞的进程，则不产生任何结果。 经典同步问题生产者-消费者问题生产者-消费者问题描述的是：生产者和消费者两个线程共享一个公共的固定大小的缓冲区，生产者在生成产品后将产品放入缓冲区；而消费者从缓冲区取出产品进行处理。 它需要保证以下三个问题： 在任何时刻只能有一个生产者或消费者访问缓冲区（互斥访问）； 当缓冲区已满时，生产者不能再放入数据，必须等待消费者取出一个数据（条件同步）； 而当缓冲区为空时，消费者不能读数据，必须等待生产者放入一个数据（条件同步）。 利用信号量解决 用信号量解决生产者-消费者问题，使用了三个信号量： 互斥信号量 mutex：用来保证生产者和消费者对缓冲区的互斥访问； 资源信号量 full：记录已填充的缓冲槽数目； 资源信号量 empty：记录空的缓冲槽数目。 12345678910111213141516171819202122232425262728#define N 10int in = 0, out = 0;item buffer[N];semaphere mutex = 1, full = 0, empty = N;void producer(void) &#123; while(TRUE) &#123; item nextp = produce_item(); wait(empty); wait(mutex); buffer[in] = nextp; in = (in + 1) % N; signal(mutex); signal(full); &#125;&#125;void consumer(void) &#123; while(TRUE) &#123; wait(full); wait(mutex); item nextc = buffer[out]; out = (out + 1) % N; signal(mutex); signal(empty); consume_item(nextc); &#125;&#125; 需要注意的是进程中的多个 wait 操作顺序不能颠倒，否则可能造成死锁。例如在生产者中，当系统中没有空的缓冲槽时，生产者进程的 wait(mutex) 获取了缓冲区的访问权，但 wait(empty) 会阻塞，这样消费者也无法执行。 利用管程解决 利用管程解决时，需要为它们建立一个管程，其中 count 表示缓冲区中已有的产品数目，条件变量 full 和 empty 有 cwait 和 csignal 两个操作，另外还包括两个过程： put(x)：生产者将自己生产的产品放入到缓冲区中，而如果 count &gt;= N，表示缓冲区已满，生产者需要等待； get(x)：消费者从缓冲区中取出一个产品，如果 count &lt;= 0，表示缓冲区为空，消费者应该等待； 12345678910111213141516171819202122232425262728Monitor producerconsumer &#123; item buffer[N]; int in, out; condition full, emtpy; int count; public: void put(item x) &#123; if(count &gt;= N) &#123; cwait(full); &#125; buffer[in] = x; in = (in + 1) % N; count++; csignal(emtpy); &#125; item get() &#123; if(count &lt;= 0) &#123; cwait(emtpy); &#125; x = buffer[out]; out = (out + 1) % N; count--; csignal(full); &#125; &#123; in = 0; out = 0; count = 0; &#125;&#125; 于是生产者和消费者可描述为： 123456789101112void producer() &#123; while(TRUE) &#123; item nextp = produce_item(); producerconsumer.put(nextp); &#125;&#125;void consumer() &#123; while(TRUE) &#123; item nextc = producerconsumer.get(); consume_item(nextc); &#125;&#125; 哲学家就餐问题哲学家就餐问题描述的是：有五个哲学家共用一个圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们交替地进行思考和进餐。哲学家在平时进行思考，在饥饿时试图获取左右两只筷子，拿到两只筷子才能进餐，进餐完后放下筷子继续思考。 为实现筷子的互斥使用，可以用一个信号量表示一只筷子，五个信号量构成信号量数组，也都被初始化为 1。 1semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; 第 i 位哲学家的活动可描述为： 12345678910void philosopher(int i) &#123; while(TRUE) &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); // eat signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); // think &#125;&#125; 上述解法中，如果五位哲学家同时饥饿而都拿起左边的筷子，再试图去拿右边的筷子时，会出现无限期等待而引起死锁。 读者-写者问题读者-写者问题描绘的是：一个文件可以被多个进程共享，允许多个 Reader 进程同时读这个文件，但不允许 Wirter 进程和其他 Reader 进程或 Writer 进程同时访问这个文件。所以读者-写者需要保证一个 Writer 进程必须与其他进程互斥地访问共享对象。 解决这个问题需要设置两个互斥信号量和一个整形变量： 互斥信号量 wmutext：实现 Reader 进程和 Writer 进程在读或写时的互斥； 整形变量 readcount：正在读的进程数目； 互斥信号量 rmutext：实现多个 Reader 进程对 readcount 变量的互斥访问； 123456789101112131415161718192021222324252627semaphore rmutex = 1, wmutex = 1;int readcount = 0;void Reader() &#123; while(TRUE) &#123; wait(rmutex); if(readcount == 0) &#123; wait(wmutex); &#125; readcount++; signal(rmutex); // perform read opertaion wait(rmutex); readcount--; if(readcount == 0) &#123; signal(wmutex); &#125; signal(rmutex); &#125;&#125;void Writer() &#123; while(TRUE) &#123; wait(wmutex); // perform wirte opertaion signal(wmutex); &#125; &#125; 只要有一个 Reader 进程在读，便不允许 Writer 进程去写。所以，仅当 readcount = 0，表示没有 Reader 进程在读时，Reader 进程才需要执行 wait(wmutex) 操作，而 readcount != 0 时，表示有其他 Reader 进程在读，也就肯定没有 Writer 在写。同理，仅当 readcount = 0 时，才执行 signal(wmutex) 类似。 进程通信进程通信是指进程之间的信息交换。在进程间要传送大量数据时，应利用高级通信方法。 共享内存在共享内存系统中，多个通信的进程共享某些数据结构或存储区，进程之间能够通过这些空间进行通信。 可分为两种类型： 基于共享数据结构的通信方式。多个进程共用某些数据结构，实现进程之间的信息交换，例如生产者-消费者问题中的缓冲区。这种方式仅适用于少量的数据，通信效率低下。 基于共享存储区的通信方式。在内存中分配一块共享存储区，多个进程可通过对该共享区域的读或写交换信息。通信的进程在通信前，需要先向系统申请共享存储区的一个分区，以便对其中的数据进行读写。 管道管道（Pipe）是指用于连接一个读进程和一个写进程以实现进程间通信的一个共享文件。发送进程以字符形式将数据送入管道，而接收进程则从管道中接收数据。 管道机制提供了三方面的协调能力： 互斥：当一个进程对管道执行读或写操作时，其他进程必须等待； 同步：当写进程把一定数量的数据写入管道，便睡眠等待，直到读进程取走数据后再把它唤醒； 确定对方是否存在，只有确定对方存在才能通信。 消息传递消息传递机制中，进程以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的原语，在进程之间进行消息传递，完成进程间数据交换。 按照实现方式，可分为两类： 直接通信方式：发送进程利用操作系统提供的发送原语，直接把消息发送给进程，接收进程则利用接收原语来接收消息； 间接通信方式：发送和接收进程，通过共享中间实体方式进行消息的发送和接收，完成进程间的通信。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(2)--进程和线程]]></title>
    <url>%2F2019%2F01%2F07%2F007_%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程什么是进程进程（process）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 OS 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。 在某一瞬间，一个 CPU 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。进程和程序间的联系和区别如下： 程序是一段静态的代码；进程是一个动态运行的过程； 程序是产生进程的基础；进程是程序功能的体现； 程序的每次执行都构成了不同的进程，通过多次运行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序； 进程的实现为了实现进程，操作系统维护了一张进程表（结构数组），每个进程占用一个进程表项（进程控制块 PCB），它是进程存在的唯一标志。该表项包含了进程状态的重要信息，包括进程标识符、状态、优先级、程序计数器、堆栈指针、寄存器等； 对进程的管理就是对通过 PCB 的组织管理来实现的。由于保存了在进程的状态变化时的必要信息，在中断一个正在执行的进程，并在后来恢复时，就好像进程从未中断过。它是支持多进程和提供多处理的关键。 进程的状态及转换如下图是进程的三种状态的状态图。一个进程的三种状态是： 运行态：进程正在占用 CPU 执行； 就绪态：进程处于准备运行状态，已经获得除 CPU 外的所有资源； 阻塞态：进程由于等待某种外部事件而暂停运行，即使获得 CPU，也不能运行。 进程之间主要有四种转换关系： 由运行态转换为就绪态：在时间片用完后，不得不让出 CPU； 由就绪态转换为运行态：进程被调度，获得处理机资源； 由阻塞态转换为就绪态：进程的 I/O 请求完成； 由运行态转换为阻塞态：进程发出 I/O 请求； 线程什么是线程线程（thread）是进程中的一条执行流程。在引入线程的操作系统中，进程是拥有资源的基本单位；而线程是 CPU 调度和分派的基本单位。 一个进程中可以有多个线程，多个线程可以并发执行，它们之间共享相同的地址空间。但如果一个线程崩溃，可能会导致其所属进程的所有线程崩溃。 进程和线程的区别 调度性：传统 OS 中，进程是调度和分派的基本单位，但在引入线程后，线程是调度和分派的基本单位； 并发性：在引入线程后，多个进程可以并发执行，一个进程中的多个线程也可以并发执行； 拥有资源：进程是拥有资源的基本单位，而线程本身并不拥有资源； 系统开销：进程切换付出的系统开销明显大于线程； 线程实现的三种方式有三种线程的实现方式： 用户线程：用户空间实现，由用户线程库管理； 内核线程：内核中实现，由操作系统管理； 轻量级进程：内核中实现，支持用户线程； 用户线程 用户线程是把整个线程包放在用户空间中，不依赖于操作系统的内核，所以它可以在不支持线程的操作系统上实现。可以用一组用户级的线程函数库来实现线程。 每个进程都需要私有的线程表，用来跟踪记录该进程中线程的状态信息，不过仅记录每个线程的程序计数器、堆栈指针、寄存器和状态等，该线程表由运行时系统管理。而且用户线程的切换由线程库函数来完成，不需要用户态、核心态切换，所以线程调度速度特别快。另外，也允许每个进程都拥有自定义的线程调度算法。 但如果一个线程发起系统调用而阻塞，尽管其他线程可以运行，但整个进程都会阻塞。当一个线程开始运行后，除非它主动较交出 CPU，否则它所在的进程中的其他线程将无法运行。 内核线程 内核线程在操作系统的内核中实现，由内核来完成对线程的创建、终止和管理。 由于线程的创建、终止和切换通过系统调用执行，由内核完成的，其系统开销比较大； 但在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他使用内核线程的运行； 轻量级进程 轻量级进程是内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。而轻量级进程内部可以对应多个用户线程。 CPU 调度调度概念处理机调度是当有多个进程（线程）竞争 CPU 时，调度程序需要从从就绪队列中挑选下一个占用 CPU 运行的进程。 调度算法是为了解决通过什么样的准则来挑选就绪对列中的哪一个进程来执行。在每次调度时需要决定在下一个 CPU 计算时将哪个进程交给 CPU。 调度算法先来先服务算法FCFS 根据进程进入就绪态的先后顺序排列。当进程进入阻塞态或结束时，就绪队列中的下一个进程占用 CPU。 实现简单，但可能短进程排在长进程后面，导致平均等待时间波动较大。 短进程优先算法SJF 选择就绪队列中执行时间最短的进程占用 CPU 运行。 可抢占系统改进：短剩余时间优先算法，即选择剩余运行时间最短的进程运行。 短进程优先算法有最优的平均周转时间，但连续的短进程可能会使长进程无法获得 CPU 资源，导致饥饿；运行时间不可预估，并不可靠。 最高响应比优先算法HRN 选择就绪队列中响应比最高的进程。它是基于短进程优先算法的改进，它不允许抢占，另外等待时间越长，响应比越高，可以避免长时间地等待。 1R = (w+s)/s // 其中 w 为等待时间，s 为执行时间。 时间片轮转算法RR 按时间片分配给进程运行。在轮转中，每个进程分到执行 1/n 的时间，时间片结束时，按先来先服务算法切换到下一个就绪进程，每隔 n-1 个时间片进程会再次执行。 如果时间片过大，进程等待时间过长，极限情况下会退化为先来先服务算法；如果时间片过小，虽然反应迅速，但上下文切换开销较大，会影响系统吞吐量。 多级反馈队列算法 就绪队列被划分为多个独立的子队列，而且每个队列可以有自己的调度策略，在队列之间可以设置优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短。 在执行时，进程在不同队列间移动，如果进程在当前优先级的时间片下没有完成，则下降到低一优先级的队列，以此类推。只有当一个队列为空时才会去执行下一个队列中的进程。 这种算法对于 CPU 密集型进程的优先级下降很快，而 I/O 密集型进程停留在高优先级。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(1)--操作系统概述]]></title>
    <url>%2F2019%2F01%2F06%2F006_%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。 参考学习： 书籍：《现代操作系统》、《深入理解计算机系统》 视频：学堂在线 - 操作系统（自主模式） 操作系统知识点 操作系统概述： 操作系统的定义以及功能； 计算机系统体系结构； 操作系统的四个特性：并发、共享、虚拟、异步； 用户态和核心态的区别； 进程和线程： 进程的几种状态及其转换； 进程与线程的区别； 进程调度的算法； 进程同步的方式； 进程通信的方式； 死锁： 死锁的概念、导致死锁的原因； 导致死锁的四个必要条件； 处理死锁的四种方式：预防、避免、检测、解除； 存储器： 内存连续分配方式采用的算法及优缺点； 分页存储管理方式； 分段存储管理方式； 段页式存储管理方法； 几种存储方式的比较及各自优缺点； 从逻辑地址到物理地址的转换过程； 虚拟存储器： 虚拟存储器的定义与实现方式； 页面置换算法，计算所需换页数； 文件系统： 文件系统基本概念； 文件分配方式； 什么是操作系统计算机系统一般由一个或多个处理器、内存、I/O 设备等组成，而操作系统就是这些硬件之上的一种软件，它为应用程序提供了一个抽象，并管理这些计算机资源。具体可以从功能上来认识操作系统。 作为扩展机器，它隐藏硬件底层实现细节，对硬件提供抽象，方便程序或用户的使用： 进程是对 CPU、主存及 I/O 设备的抽象； 虚拟内存（虚拟地址空间）是对主存和 I/O 设备的抽象； 文件是对 I/O 设备的抽象； 作为资源管理器，它在多个竞争程序之间合理地控制对处理器、存储器及 I/O 设备的分配，避免资源使用冲突。有两种共享资源的方式： 时间复用：不同程序或用户轮流使用； 空间复用：每个程序或用户得到资源的一部分； 内核态和用户态如下图是一般计算机系统的简化图。多数计算机有两种运行模式：内核态和运行态。 操作系统运行在内核态，它对所有硬件具有访问权，可以执行任何指令。用户接口程序和其余软件运行在用户态，它只能执行机器指令中的一个子集。 四大特性操作系统主要有四大特性，分别为： 并发：在宏观上有多个程序在同时运行，需要 OS 管理和调度，而在微观上是分时交替运行； 注意并发和并行的区别： 并发指的是在一段时间内有多个应用程序可以运行； 并行指的是在一个时间点有多个应用程序可以执行，并行需要计算机有多个 CPU； 共享：资源可以供内存中多个并发执行的进程共同使用，在宏观上是同时访问该资源，而在微观上是采用互斥共享。 虚拟：利用多道程序设计，让每个应用程序都觉得有一个计算机专门为它服务。 异步：程序的执行不是连贯的，而是间断性的，其速度也不可知，但只要运行环境相同，其运行结果需要保证相同。 计算机体系结构计算机系统主要由处理器、主存、I/O 设备及系统总线组成。 处理器 也称中央处理单元（CPU），是用来解释或执行主存中的指令的引擎。在任何时候，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，指向下一条指令。 主存 主存，是一个临时存储设备，用来存放程序和程序要处理的数据。存储系统大多采用分层次的存储结构。如下图： 存储层次最顶层是寄存器。下一层是两层高速缓存 L1、L2。再下一层是主存，所有不能再高速缓存行命中的访问请求会转到内存。如果内存中还没有，可能还会到虚拟内存中查找。 在层次结构中，较高层次的存储设备可以作为较低层次设备的高速缓存。更高层次的存储设备比底层的更快，但价格也更昂贵。 I/O 设备 I/O 设备是系统与外界联系的通道。主要包括磁盘、显示器、键盘等。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连，来传递信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常]]></title>
    <url>%2F2018%2F11%2F08%2F005_Java%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java 标准异常Throwable 是 Java 中最顶级的异常类，继承自 Object，实现了序列化接口，它有两个重要的子类：Exception 和 Error，二者都是 Java 异常处理的重要子类，它们之间的区别和联系如下： Error：表示系统级的错误，是 Java 运行环境内部或硬件问题，一般与虚拟机相关，例如：栈溢出、内存溢出等。这种异常抛出后不能指望程序来进行处理。 Exception：表示需要程序捕获并处理的异常，是由程序设计的不完善而出现的问题，包括运行时异常（RuntimeException）和其他异常，例如 IOException 等。 异常体系图如下： 异常分类Java 中的异常可分为两类：非受检异常（Unchecked Exception）和受检异常（Checked Exception）。 其中 Error 和 RuntimeExcpetion 表示属于非受检异常。这种异常不需要显式地捕获，也不需要在异常说明中声明，但是如果发生异常就会中断程序的执行。这种异常一般是由于代码原因导致的，例如空指针、数组越界、转型异常等。所以，只要代码没问题，这些异常就可以避免，也就不需要显式处理。 而其他的异常都属于受检异常。这种异常需要使用 try-catch 捕获处理或者在异常说明中进行声明，如果一个方法调用了有受检异常抛出的方法那么就需要对该异常进行处理，否则编译就不能通过。例如 IOException、SQLException、ClassNotFoundException 等。 123456789101112public void test() &#123; try &#123; // 异常捕获 Class.forName("timberliu.exception.User"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;// 异常说明中进行声明// throws 用来声明方法可能抛出的所有异常public void test() throws IOException &#123;&#125; 受检异常在 IO 操作中使用较多。例如 FileNotFoundException，它表示的是：告诉方法调用者，不保证这个寻找文件的操作一定成功，取决于外部因素，所以需要明确地对调用失败的情况进行特殊处理。 异常的处理在异常被捕获后，有两种处理方式：1. 自己进行处理；2. 向上抛出，交给调用者处理。具体处理时，如果不知道如何处理那就向上抛出；如果知道如何处理，那么有以下处理方式： 打印记录日志 封装异常后重新抛出 返回失败通用对象 Response.Failed() 更改程序结果后正常返回 忽略或 e.printStackTrace()，一般禁止这样使用。 12345678try &#123; // 明确抛出一个异常 throw new Exception();&#125; catch (Exception e) &#123; // 处理异常&#125; finally &#123; // 关闭 IO、网络连接等资源&#125; 将捕获的异常重新封装到一个新的异常里重新抛出，这称为异常链。大多用于将受检异常封装成非受检异常。另外，抛出的新异常必须包含原有异常，这样在处理程序时才可以通过 getCause() 和 initCause() 方法访问异常的根源。 12345678public void test() &#123; try &#123; throw new FileNotFoundException(); &#125; catch (FileNotFoundException e) &#123; // 将 e 封装到新创建的异常里 throw new RuntimeException(e); &#125;&#125; 意外情况1.在 return 中使用 finally 在 try 语句中有 return 语句时，finally 中的代码会在 try 或 catch 块中的 return 语句执行之后，返回之前执行。 123456789101112131415161718public static int test() &#123; int i = 1; try &#123; System.out.println("try"); return i = 2; &#125; finally &#123; System.out.println("before finally: " + i); i = 3; System.out.println("after finally: " + i); &#125;&#125;public static void main(String[] args) &#123; System.out.println("return: " + test());&#125;// try// before finally: 2// after finally: 3// return: 2 可以看到，这里的执行顺序是先执行 i = 2；然后执行 finally 块中的语句；最后 return。但是在 finally 语句中修改 a 的值，对结果不会造成影响。 如果 finally 语句中也有 return 语句，还会覆盖 try 或 catch 中的 return 语句的返回结果： 123456789101112public static int test() &#123; int i = 1; try &#123; return i = 2; &#125; finally &#123; return i = 3; &#125;&#125;public static void main(String[] args) &#123; System.out.println("return: " + test());&#125;// return 3 2.异常丢失 如果在 try/catch 块中，执行 System.exit(0); 后，进程会被杀死，finally 中的代码就不会执行了。 123456789public static void main(String[] args) &#123; try &#123; System.out.println("try"); System.exit(0); &#125;finally &#123; System.out.println("finally"); &#125;&#125;// try 常见的运行时异常 IndexOutOfBoundsException：数组下标越界异常 ArrayStoreException：向数组中存放与声明类型不兼容的对象异常 1234Animal[] a = new Dog[1];a[0] = new Cat();// java.lang.ArrayStoreException: timberliu.exception.Cat ArithmeticException：算术运算异常，例如除 0 运算 ClassCastException：类型强制转换异常 DateTimeException：时间运算异常 IllegalArgumentException：非法参数异常 1234Animal animal = new Dog();Cat cat = (Cat)animal;// java.lang.ClassCastException: timberliu.exception.Dog cannot be cast to timberliu.exception.Cat NegativeArraySizeException：创建一个大小为负数的数组错误 NullPointerException：空指针异常 NumberFormatException：数字格式异常，例如在字符串转换为数字时： 123int a = Integer.parseInt("abc");// java.lang.NumberFormatException: For input string: "abc" SecurityException：安全异常 UnSupportedOperationException：不支持的操作异常 更多的异常可见官方的 doc：RuntimeExcpetion（Java Platform SE 8） Java7 新特性try-with-resources 在 Java7 之前，对于 IO 操作、网络连接等，用完之后必须在 finally 块中调用 close 方法进行关闭，否则可能会导致内存泄露等问题。而从 Java7 中，可以使用 try-with-resources 语句，不需要再显式地关闭资源。 12345678910public static void main(String[] args) &#123; try (BufferedReader bufferedReader = new BufferedReader(new FileReader("e:\\file.txt"));) &#123; String line; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // handle exception &#125;&#125; 反编译一下，看它背后的实现： 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new FileReader("e:\\file.txt")); Throwable var2 = null; try &#123; String line; try &#123; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (Throwable var12) &#123; var2 = var12; throw var12; &#125; &#125; finally &#123; if (bufferedReader != null) &#123; if (var2 != null) &#123; try &#123; bufferedReader.close(); &#125; catch (Throwable var11) &#123; var2.addSuppressed(var11); &#125; &#125; else &#123; bufferedReader.close(); &#125; &#125; &#125; &#125; catch (IOException var14) &#123; ; &#125;&#125; 可以看到，编译器自动生成了关闭资源的操作。而且，以前在关闭资源时有可能也会抛出异常，在 Java7 中可以使用 Throwable.addSuppressed 方法来抑制可能抛出的异常，这也是 Java7 增加的方法。 Multi-Catch Exceptions 它表示 catch 语句能同时捕获多个异常。 1234567891011public static void main(String[] args) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new FileReader("e:\\file.txt")); String line = bufferedReader.readLine(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(line); &#125; catch (ParseException | IOException e) &#123; // handle exception &#125;&#125; 这样就可以用同样的异常处理程序，来处理多个异常。 Rethrowing Exceptions 能够直接再次抛出已捕获的异常。注意：throw new Exception(e) 抛出的是重新包装之后的异常；而 throw e 抛出的是原始的异常。 12345678910111213141516public static void test() throws IOException &#123; try &#123; throw new IOException("IOException"); &#125; catch (IOException e) &#123; throw e; &#125;&#125;public static void main(String[] args) &#123; try &#123; test(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125;&#125;// IOException]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口与内部类]]></title>
    <url>%2F2018%2F11%2F06%2F004_%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类抽象方法指的是仅有声明而没有方法体的方法，而包含一个或多个抽象方法的类，就叫抽象类，用 abstract关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。抽象类的主要目的是代码重用。大多用于抽象相关 Java 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 java.util.AbstractList。 接口接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 static 和 final 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 enum 枚举类。 接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 Cloneable、Serializable，表示这个类可以克隆或者可以序列化。 Java 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。 12345678910111213141516171819202122232425interface Study &#123; void study();&#125;interface Play &#123; void play();&#125;Class Person &#123; public void doSomething() &#123; System.out.println("person doSomething"); &#125;&#125;public class Student extends Person implements Study, Play &#123; @Override public void doSomething() &#123; System.out.println("student doSomething"); &#125; void study() &#123; System.out.println("study"); &#125; void play() &#123; System.out.println("play"); &#125;&#125; 抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。 1234567891011121314151617181920212223interface Diner &#123; void eat();&#125;interface Sleeper &#123; void sleep();&#125;// 接口可以继承接口（支持多继承）interface Student extends Diner, Sleeper &#123; void study();&#125;// 抽象类可以实现接口abstract class Undergraduate implements Student &#123; @Override public void eat() &#123; System.out.println("eat"); &#125; @Override public void sleep() &#123; System.out.println("sleep"); &#125; public abstract void study();&#125; 抽象类与接口比较 一个类只能继承一个抽象类，但可以实现多个接口； 接口中的字段只能是 static 和 final 的，而抽象类的字段没有限制； 接口中的方法只能是 public 的，而抽象类的方法则没有限制。 一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 Java8 开始也增加了默认方法，使得修改接口的成本也降低很多。 如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。 默认方法在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。 所以从 Java8 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。 1234567public interface Sized &#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 例如，Java 8 中 List 接口的 sort 方法就是默认方法。 123456789default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 1.可选方法 默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。 例如，在 Java8 中，Iterator 接口为 remove 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 Iterator 接口的每一个类都声明一个空的 remove 方法。 1234567interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next(); default void remove() &#123; throw new UnSupportedOperationException(); &#125;&#125; 2.行为的多继承 默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法: 1234567891011121314151617interface Moveable &#123; int getX(); void setX(int x); default void moveHorizontally(int distance) &#123; setX(getX() + distance); &#125;&#125;interface Resizable &#123; int getWidth(); void setWidth(int width); default void resizeWidth(int distance) &#123; setWidth(getWidth() + distance); &#125;&#125; 12345678public class Change implements Moveable, Resizable &#123; public static void main(String[] args) &#123; Change c = new Change(); c.moveHorizontally(10); c.resizeWidth(10); &#125;&#125; 解决冲突Java 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。 第一条规则 在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 1234567891011121314151617interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;class B &#123; public void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C extends B implements A &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125; 上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。 第二条规则 如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。 123456789101112131415161718interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B extends A &#123; default void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello form B 在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。 第三条规则 如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。 1234567891011121314151617181920212223interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B &#123; default void hello() &#123; System.out.println("hello from B"); &#125;&#125;public class C implements A, B &#123; @Override public void hello() &#123; A.super.hello(); &#125; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello from A 上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 hello 方法，并且在调用时，使用 X.super.f() 这种语法，显式地指定使用哪一个接口中的方法。 内部类从外部类对象的非静态方法之外的任意位置创建某个内部类的对象，那么必须指明这个对象的类型：OuterClassName.InnerClassName。而且当生成一个内部类对象时，内部类对象会拥有一个指向外部类对象的引用，也就拥有了外围类所有成员的访问权。 要想创建内部类对象，必须使用外部类的对象来创建，这需要使用 .new 语法。 12345678public class Outer &#123; public class Inner &#123; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); &#125;&#125; 而在内部类中如果想要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。 123456789101112131415161718public class Outer &#123; public void f() &#123; System.out.println("Outer.f()"); &#125; public class Inner &#123; public Outer outer() &#123; return Outer.this; &#125; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.outer().f(); &#125;&#125;// Outer.f() 匿名内部类 1234567891011121314151617181920212223public class Outer &#123; class Inner &#123; public void value() &#123; System.out.println("inner class"); &#125; &#125; public Inner inner(final String str) &#123; return new Inner() &#123; @Override public void value() &#123; System.out.println("inner subclass: " + str); &#125; &#125;; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.inner("Inner"); inner.value(); &#125;&#125;// inner subclass: Inner 上面就是一个匿名内部类的例子，表示创建一个继承自 Inner 的匿名类的对象。在匿名内部类中，一般使用默认的构造器来生成内部类。另外，如果在匿名内部类希望使用一个在外部定义的对象，那么必须将其声明为 final。 但是匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但两者不能兼备。它只能扩展一个类或者只实现一个接口。 工厂模式接口一般用来实现多重继承，而生成遵循某个接口的对象可以使用工厂设计模式。一般在工厂对象上调用的是创建方法，而该工厂对象会生成接口的某个实现的对象。 工厂模式的实现在使用匿名内部类时会更加优雅。 123456interface Game &#123; boolean move();&#125;interface GameFactory &#123; Game getGame();&#125; 123456789101112131415class Checkers implements Game &#123; private Checkers() &#123; &#125; private int moves = 0; private static final int MOVES = 3; public boolean move() &#123; System.out.println("Checkers move " + moves); return ++moves != MOVES; &#125; public static GameFactory factory = new Factory() &#123; public Game getGame() &#123; return new Checkers(); &#125; &#125;;&#125; 12345678910111213public class Games &#123; public static void playGame(GameFactory factory) &#123; Game g = factory.getGame(); while(s.move()) ; &#125; public static void main(String[] args) &#123; playGame(Checkers.factory); &#125;&#125;// Checkers move 0// Checkers move 1// Checkers move 2 可以看到，在使用匿名内部类时，构造器都是 private 的，并且没有任何必须去创建一个额外的工厂类。另外，对于经常只需要单一的工厂对象，也被创建为 static。 嵌套类嵌套类，也就是静态内部类，要创建嵌套类对象，不需要外部类对象。 123456789101112public class Outer &#123; public static class Inner &#123; public static void hello() &#123; System.out.println("static inner class"); &#125; &#125; public static void main(String[] args) &#123; Inner.hello(); &#125;&#125;// static inner class 与内部类相比，区别如下： 创建内部类需要外部类的对象；嵌套类不需要外围类的对象 内部类不可以定义静态成员变量；嵌套类可以定义静态成员变量 内部类可以访问外部类的成员变量；嵌套类不可以访问非静态的外部类的成员变量]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型与运算]]></title>
    <url>%2F2018%2F11%2F03%2F003_%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[基本数据类型Java 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下： Java 中的 char 使用 Unicode 编码，占两个字节。所以在 Unicode 编码中存在的中文，都可以用 char 存储。 在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：Java中，为什么 byte 类型的取值范围为-128~127?。 浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。Java 中使用 IEEE754表示法，分为单精度和双精度两种，也就是 float 和 double，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。 包装类型每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别： 默认值不同。基本类型的默认值为 0、false 等；而包装类默认为 null 初始化不同。基本类型不需要初始化；而包装类需要 new。 存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中 元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法 基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 Java5 提供的一个语法糖。自动装箱就是 Java自动将原始类型值转换为对应的对象；自动拆箱就是 Java 自动将对象转换为对应的基本类型。例如： 1234public static void main(String[] args) &#123; int i = 1; Integer n = i;&#125; 在反编译后，代码如下： 1234public static void main(String[] args) &#123; int i = 1; Integer n = Integer.valueOf(i);&#125; 可以看到，自动装箱就是调用 Integer 的 valueOf() 方法实现的；而自动拆箱是调用 Integer 的 xxxValue() 方法实现的。 整型的缓存机制Java5 中，Integer 引入了一个新功能来节省内存和提高性能。在使用 Integer.valueOf()方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。 valueOf() 方法的实现如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 Integer 对象。 IntegerCache 是 Integer 的一个内部类，缓存池的大小默认为 -128~127。最大值可通过 -XX:AutoBoxCacheMax=xxx 修改。这个缓存在 Integer 类第一次被使用时，通过一个 for 循环存储在一个整数数组中。 1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 由于编译器在自动装箱时会调用 valueOf 方法，所以创建多个相同的值时，会引用相同的对象。 123456public static void main(String[] args) &#123; Integer i = 123; Integer j = 123; System.out.println(i == j);&#125;// true 所有的包装类都有类似的缓存机制： ByteCache 可以缓存 Byte 对象 ShortCache 可以缓存 Short 对象 LongCache 可以缓存 Long 对象 CharacterCache 可以缓存 Character 对象 Byte、Short、Long 的缓存范围都是固定的，为 -128~127。而 CharacterCache 的范围为 0~127。除了 Integer，这个范围都不能改变。 高精度类型Java 还提供了两个用于高精度计算的类：BigInteger 和 BigDecimal。 BigInteger 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。 BigDecimal 支持任意精度的定点数。可以用它进行精确的货币运算。 在 Java 中，对于金额的运算和在数据库中的存储，一般有两种方式： 以元为单位。Java 中存储类型为 BigDecimal，在数据库中的存储类型为 number(10, 2)，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。 以分为单位。Java 中存储类型为 Long，在数据库中存储类型为 big int。取整和保留方式如前面一样。 看一下下面的例子： 123456public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);&#125; 在进行金额运算时，使用 BigDecimal 类，并且将 double 转为 String 类型进行运算。在使用 divide 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。 值传递与引用传递先来看一下值传递与引用传递的概念： 值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。 引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。 那么 Java 中到底是值传递还是引用传递？先来看下面的例子： 123456789101112public static void change(int j) &#123; j = 2; System.out.println("change: j = " + j);&#125;public static void main(String[] args) &#123; int i = 1; change(i); System.out.println("main: i = " + i);&#125;// change: j = 2// main: i = 1 可以看到，change 方法内部并没有改变实际参数的值，那么 Java 就是值传递吗？再来看下面的例子： 1234567891011121314public static void change(User user) &#123; user.setAge(21); System.out.println("change: " + user);&#125;public static void main(String[] args) &#123; User user = new User(); user.setName("Timber"); user.setAge(20); change(user); System.out.println("main: " + user);&#125;// change: User&#123;name='Timber', age=21&#125;// main: User&#123;name='Timber', age=21&#125; 可以看到，实际参数的值被改变了，那么 Java 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子： 123456789101112public static void change(String name2) &#123; name2 = "TimberLiu"; System.out.println("change: " + name2);&#125;public static void main(String[] args) &#123; String name1 = "Timber"; change(name1); System.out.println("main: " + name1);&#125;// change: TimberLiu// main: Timber 可以看到，实际参数的值又被改变了，这又作何解释呢？ Java 的值传递其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 传递参数时是否会进行拷贝，创建一个副本。 再来看一下上面的第二个例子，是如何传递的呢？ 可以看到，当把 user 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？ 12345678910111213141516public static void change(User user2) &#123; user2 = new User(); user2.setName("TimberLiu"); user2.setAge(21); System.out.println("change:" + user2);&#125;public static void main(String[] args) &#123; User user1 = new User(); user1.setName("Timber"); user1.setAge(20); change(user1); System.out.println("main: " + user1);&#125;// change: User&#123;name='TimberLiu', age=21&#125;// main: User&#123;name='Timber', age=20&#125; 这个过程发生了什么呢？看下图： 可以看到，这里把 user1 传递给 change 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 change 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 user2 的修改并不会影响到 user1 中的内容。 所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。 那么，为什么上面在传递 String 对象和 User 对象结果不一样呢？这是因为 String 类型是不可变的，在赋值 name2 = &quot;TimberLiu&quot; 时，会重新创建一个 String，而并没有修改实际参数的值。 所以，Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用。 类型转换Java 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下： 在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。 另外，在对基本数据进行运算时，所有 byte、short、char 类型的值都会自动被提升为 int。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。 在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子： 123456789public class Overflow &#123; public static void main(String[] args) &#123; int big = Integer.MAX_VALUE; System.out.println("big = " + big); System.out.println("bigger = " + (big + 1)); &#125;&#125;// big = 2147483647// bigger = -2147483648 switch 对 String 的支持switch 原本只支持整型，而 byte、short、char 可以转换为 int 型，所以也可以使用。但从 Java7 开始，在 switch 条件判断语句中也可以使用 String 类型了。 123456789101112public void decompile(String str) &#123; switch(str) &#123; case "aaa": System.out.println("aaa"); break; case "bbb": System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 在反编译后，可以看到： 12345678910111213141516171819202122232425public void decompile(String str) &#123; byte var3 = -1; switch(str.hashCode()) &#123; case 96321: if (str.equals("aaa")) &#123; var3 = 0; &#125; break; case 97314: if (str.equals("bbb")) &#123; var3 = 1; &#125; &#125; switch(var3) &#123; case 0: System.out.println("aaa"); break; case 1: System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 可以看到，String 的 switch 还是比较的 byte 类型。先声明了一个 byte 类型，然后通过 hashCode 和 equals 两个方法先后进行比较来赋予 byte 变量不同的值，最后 switch 来执行不同的代码。这里在 hash 之后再进行 equals 判断是有必要的，因为 hash 可能发生碰撞。 参考资料 Hollis：[译]Java中整型的缓存机制 Hollis：为什么说Java中只有值传递 SEU_Calvin：Java技术——Java中的参数传值方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象中的一些概念]]></title>
    <url>%2F2018%2F11%2F01%2F001_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[this、superthis 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 this 调用构造器，但必须将构造器置于最起始处。 123456789101112public class User&#123; private String name; private int age; public User(String name) &#123; this.name = name; &#125; public User(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super 关键字表示如果子类重写了父类的某个方法，可以通过 super 关键字来调用父类的方法实现，也可以用来调用父类的构造器。 123456789101112public class Person&#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void say() &#123; System.out.println(name + ":" + age); &#125;&#125; 12345678910111213141516171819public class Student extends Person &#123; private int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; @Override public void say() &#123; super.say(); System.out.println(name + ":" + age + "," + score); &#125; public static void main(String[] args) &#123; Student student = new Student("Timber", 20, 80); student.say(); &#125;&#125;// Timber:20// Timber:20,80 finalfinal 关键字可用于三种情况：变量、方法和类。 1.变量 对于基本类型时，final 使数值恒定不变；对于引用类型时，final 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。 另外，在参数列表中还可以将参数声明为 final，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。 2.方法 final 方法不可以被重写。 类中所有的 private 方法都隐式地指定为 final，所以 private 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。 3.类 final 类不能被继承，而且 final 类中的所有方法都隐式地被指定为 final，无法覆盖它们。 static当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 static 方法或访问其 static 域。 1.变量 当 static 作用于某个字段时，会改变数据的创建方式，因为 static 字段对每个类只有一份存储空间，存放在方法区中；而非 static 字段则对每个对象都有一个存储空间，存放在堆中。 2.方法 对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 this 关键字。而 static 方法就是没有 this 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 static 方法，实际上这正是 static 方法的主要用途。 3.静态块 Java 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。 123456public Class User &#123; private String name; static &#123; name = "Timber"; &#125;&#125; 这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。 重写与重载1.重写 重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。 1234567891011121314151617class Person &#123; public void doSomething() &#123; System.out.println("do something"); &#125;&#125; class Student extends Person&#123; @Override public void doSomething() &#123; System.out.println("studying"); &#125; public static void main(String[] args) &#123; Person person = new Student(); person.doSomething(); &#125;&#125;// studying 上面就是一个重写的例子。重写一般需要注意以下几点： 子类方法的方法签名必须和父类方法相同； 子类方法的返回类型必须小于等于父类的方法； 子类中的访问权限必须大于等于父类的方法； 子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常 不能重写被标识为 final 的方法 重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。 12345678910111213141516public class Person &#123; String s = "person";&#125;public class Student extends Person &#123; String s = "student";&#125;public class Test &#123; public static void main(String[] args) &#123; Person a1 = new Student(); System.out.println("a1.s: " + a1.s); Student a2 = new Student(); System.out.println("a2.s: " + a2.s); &#125;&#125;// a1.s: person// a2.s: student 2.重载 重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。 123456789class Person&#123; public void doSomething() &#123; System.out.println("studying"); &#125; public void doSomething(String thing) &#123; System.out.println("studying " + thing); &#125;&#125; 上面就是一个重载的例子。重载一般需要注意几点： 被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。 根据方法的返回值不能区分重载 重载涉及到基本类型的自动提升时可能会造成混淆。 构造器构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 new 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。 一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 new Person() 创建对象时就会报错。 对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 int 初始化为 0，引用类型初始化为 null等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。 对象的创建过程如下： 当首次创建类对象，或者类的静态方法/静态域被首次访问时，Java 解释器查找类文件； 然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。 如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 null； 然后执行出现于成员变量定义处的初始化动作； 然后再执行构造器。 多态多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件： 有类继承或接口实现 子类要重写父类的方法 父类的引用指向子类的对象 根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。 类实例化顺序类的初始化顺序如下： 按顺序执行父类静态变量和静态代码块 按顺序执行子类静态变量和子类静态代码块 按顺序执行父类非静态变量（父类实例变量）和动态代码块 执行父类构造函数 按顺序执行子类非静态变量（子类实例变量）和动态代码块 执行子类构造函数 举个栗子： 12345678910111213141516171819202122232425262728293031323334353637public class Student extends Person &#123; public static int i = 0; // 3 public int j = 0; // 8 public Student()&#123; // 10 System.out.println("Student Constructor"); &#125; &#123; // 9 System.out.println("Student not static block"); &#125; static &#123; // 4 System.out.println("Student static block"); &#125; public static void main(String[] args) &#123; new Student(); &#125;&#125;class Person &#123; static &#123; // 1 System.out.println("Person static block"); &#125; &#123; // 5 System.out.println("Person not static block"); &#125; public Person()&#123; // 7 System.out.println("Person Constructor"); &#125; public static int i = 0; // 2 public int j = 0; // 6&#125; 打印结果为： 123456Person static blockStudent static blockPerson not static blockPerson ConstructorStudent not static blockStudent Constructor 再看一个栗子： 1234567891011121314151617181920212223public class Son extends Father&#123; public static void main(String[] args) &#123; new Father(); &#125;&#125;class Father&#123; static &#123; // 1 System.out.println("Father static block"); &#125; &#123; // 3 6 System.out.println("Father not static block"); &#125; public Father()&#123; // 5 8 System.out.println("Father Constructor"); &#125; public static Father father = new Father(); // 2 public int j = 0; // 4 7 &#125; 打印结果是： 12345Father static blockFather not static blockFather ConstructorFather not static blockFather Constructor 这里，首先执行静态代码块，打印出 Father static block，然后执行静态变量 father，发现需要 new 一个 Father 对象，然后执行动态代码块、实例变量和构造器。 静态变量初始化后，再执行动态代码块和实例变量，最后执行构造器。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象思想与 Java 平台]]></title>
    <url>%2F2018%2F10%2F28%2F002_%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E4%B8%8EJava%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[学习 Java 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。 Java 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 Java 平台又该如何理解？今天就来学习一下。 面向对象思想所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。 而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。 在面向对象程序设计中会创建抽象数据类型，也就是类 class，它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。 三大特征1.封装 封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。 Java 用三个关键字在类内设定边界：public、protected、private，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。 2.继承 代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 private，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。 另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写 overriding。 那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。 3.多态 在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。 在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。 五大设计原则面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。 单一职责（Single Responsibility）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。 开关封闭（Open-Closed）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。 里氏替换（Liskov Substitution）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。 接口隔离（Interface-Segregation）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。 依赖倒置（Dependency Inversion）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。 对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。 解释型语言先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：C/C++ 等。 解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：Java、python 等。 严格来说，传统的 Java 是解释型语言，但加入了 JIT、AOT 编译器后，让 Java 也拥有了编译型语言的特性。它总共有三种执行的方式： Java 源代码首先经过 Javac 编译成 .class 文件，然后： 解释执行：.class 文件经过 JVM 内嵌的解释器解释执行。 编译执行：即时编译器（Just In Time 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热） 编译执行: Java 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成） Java 与 C++ 的区别Java 和 C++ 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：C++ 是编译型语言，Java 是解释型语言。 二者主要区别如下： - Java C++ 语言类型 解释型 编译型 平台相关性 跨平台 平台相关的 语言 纯粹的面向对象语言 既支持面向对象也支持面向过程 数字类型 在所有平台上基本类型有标准的范围限制和字节长度 对数字类型有标准的范围限制但字节长度跟具体实现有关 参数传递 只有值传递它的引用可以理解为安全指针 有值传递和引用传递 内存管理 自动垃圾回收 需要显示的内存管理，支持析构函数 继承与实现 支持多重继承 只允许单继承，但可以多实现 操作符 不支持操作符重载仅对 String 有两个内置的加法运算 支持操作符重载 JDK、JRE、JVM下图是 Oracle 官方文档中的 JDK、JRE、JVM 三者间的关系： 三者详细： JDK：Java Development Kit（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。 JRE: Java Runtime Enviroment（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。 JVM：Java Virtual Machine（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。 跨平台特性Java 的跨平台特性与 Java 虚拟机的存在密不可分。其实 Java 语言本身与其他编程语言没有特别大的差异，并不是说 Java 语言可以跨平台，而是在不同的平台都有可以让 Java 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 JDK，安装 JDK 也就有了 Java 的运行环境。 简单来说，Java 首先通过 javac 编译器将源码编译为字节码 .class 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 JVM 会可以根据不同的平台，使用不同的 JVM 映射规则，生成对应的机器码，让其与操作系统无关。所以 Java 才有了“编译一次，到处运行”的效果。 Java 平台Java 是一种面向对象的语言，最显著的特性有两个方面： 跨平台特性。也就是“编译一次，到处运行”（Compile once, run anywhere)，能够非常容易地获得跨平台能力； 垃圾回收机制。Java 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。 对于 Java 平台，有很多个方面可以谈： Java 语言特性：面向对象特性、泛型、Lamdba 等 基础类库：集合、IO/NIO、网络、并发等基础类库 JVM：类加载机制、垃圾回收、常用工具 Java 生态：JavaEE、Spring、Maven、Hadoop 等 下图是总结的一个蓝图： 参考资料 《Java 编程思想》 Hollis：牢记面向对象五个基本原则 十四期_李光：面向对象与面向过程的本质的区别]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
