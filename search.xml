<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[抽象类和接口]]></title>
    <url>%2F2018%2F11%2F06%2FAbstractClassAndInterface%2F</url>
    <content type="text"><![CDATA[抽象类抽象方法指的是仅有声明而没有方法体的方法。使用 abstract 关键字进行声明：1abstract void f() 而包含一个或多个抽象方法的类，就叫抽象类，用 abstract关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。 抽象类的主要目的是代码重用。大多用于抽象相关 Java 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 java.util.AbstractList。 接口接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 static 和 final 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 enum 枚举类。 接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 Cloneable、Serializable，表示这个类可以克隆或者可以序列化。 Java 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。 12345678910111213141516171819202122232425interface Study &#123; void study();&#125;interface Play &#123; void play();&#125;Class Person &#123; public void doSomething() &#123; System.out.println("person doSomething"); &#125;&#125;public class Student extends Person implements Study, Play &#123; @Override public void doSomething() &#123; System.out.println("student doSomething"); &#125; void study() &#123; System.out.println("study"); &#125; void play() &#123; System.out.println("play"); &#125;&#125; 抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。 1234567891011121314151617181920212223interface Diner &#123; void eat();&#125;interface Sleeper &#123; void sleep();&#125;// 接口可以继承接口（支持多继承）interface Student extends Diner, Sleeper &#123; void study();&#125;// 抽象类可以实现接口abstract class Undergraduate implements Student &#123; @Override public void eat() &#123; System.out.println("eat"); &#125; @Override public void sleep() &#123; System.out.println("sleep"); &#125; public abstract void study();&#125; 抽象类与接口比较 一个类只能继承一个抽象类，但可以实现多个接口； 接口中的字段只能是 static 和 final 的，而抽象类的字段没有限制； 接口中的方法只能是 public 的，而抽象类的方法则没有限制。 一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 Java8 开始也增加了默认方法，使得修改接口的成本也降低很多。 如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。 默认方法在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。 所以从 Java8 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。 1234567public interface Sized &#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 例如，Java 8 中 List 接口的 sort 方法就是默认方法。 123456789default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 1.可选方法 默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。 例如，在 Java8 中，Iterator 接口为 remove 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 Iterator 接口的每一个类都声明一个空的 remove 方法。 1234567interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next(); default void remove() &#123; throw new UnSupportedOperationException(); &#125;&#125; 2.行为的多继承 默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法: 1234567891011121314151617interface Moveable &#123; int getX(); void setX(int x); default void moveHorizontally(int distance) &#123; setX(getX() + distance); &#125;&#125;interface Resizable &#123; int getWidth(); void setWidth(int width); default void resizeWidth(int distance) &#123; setWidth(getWidth() + distance); &#125;&#125; 12345678public class Change implements Moveable, Resizable &#123; public static void main(String[] args) &#123; Change c = new Change(); c.moveHorizontally(10); c.resizeWidth(10); &#125;&#125; 解决冲突Java 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。 第一条规则 在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 1234567891011121314151617interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;class B &#123; public void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C extends B implements A &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125; 上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。 第二条规则 如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。 123456789101112131415161718interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B extends A &#123; default void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello form B 在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。 第三条规则 如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。 1234567891011121314151617181920212223interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B &#123; default void hello() &#123; System.out.println("hello from B"); &#125;&#125;public class C implements A, B &#123; @Override public void hello() &#123; A.super.hello(); &#125; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello from A 上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 hello 方法，并且在调用时，使用 X.super.f() 这种语法，显式地指定使用哪一个接口中的方法。 参考资料 《Java 编程思想》 《Java8 实战》]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的运算]]></title>
    <url>%2F2018%2F11%2F05%2FJavaOperation%2F</url>
    <content type="text"><![CDATA[值传递与引用传递先来看一下值传递与引用传递的概念： 值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。 引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。 那么 Java 中到底是值传递还是引用传递？先来看下面的例子： 123456789101112public static void change(int j) &#123; j = 2; System.out.println("change: j = " + j);&#125;public static void main(String[] args) &#123; int i = 1; change(i); System.out.println("main: i = " + i);&#125;// change: j = 2// main: i = 1 可以看到，change 方法内部并没有改变实际参数的值，那么 Java 就是值传递吗？再来看下面的例子： 1234567891011121314public static void change(User user) &#123; user.setAge(21); System.out.println("change: " + user);&#125;public static void main(String[] args) &#123; User user = new User(); user.setName("Timber"); user.setAge(20); change(user); System.out.println("main: " + user);&#125;// change: User&#123;name='Timber', age=21&#125;// main: User&#123;name='Timber', age=21&#125; 可以看到，实际参数的值被改变了，那么 Java 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子： 123456789101112public static void change(String name2) &#123; name2 = "TimberLiu"; System.out.println("change: " + name2);&#125;public static void main(String[] args) &#123; String name1 = "Timber"; change(name1); System.out.println("main: " + name1);&#125;// change: TimberLiu// main: Timber 可以看到，实际参数的值又被改变了，这又作何解释呢？ Java 的值传递其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 传递参数时是否会进行拷贝，创建一个副本。 再来看一下上面的第二个例子，是如何传递的呢？ 可以看到，当把 user 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？ 12345678910111213141516public static void change(User user2) &#123; user2 = new User(); user2.setName("TimberLiu"); user2.setAge(21); System.out.println("change:" + user2);&#125;public static void main(String[] args) &#123; User user1 = new User(); user1.setName("Timber"); user1.setAge(20); change(user1); System.out.println("main: " + user1);&#125;// change: User&#123;name='TimberLiu', age=21&#125;// main: User&#123;name='Timber', age=20&#125; 这个过程发生了什么呢？看下图： 可以看到，这里把 user1 传递给 change 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 change 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 user2 的修改并不会影响到 user1 中的内容。 所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。 那么，为什么上面在传递 String 对象和 User 对象结果不一样呢？这是因为 String 类型是不可变的，在赋值 name2 = &quot;TimberLiu&quot; 时，会重新创建一个 String，而并没有修改实际参数的值。 所以，Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用。 类型转换Java 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下： 在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。 另外，在对基本数据进行运算时，所有 byte、short、char 类型的值都会自动被提升为 int。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。 在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子： 123456789public class Overflow &#123; public static void main(String[] args) &#123; int big = Integer.MAX_VALUE; System.out.println("big = " + big); System.out.println("bigger = " + (big + 1)); &#125;&#125;// big = 2147483647// bigger = -2147483648 switch 对 String 的支持switch 原本只支持整型，而 byte、short、char 可以转换为 int 型，所以也可以使用。但从 Java7 开始，在 switch 条件判断语句中也可以使用 String 类型了。 123456789101112public void decompile(String str) &#123; switch(str) &#123; case "aaa": System.out.println("aaa"); break; case "bbb": System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 在反编译后，可以看到： 12345678910111213141516171819202122232425public void decompile(String str) &#123; byte var3 = -1; switch(str.hashCode()) &#123; case 96321: if (str.equals("aaa")) &#123; var3 = 0; &#125; break; case 97314: if (str.equals("bbb")) &#123; var3 = 1; &#125; &#125; switch(var3) &#123; case 0: System.out.println("aaa"); break; case 1: System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 可以看到，String 的 switch 还是比较的 byte 类型。先声明了一个 byte 类型，然后通过 hashCode 和 equals 两个方法先后进行比较来赋予 byte 变量不同的值，最后 switch 来执行不同的代码。这里在 hash 之后再进行 equals 判断是有必要的，因为 hash 可能发生碰撞。 参考资料 Hollis：为什么说Java中只有值传递 SEU_Calvin：Java技术——Java中的参数传值方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型]]></title>
    <url>%2F2018%2F11%2F03%2FBasicDateType%2F</url>
    <content type="text"><![CDATA[基本数据类型Java 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下： Java 中的 char 使用 Unicode 编码，占两个字节。所以在 Unicode 编码中存在的中文，都可以用 char 存储。 在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：Java中，为什么 byte 类型的取值范围为-128~127?。 浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。Java 中使用 IEEE754表示法，分为单精度和双精度两种，也就是 float 和 double，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。 包装类型每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别： 默认值不同。基本类型的默认值为 0、false 等；而包装类默认为 null 初始化不同。基本类型不需要初始化；而包装类需要 new。 存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中 元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法 基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 Java5 提供的一个语法糖。自动装箱就是 Java自动将原始类型值转换为对应的对象；自动拆箱就是 Java 自动将对象转换为对应的基本类型。例如： 1234public static void main(String[] args) &#123; int i = 1; Integer n = i;&#125; 在反编译后，代码如下： 1234public static void main(String[] args) &#123; int i = 1; Integer n = Integer.valueOf(i);&#125; 可以看到，自动装箱就是调用 Integer 的 valueOf() 方法实现的；而自动拆箱是调用 Integer 的 xxxValue() 方法实现的。 整型的缓存机制Java5 中，Integer 引入了一个新功能来节省内存和提高性能。在使用 Integer.valueOf()方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。 valueOf() 方法的实现如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 Integer 对象。 IntegerCache 是 Integer 的一个内部类，缓存池的大小默认为 -128~127。最大值可通过 -XX:AutoBoxCacheMax=xxx 修改。这个缓存在 Integer 类第一次被使用时，通过一个 for 循环存储在一个整数数组中。 1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 由于编译器在自动装箱时会调用 valueOf 方法，所以创建多个相同的值时，会引用相同的对象。 123456public static void main(String[] args) &#123; Integer i = 123; Integer j = 123; System.out.println(i == j);&#125;// true 所有的包装类都有类似的缓存机制： ByteCache 可以缓存 Byte 对象 ShortCache 可以缓存 Short 对象 LongCache 可以缓存 Long 对象 CharacterCache 可以缓存 Character 对象 Byte、Short、Long 的缓存范围都是固定的，为 -128~127。而 CharacterCache 的范围为 0~127。除了 Integer，这个范围都不能改变。 高精度类型Java 还提供了两个用于高精度计算的类：BigInteger 和 BigDecimal。 BigInteger 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。 BigDecimal 支持任意精度的定点数。可以用它进行精确的货币运算。 在 Java 中，对于金额的运算和在数据库中的存储，一般有两种方式： 以元为单位。Java 中存储类型为 BigDecimal，在数据库中的存储类型为 number(10, 2)，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。 以分为单位。Java 中存储类型为 Long，在数据库中存储类型为 big int。取整和保留方式如前面一样。 看一下下面的例子： 123456public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);&#125; 在进行金额运算时，使用 BigDecimal 类，并且将 double 转为 String 类型进行运算。在使用 divide 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。 参考资料 Hollis：[译]Java中整型的缓存机制]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象中的一些概念]]></title>
    <url>%2F2018%2F11%2F01%2FObject-orientedConcept%2F</url>
    <content type="text"><![CDATA[this、superthis 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 this 调用构造器，但必须将构造器置于最起始处。 123456789101112public class User&#123; private String name; private int age; public User(String name) &#123; this.name = name; &#125; public User(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super 关键字表示如果子类重写了父类的某个方法，可以通过 super 关键字来调用父类的方法实现，也可以用来调用父类的构造器。 123456789101112public class Person&#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void say() &#123; System.out.println(name + ":" + age); &#125;&#125; 12345678910111213141516171819public class Student extends Person &#123; private int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; @Override public void say() &#123; super.say(); System.out.println(name + ":" + age + "," + score); &#125; public static void main(String[] args) &#123; Student student = new Student("Timber", 20, 80); student.say(); &#125;&#125;// Timber:20// Timber:20,80 finalfinal 关键字可用于三种情况：变量、方法和类。 1.变量 对于基本类型时，final 使数值恒定不变；对于引用类型时，final 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。 另外，在参数列表中还可以将参数声明为 final，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。 2.方法 final 方法不可以被重写。 类中所有的 private 方法都隐式地指定为 final，所以 private 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。 3.类 final 类不能被继承，而且 final 类中的所有方法都隐式地被指定为 final，无法覆盖它们。 static当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 static 方法或访问其 static 域。 1.变量 当 static 作用于某个字段时，会改变数据的创建方式，因为 static 字段对每个类只有一份存储空间，存放在方法区中；而非 static 字段则对每个对象都有一个存储空间，存放在堆中。 2.方法 对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 this 关键字。而 static 方法就是没有 this 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 static 方法，实际上这正是 static 方法的主要用途。 3.静态块 Java 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。 123456public Class User &#123; private String name; static &#123; name = "Timber"; &#125;&#125; 这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。 重写与重载1.重写 重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。 1234567891011121314151617class Person &#123; public void doSomething() &#123; System.out.println("do something"); &#125;&#125; class Student extends Person&#123; @Override public void doSomething() &#123; System.out.println("studying"); &#125; public static void main(String[] args) &#123; Person person = new Student(); person.doSomething(); &#125;&#125;// studying 上面就是一个重写的例子。重写一般需要注意以下几点： 子类方法的方法签名必须和父类方法相同； 子类方法的返回类型必须小于等于父类的方法； 子类中的访问权限必须大于等于父类的方法； 子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常 不能重写被标识为 final 的方法 重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。 12345678910111213141516public class Person &#123; String s = "person";&#125;public class Student extends Person &#123; String s = "student";&#125;public class Test &#123; public static void main(String[] args) &#123; Person a1 = new Student(); System.out.println("a1.s: " + a1.s); Student a2 = new Student(); System.out.println("a2.s: " + a2.s); &#125;&#125;// a1.s: person// a2.s: student 2.重载 重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。 123456789class Person&#123; public void doSomething() &#123; System.out.println("studying"); &#125; public void doSomething(String thing) &#123; System.out.println("studying " + thing); &#125;&#125; 上面就是一个重载的例子。重载一般需要注意几点： 被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。 根据方法的返回值不能区分重载 重载涉及到基本类型的自动提升时可能会造成混淆。 构造器构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 new 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。 一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 new Person() 创建对象时就会报错。 对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 int 初始化为 0，引用类型初始化为 null等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。 对象的创建过程如下： 当首次创建类对象，或者类的静态方法/静态域被首次访问时，Java 解释器查找类文件； 然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。 如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 null； 然后执行出现于成员变量定义处的初始化动作； 然后再执行构造器。 多态多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件： 有类继承或接口实现 子类要重写父类的方法 父类的引用指向子类的对象 根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对 Java 平台的理解]]></title>
    <url>%2F2018%2F10%2F30%2FTheJavaPlatform%2F</url>
    <content type="text"><![CDATA[Java 是一种面向对象的语言，最显著的特性有两个方面： 跨平台特性。也就是“编译一次，到处运行”（Compile once, run anywhere)，能够非常容易地获得跨平台能力； 垃圾回收机制。Java 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。 解释型语言先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：C/C++ 等。 解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：Java、python 等。 严格来说，传统的 Java 是解释型语言，但加入了 JIT、AOT 编译器后，让 Java 也拥有了编译型语言的特性。它总共有三种执行的方式： Java 源代码首先经过 Javac 编译成 .class 文件，然后： 解释执行：.class 文件经过 JVM 内嵌的解释器解释执行。 编译执行：即时编译器（Just In Time 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热） 编译执行: Java 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成） Java 与 C++ 的区别Java 和 C++ 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：C++ 是编译型语言，Java 是解释型语言。 二者主要区别如下： - Java C++ 语言类型 解释型 编译型 平台相关性 跨平台 平台相关的 语言 纯粹的面向对象语言 既支持面向对象也支持面向过程 数字类型 在所有平台上基本类型有标准的范围限制和字节长度 对数字类型有标准的范围限制但字节长度跟具体实现有关 参数传递 只有值传递它的引用可以理解为安全指针 有值传递和引用传递 内存管理 自动垃圾回收 需要显示的内存管理，支持析构函数 继承与实现 支持多重继承 只允许单继承，但可以多实现 操作符 不支持操作符重载仅对 String 有两个内置的加法运算 支持操作符重载 JDK、JRE、JVM下图是 Oracle 官方文档中的 JDK、JRE、JVM 三者间的关系： 三者详细： JDK：Java Development Kit（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。 JRE: Java Runtime Enviroment（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。 JVM：Java Virtual Machine（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。 跨平台特性Java 的跨平台特性与 Java 虚拟机的存在密不可分。其实 Java 语言本身与其他编程语言没有特别大的差异，并不是说 Java 语言可以跨平台，而是在不同的平台都有可以让 Java 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 JDK，安装 JDK 也就有了 Java 的运行环境。 简单来说，Java 首先通过 javac 编译器将源码编译为字节码 .class 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 JVM 会可以根据不同的平台，使用不同的 JVM 映射规则，生成对应的机器码，让其与操作系统无关。所以 Java 才有了“编译一次，到处运行”的效果。 Java 平台对于 Java 平台，有很多个方面可以谈： Java 语言特性：面向对象特性、泛型、Lamdba 等 基础类库：集合、IO/NIO、网络、并发等基础类库 JVM：类加载机制、垃圾回收、常用工具 Java 生态：JavaEE、Spring、Maven、Hadoop 等 下图是总结的一个蓝图：]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解面向对象思想]]></title>
    <url>%2F2018%2F10%2F28%2FObject-orientedThought%2F</url>
    <content type="text"><![CDATA[学习 Java 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。 Java 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 Java 平台又该如何理解？今天就来学习一下。 面向对象思想所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。 而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。 在面向对象程序设计中会创建抽象数据类型，也就是类 class，它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。 三大特征1.封装 封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。 Java 用三个关键字在类内设定边界：public、protected、private，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。 2.继承 代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 private，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。 另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写 overriding。 那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。 3.多态 在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。 在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。 五大设计原则面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。 单一职责（Single Responsibility）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。 开关封闭（Open-Closed）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。 里氏替换（Liskov Substitution）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。 接口隔离（Interface-Segregation）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。 依赖倒置（Dependency Inversion）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。 对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。 参考资料 《Java 编程思想》 Hollis：牢记面向对象五个基本原则 十四期_李光：面向对象与面向过程的本质的区别]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(1)]]></title>
    <url>%2F2018%2F01%2F06%2FOperatingSystem1%2F</url>
    <content type="text"><![CDATA[勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。参考学习： 书籍：《现代操作系统》、《深入理解计算机系统》 视频：学堂在线 - 操作系统（自主模式） 操作系统知识点 操作系统概述： 操作系统的定义以及功能； 计算机系统体系结构； 操作系统的四个特性：并发、共享、虚拟、异步； 用户态和核心态的区别； 进程和线程： 进程的几种状态及其转换； 进程与线程的区别； 进程调度的算法； 进程同步的方式； 进程通信的方式； 死锁： 死锁的概念、导致死锁的原因； 导致死锁的四个必要条件； 处理死锁的四种方式：预防、避免、检测、解除； 存储器： 内存连续分配方式采用的算法及优缺点； 分页存储管理方式； 分段存储管理方式； 段页式存储管理方法； 几种存储方式的比较及各自优缺点； 从逻辑地址到物理地址的转换过程； 虚拟存储器： 虚拟存储器的定义与实现方式； 页面置换算法，计算所需换页数； 文件系统： 文件系统基本概念； 文件分配方式； 什么是操作系统计算机系统一般由一个或多个处理器、内存、I/O 设备等组成，而操作系统就是这些硬件之上的一种软件，它为应用程序提供了一个抽象，并管理这些计算机资源。具体可以从功能上来认识操作系统。 作为扩展机器，它隐藏硬件底层实现细节，对硬件提供抽象，方便程序或用户的使用： 进程是对 CPU、主存及 I/O 设备的抽象； 虚拟内存（虚拟地址空间）是对主存和 I/O 设备的抽象； 文件是对 I/O 设备的抽象； 作为资源管理器，它在多个竞争程序之间合理地控制对处理器、存储器及 I/O 设备的分配，避免资源使用冲突。有两种共享资源的方式： 时间复用：不同程序或用户轮流使用； 空间复用：每个程序或用户得到资源的一部分； 内核态和用户态如下图是一般计算机系统的简化图。多数计算机有两种运行模式：内核态和运行态。 操作系统运行在内核态，它对所有硬件具有访问权，可以执行任何指令。用户接口程序和其余软件运行在用户态，它只能执行机器指令中的一个子集。 四大特性操作系统主要有四大特性，分别为： 并发：在宏观上有多个程序在同时运行，需要 OS 管理和调度，而在微观上是分时交替运行； 注意并发和并行的区别： 并发指的是在一段时间内有多个应用程序可以运行； 并行指的是在一个时间点有多个应用程序可以执行，并行需要计算机有多个 CPU； 共享：资源可以供内存中多个并发执行的进程共同使用，在宏观上是同时访问该资源，而在微观上是采用互斥共享。 虚拟：利用多道程序设计，让每个应用程序都觉得有一个计算机专门为它服务。 异步：程序的执行不是连贯的，而是间断性的，其速度也不可知，但只要运行环境相同，其运行结果需要保证相同。 计算机体系结构计算机系统主要由处理器、主存、I/O 设备及系统总线组成。 处理器 也称中央处理单元（CPU），是用来解释或执行主存中的指令的引擎。在任何时候，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，指向下一条指令。 主存 主存，是一个临时存储设备，用来存放程序和程序要处理的数据。存储系统大多采用分层次的存储结构。如下图： 存储层次最顶层是寄存器。下一层是两层高速缓存 L1、L2。再下一层是主存，所有不能再高速缓存行命中的访问请求会转到内存。如果内存中还没有，可能还会到虚拟内存中查找。 在层次结构中，较高层次的存储设备可以作为较低层次设备的高速缓存。更高层次的存储设备比底层的更快，但价格也更昂贵。 I/O 设备 I/O 设备是系统与外界联系的通道。主要包括磁盘、显示器、键盘等。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连，来传递信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
