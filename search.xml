<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[序列化与反序列化]]></title>
    <url>%2F2019%2F02%2F17%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[序列化与反序列化序列化(Serialization)是将对象转换为可传输的格式的过程，一般是以字节码或 XML 格式传输。而反序列化是将字节码或 XML 码编码格式还原为完全相等的对象的过程。 对象序列化机制也是一种对象持久化方式，通过对象序列化，可以把对象的状态保存为字节数组，并在需要时将这个字节数组通过反序列化的方式再转换成对象，如此可以很容易地在对象和字节数组之间进行转换。 除了持久化时用到序列化之外，当在网络中传输对象、使用 RMI 和 RPC 时，都会用到对象序列化。 如何序列化Java 中提供了一套方便的 API 来支持，将对象进行序列化和反序列化。其中包括以下接口和类： java.io.Serializable java.io.Externalizable ObjectOutputStream ObjectInputStream ObjectOutput ObjectInput ObjectInput 和 ObjectOutput 接口ObjectInput ObjectInput 接口扩展自 DataInput 接口以包含对象的读操作。 DataInput 接口用于从二进制流中读取字节，并根据所有 Java 基本类型数据进行重构。同时还提供根据 UTF-8 修改版格式的数据重构 String 的工具。 对于此接口中的所有数据读取例程来说，如果在读取所需字节数之前已经到达文件末尾 (end of file)，则将抛出 EOFException（IOException 的一种）。如果因为到达文件末尾以外的其他原因无法读取字节，则将抛出 IOException 而不是 EOFException。尤其是，在输入流已关闭的情况下，将抛出 IOException。 ObjectOutput ObjectOutput 扩展 DataOutput 接口以包含对象的写入操作。 DataOutput 接口用于将数据从任意 Java 基本类型转换为一系列字节，并将这些字节写入二进制流。同时还提供了一个将 String 转换成 UTF-8 修改版格式并写入所得到的系列字节的工具。 对于此接口中写入字节的所有方法，如果由于某种原因无法写入某个字节，则抛出 IOException。 ObjectInputStream 和 ObjectOutputStream 类通过 ObjectOutputStream 和 ObjectInputStream 可以对对象进行序列化及反序列化。一般使用 ObjectOutputStream 的 writeObject 方法把一个对象进行持久化，再使用 ObjectInputStream 的 readObject 从持久化存储中把对象读取出来。 Serializable 接口Java 中，只要类实现 java.io.Serializable 接口就表示可以被序列化。没有实现此接口的类将无法使其任何状态序列化或反序列化。序列化接口没有方法或字段，仅用于标识可序列化的语义。 当试图对一个对象进行序列化的时候，如果遇到不支持 Serializable 接口的对象。在此情况下，将抛出 NotSerializableException。 如果要序列化的类有父类，要想同时将在父类中定义过的变量持久化下来，那么父类也应该实现 java.io.Serializable 接口。 举个栗子，下面是一个实现了 java.io.Serializable 接口的类： 1234567891011121314151617181920212223242526public class User1 implements Serializable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 对这个 User1 对象进行序列化和反序列化： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class SerializableTest &#123; public static void main(String[] args) &#123; User1 user = new User1(); user.setName(&quot;timber&quot;); user.setAge(20); System.out.println(&quot;before: &quot; + user); // Write Obj to File ObjectOutputStream oos = null; try &#123; oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;)); oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (oos != null) &#123; try &#123; oos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; // Read Obj from File File file = new File(&quot;tempFile&quot;); ObjectInputStream ois = null; try &#123; ois = new ObjectInputStream(new FileInputStream(file)); User1 newUser = (User1) ois.readObject(); System.out.println(&quot;after: &quot; + newUser); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ois != null) &#123; try &#123; ois.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; file.delete(); &#125; &#125;&#125; 打印结果为： 12before: User1&#123;name=&apos;timber&apos;, age=20&#125;after: User1&#123;name=&apos;timber&apos;, age=20&#125; Externalizable 接口除了 Serializable 之外， Java 中还提供了另一个序列化接口 Externalizable 来自定义序列化和反序列化策略。该接口中定义了抽象方法：writeExternal 与 readExternal 方法。当使用 Externalizable 进行序列化和反序列化时需要实现这两个方法。 如果在这两个方法中没有定义序列化实现细节，进行序列化和反序列化后得到的对象的所有属性的值都变成了默认值。也就是说之前的那个对象的状态并没有被持久化下来。 另外，若使用 Externalizable 接口进行序列化，在读取对象时，会调用被序列化类的无参构造器去创建一个新的对象，然后再将被保存对象的字段的值分别填充到新对象中。所以，实现 Externalizable 接口的类必须要提供一个 public 的无参的构造器。 下面是一个实现 Externalizable 接口的类： 1234567891011121314151617181920212223242526272829303132333435363738public class User2 implements Externalizable &#123; private String name; private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(name); out.writeInt(age); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; name = (String) in.readObject(); age = in.readInt(); &#125; @Override public String toString() &#123; return &quot;User1&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; 对这个 User2 对象进行序列化和反序列化： 1234567891011121314151617181920212223242526public class ExternalizableTest &#123; public static void main(String[] args) &#123; User2 user = new User2(); user.setName(&quot;timber&quot;); user.setAge(20); System.out.println(user); //Write Obj to file try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(&quot;tempFile&quot;))) &#123; oos.writeObject(user); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //Read Obj from file File file = new File(&quot;tempFile&quot;); User2 user2 = null; try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file))) &#123; user2 = (User2) ois.readObject(); &#125; catch (IOException | ClassNotFoundException e) &#123; e.printStackTrace(); &#125; System.out.println(user2); &#125;&#125; 相关知识transient 关键字transient 关键字可以控制变量的序列化。如果在变量声明前加上该关键字，可以阻止该变量被序列化。在被反序列化时，transient 变量的值被设为初始值，如 int 类型是 0，引用类型是 null。 序列化ID虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID)。 序列化 ID 一般有两种生成策略： 一种是固定的 1L。如果没有特殊需求，就是用默认的 1L 就可以； 一种是随机生成一个不重复的 long 类型数据。有时可通过改变序列化 ID 可以用来限制某些用户的使用。 静态变量在 Java 序列化保存对象时，会将其状态保存为一组字节，在需要时将这些字节封装成对象。这里的状态指的是对象的成员变量，也就是说不会保存类中的静态变量。 Serializable接口为空？Serializable 虽只是一个空接口。但底层实现中，在序列化操作时，会判断要被序列化的类是否是 Enum、Array 和 Serializable 类型，如果不是则直接抛出 NotSerializableException。以此来保证只有实现了该接口的方法才能进行序列化与反序列化。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 源码阅读]]></title>
    <url>%2F2019%2F02%2F16%2FString%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[本文基于 JDK1.8，在其他版本中会有不同。 定义及属性12public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; String 类被 final 修饰，表示不可变。实现了 Serializable, Comparable&lt;String&gt;, CharSequence 接口。 value[]：String 类底层通过 final 类型的 char 数组实现，用于存储字符串内容； hash：用于缓存当前字符串的 hashcode 值，默认为 0； 构造器String 类中重载的构造器很多，其中比较常用的有： 字符串构造1234public String(String original) &#123; this.value = original.value; this.hash = original.hash;&#125; 用一个 String 类型的对象来初始化 String。实现中直接将源 String 的 value 和 hash 两个属性直接赋值给目标 String。 可以看出，新创建的 String 对象是传入的参数 String 的一个副本。除非确实需要显式得赋值一个字符串对象，否则没有必要使用此构造器来创建一个 String 对象。 字符数组构造12345678public String(char value[]) &#123; this.value = Arrays.copyOf(value, value.length);&#125;public String(char value[], int offset, int count) &#123; // check bounds this.value = Arrays.copyOfRange(value, offset, offset+count);&#125; 也可以使用一个 char 数组来创建一个 String，实现中通过 Array.copyOf 或 Array.copyOfRange 方法，将原有的字符数组中的内容逐一地赋值到新 String 的字符数组中。 在复制时，即可以复制整个字符数组，也可以通过 offset 和 count 两个参数来复制字符数组的一部分。 字节数组构造123456public String(byte bytes[], int offset, int length, Charset charset) &#123; if (charset == null) throw new NullPointerException("charset"); checkBounds(bytes, offset, length); this.value = StringCoding.decode(charset, bytes, offset, length);&#125; 使用 byte 数组来构造一个 String，需要将 byte 数组转换为 char 数组。由于在网络传输中，经常需要在 byte[]、char[] 和 String 之间相互转化，所以 StringCoding 类提供了一系列重载的构造方法，例如这里的 StringCoding.decode(charset, bytes, offset, length) 方法，它通过指定的 charset 对 byte 数组解码为 unicode 的 char 数组，构造新的 String。 还有其他几种类似的构造方法，可以选择性地指定编码格式、解码的第一个字节下标、解码的字节数。 在 StringCoding.decode 方法中，如果没有指定编码格式，则默认使用 ISO-8859-1 格式进行操作。 常用方法比较方法equals 方法用于比较当前对象与传入的字符串对象是否相等。 123456789101112131415161718192021222324252627public boolean equals(Object anObject) &#123; // 如果它们是一个对象，肯定为 true if (this == anObject) &#123; return true; &#125; // 传入的对象必须是 String if (anObject instanceof String) &#123; // 将 Object 强转为 String 类型 String anotherString = (String)anObject; int n = value.length; // 两者的字符序列长度是否相等 if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; // 逐一比较两个字符数组的每一个字符 while (n-- != 0) &#123; // 只要有一个不等，即返回 false if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;&#125; regionMatches 方法用于比较当前对象与传入的字符串对象的指定区域是否相等。但可以传入一个 boolean 值用于指定是否忽略大小写。 1234567891011121314151617181920212223242526272829303132public boolean regionMatches(boolean ignoreCase, int toffset, String other, int ooffset, int len) &#123; char ta[] = value; int to = toffset; char pa[] = other.value; int po = ooffset; if ((ooffset &lt; 0) || (toffset &lt; 0) || (toffset &gt; (long)value.length - len) || (ooffset &gt; (long)other.value.length - len)) &#123; return false; &#125; while (len-- &gt; 0) &#123; char c1 = ta[to++]; char c2 = pa[po++]; if (c1 == c2) &#123; continue; &#125; if (ignoreCase) &#123; // 根据传入的 boolean 值来判断是否分别转换为大写、小写进行比较 char u1 = Character.toUpperCase(c1); char u2 = Character.toUpperCase(c2); if (u1 == u2) &#123; continue; &#125; if (Character.toLowerCase(u1) == Character.toLowerCase(u2)) &#123; continue; &#125; &#125; return false; &#125; return true;&#125; compareTo 方法按照字典序比较两个字符串的大小。 1234567891011121314151617181920public int compareTo(String anotherString) &#123; int len1 = value.length; int len2 = anotherString.value.length; int lim = Math.min(len1, len2); char v1[] = value; char v2[] = anotherString.value; int k = 0; // 逐一比较每一个字符的大小 while (k &lt; lim) &#123; char c1 = v1[k]; char c2 = v2[k]; if (c1 != c2) &#123; // 只要有一个能分为大小，即返回 return c1 - c2; &#125; k++; &#125; return len1 - len2;&#125; hashcode123456789101112public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125; String 类计算的 hashcode 的公式如下： 1s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1] getBytes1234public byte[] getBytes(Charset charset) &#123; if (charset == null) throw new NullPointerException(); return StringCoding.encode(charset, value, 0, value.length);&#125; 使用指定的字符集编码将 String 对象编码成一个 byte 数组。也有不指定编码格式的 getBytes 版本，会默认使用系统的编码方式，例如在中文操作系统中可能使用 GBK，在英文系统中可能使用 IOS-8859-1 格式。 indexOfindexOf 方法返回指定字符在当前 String 对象第一次出现的索引位置。 123456789101112131415161718192021222324public int indexOf(int ch, int fromIndex) &#123; final int max = value.length; if (fromIndex &lt; 0) &#123; fromIndex = 0; &#125; else if (fromIndex &gt;= max) &#123; return -1; &#125; // 一个完整的 Unicode 字符叫代码点 CodePoint， // String 对象以 UTF-16 保存 Unicode 字符，需要两个字符表示一个超大字符集的汉字 // 如果 cd 参数小于 Unicode 补充代码点的最小值 0x010000 if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; final char[] value = this.value; // 遍历字符数组 for (int i = fromIndex; i &lt; max; i++) &#123; // 如果当前字符等于 ch，则返回索引 i if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return indexOfSupplementary(ch, fromIndex); &#125;&#125; lastIndexOf 方法返回指定字符在当前 String 对象最后一次出现的索引位置。 1234567891011121314public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125;&#125; replacereplace 方法将当前字符串对象中所有的 oldChar 字符替换为 newChar，返回一个新的 String 对象。 123456789101112131415161718192021222324252627282930public String replace(char oldChar, char newChar) &#123; if (oldChar != newChar) &#123; int len = value.length; int i = -1; char[] val = value; // 从索引位置零开始，查找当前字符串中第一次出现字符 oldChar 的索引位置 while (++i &lt; len) &#123; if (val[i] == oldChar) &#123; break; &#125; &#125; if (i &lt; len) &#123; char buf[] = new char[len]; // 将 [0,i) 之间的字符直接缓存到 buf 字符数组中 for (int j = 0; j &lt; i; j++) &#123; buf[j] = val[j]; &#125; // 遍历 [i, len - 1] 之间的字符 while (i &lt; len) &#123; char c = val[i]; // 如果遍历到的字符与 oldChar 相等，则替换，否则保持不变 buf[i] = (c == oldChar) ? newChar : c; i++; &#125; return new String(buf, true); &#125; &#125; return this;&#125; 两个方法根据给定的正则表达式替换匹配到的第一个或全部的子字符串。 1234567public String replaceFirst(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceFirst(replacement);&#125;public String replaceAll(String regex, String replacement) &#123; return Pattern.compile(regex).matcher(this).replaceAll(replacement);&#125; valueOfcopyValueOf 方法将指定的字符数组转换成一个 String 对象。 123public static String copyValueOf(char data[], int offset, int count) &#123; return new String(data, offset, count);&#125; valueOf 方法将六种基本数据类型的变量转换成 String 类型。 123456789101112131415161718192021222324public static String valueOf(boolean b) &#123; return b ? "true" : "false";&#125;public static String valueOf(char c) &#123; char data[] = &#123;c&#125;; return new String(data, true);&#125;public static String valueOf(int i) &#123; return Integer.toString(i);&#125;public static String valueOf(long l) &#123; return Long.toString(l);&#125;public static String valueOf(float f) &#123; return Float.toString(f);&#125;public static String valueOf(double d) &#123; return Double.toString(d);&#125; concat将指定的字符串拼接到当期字符串的末尾。 123456789101112public String concat(String str) &#123; int otherLen = str.length(); if (otherLen == 0) &#123; return this; &#125; int len = value.length; // 创建一个 len + otherLen 大小的数组，将 value 拷贝过去 char buf[] = Arrays.copyOf(value, len + otherLen); // 将 str 中的字符拷贝到 buf 中 str.getChars(buf, len); return new String(buf, true);&#125; startsWith判断当前字符串从索引位置 toofset 开始是否以指定的前缀字符串开头。 12345678910111213141516public boolean startsWith(String prefix, int toffset) &#123; char ta[] = value; int to = toffset; char pa[] = prefix.value; int po = 0; int pc = prefix.value.length; if ((toffset &lt; 0) || (toffset &gt; value.length - pc)) &#123; return false; &#125; while (--pc &gt;= 0) &#123; if (ta[to++] != pa[po++]) &#123; return false; &#125; &#125; return true;&#125; 判断当前字符串是否以指定的前缀字符串开头或结尾。 1234567public boolean startsWith(String prefix) &#123; return startsWith(prefix, 0);&#125;public boolean endsWith(String suffix) &#123; return startsWith(suffix, value.length - suffix.value.length);&#125; trimtrim 方法可去掉字符串两端的空格。 12345678910111213141516public String trim() &#123; int len = value.length; int st = 0; char[] val = value; // 找到第一个不为 ' ' 的下标 while ((st &lt; len) &amp;&amp; (val[st] &lt;= ' ')) &#123; st++; &#125; // 找到最后一个不为 ' ' 的下标 while ((st &lt; len) &amp;&amp; (val[len - 1] &lt;= ' ')) &#123; len--; &#125; // 调用 substring 方法截取 [st, len] 之间的字符串 return ((st &gt; 0) || (len &lt; value.length)) ? substring(st, len) : this;&#125; 其他方法1234567891011121314// 返回字符串中第 index 个字符public char charAt(int index) // 将 String 转换为 字符数组public char[] toCharArray() // 将 String 按照字符 regex 分为 limit 份public String[] split(String regex, int limit)// 转换为大写public String toUpperCase()// 转换为小写public String toLowerCase()]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String 类详解]]></title>
    <url>%2F2019%2F02%2F15%2FString%E7%B1%BB%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[不可变性String 对象是不可变（Immutable）的，也就是一旦 String 类实例被创建后，就不能改变其值。这里的不可变指的是引用既不能指向其他对象，而且引用指向的对象的值也不能改变。 为什么不可变在 JDK1.6 中，String 类中的成员变量如下： 1234567891011public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123; /** The value is used for character storage. */ private final char value[]; /** The offset is the first index of the storage that is used. */ private final int offset; /** The count is the number of characters in the String. */ private final int count; 在 JDK1.7 中，String 类主要改变了 substring 方法的实现，成员变量剩下了两个： 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; /** The value is used for character storage. */ private final char value[]; 可以看出，String 就是字符数组的封装。在 JDK6 中，value 是一个 char 数组，offset 是 String 对象实际的起始位置，而 count 是所占的个数。在 JDK7 中，value 中的所有字符都属于 String 对象。 value、offset 和 count 这三个变量都是 private final 的，并且没有 setter 方法来修改，所以 String 类外部无法修改 String。所以，一旦初始化后就不能修改，String 对象也就是不可变的。 真的不可变吗String 中的 char 数组 value 是 private final 的，被 final 修饰 虽然不能指向其他数组对象，但却可以通过反射修改其指向的数组。 使用反射可以得到 String 类的 value 属性，修改访问权限，然后就可以对数组内容进行修改。 123456789101112131415public static void main(String[] args) throws Exception &#123; String s = "abc"; System.out.println(s); // 获取 value 字段 Field field = String.class.getDeclaredField("value"); // 修改 value 字段访问权限 field.setAccessible(true); // 获取 s 对象上 value 属性的值 char[] value = (char[]) field.get(s); value[1] = 'd'; System.out.println(s);&#125;// abc// adc 可以看到，通过反射是可以修改 “不可变” 对象的。 不可变的优点String 被设计为不可变的，在 Security、Cache、Thread Safe 方面都有很多优点： 安全性。String 被广泛地使用在其他 Java 类中充当参数。例如 网络连接、IO 操作、数据库连接等，如果字符串可变，那么可能会导致安全问题。 字符串常量池。String 类维护了一个运行时常量池，会对创建的字符串进行缓存，如此在使用时更加高效。而这就建立在不可变的基础上，不用担心数据冲突问题。 缓存 hashcode。Java 中经常用到字符串的哈希值，字符串的不可变能保证其 hashcode 永远保持一致，这样在每次使用一个字符串的 hashcode 时，就不用重新计算一次，也更加高效。 线程安全性。由于 String 对象不能被改变，所以同一个字符串实例可以被多个线程共享，而不用因为线程安全问题使用同步。 不可变的缺点当然，设计为不可变也会出现一些缺点，例如在类似拼接、裁剪等操作时，都会创建新的 String 对象，如果程序设计不当，便会产生大量无用的字符串对象，耗费时间空间。 “+” 的实现1、对于两个编译期常量(编译期可知)，例如 String s = &quot;a&quot; + &quot;b&quot;，编译器会进行常量折叠，即变成 String s = &quot;ab&quot;： 123456/** * String s1 = "ab"; * String s2 = "a1"; */String s1 = "a" + "b";String s2 = "a" + 1; 2、对于能够进行优化的(例如 String s = &quot;a&quot; + s1 等)用 StringBuilder 的 append() 方法替代，最后调用 toString() 方法 1234567891011121314151617/** * String s3 = (new StringBuilder()).append("a").append(s1).toString(); * String s4 = (new StringBuilder()).append(s2).append(s3).toString(); */String s3 = "a" + s1;String s4 = s2 + s3;/** * String s6 = * for (int i = 0; i &lt; 2; i++) &#123; * s6 = (new StringBuilder()).append(s6).append(i).toString(); * &#125; */String s6 = "";for (int i = 0; i &lt; 2; i++) &#123; s6 += i;&#125; substring 在 jdk6 和 7 的区别substring 是一个比较常用的方法，而且在 jdk6 和 jdk7 中的实现不同。substring(int beginIndex, in endIndex) 方法的作用是截取字符串并返回其 [beginIndex, endIndex - 1] 范围内的内容。 123String str = "abcdef";String substring = str.substring(2, 4);System.out.println(substring); 输出结果为：cd。 JDK6 中的 substring 前面说过，在 JDK 6 中，String 类的三个成员变量：char value[]，int offset，int count，三个变量决定了 String 存储的真正的字符数组。 String 中主要相关源码如下： 1234567891011String(int offset, int count, char value[]) &#123; this.value = value; this.offset = offset; this.count = count;&#125;public String substring(int beginIndex, int endIndex) &#123; // 检查边界 return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this : new String(offset + beginIndex, endIndex - beginIndex, value);&#125; 当调用 substring 方法时，会创建一个 String 对象，但 value 引用仍然指向堆中的同一个字符数组。它的内存变化： 如果字符串很长，在使用 substring 进行切割时只需要很短的一段，就可能导致性能问题.。因为只需要一小段字符串，但是却引用了整个字符串，这个很长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露。 JDK7 中的 substring 在 JDK7 中，主要剩下一个 value 变量，它的主要源码如下； 1234567891011public String(char value[], int offset, int count) &#123; // 检查边界 this.value = Arrays.copyOfRange(value, offset, offset+count);&#125;public String substring(int beginIndex) &#123; // 检查边界 int subLen = value.length - beginIndex; // 检查边界 return (beginIndex == 0) ? this : new String(value, beginIndex, subLen);&#125; 可以看到，JDK 7 中的 subString 方法，使用 new String 创建了一个新字符串，避免对老字符串的引用，从而解决了内存泄露问题。它的内存变化如下： StringBuffer、StringBuilderString String 是不可变对象，被声明为 final class，所有属性也都是 final 的。由于其不可变性，类似拼接、裁剪等操作，都会产生一个新的 String 对象，然后指针指向新的 String 对象，如果操作不当，可能会产生大量临时字符串。 在字符串内容不经常变化的业务场景优先使用 String 类。例如：常量声明、少量的字符串拼接等。 StringBuffer StringBuffer 是一个线程安全的可变字符序列。它解决了由于拼接产生太多中间对象的问题，可以用 append 或 add 方法，把字符串添加到字符串的末尾或指定位置。 它虽然保证了线程安全，也带来了额外的性能开销，所以除非有线程安全的需要，否则还是推荐使用 StringBuilder。 StringBulider StringBuilder 在能力与 StringBuffer 没有本质区别，但不保证同步，有效减小了开销。如果可能，在字符串拼接时建议优先使用。 为了能实现可修改的目的，StringBuffer 和 StringBuilder 底层都是可修改的数组，二者都继承了 AbstarctStringBuilder，包含了基本操作，区别仅在于最终的方法是否加了 synchronized。 JDK 9 改进在 JDK9 之前，String 类内部使用 char 数组来存储数据，但 char 是两个字节大小，这样就造成了一定的浪费。 在 JDK9 中，引入了 Compact Strings 的设计，对字符串进行改进，将 char 数组改变为 byte 数组加上一个标识编码的 coder，并且对相关字符串操作进行修改。 成员变量变化如下： 12345public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123; @Stable private final byte[] value; private final byte coder; 改进之后，在存储数据时，如果传入 byte 数组，直接赋值就好，如果传入 char 数组，其源码如下： 1234567891011121314151617String(char[] value, int off, int len, Void sig) &#123; if (len == 0) &#123; this.value = "".value; this.coder = "".coder; return; &#125; if (COMPACT_STRINGS) &#123; // COMPACT_STRINGS 默认初始化为 true byte[] val = StringUTF16.compress(value, off, len); if (val != null) &#123; this.value = val; this.coder = LATIN1; return; &#125; &#125; this.coder = UTF16; this.value = StringUTF16.toBytes(value, off, len);&#125; 其中，StringUTF16.compress 方法实现如下： 12345678910111213141516171819202122public static byte[] compress(char[] val, int off, int len) &#123; byte[] ret = new byte[len]; if (compress(val, off, ret, 0, len) == len) &#123; return ret; &#125; return null;&#125;···@HotSpotIntrinsicCandidatepublic static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) &#123; for (int i = 0; i &lt; len; i++) &#123; char c = src[srcOff]; if (c &gt; 0xFF) &#123; len = 0; break; &#125; dst[dstOff] = (byte)c; srcOff++; dstOff++; &#125; return len;&#125; 在 for 循环中，如果 char 数组中每一个字符都小于等于 0xFF，那么将 char 转换为 byte，完成构造，其 coder 为 LATIN1。 而如果存在一个大于 0xFF 的字符，就会跳出循环，最终 StringUTF6.compress 方法返回 null，通过 StringUTF16.toBytes 方法: 1234567891011121314151617181920212223@HotSpotIntrinsicCandidatepublic static byte[] toBytes(char[] value, int off, int len) &#123; byte[] val = newBytesFor(len); for (int i = 0; i &lt; len; i++) &#123; putChar(val, i, value[off]); off++; &#125; return val;&#125;public static byte[] newBytesFor(int len) &#123; // check bound return new byte[len &lt;&lt; 1];&#125;@HotSpotIntrinsicCandidate// intrinsic performs no bounds checksstatic void putChar(byte[] val, int index, int c) &#123; assert index &gt;= 0 &amp;&amp; index &lt; length(val) : "Trusted caller missed bounds check"; index &lt;&lt;= 1; val[index++] = (byte)(c &gt;&gt; HI_BYTE_SHIFT); val[index] = (byte)(c &gt;&gt; LO_BYTE_SHIFT);&#125; 通过 newBytesFor 方法 new 一个两倍长度的 byte 数组，在 for 循环中，通过 putChar 方法来填充 byte 数组，将 char 字符分为两部分，存储两个相邻的 byte 数组中。 String 类中方法基本都重新实现了一遍，但对外提供的接口没有改变。重构后，在字符串中所有字符小于 0xFF 时，可以节省一半的内存。 JDK 11 新特性JDK 11 中 String 类增加了一系列的字符串处理方法： 1234567891011121314151617// 判断字符串是否为空白System.out.println(" ".isBlank()); // true// 去除首尾空格System.out.println(" Timber ".strip()); // Timber// 去除首部空格System.out.println(" Timber".stripLeading()); // Timber// 去除尾部空格System.out.println("Timber ".stripTrailing()); // Timber// 重复字符串System.out.println("Timber".repeat(2)); // TimberTimber// 获取字符串中的行数System.out.println("A\nB\nC".lines().count()); // 3 参考资料 三张图彻底了解JDK 6和JDK 7中substring的原理及区别 JDK9的String类内部实现变更了！]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v2.0 环境搭建]]></title>
    <url>%2F2019%2F02%2F14%2Fmmallv2.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[Redis 配置与安装从官网下载 redis 到 /developer/setup 目录下 1wget http://download.redis.io/releases/redis-4.0.12.tar.gz 然后，将其解压到 /developer 目录下，进入到 redis-4.0.12 目录下，进行编译： 123tar -zxvf redis-4.0.12.tar.gz -C ../cd redis-4.0.12/make 再将其名修改为 redis-4.0.12_1，另外再拷贝一份为 redis-4.0.12_2： 12mv redis-4.0.12/ redis-4.0.12_1cp redis-4.0.12_1/ redis-4.0.12_2/ -R 然后，修改 redis-4.0.12_2/src/ 目录下的 redis.conf 文件，端口修改为 6380： 1port 6380 然后，分别进入到 src/ 目录下，后台启动 redis： 1./redis-server ../redis.conf &amp; Tomcat 配置多实例在单机部署多应用时，官方不建议复制一个又一份的全部 Tomcat 目录进行多实例的部署，而是按照如下图实现： CATALINA_HOME 指 Tomcat 的安装路径，包含 bin 和 lib 目录，而 CATALINA_BASE 指实例存放路径，包含 conf、webapps、logs 等目录。 复制出两个实例 首先新建两个 tomcat1、tomcat2 文件夹，并把 apache-tomcat-8.5.35 目录下的 conf、webapps、temp、logs、work 五个文件移动到 tomcat1 中，再将其复制一份到 tomcat2 中： 1234mkdir tomcat1 tomcat2cd apache-tomcat-8.5.11mv conf/ webapps/ temp/ logs/ work/ -t ../tomcat1cp -r ../tomcat1/* ../tomcat2 结果如下图所示： 配置 server.xml 端口 修改 conf/server.xml 中的三个端口： Server port：用于监听关闭 Tomcat 的 shutdown 命令，默认为 8005 Connector port：用于监听 HTTP 请求，默认为 8080 Connector port（protocol=”AJP/1.3”）：用于监听 AJP 协议上的请求，通常用于整合 Apache Server 等其他 HTTP 服务器，默认为 8009 将 tomcat2 实例的端口分别修改为 8006、8080、8010，并对 webapps/ROOT 下的 index.jsp 首页作相应修改。 创建启动、关闭脚本 新建一个 tomcat-shell 文件夹，存放启动和关闭脚本，并赋予其执行权限： 12345mkdir tomcat-shellcd tomcat-shell/vim start.shvim shutdown.shchmod u+x start.sh shutdown.sh start.sh 脚本如下： 12345678#!/bin/bashexport CATALINA_BASE=/developer/$1export CATALINA_HOME=/developer/apache-tomcat-8.5.35cd $CATALINA_HOME/binsh startup.sh shutdown.sh 脚本如下： 12345678#!/bin/bashexport CATALINA_BASE=/developer/$1export CATALINA_HOME=/developer/apache-tomcat-8.5.35cd $CATALINA_HOME/binsh shutdown.sh 启动和关闭脚本中，$1 表示执行时的第一个参数。 启动实例 执行以下命令，启动两个实例： 12./start.sh tomcat1./start.sh tomcat2]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v2.0 Redis + Cookie 实现单点登录]]></title>
    <url>%2F2019%2F02%2F14%2Fmmallv2.0redis%2Bcookie%E5%AE%9E%E7%8E%B0%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[电商项目中，在单服务器时，用户登录时将用户信息设置到 session 中，获取用户信息从 session 中获取，退出时从 session 中删除即可。 但在搭建 Tomcat 集群后，就需要考虑 Session 共享问题，可通过单点登录解决方案实现，这里主要有两种方法，一种是通过 Redis + Cookie 自己实现，另一种是借助 Spring Session 框架解决。 Redis+Cookie 实现单点登录的思路用户登录： 首先验证用户密码是否正确，并返回用户信息； 使用 uuid 或 session.getId 生成唯一 id(token)，设置到 cookie 中，将其写给客户端； 将用户信息(user 对象)转换为 json 格式； 以 key=token，value=(user 的 json 格式)，写到 redis 中，并设置过期时间； 退出登录： 用户请求时会携带 cookie，从 cookie 中获取到 token； 从请求中获取到 cookie，将其过期时间设置为 0，再写入到响应中，即删除了 token； 再从 redis 中删除 token； 获取用户信息： 从请求携带的 cookie 中获取到 token； 根据 token 在 redis 中查询相应的 user 对象的 json 串； 将 json 串转换为 user 对象； Redis 连接池及工具类由于 token 和 user 对象都会存储在 redis 中，所以这里封装一个 redis 的连接池和工具类。 首先，封装一个 redis 连接池，每次直接从连接池中获取 jedis 实例即可。 12345678910111213141516171819202122232425262728293031323334public class RedisPool &#123; private static JedisPool jedisPool; private static String redisIP = PropertiesUtil.getProperty("redis.ip", "192.168.23.130"); private static Integer redisPort = Integer.parseInt(PropertiesUtil.getProperty("redis.port", "6379")); // 最大连接数 private static Integer maxTotal = Integer.parseInt(PropertiesUtil.getProperty("redis.max.total", "20")); // 最大的 idle 状态的 jedis 实例个数 private static Integer maxIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.max.idle", "10")); // 最小的 idle 状态的 jedis 实例个数 private static Integer minIdle = Integer.parseInt(PropertiesUtil.getProperty("redis.min.idle", "2")); // 在 borrow 一个 jedis 实例时，是否要进行验证操作 private static Boolean testOnBorrow = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.borrow", "true")); // 在 return 一个 jedis 实例时，是否要进行验证操作 private static Boolean testOnReturn = Boolean.parseBoolean(PropertiesUtil.getProperty("redis.test.return", "true")); static &#123; JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(maxTotal); config.setMaxIdle(maxIdle); config.setMinIdle(minIdle); config.setTestOnBorrow(testOnBorrow); config.setTestOnReturn(testOnReturn); jedisPool = new JedisPool(config, redisIP, redisPort, 1000*2); &#125; public static Jedis getJedis() &#123; return jedisPool.getResource(); &#125; public static void returnJedis(Jedis jedis) &#123; jedis.close(); &#125;&#125; 然后，再将其封装成一个工具类，基本操作就是从 redis 连接池中获取 jedis 实例，进行 set/get/expire 等操作，然后将其放回到 redis 连接池中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970@Slf4jpublic class RedisPoolUtil &#123; // exTime 以秒为单位 public static Long expire(String key, int exTime) &#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.expire(key, exTime); &#125; catch (Exception e) &#123; log.error("expire key:&#123;&#125;, error", key, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; public static Long del(String key) &#123; Jedis jedis = null; Long result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.del(key); &#125; catch (Exception e) &#123; log.error("del key:&#123;&#125;, error", key, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; public static String get(String key) &#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.get(key); &#125; catch (Exception e) &#123; log.error("get key:&#123;&#125;, error", key, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; public static String set(String key, String value) &#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.set(key, value); &#125; catch (Exception e) &#123; log.error("set key:&#123;&#125;, value:&#123;&#125;, error", key, value, e); &#125; RedisPool.returnJedis(jedis); return result; &#125; // exTime 以秒为单位 public static String setEx(String key, String value, int exTime) &#123; Jedis jedis = null; String result = null; try &#123; jedis = RedisPool.getJedis(); result = jedis.setex(key, exTime, value); &#125; catch (Exception e) &#123; log.error("setex key:&#123;&#125;, value:&#123;&#125;, error", key, value, e); &#125; RedisPool.returnJedis(jedis); return result; &#125;&#125; JsonUtil 工具类将 user 对象存储在 redis 中，需要转换为 json 格式，从 redis 中获取 user 对象，又需要转换为 user 对象。这里封装一个 json 的工具类。 JsonUtil 工具类主要使用 ObjectMapper 类。 bean 类转换为 String 类型，使用 writerValueAsString 方法。 String 类型转换为 bean 类，使用 readValue 方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273@Slf4jpublic class JsonUtil &#123; private static ObjectMapper objectMapper = new ObjectMapper(); static &#123; // 序列化时将所有字段列入 objectMapper.setSerializationInclusion(JsonSerialize.Inclusion.ALWAYS); // 取消默认将 DATES 转换为 TIMESTAMPS objectMapper.configure(SerializationConfig.Feature.WRITE_DATES_AS_TIMESTAMPS, false); // 忽略空 bean 转 json 的错误 objectMapper.configure(SerializationConfig.Feature.FAIL_ON_EMPTY_BEANS, false); // 所有日期样式统一 objectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd HH:mm:ss")); // 忽略 在 json 字符串中存在，在 java 对象中不存在对应属性的情况 objectMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false); &#125; public static &lt;T&gt; String obj2Str(T obj) &#123; if (obj == null) &#123; return null; &#125; try &#123; return obj instanceof String ? (String) obj : objectMapper.writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error", e); return null; &#125; &#125; public static &lt;T&gt; String obj2StrPretty(T obj) &#123; if (obj == null) &#123; return null; &#125; try &#123; return obj instanceof String ? (String) obj : objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); &#125; catch (Exception e) &#123; log.warn("Parse Object to String error", e); return null; &#125; &#125; public static &lt;T&gt; T str2Obj(String str, Class&lt;T&gt; clazz) &#123; if (StringUtils.isEmpty(str) || clazz == null) &#123; return null; &#125; try &#123; return clazz.equals(String.class) ? (T)str : objectMapper.readValue(str, clazz); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error", e); return null; &#125; &#125; public static &lt;T&gt; T str2Obj(String str, TypeReference&lt;T&gt; typeReference) &#123; if (StringUtils.isEmpty(str) || typeReference == null) &#123; return null; &#125; try &#123; return typeReference.getType().equals(String.class) ? (T)str : objectMapper.readValue(str, typeReference); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error", e); return null; &#125; &#125; public static &lt;T&gt; T str2Obj(String str, Class&lt;?&gt; collectionClass, Class&lt;?&gt; elementClass) &#123; JavaType javaType = objectMapper.getTypeFactory().constructParametricType(collectionClass, elementClass); try &#123; return objectMapper.readValue(str, javaType); &#125; catch (Exception e) &#123; log.warn("Parse String to Object error", e); return null; &#125; &#125;&#125; CookieUtil 工具类登录时需要将 token 设置到 cookie 中返回给客户端，退出时需要从 request 中携带的 cookie 中读取 token，设置过期时间后，又将其设置到 cookie 中返回给客户端，获取用户信息时，获取用户信息时，需要从 request 中携带的 cookie 中读取 token，在 redis 中查询后获得 user 对象。这里呢，也封装一个 cookie 的工具类。 在 CookieUtil 中： readLoginToken 方法主要从 request 读取 Cookie； writeLoginToken 方法主要设置 Cookie 对象加到 response 中； delLoginToken 方法主要从 request 中读取 Cookie，将其 maxAge 设置为 0，再添加到 response 中； 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4jpublic class CookieUtil &#123; private static final String COOKIE_DOMAIN = ".happymmall.com"; private static final String COOKIE_NAME = "mmall_login_token"; public static String readLoginToken(HttpServletRequest request) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; log.info("read cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); if (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123; log.info("return cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); return cookie.getValue(); &#125; &#125; &#125; return null; &#125; public static void writeLoginToken(HttpServletResponse response, String token) &#123; Cookie cookie = new Cookie(COOKIE_NAME, token); cookie.setDomain(COOKIE_DOMAIN); cookie.setPath("/"); // 防止脚本攻击 cookie.setHttpOnly(true); // 单位是秒，如果是 -1，代表永久； // 如果 MaxAge 不设置，cookie 不会写入硬盘，而是在内存，只在当前页面有效 cookie.setMaxAge(60 * 60 * 24 * 365); log.info("write cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); response.addCookie(cookie); &#125; public static void delLoginToken(HttpServletRequest request, HttpServletResponse response) &#123; Cookie[] cookies = request.getCookies(); if (cookies != null) &#123; for (Cookie cookie : cookies) &#123; if (StringUtils.equals(COOKIE_NAME, cookie.getName())) &#123; cookie.setDomain(COOKIE_DOMAIN); cookie.setPath("/"); // maxAge 设置为 0，表示将其删除 cookie.setMaxAge(0); log.info("del cookieName:&#123;&#125;, cookieValue:&#123;&#125;", cookie.getName(), cookie.getValue()); response.addCookie(cookie); return; &#125; &#125; &#125; &#125;&#125; 具体业务登录时验证密码后： 12CookieUtil.writeLoginToken(response, session.getId());RedisShardedPoolUtil.setEx(session.getId(), JsonUtil.obj2Str(serverResponse.getData()), Const.RedisCacheExtime.REDIS_SESSION_EXTIME); 退出登录时： 123String loginToken = CookieUtil.readLoginToken(request);CookieUtil.delLoginToken(request, response);RedisShardedPoolUtil.del(loginToken); 获取用户信息时： 123456String loginToken = CookieUtil.readLoginToken(request);if (StringUtils.isEmpty(loginToken)) &#123; return ServerResponse.createByErrorMessage("用户未登录，无法获取当前用户信息");&#125;String userJsonStr = RedisShardedPoolUtil.get(loginToken);User user = JsonUtil.str2Obj(userJsonStr, User.class); SessionExpireFilter 过滤器另外，在用户登录后，每次操作后，都需要重置 Session 的有效期。可以使用过滤器来实现。 12345678910111213141516171819202122public class SessionExpireFilter implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest; String loginToken = CookieUtil.readLoginToken(httpServletRequest); if (StringUtils.isNotEmpty(loginToken)) &#123; String userJsonStr = RedisShardedPoolUtil.get(loginToken); User user = JsonUtil.str2Obj(userJsonStr, User.class); if (user != null) &#123; RedisShardedPoolUtil.expire(loginToken, Const.RedisCacheExtime.REDIS_SESSION_EXTIME); &#125; &#125; filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; &#125;&#125; 还需要在 web.xml 文件中进行配置： 12345678&lt;filter&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.mmall.controller.common.SessionExpireFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;sessionExpireFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 此方式的缺陷 redis + cookie 方式实现的单点登录对代码侵入性比较大； 客户端必须启用 cookie，而有些浏览器不支持 cookie； Cookie 设置 domain 时必须统一，服务器也必须统一域名方式； Spring Session 实现Spring Session 是 Spring 的项目之一，它提供了创建和管理 Server HTTPSession 的方案。并提供了集群 Session 功能，默认采用外置的 Redis 来存储 Session 数据，以此来解决 Session 共享的问题。 Spring Session 可以无侵入式地解决 Session 共享问题，但是不能进行分片。 Spring Session 项目集成1、引入 Spring Session pom 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;version&gt;1.2.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; 2、配置 DelegatingFilterProxy 12345678&lt;filter&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;springSessionRepositoryFilter&lt;/filter-name&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3、配置 RedisHttpSessionConfiguration 123&lt;bean id="redisHttpSessionConfiguration" class="org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration"&gt; &lt;property name="maxInactiveIntervalInSeconds" value="1800" /&gt;&lt;/bean&gt; 4、配置 JedisPoolConfig 123&lt;bean id="jedisPoolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxTotal" value="20" /&gt;&lt;/bean&gt; 5、配置 JedisSessionFactory 123456&lt;bean id="jedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" &gt; &lt;property name="hostName" value="192.168.23.130" /&gt; &lt;property name="port" value="6379" /&gt; &lt;property name="database" value="0" /&gt; &lt;property name="poolConfig" ref="jedisPoolConfig" /&gt;&lt;/bean&gt; 6、配置 DefaultCookieSerializer 1234567&lt;bean id="defaultCookieSerializer" class="org.springframework.session.web.http.DefaultCookieSerializer"&gt; &lt;property name="cookieName" value="SESSION_NAME" /&gt; &lt;property name="domainName" value=".happymmall.com" /&gt; &lt;property name="useHttpOnlyCookie" value="true" /&gt; &lt;property name="cookiePath" value="/" /&gt; &lt;property name="cookieMaxAge" value="31536000" /&gt;&lt;/bean&gt; 业务代码用户登录时： 1session.setAttribute(Const.CURRENT_USER, response.getData()); 退出登录时： 1session.removeAttribute(Const.CURRENT_USER); 获得用户信息时： 1User user = (User) session.getAttribute(Const.CURRENT_USER);]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v2.0 分布式锁实现定时关单]]></title>
    <url>%2F2019%2F02%2F14%2Fmmallv2.0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9A%E6%97%B6%E5%85%B3%E5%8D%95%2F</url>
    <content type="text"><![CDATA[在电商项目中，用户购买商品在生成订单后，一定时间内如果没有付款，应该将订单关闭。这里，主要用 Spring Schedule和分布式锁来实现，而分布式锁也分别用 Redis 命令原生实现和 Redisson 框架两种方式。 Spring Schedule 介绍Spring Schedule 是一个任务调度框架，用于定时任务调度等。主要通过 @Scheduled 注解来创建定时任务，可通过 cron 表达式来指定任务特定的执行时间。 Cron 表达式Cron 表达式是一个字符串，由 6 或 7 个字段组成，对应为 秒、分、时、日、月、周、年(可选)。 允许的值和特殊字符 字段名 允许的值 允许的特殊字符 秒 0-59 , - * / 分 0-59 , - * / 时 0-23 , - * / 月内第几天 1-31 , - * / ? L W C 月 1-12 或 JAN-DEC , - * / 周内第几天 1-7 或 SUN-SAT , - * / ? L C # 年(可选) 留空，1970-2099 , - * / 特殊字符的含义 *：匹配任意值，例如秒域为 * 表示每秒都会触发事件； ?: 只能在月内第几天和周内第几天两个域使用，用于执行不明确的值。当两个域之一被指定值后，为避免冲突，需要将另一个的值设为 ?； -: 指定一个范围，例如分域为 3-6，表示从 3 分到 6 分钟每分钟触发一次； / : 指定增量，表示起始时间开始触发，然后每隔固定时间触发一次，例如分域为 5/15，则意味着 5 分、20 分、35 分、50 分，分别触发一次； ,：指定几个可选值。例如在分域使用 5,15，则意味着在 5 和 20 分各触发一次； L : 表示最后，只能出现在周内第几天和月内第几天域，表示一月的最后一天，或一周的最后一天。如果在周内第几天域前加上数字，表示一月的最后一个第几天。例如 5L 表示一个月的最后一个周五； W : 指定有效工作日(周一到周五)，只能在月内第几天域使用，系统将在离指定日期的最近的有效工作日触发。注意一点，W 的最近寻找不会跨过月份； LW : 两个字符可以连用，表示一月的最后一个工作日，即最后一个星期五。 # : 指定一月的周内第几天，只能出现在月内第几天域。例如在 2#3，表示一月的第三个星期一(2 表示周一，3 表示第三周)。 C：可以在月内第几天和周内第几天使用。 举例 1234567891011"0 1 * * * *" 表示每小时1分0秒执行一次"*/20 * * * * *" 表示每20秒执行一次"0 0 9-12 * * *" 表示每天9，10，11，12点执行一次"0 0/20 9-12 * * *" 表示每天9点到12点，每20分钟执行一次"0 0 9-12 * * 2-6" 表示每周一至周五，9点到12点的0分0秒执行一次"0 0 0 1 4 ?" 表示4月1日0时0分0秒执行一次 实现定时任务首先，在 applicationContext.xml 文件中配置： 1&lt;task:annotation-driven/&gt; 开启定时任务。注意，导入约束时导入的是 http://www.springframework.org/schema/task。 然后，创建定时关闭订单的 task： 123456789101112131415@Component@Slf4jpublic class CloseOrderTask &#123; @Autowired private IOrderService iOrderService; @Scheduled(cron="0 */1 * * * ?") public void closeOrderTaskV1() &#123; log.info("关闭订单定时任务启动"); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour", "1")); iOrderService.closeOrder(hour); log.info("关闭订单定时任务结束"); &#125;&#125; 表示每隔一分钟就查看是否有超过一个小时的订单未付款，如果有则进行关闭。IOrderServiceImpl 的 closeOrder 方法如下： 1234567891011121314151617181920@Overridepublic void closeOrder(int hour) &#123; Date closeDateTime = DateUtils.addHours(new Date(), -hour); List&lt;Order&gt; orderList = orderMapper.selectOrderStatusByCreateTime(Const.OrderStatusEnum.NO_PAY.getCode(), DateTimeUtil.dateToStr(closeDateTime)); for (Order order : orderList) &#123; List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNo(order.getOrderNo()); for (OrderItem orderItem : orderItemList) &#123; Integer stock = productMapper.selectStockByProductId(orderItem.getId()); if (stock == null) &#123; continue; &#125; Product product = new Product(); product.setId(orderItem.getProductId()); product.setStock(stock + orderItem.getQuantity()); productMapper.updateByPrimaryKeySelective(product); &#125; orderMapper.closeOrderByOrderId(order.getId()); log.info("关闭订单OrderNo：&#123;&#125;", order.getOrderNo()); &#125;&#125; 主要逻辑是，首先查询超过一个小时的订单列表，然后对列表中的每一条订单，根据订单号查询商品列表，对每一件商品的库存进行更新，最后，对订单的状态进行修改，即意味着删除。 如此，定时关闭一定时间内未付款的订单的 v1 版本就完成了。但是在 tomcat 集群环境下，每次只需要一台机器执行即可，不用每台机器都执行；而且，多台机器同时执行也容易造成数据错乱。所以，这就需要使用分布式锁来进行保证。 Redis 命令实现分布式锁Redis 命令下面是其中会用到的一下 Redis 命令： 1).setnx key value SET if Not eXists 的简称。如果键不存在，则将键 key 的值设置为 value。否则如果键已经存在，则不做任何操作。 设置成功时返回 1，设置失败时返回 0。 2).getset key value 将键 key 的值设为 value，并返回键 key 在被设置之前的旧值。 如果键 key 存在旧值，则会返回。否则如果不存在旧值，也就是键 key 在设置之前并不存在，则返回 nil。 3).expire key seconds 为给定的键 key 设置生存时间，当 key 的生存时间为 0(过期) 时，它会被自动删除。 4).del key [key...] 删除给定的一个或多个 key。 Redis 分布式锁Redis 分布式锁原理 Redis 分布式锁的流程图如下: 它的主要原理是：首先，通过 setnx 存入一个 lockkey，如果设置成功，也就是获取锁成功，就为锁设置一个有效期，然后执行业务，之后将 lockkey 删除，最后将锁释放。如果设置失败，也就是获取锁失败，则直接结束。 这里使用 setnx 命令，开始时 Redis 中不存在 lockkey，setnx(lockkey) 就会返回 1，表示本台机器获取到了锁，可以定时执行业务。而其他机器在有效期内获取锁时，lockkey 已经存在，就会返回 0，表示没有获取到锁，其他机器正在执行业务。 构建分布式任务调度 利用 Spring Schedule + Redis 分布式锁构建分布式任务调度，方法 closeOrderTaskV2 版本如下： 12345678910111213141516171819202122232425@Scheduled(cron = "0 */1 * * * ?")public void closeOrderTaskV2() &#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout", "5000")); // 获取锁 Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout)); if (setnxResult != null &amp;&amp; setnxResult.intValue() == 1) &#123; // 如果返回值是 1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; else &#123; log.info("没有获取到分布式锁：&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; log.info("关闭订单定时任务结束");&#125;private void closeOrder(String lockName) &#123; // 修改存活时间 RedisShardedPoolUtil.expire(lockName, 5); log.info("获取&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour", "2")); iOrderService.closeOrder(hour); // 删除 key RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); log.info("释放&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName());&#125; 缺点 如果某台 tomcat 机器成功获取到锁，但在为锁设置有效期之前，tomcat 机器意外关闭，这时就会产生死锁。 可以在 CloseOrderTask 中添加一个 delLock 方法，在销毁之前删除分布式锁： 1234@PreDestroypublic void delLock() &#123; RedisShardedPoolUtil.del(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK);&#125; 但如果直接 kill 掉 tomcat 进程，仍然不会调用这个方法，从而产生死锁。 Redis 分布式锁双重防死锁Redis 分布式锁优化原理 Redis 分布式锁优化后的流程图如下: 它的原理是：同样首先通过 setnx 存入一个 lockkey，如果设置成功，同之前一样。否则，通过 get 获得之前设置的 currentTime + timeout，判断 lockValeA 是否不为 null，并且 currentTime 大于 lockValueA，即分布式锁是否过期。 如果过期，通过 getset 将 lockkey 对应的 value 设置为 currentTime + timeout，并得到之前的旧值 lockValueB，判断 lockValueB 是否为 null，即 lockkey 是否还存在，或者 lockValueA 是否等于 lockValueB，即在这个过程中锁没有改变。如果条件满足，则表示获取锁成功，同 setnx 获取锁成功一样。 如果锁没有过期，则表示获取锁失败，直接结束。在 getset 后，如果 lockValueB 不为空，即 lockkey 仍然存在，或者锁被改变了，也表示获取锁失败，直接结束。 构建分布式任务调度 利用 Spring Schedule + Redis 分布式锁构建分布式任务调度，方法 closeOrderTaskV3 版本如下： 123456789101112131415161718192021222324252627@Scheduled(cron = "0 */1 * * * ?")public void closeOrderTaskV3() &#123; log.info("关闭订单定时任务启动"); long lockTimeout = Long.parseLong(PropertiesUtil.getProperty("lock.timeout", "5000")); // 获取锁 Long setnxResult = RedisShardedPoolUtil.setnx(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout)); if (setnxResult != null &amp;&amp; setnxResult.intValue() == 1) &#123; // 如果返回值是 1，代表设置成功，获取锁 closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; else &#123; // 未获取到锁，继续判断时间戳，看锁是否过期 String lockValueStr = RedisShardedPoolUtil.get(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); if (lockValueStr != null &amp;&amp; System.currentTimeMillis() &gt; Long.parseLong(lockValueStr)) &#123; // 锁过期，重置并获取锁 String getSetResult = RedisShardedPoolUtil.getSet(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, String.valueOf(System.currentTimeMillis() + lockTimeout)); if (getSetResult == null || (getSetResult != null &amp;&amp; StringUtils.equals(lockValueStr, getSetResult))) &#123; closeOrder(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; else &#123; log.info("没有获取到分布式锁：&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125; else &#123; log.info("没有获取到分布式锁：&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); &#125; &#125; log.info("关闭订单定时任务结束");&#125; Redisson 实现分布式锁Redisson 是架设在 Redis 上的一个 Java 驻内存数据网格，它在基于 NIO 的 Netty 框架上，充分地利用了 Redis 键值数据库提供的一系列优势。 将 Redisson 集成到项目中，只需要在 pom.xml 文件需要添加 redisson 和 jackson-dataformat-avro 的依赖。 Redisson 初始化类 1234567891011121314151617181920212223public class RedissonManager &#123; private Config config = new Config(); private Redisson redisson; private static String redis1IP = PropertiesUtil.getProperty("redis1.ip", "192.168.23.130"); private static Integer redis1Port = Integer.parseInt(PropertiesUtil.getProperty("redis1.port", "6379")); @PostConstruct public void init() &#123; try &#123; config.useSingleServer().setAddress(redis1IP + ":" + redis1Port); redisson = (Redisson) Redisson.create(config); log.info("初始化 Redisson 结束"); &#125; catch (Exception e) &#123; log.error("初始化 Redisson 失败", e); &#125; &#125; public Redisson getRedisson() &#123; return redisson; &#125;&#125; 这里使用单服务器模式，在传入地址时采用 ip:port 格式。 任务调度 v4 版本 tryLock 方法在获取锁时，三个参数分别为：尝试获取锁最多等待的时间、获取锁后自动释放的时间、时间单元。 1234567891011121314151617181920212223@Scheduled(cron = "0 */1 * * * ?")public void closeOrderTaskV4() &#123; RLock lock = redissonManager.getRedisson().getLock(Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK); boolean locked = false; try &#123; if(locked = lock.tryLock(0, 5, TimeUnit.SECONDS)) &#123; log.info("Redisson 获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName()); int hour = Integer.parseInt(PropertiesUtil.getProperty("close.order.task.time.hour", "2")); iOrderService.closeOrder(hour); &#125; else &#123; log.info("Redisson 没有获取到分布式锁：&#123;&#125;, ThreadName:&#123;&#125;", Const.REDIS_LOCK.CLOSE_ORDER_TASK_LOCK, Thread.currentThread().getName()); &#125; &#125; catch (InterruptedException e) &#123; log.error("Redisson 获取分布式锁异常", e); &#125; finally &#123; if (!locked) &#123; return; &#125; lock.unlock(); log.info("Redisson 释放分布式锁"); &#125;&#125; 这里 tryLock 方法在获取锁之后，如果后续的执行业务时间小于 1 秒，而另外的 tomcat 在等待 1 秒后，又能重新获取锁，就会出现两个进程都获得锁的情况。 所以，应该将 waitTime 设置为 0（waitTime 时间小于业务执行时间）。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之环境搭建]]></title>
    <url>%2F2019%2F01%2F29%2Fmmallv1.0%E9%A1%B9%E7%9B%AE%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[配置软件源首先，需要进行源配置，可使用阿里云的源，可查看： https://opsx.alibaba.com/mirror 1234561、备份mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup2、下载新的CentOS-Base.repo 到/etc/yum.repos.d/wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo3、生成缓存yum makecache 创建用户并修改密码首先，添加普通用户： 1useradd timberliu 再更改密码： 1passwd timberliu 之后退出重新登录验证。 安装 JDK删除系统自带 jdk 首先，执行以下命令查看自带的 jdk： 1rpm -qa | grep jdk 然后，使用 sudo yum remove xxx 命令进行删除。 下载与安装 首先，在根目录创建一个 developer，再创建一个 setup，用于存放安装包： 1mkdir -p /developer/setup 从 Oracle 官网得到 jdk1.8 的下载地址（可能会改变）： 1https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm 使用 wget 命令安装到 setup 下： 1wget --no-cookie --header "Cookie:oraclelicense=accept-securebackup-cookie" https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.rpm 需要注意的是：在 Oracle 官网下载 rpm 时需要在 wget 后面加上 --no-cookie --header &quot;Cookie:oraclelicense=accept-securebackup-cookie&quot; 接受许可协议。 然后执行下面的命令进行安装： 1rpm -ivh jdk-8u201-linux-x64.rpm 默认会安装到 /usr/java 目录下。 配置环境变量 执行 sudo vim /etc/profile 命令配置环境变量： 123export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jarexport PATH=$PATH:$JAVA_HOME/bin 然后，执行 source /etc/profile 使配置生效。使用 java -version，查看是否配置成功： 安装 Tomcat首先，使用 wget 命令从阿里云镜像网站下载 tomcat，到 setup 目录下： 1wget https://mirrors.aliyun.com/apache/tomcat/tomcat-8/v8.5.35/bin/apache-tomcat-8.5.35.tar.gz 再使用 tar 命令解压缩到 developer 目录下： 1tar -zxvf apache-tomcat-8.5.35.tar.gz -C ../ 再执行 vim /etc/profile 配置环境变量： 12export CATALINA_HOME=/developer/apache-tomcat-8.5.35export PATH=$CATALINA_HOME/bin: 再修改 apache-tomcat-8.5.35 下的 conf/server.xml 文件： 1vim conf/server.xml 修改 8080 端口的 URI 的字符编码为 &quot;UTF-8&quot;： 123&lt;Connector port="8080" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" URIEncoding="UTF-8" /&gt; 最后，启动 tomcat： 1bin/startup.sh 安装 Maven和 tomcat 一样，得到 maven 的下载地址，进行下载： 1wget https://mirrors.aliyun.com/apache/maven/maven-3/3.0.5/binaries/apache-maven-3.0.5-bin.tar.gz 然后，使用 tar 解压缩到 developer 目录下： 1tar -zxvf apache-maven-3.0.5-bin.tar.gz -C ../ 然后，将 maven 配置到环境变量中： 12export MAVEN_HOME=/developer/apache-maven-3.0.5export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin 执行 source /etc/profile 使配置生效。执行 mvn -version 查看是否安装成功。 安装 vsftpd下载与安装 使用 yum 直接执行下面的命令安装： 1yum -y install vsftpd 在根目录下创建 product 目录，再创建 ftpfile 目录，用于存放上传的文件： 1mkdir -p /product/ftpfile 添加匿名用户 首先，添加一个匿名用户： 1useradd ftpuser -d /product/ftpfile -s /sbin/nologin 修改 ftpfile 文件夹的权限，用户组和用户都是 ftpuser： 1chown -R ftpuser.ftpuser ./ftpfile/ 修改 ftpuser 的密码： 1passwd ftpuser 然后，在 etc/vsftpd 下创建 chroot_list 文件，在其中添加用户名，这里就是 ftpuser： 12cd /etc/vsftpd/vim chroot_list 确认安全策略 查看安全策略，确保其中的 SELINUX 为 disabled： 1vim /etc/selinux/config 为避免验证时碰到 550 拒绝访问错误，执行下面的命令： 12[timberliu@iZ2ze222ncoofcesrn22waZ vsftpd]$ sudo setsebool -P ftp_home_dir 1setsebool: SELinux is disabled. 配置 vsftpd.conf 文件 使用 sudo vim vsftpd.conf 命令编辑： 12345678910111213141516local_root=/product/ftpfile#chroot_local_user=YESanon_root=/product/ftpfileuse_localtime=YES#匿名anonymous_enable=NOchroot_local_user=NOchroot_list_enable=YES# (default follows)chroot_list_file=/etc/vsftpd/chroot_list#pasv_enable=YESpasv_min_port=61001pasv_max_port=62000 启动 vsftpd 启动 vsftpd:1systemctl start vsftpd 查看 vsftpd 服务的状态： 1systemctl status vsftpd.service 将其设置开机自启动： 1systemctl enable vsftpd.service 安装 Nginx下载与安装 首先，安装 Nginx 需要依赖的环境： 1yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel 使用 wget 命令从官网下载 Nginx： 1wget http://nginx.org/download/nginx-1.14.0.tar.gz 使用 tar 解压缩到 setup 目录： 1tar -zxvf nginx-1.14.0.tar.gz -C ../ 进入 Nginx 目录，分别执行以下命令： 123./configuremakemake install 更改配置 然后，进入到 Nginx 安装目录的 conf下面： 1cd /usr/local/nginx/conf 编辑 nginx.conf 文件： 1vim nginx.conf 在其中添加如下: 1include vhost/*.conf; 然后，在 conf 目录下创建 vhost 文件夹。在 vhost 文件夹中创建 admin.timberliu.com.conf、timberliu.com.conf、s.timberliu.com.conf 和 img.timberliu.com.conf 文件。 在启动 Nginx 后，访问 123.56.9.126，即可看到 Nginx 页面。 安装 MySQL首先，需要删除掉系统自装或以前安装的 mysql： rosten：centos下完全卸载mysql 下载与安装： 近博：Centos6.8通过yum安装mysql5.7Linux社区-xyang81：CentOS7 64位下MySQL5.7安装与配置（YUM） 注意：CentOS 6 和 7 中对于服务的管理也出现不同。CentOS 6 中使用 service 命令进行启动停止服务，使用 chkconfig 命令设置开机自启；而在 CentOS 7 中对所有服务都集中在到 systemctl 中，通过 /usr/lib/systemd/system 下以 .service 结尾的配置文件来管理。 在安装完 MySQL 后，使用 mysql -u root 进入 mysql，通过如下方式修改密码： 12update mysql.user set authentication_string=password('root') where user='root';flush privileges; 然后退出 mysql，重新登录。使用如下命令创建一个新用户 mmall： 1grant usage on *.* to 'username'@'localhost' identified by 'password' with grant option; 然后创建数据库： 12create database `mmall` default character set utf8 COLLATE utf8_genernal_ci;flush privileges; 对新建的用户赋予权限，并刷新权限： 1grant all privileges on mmall.* to 'username'@'localhost' identified by 'password'; 再导入 sql 文件创建表。这里需要先将 sql 文件上传到服务器上，然后使用 source 命令就可以创建表了： 1source /developer/mmall.sql 安装 Git首先，安装 git 环境需要的依赖： 1yum -y install zlib-devel openssl-devel cpio expat-devel gettext-devel curl-devel perl-ExtUtils-CBuilder 再下载 git 的压缩包到 setup 目录下： 1wget https://www.kernel.org/pub/software/scm/git/git-2.11.1.tar.gz 对刚才的包解压缩： 1tar -zxvf git-2.11.1.tar.gz -C ../ 然后进行编译，安装: 123cd /developer/git-2.11.1make prefix=/usr/local/git allmake prefix=/usr/local/git install 打开 vim /etc/profile 配置环境变量： 1export PATH=$PATH:$JAVA_HOME/bin:$MAVEN_HOME/bin:/usr/local/git/bin 执行 source /etc/profile 使之生效。可以使用 git --version 查看版本。 然后，添加用户名和邮箱： 12git config --global user.name "yourusername"git config --global user.email "youremail" 另外，在 linux 和 windows 下换行符不同，这里配置： 1git config --global core.autocrlf false 表示使 git 不要转换换行符。还需要配置： 1git config --global core.quotepath off 表示防止中文乱码问题。然后，设置编码为 utf-8： 1git config --global gui.encoding utf-8 创建密钥，默认即可： 1ssh-keygen -t rsa -C "youremail" 然后，执行下面的命令: 1ssh-add ~/.ssh/id_rsa 如果出现 Could not open a connection to your authentication agent.，则执行 eval，再执行上面的命令： 12eval `ssh-agent`ssh-add ~/.ssh/id_rsa 然后，使用下面的命令获取公钥： 1cat ~/.ssh/id_rsa.pub 将其复制到 github 的 SSH keys 中即可。 防火墙配置在阿里云服务器中，需要配置规则，放行所需端口入方向规则。可以参考这篇文章：aquarius_wing：阿里云服务器上tomcat无法访问的问题 在 CentOS7 下默认使用 firewall 作为防火墙，使用 iptables 需要重新设置一下。在 /etc/sysconfig 目录下没有 iptables 文件，需要执行以下命令进行安装： 1yum -y install iptables-services 然后在 iptables 文件中配置端口如下： 1234567891011121314151617181920212223242526*filter:INPUT ACCEPT [0:0]:FORWARD ACCEPT [0:0]:OUTPUT ACCEPT [0:0]-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT-A INPUT -p icmp -j ACCEPT-A INPUT -i lo -j ACCEPT#ssh port -A INPUT -m state --state NEW -m tcp -p tcp --dport 22 -j ACCEPT#vsftpd-A INPUT -p TCP --dport 61001:62000 -j ACCEPT-A OUTPUT -p TCP --sport 61001:62000 -j ACCEPT-A INPUT -p TCP --dport 20 -j ACCEPT-A OUTPUT -p TCP --sport 20 -j ACCEPT-A INPUT -p TCP --dport 21 -j ACCEPT-A OUTPUT -p TCP --sport 21 -j ACCEPT#nginx-A INPUT -p tcp -m tcp --dport 80 -j ACCEPT-A INPUT -j REJECT --reject-with icmp-host-prohibited-A FORWARD -j REJECT --reject-with icmp-host-prohibitedCOMMIT 保存退出后，执行以下命令启动防火墙: 1systemctl restart iptables.service 然后，设置防火墙开机自启动： 1systemctl enable iptables.service]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之支付模块]]></title>
    <url>%2F2019%2F01%2F28%2Fmmallv1.0%E6%94%AF%E4%BB%98%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[扫码支付支付流程 在商家发出预下单请求后，支付宝后台会返回二维码信息给用户，然后用户通过支付宝钱包扫码，之后支付宝后台会把支付结果信息返回给商家后台。 扫码支付调用流程 主要的思路如下： 商家系统调用支付宝接口发起预下单请求，获得二维码图片地址；然后通过二维码串生成二维码图片，上传至图片服务器，并将 url 返回给前台； 发起轮询获得支付结果：通过支付时传入的商品订单号查询支付结果； 还可以通过异步通知获得支付结果，注意：一定要对异步通知进行验签，确保通知是支付宝发出的。另外，还要更新数据库中的信息 实现细节预下单请求 首先，创建扫码支付请求 builder，并设置标题、总金额、交易号、回调地址、商品列表集合等请求参数。在创建商品时，可以使用 newInstance方法传入商品 id、名称、单价、数量等信息创建，然后添加到商品列表集合中。 1234567891011121314151617List&lt;GoodsDetail&gt; goodsDetailList = new ArrayList&lt;&gt;();List&lt;OrderItem&gt; orderItemList = orderItemMapper.getByOrderNoUserId(orderNo, userId);for (OrderItem orderItem : orderItemList) &#123; // 创建一个商品信息，参数含义分别为商品id（使用国标）、名称、单价（单位为分）、数量，如果需要添加商品类别，详见GoodsDetail GoodsDetail goods = GoodsDetail.newInstance(orderItem.getProductId().toString(), orderItem.getProductName(), BigDecimalUtil.add(orderItem.getCurrentUnitPrice().doubleValue(), 100.0).longValue(), orderItem.getQuantity()); // 创建好一个商品后添加至商品明细列表 goodsDetailList.add(goods);&#125;AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount) .setOutTradeNo(outTradeNo).setUndiscountableAmount(undiscountableAmount) .setSellerId(sellerId).setBody(body).setOperatorId(operatorId) .setStoreId(storeId).setExtendParams(extendParams).setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url")) //支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); 然后，使用 Config.init() 加载 zbinfo 配置文件，其中配置了支付宝的支付宝网关名、pid、appid、RSA私钥、公钥等。注意：加载文件一定要在创建 AlipayTradeService 对象之前调用： 1Configs.init("zfbinfo.properties"); 再然后，创建 AlipayTradeService 单例或静态对象： 1AlipayTradeService tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); 最后，使用 tradePrecreate() 方法发起预下单请求： 1AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); 同步订单的二维码串，并生成二维码 首先，判断上一步中 result 的订单状态，如果为 SUCCESS，则表示预下单成功； 12345switch (result.getTradeStatus()) &#123; case SUCCESS: log.info("支付宝预下单成功: )"); ···&#125; 然后，可以使用 result.getResponse() 得到响应对象。再使用 response.getOutTradeNo() 得到订单号，并创建上传到服务器的存放路径。 123AlipayTradePrecreateResponse response = result.getResponse();···String qrPath = String.format(path + "/qr-%s.png", response.getOutTradeNo()); 然后，使用 ZxingUtils.getQRCodeImge() 方法将 getQrCode() 得到的二维码串转换为宽度为 256 的图片存放在 qrPath 下。 1ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); 最后，使用 FtpUtil.uploadFile 方法将图片上传到图片服务器。 123456File targetFile = new File(qrPath);try &#123; FtpUtil.uploadFile(Lists.newArrayList(targetFile));&#125; catch (IOException e) &#123; log.error("上传二维码失败");&#125; 轮询查看交易的状态 这里，主要是到数据库中查询订单信息，判断订单状态即可： 12345Order order = orderMapper.selectByUserIdAndOrderNo(userId, orderNo);···if(order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode()) &#123; return ServerResponse.createBySuccess();&#125; 异步通知结果 首先，在收到异步通知时，参数以 Map&lt;String, String[]&gt; 的形式封装在 request 中，需要将其转换为 Map&lt;String, String&gt; 形式： 123456789101112Map&lt;String, String&gt; params = Maps.newHashMap();Map&lt;String, String[]&gt; requestParams = request.getParameterMap();for(Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) &#123; String name = (String) iter.next(); String[] values = (String[]) requestParams.get(name); String valueStr = ""; for(int i = 0; i &lt; values.length; i++) &#123; valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ","; &#125; params.put(name, valueStr);&#125; 然后，对于返回的结果，除了 sign、sign_type 两个参数，其他都需要验签。在源码实现中，已经移除了 sign 参数，只需要移除 sign_type 即可。另外对剩余参数进行 url_encode，并进行字段排序组成待验签字符串，还有将 sign 使用 base64 解码为字节码串也都已实现： 1params.remove("sign_type"); 然后，使用 RSA 验签方法，通过签名字符串、支付宝公钥、字符编码、signType 验证签名。 1boolean alipayRSACheckedV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), "utf-8", Configs.getSignType()); 然后，在服务层中，需要更改订单的支付时间与支付状态： 12345if(Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)) &#123; order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order);&#125; 最后，再将支付信息添加到支付信息表中： 12345678PayInfo payInfo = new PayInfo();payInfo.setUserId(order.getUserId());payInfo.setOrderNo(orderNo);payInfo.setPayPlatform(Const.PayPlatformEnum.ALIPAY.getCode());payInfo.setPlatformNumber(tradeNo);payInfo.setPlatformStatus(tradeStatus);payInfoMapper.insert(payInfo); NatAPP 内网穿透在支付时，支付宝异步回调需要让回调地址可以被外网访问，可以使用 natapp 进行内网穿透。这里参考文档 NATAPP1分钟快速新手图文教程 即可。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之购物车、收货地址、订单模块]]></title>
    <url>%2F2019%2F01%2F28%2Fmmallv1.0%E8%B4%AD%E7%89%A9%E8%BD%A6%E3%80%81%E6%94%B6%E8%B4%A7%E5%9C%B0%E5%9D%80%E3%80%81%E8%AE%A2%E5%8D%95%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[购物车模块1、购物车模块中购物车的设计，购物车对象如下： 1234567891011public class CartVo &#123; // 商品集合 private List&lt;CartProductVo&gt; cartProductVoList; // 购物车总价 private BigDecimal cartTotalPrice; // 是否全被选中 private Boolean allChecked; // 图片域名 private String imageHost; // getter/setter 方法&#125; 其中，购物车每一件商品 CartProductVo 对象设计如下： 1234567891011121314151617181920public class CartProductVo &#123; private Integer id; private Integer userId; private Integer productId; // 商品数量 private Integer quantity; private String productName; private String productSubtitle; private String productMainImage; private BigDecimal price; private Integer productStatus; private BigDecimal productTotalPrice; private Integer productStock; // 此商品是否勾选 private Integer productChecked; // 限制数量的一个返回结果 private String limitQuantity; // getter/setter 方法&#125; 2、封装一个高可用的购物车核心方法：获取购物车中所有商品信息 getCartVoLimit() 方法。设计思想如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960private CartVo getCartVoLimit(Integer userId) &#123; CartVo cartVo = new CartVo(); // 根据用户 Id 查询购物车信息 List&lt;Cart&gt; cartList = cartMapper.selectCartByUserId(userId); List&lt;CartProductVo&gt; cartProductVoList = Lists.newArrayList(); BigDecimal cartTotalPrice = new BigDecimal("0"); if (CollectionUtils.isNotEmpty(cartList)) &#123; for (Cart cart : cartList) &#123; CartProductVo cartProductVo = new CartProductVo(); cartProductVo.setId(cart.getId()); cartProductVo.setUserId(cart.getUserId()); cartProductVo.setProductId(cart.getProductId()); Product product = productMapper.selectByPrimaryKey(cart.getProductId()); if (product != null) &#123; cartProductVo.setProductMainImage(product.getMainImage()); cartProductVo.setProductName(product.getName()); cartProductVo.setProductSubtitle(product.getSubtitle()); cartProductVo.setProductStatus(product.getStatus()); cartProductVo.setPrice(product.getPrice()); cartProductVo.setProductStock(product.getStock()); int buyLimitCount = 0; if (product.getStock() &gt;= cart.getQuantity()) &#123; // 库存足够 buyLimitCount = cart.getQuantity(); cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_SECCESS); &#125; else &#123; // 库存不足 buyLimitCount = product.getStock(); cartProductVo.setLimitQuantity(Const.Cart.LIMIT_NUM_FAIL); // 购物车中更新为有效的库存 Cart cartForQuantity = new Cart(); cartForQuantity.setId(cart.getId()); cartForQuantity.setQuantity(buyLimitCount); cartMapper.updateByPrimaryKeySelective(cartForQuantity); &#125; cartProductVo.setQuantity(buyLimitCount); // 计算单件商品总价 cartProductVo.setProductTotalPrice(BigDecimalUtil.mul(product.getPrice().doubleValue(), cartProductVo.getQuantity().doubleValue())); cartProductVo.setProductChecked(cart.getChecked()); &#125; // 如果商品被选中，则相加到购物中总价中 if (cart.getChecked() == Const.Cart.CHECKED) &#123; cartTotalPrice = BigDecimalUtil.add(cartTotalPrice.doubleValue(), cartProductVo.getProductTotalPrice().doubleValue()); &#125; cartProductVoList.add(cartProductVo); &#125; &#125; cartVo.setCartProductVoList(cartProductVoList); cartVo.setAllChecked(getAllCheckedStatus(userId)); cartVo.setCartTotalPrice(cartTotalPrice); cartVo.setImageHost(PropertiesUtil.getProperty("ftp.server.http.prefix")); return cartVo;&#125; 3、对于浮点型在商业运算中丢失精度问题，可以使用 BigDecimal 对象，将参数转为 String 类型进行计算： 123456789101112131415161718192021222324252627public class BigDecimalUtil &#123; public static BigDecimal add(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.add(b2); &#125; public static BigDecimal sub(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.subtract(b2); &#125; public static BigDecimal mul(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); return b1.multiply(b2); &#125; public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP); &#125;&#125; 收货地址模块1、Mybatis 自动生成主键、配置和使用 在添加收货地址时，可以自动生成主键，这里指定为 id。1&lt;insert id="insert" parameterType="com.mmall.pojo.Shipping" useGeneratedKeys="true" keyProperty="id"&gt; 然后，就可以使用 shipping.getId() 得到新添加收货地址后的 id。 2、在更新收货地址信息时，为防止横向越权，在 ShippingMapper.xml 文件中，根据用户 Id 和 ShippingId 进行更新： 123456789101112131415&lt;update id="updateByShipping" parameterType="com.mmall.pojo.Shipping"&gt; update mmall_shipping set receiver_name = #&#123;receiverName,jdbcType=VARCHAR&#125;, receiver_phone = #&#123;receiverPhone,jdbcType=VARCHAR&#125;, receiver_mobile = #&#123;receiverMobile,jdbcType=VARCHAR&#125;, receiver_province = #&#123;receiverProvince,jdbcType=VARCHAR&#125;, receiver_city = #&#123;receiverCity,jdbcType=VARCHAR&#125;, receiver_district = #&#123;receiverDistrict,jdbcType=VARCHAR&#125;, receiver_address = #&#123;receiverAddress,jdbcType=VARCHAR&#125;, receiver_zip = #&#123;receiverZip,jdbcType=VARCHAR&#125;, create_time = #&#123;createTime,jdbcType=TIMESTAMP&#125;, update_time = now() where id = #&#123;id,jdbcType=INTEGER&#125; and user_id = #&#123;userId,jdbcType=INTEGER&#125;&lt;/update&gt; 订单模块1、创建订单时需要将订单详情插入到数据库中，可以使用 MyBatis 的批量插入。使用 foreach 标签，集合中每一个对象使用括号括起来，用逗号进行分隔。 123456789101112131415&lt;insert id="batchInsert" parameterType="list"&gt; insert into mmall_order_item (id, user_id, order_no, product_id, product_name, product_image, current_unit_price, quantity, total_price, create_time, update_time) values &lt;foreach collection="list" index="index" item="item" separator=","&gt; ( #&#123;item.id,jdbcType=INTEGER&#125;, #&#123;item.userId,jdbcType=INTEGER&#125;, #&#123;item.orderNo,jdbcType=BIGINT&#125;, #&#123;item.productId,jdbcType=INTEGER&#125;, #&#123;item.productName,jdbcType=VARCHAR&#125;, #&#123;item.productImage,jdbcType=VARCHAR&#125;, #&#123;item.currentUnitPrice,jdbcType=DECIMAL&#125;, #&#123;item.quantity,jdbcType=INTEGER&#125;, #&#123;item.totalPrice,jdbcType=DECIMAL&#125;, now(), now() ) &lt;/foreach&gt;&lt;/insert&gt; 另外，需要注意的是：Mybatis 批量插入时默认的最大数据量是 1 M，如果超过则会报 PacketTooBigException 异常。可以通过 mysql 安装目录下的 my.ini 文件中，mysqld 段的 max_allowed_packet = 1 M 进行调整； 2、对于产品状态、订单状态、支付平台、支付方式，都使用枚举类表示。如何设计一个实用安全扩展性强大的枚举类？例如，订单状态如下： 1234567891011121314151617181920212223242526public enum OrderStatusEnum &#123; CANCELED(0, "已取消"), NO_PAY(10, "未支付"), PAID(20, "已支付"), SHIPPED(40, "已发货"), ORDER_SUCCESS(50, "订单完成"), ORDER_CLOSED(60, "订单关闭"); private String value; private int code; OrderStatusEnum(int code, String value) &#123; this.code = code; this.value = value; &#125; public String getValue() &#123; return value; &#125; public int getCode() &#123; return code; &#125; public static OrderStatusEnum codeOf(int code) &#123; for (OrderStatusEnum orderStatusEnum : values()) &#123; if(orderStatusEnum.getCode() == code) &#123; return orderStatusEnum; &#125; &#125; throw new RuntimeException("没有找到对应的枚举"); &#125;&#125; 3、订单号的生成规则，必须唯一严谨。由于这里用户量不多，并发量小，可使用如下方式： 1234private long generateOrderNo() &#123; long currentTime = System.currentTimeMillis(); return currentTime + new Random().nextInt(100);&#125; 这里使用当前时间戳并加上一个 100 以内的随机数生成。]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mmall_v1.0 项目总结之用户、分类、商品模块]]></title>
    <url>%2F2019%2F01%2F27%2Fmmallv1.0%E7%94%A8%E6%88%B7%E3%80%81%E5%88%86%E7%B1%BB%E3%80%81%E5%95%86%E5%93%81%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[项目搭建使用 IDEA 创建项目，并上传到 Github 上。 参考文章：stevennest：IDEA创建项目及上传到github 用户模块在用户模块中，主要包括以下几个功能： 需要注意的问题有以下几点： 1、在忘记密码-检查问题时，使用 UUID 生成唯一标识，存储在缓存中，并将这个标识传递给前端； 12String forgetToken = UUID.randomUUID().toString();TokenCache.setKey(TokenCache.TOKEN_PREFIX + username, forgetToken); 在忘记密码-重置密码时，前端需要携带 token，服务器端需要判断 token 是否过期，并与缓存中的 token 进行对比，以防止横向越权访问。 12345String token = TokenCache.getKey(TokenCache.TOKEN_PREFIX + username);if(StringUtils.equals(forgetToken, token)) &#123; ···&#125; 2、在后台管理模块中，为防止纵向越权，在数据表设计时添加了 role 属性，在登录后台，或修改其数据时，都需要检验该用户的 role。 3、对于密码的存储，使用 MD5 进行加密，并且增加了 Salt 值。 4、在忘记密码-检查问题时，生成的 token 使用 Guava 进行缓存，以 key/value 形式进行存储。缓存使用主要实现如下： 123456789101112private static LoadingCache&lt;String, String&gt; localCache = CacheBuilder.newBuilder() .initialCapacity(1000) // 设置缓存最大值为 10000，如果超过这个值，会使用 LRU 算法进行清除 .maximumSize(10000) // 过期时间，及单位 .expireAfterAccess(12, TimeUnit.HOURS) .build(new CacheLoader&lt;String, String&gt;() &#123; @Override public String load(String s) &#123; return "null"; &#125; &#125;); 然后，可通过 set/get 方法设置、并获取值。12345678910public static void setKey(String key, String value) &#123; localCache.put(key, value);&#125;public static String getKey(String key) &#123; ··· value = localCache.get(key); ··· return value;&#125; 5、使用 ServerResponse 高复用响应式对象。其中三个属性如下： 123private int status;private String msg;private T data; 使用 enum 枚举类来表示不同的响应码。主要有四种响应码： 12345678public enum ResponseCode &#123; SUCCESS(0, "SUCCESS"), ERROR(1, "ERROR"), NEED_LOGIN(10, "NEED_LOGIN"), ILLEGAL_ARGUMENT(2, "ILLEGAL_ARGUMENT"); ···&#125; 另外，其中使用了 @JsonSerialize(include = JsonSerialize.Inclusion.NON_NULL) 标记 ServerResponse，表示在序列化对象时，忽略为空的属性，使用了 @JsonIgnore 标记 isSuccess 方法，表示在序列化时，忽略此方法。 6、用户登录信息使用 Session 进行存储。 1session.setAttribute(Const.CURRENT_USER, response.getData()); 7、使用 StringUtils、CollectionUtils 等工具类简化操作。 8、使用 slf4j 的 LoggerFactory 生成 logger 对象，打印日志。 123private static Logger logger = LoggerFactory.getLogger(TokenCache.class);logger.info("···"); 分类管理模块1、在分类管理中，需要用到无限层级的树状数据结构显示分类。可以在设计数据表时添加 parentId 属性，表示其父结点的 Id。另外，如果 parentId 为 0，表示当前结点为根结点分类。 2、在查询子结点分类时，需要用到递归算法。首先，根据前台传来的 id 判断该结点是否存在，如果存在，则添加到 categorySet 中。然后调用 findChildCategory 方法查询子节点分类： 12345Category category = categoryMapper.selectByPrimaryKey(categoryId);if(category != null) &#123; categorySet.add(category);&#125;findChildCategory(categorySet, categoryId); 其中，会根据 parentId 查询与子分类平级的结点得到一个 List 集合。然后遍历此集合，将子分类结点添加到 categroySet，再递归查询子节点。 1234567private void findChildCategory(Set&lt;Category&gt; categorySet, Integer parentId) &#123; List&lt;Category&gt; categoryList = categoryMapper.getChildrenCategoryByParentId(parentId); for (Category category: categoryList) &#123; categorySet.add(category); findChildCategory(categorySet, category.getId()); &#125;&#125; 然后，创建 List 集合，遍历 categorySet，将 category 的 id 添加到 categoryIdList 中，返回给前端。 123456List&lt;Integer&gt; categoryIdList = Lists.newArrayList();if(categoryId != null) &#123; for (Category categoryItem: categorySet) &#123; categoryIdList.add(categoryItem.getId()); &#125;&#125; 3、在存储 category 时，为了防止对象重复，这里使用 Set 进行排重。 1Set&lt;Category&gt; categorySet = Sets.newHashSet(); 另外，Set 中存放的对象 Category 要判断是否相等，这里针对 id，重写了 hashCode 和 equals 方法。 123456789101112@Overridepublic boolean equals(Object o) &#123; if (this == o) &#123; return true; &#125; if (!(o instanceof Category)) &#123; return false; &#125; Category category = (Category) o; return id != null ? id.equals(category.id) : category.id == null;&#125;@Overridepublic int hashCode() &#123; return id != null ? id.hashCode() : 0;&#125; 商品管理模块1、SpringMVC 文件上传使用 FTPClient。在上传文件之前，首先需要连接服务并登陆。另外，还需要设置远程目录、缓存大小、编码格式等。最后，使用 storeFile 方法传入文件名和文件输入流，上传文件。需要注意的是，上传后要关闭输入流和 FtpClient。主要实现如下： 1234567891011121314151617181920212223242526272829303132333435363738private boolean uploadFile(String remotePath, List&lt;File&gt; fileList) throws IOException &#123; boolean uploaded = false; FileInputStream fis = null; boolean isSuccess = connectServer(ip, port, user, password); // 连接服务器 if(isSuccess) &#123; try &#123; ftpClient.changeWorkingDirectory(remotePath); // 远程目录 ftpClient.setBufferSize(1024); // 缓存 ftpClient.setControlEncoding("UTF-8"); // 编码格式 ftpClient.setFileType(FTPClient.BINARY_FILE_TYPE); // 文件类型 ftpClient.enterLocalPassiveMode(); for (File fileItem : fileList) &#123; fis = new FileInputStream(fileItem); ftpClient.storeFile(fileItem.getName(), fis); &#125; uploaded = true; &#125; catch (IOException e) &#123; logger.error("上传文件异常", e); uploaded = false; e.printStackTrace(); &#125; finally &#123; if(fis != null) &#123; fis.close(); &#125; ftpClient.disconnect(); &#125; &#125; return uploaded;&#125;private boolean connectServer(String ip, int port, String user, String password) &#123; boolean isSuccess = false; ftpClient = new FTPClient(); try &#123; ftpClient.connect(ip, port); // 连接服务器 isSuccess = ftpClient.login(user, password); // 登录 &#125; catch (IOException e) &#123; logger.error("连接 FTP 服务器失败", e); &#125; return isSuccess;&#125; 2、使用流来读取 Properties 配置文件，这里使用 java.util.Properties 类的 load 方法来加载 mmall.properties 文件，再使用 getProperty 方法得到配置。主要实现如下： 123456789101112131415161718// 使用静态块来初始化并加载配置文件static &#123; String fileName = "mmall.properties"; props = new Properties(); try &#123; props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName),"UTF-8")); &#125; catch (IOException e) &#123; logger.error("配置文件读取异常",e); &#125;&#125;// 然后，可以使用 getProperty 获取public static String getProperty(String key, String defaultValue)&#123; String value = props.getProperty(key.trim()); if(StringUtils.isBlank(value))&#123; value = defaultValue; &#125; return value.trim();&#125; 3、使用 joda-time 处理时间。主要有两种形式：分别为将 String 转为 Date 和将 Date 转为 String。 1234567891011121314// 将 String 转为 Datepublic static Date strToDate(String str, String formatStr) &#123; DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern(formatStr); DateTime dateTime = dateTimeFormatter.parseDateTime(str); return dateTime.toDate();&#125;// 将 Date 转为 Stringpublic static String dateToStr(Date date, String formatStr) &#123; if(date == null) &#123; return StringUtils.EMPTY; &#125; DateTime dateTime = new DateTime(date); return dateTime.toString(formatStr);&#125; 4、对于 dao 层生成的 pojo，在 service 和 controller 层使用时，可能由于其他业务逻辑，已不能满足需求，这时就可以使用 BO（business Object）、VO（view Object） 对象。它是在原有 pojo 对象的基础上另外添加一些属性以满足业务的需求。 项目中，由于业务逻辑还不是特别复杂，所以使用的是简化版本，即 VO(value Object) 对象。 5、使用 MyBatis-PageHelper 分页及动态排序。一般，都需要先设置页数和每页数量。然后创建 PageInfo 对象，设置 List 集合对象。最后将 PageInfo 对象返回即可。 1234PageHelper.startPage(pageNum, pageSize);PageInfo pageInfo = new PageInfo(productList);pageInfo.setList(productListVoList);]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>mmall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(5)-内存管理]]></title>
    <url>%2F2019%2F01%2F11%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。 连续内存分配在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。 动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。 内存管理方式为实现动态分区分配，系统必须对空闲的内存进行管理，主要有两种方法：位图法和空闲区链表。 位图法 使用位图方法时，内存可能被划分为小到几个字或大到几千个字节的分配单元。每个分配单元对应位图中的一位，0 表示空闲，1 表示占用。 位图的缺点是如果想要调入一个占 k 个分配单元的进程，必须搜索位图，找出有 k 个连续 0 的串。查找位图中指定长度的连续 0 串的操作很耗时。 空闲区链表法 链表法是维护一个已分配内存段和空闲内存段的链表。链表的结点包括一个进程，或两个进程间的一块空闲区。 内存分配算法在将程序加载入内存时，需要按照一定的算法，从位图或空闲链表中选择分区分配给进程。 首次适配(first fit) 首次适配算法要求空闲区链表按照地址递增的顺序排序。在分配内存时，沿着链表进行搜索，直到找到一个足够大的分区，将其分为两部分，一部分供进程使用，一部分形成新的空闲区。 它的实现比较简单，但是低地址部分不断被划分，会留下许多小空闲分区。 下次适配(next fit) 下次适配算法和首次适配算法类似，只是不再像首次适配算法那样每次都从头开始，而是从上次找到的空闲分区的下一个空闲分区开始搜索。 最佳适配(best fit) 最佳适配算法要求将空闲分区按照其容量大小进行排序。在分配内存时，查找一个能满足要求、又是最小的的空闲分区，分配给进程。 这种算法的缺点是分区在每次分配后的剩余部分总是最小的，会留下许多难以利用的碎片。 最差适配(worst fit) 最差适配算法在分配内存时，总是选择一个最大的空闲分区，划分为两部分，一部分给进程使用，另一部分形成新的空闲分区。 最差适配算法使得剩下的空闲分区不至于产生太小的碎片；但是这样容易破坏大的空闲分区，后续难以找到大的分区。 快速适配(quick fit) 快速适配算法是将空闲分区按照其容量进行分类，为每一类相同容量的空闲分区单独维护一个链表。同时，设立一张管理索引表，表中每一项对应一种空闲分区类型。 快速适配算法的缺点是在进程被终止或换出释放分区时，有效地合并分区非常耗时。 非连续内存分配在非连续分配时，根据所分配地址空间的基本单位不同，可将其分为分页存储管理、分段存储管理、段页式存储管理三种方式。 分页存储管理在分页存储管理方式中，把用户程序的地址空间划分为若干个固定大小的页。典型的页面大小为 1KB。相应地，也将内存空闲分为若干个物理块，页和块大小相同，这样可以将用户程序的任一页放入任一物理快中实现非连续分配。 分页地址中的地址结构为： 地址长度为 32 位，其中 0~11 位为页内地址，即每页的大小为 4KB；12~31 位为页号，最多允许有 1M 页。 系统为每一个进程建立了一张页表，它负责逻辑页号到物理块号之间的地址转换。每一个页面对应一个页表项，记录了相应页在内存中对应的物理块号。 在 CPU 中设置一个页表基址寄存器，存储着页表的起始地址和页表的长度。 在进行地址转换时，首先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问地址已超过进程的地址空间，产生越界中断。如果没有发生越界中断，则将页表始址与页号和页表项长度的乘积相加，得到该页表项在页表中的位置，于是可从中得到该页的物理块号，最后根据物理块号和页内地址便可得到物理地址。 分页式存储管理方式主要有两个缺点： 性能问题：访问一个内存单元需要两次内存访问，第一次访问获取页表项，第二次访问才访问数据。（快表） 如果每页太小，页表可能会非常大，较难找到连续的大内存空间。（多级页表） 页表改进快表 为提高地址转换速度，可在地址转换机构中增加一个可并行查询的缓冲寄存器，称为快表。 在进行地址转换时，首先将页号与快表中的所有页号进行比较，如果其中有与此相匹配的页号，便可直接从快表中读出该页所对应的物理块号。如果在快表中没有对应的页表项，则还需要去访问内存中的页表，在找到物理块号后，得到要访问的物理地址。另外，还要将此页表项存入到快表中。如果快表已满，则需要找到一个合适的页表项，将其换出。 两级页表或多级页表 两级页表或多级页表的方法，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。同样，建立一张外层页表，每个页表项中记录了页表层面的物理块号。 在进行地址变换时，需要增加一个外层页表寄存器，用于存放外层页表的起始地址。利用外层页表始址和逻辑地址中的外层页号找到指定页表分页的始址，再利用外层页内地址找到指定的页表项，从中得到该页在内存的物理块号，最终得到物理地址。访问一次内存单元一共需要 3 次内存访问。 分段式存储管理在分段式存储管理方式中，进程的地址空间被划分为若干个段，例如主代码段、子模块代码段、堆栈段、初始化数据段、符号表等。每个段都从 0 开始编址，采用连续的地址空间，各段的长度也并不相等。 分段地址中的地址结构如下： 该地址结构中，允许一个进程最多有 64K 个段，每个段的最大长度为 64KB。 系统为每个进程建立了一张段表，用于实现从逻辑段到物理内存区的映射。每个段在表中占有一个表项，其中记录了该段在内存中的基址和段的长度。 系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址转换时，首先将段号与段表长度进行比较。如果段号大于段表长度，则访问越界。 如果没有越界，则根据段表的始址和该段的段号，得到该段对应段表项的位置，从中读出该段在内存的起始地址。再检查段内地址是否超过该段的段长。如果超过，同样产生越界中断；否则将该段的基址和段内地址相加，最后得到要访问的内存地址。 分页式和分段式比较 采用分页存储是为了提高内存的利用率；采用分段是为了更好地满足用户的需要。 分页存储中，页面的大小由系统决定，而且大小固定；分段存储中，段的长度由用户程序决定。 分页存储中，页表中主要存储物理块号；分段存储中，段表中主要存储段基址和段长。 段页式存储管理段页式存储是分段和分页的结合，先将用户程序分为若干个段，再把每个段分成若干个页。段页式的地址结构为段号、段内页号和页内地址三部分。 为实现地址转换，系统中需要同时设置段表和页表。不过这里的段表中存储的是页表始址和段长。 在进行地址转换时，首先将段号与段长进行比较，如果段号小于段长表示未越界，于是利用段表始址和段号求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号来获得对应页的页表项位置，从中读出该页所在的物理块号，再利用块号和页内地址来得到物理地址。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(6)-虚拟内存和文件分配]]></title>
    <url>%2F2019%2F01%2F11%2F%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[虚拟内存在逻辑上实现了对内存容量的扩充，既满足了用户的需要，又改善了系统性能。这篇文章总结了虚拟内存的基本概念、实现方式以及几种页面置换算法。最后是几种文件分配方式。 基本概念局部性原理：程序执行时，在一较短时间内，程序的执行仅仅局限于某一部分，其访问的存储空间也局限于某个区域。主要表现在两个方面： 时间局限性：如果某条指令被执行，不久以后该指令可能再次执行；如果某些数据被访问，不久以后该数据可能再次被访问； 空间局限性：如果某段存储单元被访问，其附近的存储单元可能也会被访问。 基于局部性原理，在加载程序时，只需将当前执行所需的部分页面或段装入内存。程序执行时，如果要访问的页面或段不在内存中，则发生缺页中断，于是 OS 利用请求调页功能将相应的页面或段调入内存，继续执行。如果内存已满，则利用置换功能，将内存中暂时不用的页面或段调出到外存，再将所需的页面或段调入内存，使程序继续执行。 虚拟内存是指具有请求调入功能和置换功能，从逻辑上对内存容量进行扩充的一种内存系统。实现方式有三种：请求分页存储管理方式、请求段式存储管理方式和请求段页式存储管理方式。 请求分页存储管理请求分页存储管理是在分页存储管理的基础上，增加请求调页和页面置换功能。它允许用户程序只装入部分页面就启动程序运行。在运行中如果发现所需页面不在内存中，则发出缺页中断，OS 就会将外存中相应的页面调入内存使其继续运行。每次调入和换出的基本单位是长度固定的页面。 请求分页存储管理中的地址转换与分页式相比，在页表项中添加了一些标志位： 状态位：表示该页是否已调入内存。 修改位：表示该页在调入内存后是否被修改过。在置换该页时，判断是否要把它写回外存。 访问位：表示该页在一段时间内被访问的次数。供置换算法在选择换出页面时参考。 外存地址：表示该页在外存上的地址。 请求分页存储管理系统中，在进行地址转换时，首先在快表中查找要访问的页。如果找到，便修改页表项中的访问位，供置换算法选择换出页面时参考。如果是写指令，还需要将修改位置为 1，表示该页在调入内存后被修改过。然后利用页表项中的物理块号和页内地址，得到物理地址。 如果在快表中未找到该页的页表项，则应到内存中去查找页表，再从找到的页表项中的状态位来判断该页是否调入内存。如果该页已调入，则应将该页的页表项写入快表；如果该页没有调入内存，则应该产生缺页中断，操作系统从外存中找到缺失的页面。 如果内存已满，则利用置换算法选择一页换出，如果该页被修改过，则需要将该页写回到外存中。最后将缺页从外存换入到内存中，继续运行程序。 页面置换算法最优算法（Optimal） 置换在未来最长时间内不再被访问的页面。这只是一种理想情况，只能用来评价其他置换算法的性能。 先进先出算法（FIFO） 选择进入内存时间最长的页面进行置换。在实现时维护一个所有已调入内存的页面的链表，按照进入内存的先后次序排序，链首最早，链尾最进。在出现缺页时，选择链首的页面进行置换，将新页面添加到链尾。 这种算法实现简单。但调出的页面可能会经常访问，性能较差，一般和其他算法结合使用。 最近最久未使用算法（LRU） 选择最长时间没有使用的页面进行置换。它依据的是如果某个页面长时间没有被访问，则在将来一段时间可能还不会访问。 在实现时维护一个按最近一次访问时间排序的链表，链表首是刚使用过的页面，链表尾是最久未使用的页面。在访问页面时，找到相应的页面，将其移动到链表首；在出现缺页时，删除链表尾节点，将新页面添加到链表首。 这种算法是最优算法的一种近似，但实现起来仍然比较复杂。 时钟算法（Clock） 也称为最近未使用算法（NRU）。在实现时，在页表项中增加一个访问位，表示过去一段时间内是否被访问过，初始时都置为 0，另外将页面组织成环形链表，添加一条指针指向最先被调入内存的页面。 当访问某页面时，将其访问项置为 1。在出现缺页异常时，从指针处开始查找，如果页面没有被访问过，即访问项为 0，则进行置换；如果被访问过，则将访问项置为 0，暂不换出，再将指针指向下一个页面继续查找，直到找到可以置换的页面。 最少使用算法（LFU） 置换最近一段时间访问次数最少的页面。在实现时，对每个页面设置一个访问计数，在访问页面时，对访问计数加 1；在出现缺页异常时，置换访问计数最少的页面。 文件分配文件分配实际上是如何表示分配给一个文件的数据块的位置和顺序。主要有以下几种分配方式：连续分配、链式分配和索引分配。 连续分配 使用连续的若干个数据块来存储文件。它在文件控制块中记录起始第一个数据块的位置和长度。 采用连续分配方式，读取文件的顺序访问和随机访问效率较高，但是剩余的碎片难以利用，另外文件长度增长也比较复杂。 链式分配 将文件以数据块链表的形式存储。文件控制块中包含了第一个数据块和最后一个数据块的指针。 链式分配方式在创建、增大、缩小文件时比较容易，而且没有碎片，但是不能实现真正的随机访问，另外一个数据块被破坏，后面的数据块就都丢了。 索引分配 为每个文件创建一个索引数据块，索引数据块中存储了指向文件数据块的指针列表，文件控制块中包含了指向索引数据块的指针。 这种实现在创建文件、增大、缩小文件时比较容易，也没有碎片，也支持随机访问。但是在文件很小时，存储索引开销相对较大，在文件很大时，需要增加额外的索引快。 UFS（Unix File System） UFS 的多级索引分配：在文件控制块中，如果数据块小于 10，采用直接索引；如果大于 10 块，第 11 块开始采用一级间接索引，它先指向一个索引块，索引块中再指向实际的数据块。如果数据块大到一定程度，会采用二级间接索引，依次类推。 多级索引分配方式大大提高了文件大小的限制阈值，可以动态分配数据块，文件扩展很容易，对于小文件开销较小，对于大文件使用间接索引也比较合理。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(4)--死锁]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁概念在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。 死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。 出现死锁的四个必要条件： 互斥。在任何时刻一个资源只能被一个进程使用。 拥有和请求。已经得到某个资源的进程可以再请求新的资源； 不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放； 循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。 对于死锁，有四种处理的策略：1. 忽略；2. 预防死锁；3. 避免死锁；4. 检测死锁并恢复。 死锁预防预防是指通过破坏死锁产生的四个必要条件的一个或多个，以避免发生死锁。 破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源； 破坏拥有和请求：有两种方案： 已拥有资源的进程不能再去请求其他资源。一种实现方法是要求进程在开始执行前请求需要的所有资源。 要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源。 破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占； 破坏循环等待：有两种方案： 一种方法是保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源； 另一种方法是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源。 死锁避免死锁避免是利用一些事先已知的信息，在分配资源时判断是否会出现死锁，如果不会出现死锁才会分配资源。 而判断是否会出现死锁就是看是否能找到一个安全序列，系统能按照这个安全序列，也就是进程的推进顺序为每个进程分配其所需资源，直到满足每个进程所需的资源，使每个进程都能顺序执行。 银行家算法为实现银行家算法，进程在进入系统时，要求进程声明需要资源的最大数目，但不能超过系统能提供的最大资源数目。当一个进程请求资源时，需要确定是否有足够资源分配给该进程，如果有，再检查在分配资源后，系统是否安全。 假定线程数量为 n，资源类型数量为 m，银行家算法的数据结构如下： Max (总需求量)：n*m 矩阵，表示进程 Ti 最多请求 Max[i, j] 个类型为 Rj 的资源； Available (剩余空闲量)：长度为 m 的向量，表示当前有 Available[i] 个类型 Rj 的可用资源； Allocation (已分配量)：n*m 矩阵，表示进程 Ti 当前分配了 Allocation[i, j] 个类型为 Rj 的资源； Need (未来需要量)：n*m 矩阵，表示进程 Ti 未来需要 Need[i, j] 个类型为 Rj 资源； 可以得出它们满足等式：Need[i, j] = Max[i, j] - Allocation[i, j]。 银行家算法的核心部分，安全状态的判断如下： 创建长度为 m 的向量 Work，表示当前资源剩余量，并进行初始化：Work = Avaiable; 在未运行的进程中寻找未来需要量 Need[i] 比当前可用量 Work 小的进程 Ti，如果找到则继续执行 3，否则转 4； 执行 Work = Work + Allocation[j]; ，将资源分配给进程 Ti 运行完毕后，回收其资源。转 2： 如果资源可以分配给所有进程，则系统处于安全状态； 如此完整的银行家算法如下：首先进行初始化，Request_i 表示进程 Ti 的资源请求向量，Request_i[j] 表示进程 Ti 请求资源 Rj 的实例。然后循环判断： 如果 Request_i &lt;= Need[i]，转到 2。否则拒绝资源请求，因为进程已经超过最大要求； 如果 Request_i &lt;= Available，转到 3。否则进程 Ti 必须等待，因为现在可用资源不足； 通过安全状态判断来确定是否分配资源给 Ti，如果安全则分配，否则拒绝 Ti 的资源请求。 死锁检测和恢复可以允许系统进入死锁状态，但会维护一个系统的资源分配图，定期调用死锁检测算法来检测途中是否存在死锁，检测到死锁发生后，采取死锁恢复算法进行恢复。 死锁检测方法如下： 在资源分配图中，找到不会阻塞又不独立的进程结点，使该进程获得其所需资源并运行，运行完毕后，再释放其所占有的全部资源。也就是消去该进程结点的请求边和分配边。 使用上面的算法进行一系列简化，若能消去所有边，则表示不会出现死锁，否则会出现死锁。 在检测死锁时，可以采用两种方法： 抢占资源。从一个或多个进程中抢占资源分配给死锁进程。 终止进程。可以终止所有的死锁进程；也可以按照某种顺序，逐个终止进程，释放其占有资源，直到死锁解除。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(3)--进程的同步和通信方式]]></title>
    <url>%2F2019%2F01%2F08%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间同步基本概念为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。 对于同步机制，需要遵循以下四个规则： 空闲则入：没有进程在临界区时，任何进程可以进入； 忙则等待：有进程在临界区时，其他进程均不能进入临界区； 有限等待：等待进入临界区的进程不能无限期等待； 让权等待（可选）：不能进入临界区的进程，应该释放 CPU，如转换到阻塞态； 信号量信号量机制（semaphore）是一种协调共享资源访问的方法。信号量由一个变量 semaphore 和两个原子操作组成，信号量只能通过 P 和 V 操作来完成，而且 P和 V 操作都是原子操作。 将信号量表示如下： 1234typedef struct &#123; int value; struct process_control_block *list;&#125; semaphore; 相应的 P(wait) 操作和 V(signal) 操作如下实现： 123456789101112wait(semaphore *S) &#123; S-&gt;value--; if(S-&gt;value &lt; 0) &#123; block(S-&gt;list); &#125;&#125;signal(semaphore *S) &#123; S-&gt;value++; if(S-&gt;value &lt;= 0) &#123; wakeup(S-&gt;list); &#125;&#125; 信号量可分为两类：互斥信号量，信号量大小为为 0 或 1，用来实现进程的互斥访问；资源信号量，信号量大小为资源数，用来表示系统资源数目。 资源信号量 代表资源信号量时，S-&gt;value 初值表示系统资源的数目，P 操作意味着进程请求一个资源，于是系统中可分配的资源数减一，如果 S-&gt;value &lt; 0，表示该类资源已分配完毕，因此阻塞该进程，并插入信号量链表 S-&gt;list 中。小于 0 时，S-&gt;value 的绝对值表示该信号量链表中阻塞的进程数。 V 操作表示进程释放一个资源，于是系统中可分配的资源数加一，如果增加一后仍然 S-&gt;value &lt;= 0，表示该信号量链表中仍然有阻塞的进程，因此调用 wakeup，将 S-&gt;list 中的第一个进程唤醒。 互斥信号量 代表互斥信号量时，S-&gt;value 初值为 1，表示只允许一个进程访问该资源。 利用信号量实现两个进程互斥描述如下： 123456semaphore mutex = 1;P() &#123; wait(mutex); 临界区； signal(mutex);&#125; 当 mutex = 1 时，表示两个进程都没有进入临界区，当 mutex = 0 时，表示一个进程进入临界区运行；当 mutex = -1 时，表示一个进程进入临界区运行，另一个进程被阻塞在信号量队列中。 管程管程采用面向对象思想，将表示共享资源的数据结构及相关的操作，包括同步机制，都集中并封装到一起。所有进程都只能通过管程间接访问临界资源，而管程只允许一个进程进入并执行操作，从而实现进程互斥。 12345678910111213Monitor monitor_name &#123; share variable declarations; condition declarations; public: void P1(···) &#123; ··· &#125; &#123; initialization code; &#125;&#125; 管程中设置了多个条件变量，表示多个进程被阻塞或挂起的条件，条件变量的形式为 condition x, y;，它也是一种抽象数据类型，每个变量保存了一条链表，记录因该条件而阻塞的进程，与条件变量相关的两个操作：condition.cwait 和 condition.csignal。 condition.cwait：正在调用管程的进程因 condition 条件需要被阻塞，则调用 condition.cwait 将自己插入到 condition 的等待队列中，并释放管程。此时其他进程可以使用该管程。 condition.csignal：正在调用管程的进程发现 condition 条件发生变化，则调用 condition.csignal 唤醒一个因 condition 条件而阻塞的进程。如果没有阻塞的进程，则不产生任何结果。 经典同步问题生产者-消费者问题生产者-消费者问题描述的是：生产者和消费者两个线程共享一个公共的固定大小的缓冲区，生产者在生成产品后将产品放入缓冲区；而消费者从缓冲区取出产品进行处理。 它需要保证以下三个问题： 在任何时刻只能有一个生产者或消费者访问缓冲区（互斥访问）； 当缓冲区已满时，生产者不能再放入数据，必须等待消费者取出一个数据（条件同步）； 而当缓冲区为空时，消费者不能读数据，必须等待生产者放入一个数据（条件同步）。 利用信号量解决 用信号量解决生产者-消费者问题，使用了三个信号量： 互斥信号量 mutex：用来保证生产者和消费者对缓冲区的互斥访问； 资源信号量 full：记录已填充的缓冲槽数目； 资源信号量 empty：记录空的缓冲槽数目。 12345678910111213141516171819202122232425262728#define N 10int in = 0, out = 0;item buffer[N];semaphere mutex = 1, full = 0, empty = N;void producer(void) &#123; while(TRUE) &#123; item nextp = produce_item(); wait(empty); wait(mutex); buffer[in] = nextp; in = (in + 1) % N; signal(mutex); signal(full); &#125;&#125;void consumer(void) &#123; while(TRUE) &#123; wait(full); wait(mutex); item nextc = buffer[out]; out = (out + 1) % N; signal(mutex); signal(empty); consume_item(nextc); &#125;&#125; 需要注意的是进程中的多个 wait 操作顺序不能颠倒，否则可能造成死锁。例如在生产者中，当系统中没有空的缓冲槽时，生产者进程的 wait(mutex) 获取了缓冲区的访问权，但 wait(empty) 会阻塞，这样消费者也无法执行。 利用管程解决 利用管程解决时，需要为它们建立一个管程，其中 count 表示缓冲区中已有的产品数目，条件变量 full 和 empty 有 cwait 和 csignal 两个操作，另外还包括两个过程： put(x)：生产者将自己生产的产品放入到缓冲区中，而如果 count &gt;= N，表示缓冲区已满，生产者需要等待； get(x)：消费者从缓冲区中取出一个产品，如果 count &lt;= 0，表示缓冲区为空，消费者应该等待； 12345678910111213141516171819202122232425262728Monitor producerconsumer &#123; item buffer[N]; int in, out; condition full, emtpy; int count; public: void put(item x) &#123; if(count &gt;= N) &#123; cwait(full); &#125; buffer[in] = x; in = (in + 1) % N; count++; csignal(emtpy); &#125; item get() &#123; if(count &lt;= 0) &#123; cwait(emtpy); &#125; x = buffer[out]; out = (out + 1) % N; count--; csignal(full); &#125; &#123; in = 0; out = 0; count = 0; &#125;&#125; 于是生产者和消费者可描述为： 123456789101112void producer() &#123; while(TRUE) &#123; item nextp = produce_item(); producerconsumer.put(nextp); &#125;&#125;void consumer() &#123; while(TRUE) &#123; item nextc = producerconsumer.get(); consume_item(nextc); &#125;&#125; 哲学家就餐问题哲学家就餐问题描述的是：有五个哲学家共用一个圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们交替地进行思考和进餐。哲学家在平时进行思考，在饥饿时试图获取左右两只筷子，拿到两只筷子才能进餐，进餐完后放下筷子继续思考。 为实现筷子的互斥使用，可以用一个信号量表示一只筷子，五个信号量构成信号量数组，也都被初始化为 1。 1semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; 第 i 位哲学家的活动可描述为： 12345678910void philosopher(int i) &#123; while(TRUE) &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); // eat signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); // think &#125;&#125; 上述解法中，如果五位哲学家同时饥饿而都拿起左边的筷子，再试图去拿右边的筷子时，会出现无限期等待而引起死锁。 读者-写者问题读者-写者问题描绘的是：一个文件可以被多个进程共享，允许多个 Reader 进程同时读这个文件，但不允许 Wirter 进程和其他 Reader 进程或 Writer 进程同时访问这个文件。所以读者-写者需要保证一个 Writer 进程必须与其他进程互斥地访问共享对象。 解决这个问题需要设置两个互斥信号量和一个整形变量： 互斥信号量 wmutext：实现 Reader 进程和 Writer 进程在读或写时的互斥； 整形变量 readcount：正在读的进程数目； 互斥信号量 rmutext：实现多个 Reader 进程对 readcount 变量的互斥访问； 123456789101112131415161718192021222324252627semaphore rmutex = 1, wmutex = 1;int readcount = 0;void Reader() &#123; while(TRUE) &#123; wait(rmutex); if(readcount == 0) &#123; wait(wmutex); &#125; readcount++; signal(rmutex); // perform read opertaion wait(rmutex); readcount--; if(readcount == 0) &#123; signal(wmutex); &#125; signal(rmutex); &#125;&#125;void Writer() &#123; while(TRUE) &#123; wait(wmutex); // perform wirte opertaion signal(wmutex); &#125; &#125; 只要有一个 Reader 进程在读，便不允许 Writer 进程去写。所以，仅当 readcount = 0，表示没有 Reader 进程在读时，Reader 进程才需要执行 wait(wmutex) 操作，而 readcount != 0 时，表示有其他 Reader 进程在读，也就肯定没有 Writer 在写。同理，仅当 readcount = 0 时，才执行 signal(wmutex) 类似。 进程通信进程通信是指进程之间的信息交换。在进程间要传送大量数据时，应利用高级通信方法。 共享内存在共享内存系统中，多个通信的进程共享某些数据结构或存储区，进程之间能够通过这些空间进行通信。 可分为两种类型： 基于共享数据结构的通信方式。多个进程共用某些数据结构，实现进程之间的信息交换，例如生产者-消费者问题中的缓冲区。这种方式仅适用于少量的数据，通信效率低下。 基于共享存储区的通信方式。在内存中分配一块共享存储区，多个进程可通过对该共享区域的读或写交换信息。通信的进程在通信前，需要先向系统申请共享存储区的一个分区，以便对其中的数据进行读写。 管道管道（Pipe）是指用于连接一个读进程和一个写进程以实现进程间通信的一个共享文件。发送进程以字符形式将数据送入管道，而接收进程则从管道中接收数据。 管道机制提供了三方面的协调能力： 互斥：当一个进程对管道执行读或写操作时，其他进程必须等待； 同步：当写进程把一定数量的数据写入管道，便睡眠等待，直到读进程取走数据后再把它唤醒； 确定对方是否存在，只有确定对方存在才能通信。 消息传递消息传递机制中，进程以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的原语，在进程之间进行消息传递，完成进程间数据交换。 按照实现方式，可分为两类： 直接通信方式：发送进程利用操作系统提供的发送原语，直接把消息发送给进程，接收进程则利用接收原语来接收消息； 间接通信方式：发送和接收进程，通过共享中间实体方式进行消息的发送和接收，完成进程间的通信。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(2)--进程和线程]]></title>
    <url>%2F2019%2F01%2F07%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程什么是进程进程（process）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 OS 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。 在某一瞬间，一个 CPU 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。进程和程序间的联系和区别如下： 程序是一段静态的代码；进程是一个动态运行的过程； 程序是产生进程的基础；进程是程序功能的体现； 程序的每次执行都构成了不同的进程，通过多次运行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序； 进程的实现为了实现进程，操作系统维护了一张进程表（结构数组），每个进程占用一个进程表项（进程控制块 PCB），它是进程存在的唯一标志。该表项包含了进程状态的重要信息，包括进程标识符、状态、优先级、程序计数器、堆栈指针、寄存器等； 对进程的管理就是对通过 PCB 的组织管理来实现的。由于保存了在进程的状态变化时的必要信息，在中断一个正在执行的进程，并在后来恢复时，就好像进程从未中断过。它是支持多进程和提供多处理的关键。 进程的状态及转换如下图是进程的三种状态的状态图。一个进程的三种状态是： 运行态：进程正在占用 CPU 执行； 就绪态：进程处于准备运行状态，已经获得除 CPU 外的所有资源； 阻塞态：进程由于等待某种外部事件而暂停运行，即使获得 CPU，也不能运行。 进程之间主要有四种转换关系： 由运行态转换为就绪态：在时间片用完后，不得不让出 CPU； 由就绪态转换为运行态：进程被调度，获得处理机资源； 由阻塞态转换为就绪态：进程的 I/O 请求完成； 由运行态转换为阻塞态：进程发出 I/O 请求； 线程什么是线程线程（thread）是进程中的一条执行流程。在引入线程的操作系统中，进程是拥有资源的基本单位；而线程是 CPU 调度和分派的基本单位。 一个进程中可以有多个线程，多个线程可以并发执行，它们之间共享相同的地址空间。但如果一个线程崩溃，可能会导致其所属进程的所有线程崩溃。 进程和线程的区别 调度性：传统 OS 中，进程是调度和分派的基本单位，但在引入线程后，线程是调度和分派的基本单位； 并发性：在引入线程后，多个进程可以并发执行，一个进程中的多个线程也可以并发执行； 拥有资源：进程是拥有资源的基本单位，而线程本身并不拥有资源； 系统开销：进程切换付出的系统开销明显大于线程； 线程实现的三种方式有三种线程的实现方式： 用户线程：用户空间实现，由用户线程库管理； 内核线程：内核中实现，由操作系统管理； 轻量级进程：内核中实现，支持用户线程； 用户线程 用户线程是把整个线程包放在用户空间中，不依赖于操作系统的内核，所以它可以在不支持线程的操作系统上实现。可以用一组用户级的线程函数库来实现线程。 每个进程都需要私有的线程表，用来跟踪记录该进程中线程的状态信息，不过仅记录每个线程的程序计数器、堆栈指针、寄存器和状态等，该线程表由运行时系统管理。而且用户线程的切换由线程库函数来完成，不需要用户态、核心态切换，所以线程调度速度特别快。另外，也允许每个进程都拥有自定义的线程调度算法。 但如果一个线程发起系统调用而阻塞，尽管其他线程可以运行，但整个进程都会阻塞。当一个线程开始运行后，除非它主动较交出 CPU，否则它所在的进程中的其他线程将无法运行。 内核线程 内核线程在操作系统的内核中实现，由内核来完成对线程的创建、终止和管理。 由于线程的创建、终止和切换通过系统调用执行，由内核完成的，其系统开销比较大； 但在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他使用内核线程的运行； 轻量级进程 轻量级进程是内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。而轻量级进程内部可以对应多个用户线程。 CPU 调度调度概念处理机调度是当有多个进程（线程）竞争 CPU 时，调度程序需要从从就绪队列中挑选下一个占用 CPU 运行的进程。 调度算法是为了解决通过什么样的准则来挑选就绪对列中的哪一个进程来执行。在每次调度时需要决定在下一个 CPU 计算时将哪个进程交给 CPU。 调度算法先来先服务算法FCFS 根据进程进入就绪态的先后顺序排列。当进程进入阻塞态或结束时，就绪队列中的下一个进程占用 CPU。 实现简单，但可能短进程排在长进程后面，导致平均等待时间波动较大。 短进程优先算法SJF 选择就绪队列中执行时间最短的进程占用 CPU 运行。 可抢占系统改进：短剩余时间优先算法，即选择剩余运行时间最短的进程运行。 短进程优先算法有最优的平均周转时间，但连续的短进程可能会使长进程无法获得 CPU 资源，导致饥饿；运行时间不可预估，并不可靠。 最高响应比优先算法HRN 选择就绪队列中响应比最高的进程。它是基于短进程优先算法的改进，它不允许抢占，另外等待时间越长，响应比越高，可以避免长时间地等待。 1R = (w+s)/s // 其中 w 为等待时间，s 为执行时间。 时间片轮转算法RR 按时间片分配给进程运行。在轮转中，每个进程分到执行 1/n 的时间，时间片结束时，按先来先服务算法切换到下一个就绪进程，每隔 n-1 个时间片进程会再次执行。 如果时间片过大，进程等待时间过长，极限情况下会退化为先来先服务算法；如果时间片过小，虽然反应迅速，但上下文切换开销较大，会影响系统吞吐量。 多级反馈队列算法 就绪队列被划分为多个独立的子队列，而且每个队列可以有自己的调度策略，在队列之间可以设置优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短。 在执行时，进程在不同队列间移动，如果进程在当前优先级的时间片下没有完成，则下降到低一优先级的队列，以此类推。只有当一个队列为空时才会去执行下一个队列中的进程。 这种算法对于 CPU 密集型进程的优先级下降很快，而 I/O 密集型进程停留在高优先级。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(1)--操作系统概述]]></title>
    <url>%2F2019%2F01%2F06%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。 参考学习： 书籍：《现代操作系统》、《深入理解计算机系统》 视频：学堂在线 - 操作系统（自主模式） 操作系统知识点 操作系统概述： 操作系统的定义以及功能； 计算机系统体系结构； 操作系统的四个特性：并发、共享、虚拟、异步； 用户态和核心态的区别； 进程和线程： 进程的几种状态及其转换； 进程与线程的区别； 进程调度的算法； 进程同步的方式； 进程通信的方式； 死锁： 死锁的概念、导致死锁的原因； 导致死锁的四个必要条件； 处理死锁的四种方式：预防、避免、检测、解除； 存储器： 内存连续分配方式采用的算法及优缺点； 分页存储管理方式； 分段存储管理方式； 段页式存储管理方法； 几种存储方式的比较及各自优缺点； 从逻辑地址到物理地址的转换过程； 虚拟存储器： 虚拟存储器的定义与实现方式； 页面置换算法，计算所需换页数； 文件系统： 文件系统基本概念； 文件分配方式； 什么是操作系统计算机系统一般由一个或多个处理器、内存、I/O 设备等组成，而操作系统就是这些硬件之上的一种软件，它为应用程序提供了一个抽象，并管理这些计算机资源。具体可以从功能上来认识操作系统。 作为扩展机器，它隐藏硬件底层实现细节，对硬件提供抽象，方便程序或用户的使用： 进程是对 CPU、主存及 I/O 设备的抽象； 虚拟内存（虚拟地址空间）是对主存和 I/O 设备的抽象； 文件是对 I/O 设备的抽象； 作为资源管理器，它在多个竞争程序之间合理地控制对处理器、存储器及 I/O 设备的分配，避免资源使用冲突。有两种共享资源的方式： 时间复用：不同程序或用户轮流使用； 空间复用：每个程序或用户得到资源的一部分； 内核态和用户态如下图是一般计算机系统的简化图。多数计算机有两种运行模式：内核态和运行态。 操作系统运行在内核态，它对所有硬件具有访问权，可以执行任何指令。用户接口程序和其余软件运行在用户态，它只能执行机器指令中的一个子集。 四大特性操作系统主要有四大特性，分别为： 并发：在宏观上有多个程序在同时运行，需要 OS 管理和调度，而在微观上是分时交替运行； 注意并发和并行的区别： 并发指的是在一段时间内有多个应用程序可以运行； 并行指的是在一个时间点有多个应用程序可以执行，并行需要计算机有多个 CPU； 共享：资源可以供内存中多个并发执行的进程共同使用，在宏观上是同时访问该资源，而在微观上是采用互斥共享。 虚拟：利用多道程序设计，让每个应用程序都觉得有一个计算机专门为它服务。 异步：程序的执行不是连贯的，而是间断性的，其速度也不可知，但只要运行环境相同，其运行结果需要保证相同。 计算机体系结构计算机系统主要由处理器、主存、I/O 设备及系统总线组成。 处理器 也称中央处理单元（CPU），是用来解释或执行主存中的指令的引擎。在任何时候，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，指向下一条指令。 主存 主存，是一个临时存储设备，用来存放程序和程序要处理的数据。存储系统大多采用分层次的存储结构。如下图： 存储层次最顶层是寄存器。下一层是两层高速缓存 L1、L2。再下一层是主存，所有不能再高速缓存行命中的访问请求会转到内存。如果内存中还没有，可能还会到虚拟内存中查找。 在层次结构中，较高层次的存储设备可以作为较低层次设备的高速缓存。更高层次的存储设备比底层的更快，但价格也更昂贵。 I/O 设备 I/O 设备是系统与外界联系的通道。主要包括磁盘、显示器、键盘等。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连，来传递信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 异常]]></title>
    <url>%2F2018%2F11%2F08%2FJava%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[Java 标准异常Throwable 是 Java 中最顶级的异常类，继承自 Object，实现了序列化接口，它有两个重要的子类：Exception 和 Error，二者都是 Java 异常处理的重要子类，它们之间的区别和联系如下： Error：表示系统级的错误，是 Java 运行环境内部或硬件问题，一般与虚拟机相关，例如：栈溢出、内存溢出等。这种异常抛出后不能指望程序来进行处理。 Exception：表示需要程序捕获并处理的异常，是由程序设计的不完善而出现的问题，包括运行时异常（RuntimeException）和其他异常，例如 IOException 等。 异常体系图如下： 异常分类Java 中的异常可分为两类：非受检异常（Unchecked Exception）和受检异常（Checked Exception）。 其中 Error 和 RuntimeExcpetion 表示属于非受检异常。这种异常不需要显式地捕获，也不需要在异常说明中声明，但是如果发生异常就会中断程序的执行。这种异常一般是由于代码原因导致的，例如空指针、数组越界、转型异常等。所以，只要代码没问题，这些异常就可以避免，也就不需要显式处理。 而其他的异常都属于受检异常。这种异常需要使用 try-catch 捕获处理或者在异常说明中进行声明，如果一个方法调用了有受检异常抛出的方法那么就需要对该异常进行处理，否则编译就不能通过。例如 IOException、SQLException、ClassNotFoundException 等。 123456789101112public void test() &#123; try &#123; // 异常捕获 Class.forName("timberliu.exception.User"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125;&#125;// 异常说明中进行声明// throws 用来声明方法可能抛出的所有异常public void test() throws IOException &#123;&#125; 受检异常在 IO 操作中使用较多。例如 FileNotFoundException，它表示的是：告诉方法调用者，不保证这个寻找文件的操作一定成功，取决于外部因素，所以需要明确地对调用失败的情况进行特殊处理。 异常的处理在异常被捕获后，有两种处理方式：1. 自己进行处理；2. 向上抛出，交给调用者处理。具体处理时，如果不知道如何处理那就向上抛出；如果知道如何处理，那么有以下处理方式： 打印记录日志 封装异常后重新抛出 返回失败通用对象 Response.Failed() 更改程序结果后正常返回 忽略或 e.printStackTrace()，一般禁止这样使用。 12345678try &#123; // 明确抛出一个异常 throw new Exception();&#125; catch (Exception e) &#123; // 处理异常&#125; finally &#123; // 关闭 IO、网络连接等资源&#125; 将捕获的异常重新封装到一个新的异常里重新抛出，这称为异常链。大多用于将受检异常封装成非受检异常。另外，抛出的新异常必须包含原有异常，这样在处理程序时才可以通过 getCause() 和 initCause() 方法访问异常的根源。 12345678public void test() &#123; try &#123; throw new FileNotFoundException(); &#125; catch (FileNotFoundException e) &#123; // 将 e 封装到新创建的异常里 throw new RuntimeException(e); &#125;&#125; 意外情况1.在 return 中使用 finally 在 try 语句中有 return 语句时，finally 中的代码会在 try 或 catch 块中的 return 语句执行之后，返回之前执行。 123456789101112131415161718public static int test() &#123; int i = 1; try &#123; System.out.println("try"); return i = 2; &#125; finally &#123; System.out.println("before finally: " + i); i = 3; System.out.println("after finally: " + i); &#125;&#125;public static void main(String[] args) &#123; System.out.println("return: " + test());&#125;// try// before finally: 2// after finally: 3// return: 2 可以看到，这里的执行顺序是先执行 i = 2；然后执行 finally 块中的语句；最后 return。但是在 finally 语句中修改 a 的值，对结果不会造成影响。 如果 finally 语句中也有 return 语句，还会覆盖 try 或 catch 中的 return 语句的返回结果： 123456789101112public static int test() &#123; int i = 1; try &#123; return i = 2; &#125; finally &#123; return i = 3; &#125;&#125;public static void main(String[] args) &#123; System.out.println("return: " + test());&#125;// return 3 2.异常丢失 如果在 try/catch 块中，执行 System.exit(0); 后，进程会被杀死，finally 中的代码就不会执行了。 123456789public static void main(String[] args) &#123; try &#123; System.out.println("try"); System.exit(0); &#125;finally &#123; System.out.println("finally"); &#125;&#125;// try 常见的运行时异常 IndexOutOfBoundsException：数组下标越界异常 ArrayStoreException：向数组中存放与声明类型不兼容的对象异常 1234Animal[] a = new Dog[1];a[0] = new Cat();// java.lang.ArrayStoreException: timberliu.exception.Cat ArithmeticException：算术运算异常，例如除 0 运算 ClassCastException：类型强制转换异常 DateTimeException：时间运算异常 IllegalArgumentException：非法参数异常 1234Animal animal = new Dog();Cat cat = (Cat)animal;// java.lang.ClassCastException: timberliu.exception.Dog cannot be cast to timberliu.exception.Cat NegativeArraySizeException：创建一个大小为负数的数组错误 NullPointerException：空指针异常 NumberFormatException：数字格式异常，例如在字符串转换为数字时： 123int a = Integer.parseInt("abc");// java.lang.NumberFormatException: For input string: "abc" SecurityException：安全异常 UnSupportedOperationException：不支持的操作异常 更多的异常可见官方的 doc：RuntimeExcpetion（Java Platform SE 8） Java7 新特性try-with-resources 在 Java7 之前，对于 IO 操作、网络连接等，用完之后必须在 finally 块中调用 close 方法进行关闭，否则可能会导致内存泄露等问题。而从 Java7 中，可以使用 try-with-resources 语句，不需要再显式地关闭资源。 12345678910public static void main(String[] args) &#123; try (BufferedReader bufferedReader = new BufferedReader(new FileReader("e:\\file.txt"));) &#123; String line; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (IOException e) &#123; // handle exception &#125;&#125; 反编译一下，看它背后的实现： 123456789101112131415161718192021222324252627282930313233public static void main(String[] args) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new FileReader("e:\\file.txt")); Throwable var2 = null; try &#123; String line; try &#123; while((line = bufferedReader.readLine()) != null) &#123; System.out.println(line); &#125; &#125; catch (Throwable var12) &#123; var2 = var12; throw var12; &#125; &#125; finally &#123; if (bufferedReader != null) &#123; if (var2 != null) &#123; try &#123; bufferedReader.close(); &#125; catch (Throwable var11) &#123; var2.addSuppressed(var11); &#125; &#125; else &#123; bufferedReader.close(); &#125; &#125; &#125; &#125; catch (IOException var14) &#123; ; &#125;&#125; 可以看到，编译器自动生成了关闭资源的操作。而且，以前在关闭资源时有可能也会抛出异常，在 Java7 中可以使用 Throwable.addSuppressed 方法来抑制可能抛出的异常，这也是 Java7 增加的方法。 Multi-Catch Exceptions 它表示 catch 语句能同时捕获多个异常。 1234567891011public static void main(String[] args) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new FileReader("e:\\file.txt")); String line = bufferedReader.readLine(); SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd"); Date date = format.parse(line); &#125; catch (ParseException | IOException e) &#123; // handle exception &#125;&#125; 这样就可以用同样的异常处理程序，来处理多个异常。 Rethrowing Exceptions 能够直接再次抛出已捕获的异常。注意：throw new Exception(e) 抛出的是重新包装之后的异常；而 throw e 抛出的是原始的异常。 12345678910111213141516public static void test() throws IOException &#123; try &#123; throw new IOException("IOException"); &#125; catch (IOException e) &#123; throw e; &#125;&#125;public static void main(String[] args) &#123; try &#123; test(); &#125; catch (IOException e) &#123; System.out.println(e.getMessage()); &#125;&#125;// IOException]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[接口与内部类]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[抽象类抽象方法指的是仅有声明而没有方法体的方法。使用 abstract 关键字进行声明：1abstract void f() 而包含一个或多个抽象方法的类，就叫抽象类，用 abstract关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。抽象类的主要目的是代码重用。大多用于抽象相关 Java 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 java.util.AbstractList。 接口接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 static 和 final 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 enum 枚举类。 接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 Cloneable、Serializable，表示这个类可以克隆或者可以序列化。 Java 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。 12345678910111213141516171819202122232425interface Study &#123; void study();&#125;interface Play &#123; void play();&#125;Class Person &#123; public void doSomething() &#123; System.out.println("person doSomething"); &#125;&#125;public class Student extends Person implements Study, Play &#123; @Override public void doSomething() &#123; System.out.println("student doSomething"); &#125; void study() &#123; System.out.println("study"); &#125; void play() &#123; System.out.println("play"); &#125;&#125; 抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。 1234567891011121314151617181920212223interface Diner &#123; void eat();&#125;interface Sleeper &#123; void sleep();&#125;// 接口可以继承接口（支持多继承）interface Student extends Diner, Sleeper &#123; void study();&#125;// 抽象类可以实现接口abstract class Undergraduate implements Student &#123; @Override public void eat() &#123; System.out.println("eat"); &#125; @Override public void sleep() &#123; System.out.println("sleep"); &#125; public abstract void study();&#125; 抽象类与接口比较 一个类只能继承一个抽象类，但可以实现多个接口； 接口中的字段只能是 static 和 final 的，而抽象类的字段没有限制； 接口中的方法只能是 public 的，而抽象类的方法则没有限制。 一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 Java8 开始也增加了默认方法，使得修改接口的成本也降低很多。 如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。 默认方法在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。 所以从 Java8 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。 1234567public interface Sized &#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 例如，Java 8 中 List 接口的 sort 方法就是默认方法。 123456789default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 1.可选方法 默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。 例如，在 Java8 中，Iterator 接口为 remove 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 Iterator 接口的每一个类都声明一个空的 remove 方法。 1234567interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next(); default void remove() &#123; throw new UnSupportedOperationException(); &#125;&#125; 2.行为的多继承 默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法: 1234567891011121314151617interface Moveable &#123; int getX(); void setX(int x); default void moveHorizontally(int distance) &#123; setX(getX() + distance); &#125;&#125;interface Resizable &#123; int getWidth(); void setWidth(int width); default void resizeWidth(int distance) &#123; setWidth(getWidth() + distance); &#125;&#125; 12345678public class Change implements Moveable, Resizable &#123; public static void main(String[] args) &#123; Change c = new Change(); c.moveHorizontally(10); c.resizeWidth(10); &#125;&#125; 解决冲突Java 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。 第一条规则 在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 1234567891011121314151617interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;class B &#123; public void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C extends B implements A &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125; 上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。 第二条规则 如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。 123456789101112131415161718interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B extends A &#123; default void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello form B 在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。 第三条规则 如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。 1234567891011121314151617181920212223interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B &#123; default void hello() &#123; System.out.println("hello from B"); &#125;&#125;public class C implements A, B &#123; @Override public void hello() &#123; A.super.hello(); &#125; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello from A 上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 hello 方法，并且在调用时，使用 X.super.f() 这种语法，显式地指定使用哪一个接口中的方法。 内部类从外部类对象的非静态方法之外的任意位置创建某个内部类的对象，那么必须指明这个对象的类型：OuterClassName.InnerClassName。而且当生成一个内部类对象时，内部类对象会拥有一个指向外部类对象的引用，也就拥有了外围类所有成员的访问权。 要想创建内部类对象，必须使用外部类的对象来创建，这需要使用 .new 语法。 12345678public class Outer &#123; public class Inner &#123; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); &#125;&#125; 而在内部类中如果想要生成对外部类对象的引用，可以使用外部类的名字后面紧跟圆点和 this。 123456789101112131415161718public class Outer &#123; public void f() &#123; System.out.println("Outer.f()"); &#125; public class Inner &#123; public Outer outer() &#123; return Outer.this; &#125; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Outer.Inner inner = outer.new Inner(); inner.outer().f(); &#125;&#125;// Outer.f() 匿名内部类 1234567891011121314151617181920212223public class Outer &#123; class Inner &#123; public void value() &#123; System.out.println("inner class"); &#125; &#125; public Inner inner(final String str) &#123; return new Inner() &#123; @Override public void value() &#123; System.out.println("inner subclass: " + str); &#125; &#125;; &#125; public static void main(String[] args) &#123; Outer outer = new Outer(); Inner inner = outer.inner("Inner"); inner.value(); &#125;&#125;// inner subclass: Inner 上面就是一个匿名内部类的例子，表示创建一个继承自 Inner 的匿名类的对象。在匿名内部类中，一般使用默认的构造器来生成内部类。另外，如果在匿名内部类希望使用一个在外部定义的对象，那么必须将其声明为 final。 但是匿名内部类与正规的继承相比有些受限，因为匿名内部类既可以扩展类，也可以实现接口，但两者不能兼备。它只能扩展一个类或者只实现一个接口。 工厂模式接口一般用来实现多重继承，而生成遵循某个接口的对象可以使用工厂设计模式。一般在工厂对象上调用的是创建方法，而该工厂对象会生成接口的某个实现的对象。 工厂模式的实现在使用匿名内部类时会更加优雅。 123456interface Game &#123; boolean move();&#125;interface GameFactory &#123; Game getGame();&#125; 123456789101112131415class Checkers implements Game &#123; private Checkers() &#123; &#125; private int moves = 0; private static final int MOVES = 3; public boolean move() &#123; System.out.println("Checkers move " + moves); return ++moves != MOVES; &#125; public static GameFactory factory = new Factory() &#123; public Game getGame() &#123; return new Checkers(); &#125; &#125;;&#125; 12345678910111213public class Games &#123; public static void playGame(GameFactory factory) &#123; Game g = factory.getGame(); while(s.move()) ; &#125; public static void main(String[] args) &#123; playGame(Checkers.factory); &#125;&#125;// Checkers move 0// Checkers move 1// Checkers move 2 可以看到，在使用匿名内部类时，构造器都是 private 的，并且没有任何必须去创建一个额外的工厂类。另外，对于经常只需要单一的工厂对象，也被创建为 static。 嵌套类嵌套类，也就是静态内部类，要创建嵌套类对象，不需要外部类对象。 123456789101112public class Outer &#123; public static class Inner &#123; public static void hello() &#123; System.out.println("static inner class"); &#125; &#125; public static void main(String[] args) &#123; Inner.hello(); &#125;&#125;// static inner class 与内部类相比，区别如下： 创建内部类需要外部类的对象；嵌套类不需要外围类的对象 内部类不可以定义静态成员变量；嵌套类可以定义静态成员变量 内部类可以访问外部类的成员变量；嵌套类不可以访问非静态的外部类的成员变量]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型与运算]]></title>
    <url>%2F2018%2F11%2F03%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[基本数据类型Java 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下： Java 中的 char 使用 Unicode 编码，占两个字节。所以在 Unicode 编码中存在的中文，都可以用 char 存储。 在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：Java中，为什么 byte 类型的取值范围为-128~127?。 浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。Java 中使用 IEEE754表示法，分为单精度和双精度两种，也就是 float 和 double，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。 包装类型每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别： 默认值不同。基本类型的默认值为 0、false 等；而包装类默认为 null 初始化不同。基本类型不需要初始化；而包装类需要 new。 存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中 元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法 基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 Java5 提供的一个语法糖。自动装箱就是 Java自动将原始类型值转换为对应的对象；自动拆箱就是 Java 自动将对象转换为对应的基本类型。例如： 1234public static void main(String[] args) &#123; int i = 1; Integer n = i;&#125; 在反编译后，代码如下： 1234public static void main(String[] args) &#123; int i = 1; Integer n = Integer.valueOf(i);&#125; 可以看到，自动装箱就是调用 Integer 的 valueOf() 方法实现的；而自动拆箱是调用 Integer 的 xxxValue() 方法实现的。 整型的缓存机制Java5 中，Integer 引入了一个新功能来节省内存和提高性能。在使用 Integer.valueOf()方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。 valueOf() 方法的实现如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 Integer 对象。 IntegerCache 是 Integer 的一个内部类，缓存池的大小默认为 -128~127。最大值可通过 -XX:AutoBoxCacheMax=xxx 修改。这个缓存在 Integer 类第一次被使用时，通过一个 for 循环存储在一个整数数组中。 1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 由于编译器在自动装箱时会调用 valueOf 方法，所以创建多个相同的值时，会引用相同的对象。 123456public static void main(String[] args) &#123; Integer i = 123; Integer j = 123; System.out.println(i == j);&#125;// true 所有的包装类都有类似的缓存机制： ByteCache 可以缓存 Byte 对象 ShortCache 可以缓存 Short 对象 LongCache 可以缓存 Long 对象 CharacterCache 可以缓存 Character 对象 Byte、Short、Long 的缓存范围都是固定的，为 -128~127。而 CharacterCache 的范围为 0~127。除了 Integer，这个范围都不能改变。 高精度类型Java 还提供了两个用于高精度计算的类：BigInteger 和 BigDecimal。 BigInteger 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。 BigDecimal 支持任意精度的定点数。可以用它进行精确的货币运算。 在 Java 中，对于金额的运算和在数据库中的存储，一般有两种方式： 以元为单位。Java 中存储类型为 BigDecimal，在数据库中的存储类型为 number(10, 2)，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。 以分为单位。Java 中存储类型为 Long，在数据库中存储类型为 big int。取整和保留方式如前面一样。 看一下下面的例子： 123456public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);&#125; 在进行金额运算时，使用 BigDecimal 类，并且将 double 转为 String 类型进行运算。在使用 divide 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。 值传递与引用传递先来看一下值传递与引用传递的概念： 值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。 引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。 那么 Java 中到底是值传递还是引用传递？先来看下面的例子： 123456789101112public static void change(int j) &#123; j = 2; System.out.println("change: j = " + j);&#125;public static void main(String[] args) &#123; int i = 1; change(i); System.out.println("main: i = " + i);&#125;// change: j = 2// main: i = 1 可以看到，change 方法内部并没有改变实际参数的值，那么 Java 就是值传递吗？再来看下面的例子： 1234567891011121314public static void change(User user) &#123; user.setAge(21); System.out.println("change: " + user);&#125;public static void main(String[] args) &#123; User user = new User(); user.setName("Timber"); user.setAge(20); change(user); System.out.println("main: " + user);&#125;// change: User&#123;name='Timber', age=21&#125;// main: User&#123;name='Timber', age=21&#125; 可以看到，实际参数的值被改变了，那么 Java 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子： 123456789101112public static void change(String name2) &#123; name2 = "TimberLiu"; System.out.println("change: " + name2);&#125;public static void main(String[] args) &#123; String name1 = "Timber"; change(name1); System.out.println("main: " + name1);&#125;// change: TimberLiu// main: Timber 可以看到，实际参数的值又被改变了，这又作何解释呢？ Java 的值传递其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 传递参数时是否会进行拷贝，创建一个副本。 再来看一下上面的第二个例子，是如何传递的呢？ 可以看到，当把 user 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？ 12345678910111213141516public static void change(User user2) &#123; user2 = new User(); user2.setName("TimberLiu"); user2.setAge(21); System.out.println("change:" + user2);&#125;public static void main(String[] args) &#123; User user1 = new User(); user1.setName("Timber"); user1.setAge(20); change(user1); System.out.println("main: " + user1);&#125;// change: User&#123;name='TimberLiu', age=21&#125;// main: User&#123;name='Timber', age=20&#125; 这个过程发生了什么呢？看下图： 可以看到，这里把 user1 传递给 change 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 change 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 user2 的修改并不会影响到 user1 中的内容。 所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。 那么，为什么上面在传递 String 对象和 User 对象结果不一样呢？这是因为 String 类型是不可变的，在赋值 name2 = &quot;TimberLiu&quot; 时，会重新创建一个 String，而并没有修改实际参数的值。 所以，Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用。 类型转换Java 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下： 在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。 另外，在对基本数据进行运算时，所有 byte、short、char 类型的值都会自动被提升为 int。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。 在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子： 123456789public class Overflow &#123; public static void main(String[] args) &#123; int big = Integer.MAX_VALUE; System.out.println("big = " + big); System.out.println("bigger = " + (big + 1)); &#125;&#125;// big = 2147483647// bigger = -2147483648 switch 对 String 的支持switch 原本只支持整型，而 byte、short、char 可以转换为 int 型，所以也可以使用。但从 Java7 开始，在 switch 条件判断语句中也可以使用 String 类型了。 123456789101112public void decompile(String str) &#123; switch(str) &#123; case "aaa": System.out.println("aaa"); break; case "bbb": System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 在反编译后，可以看到： 12345678910111213141516171819202122232425public void decompile(String str) &#123; byte var3 = -1; switch(str.hashCode()) &#123; case 96321: if (str.equals("aaa")) &#123; var3 = 0; &#125; break; case 97314: if (str.equals("bbb")) &#123; var3 = 1; &#125; &#125; switch(var3) &#123; case 0: System.out.println("aaa"); break; case 1: System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 可以看到，String 的 switch 还是比较的 byte 类型。先声明了一个 byte 类型，然后通过 hashCode 和 equals 两个方法先后进行比较来赋予 byte 变量不同的值，最后 switch 来执行不同的代码。这里在 hash 之后再进行 equals 判断是有必要的，因为 hash 可能发生碰撞。 参考资料 Hollis：[译]Java中整型的缓存机制 Hollis：为什么说Java中只有值传递 SEU_Calvin：Java技术——Java中的参数传值方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象中的一些概念]]></title>
    <url>%2F2018%2F11%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[this、superthis 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 this 调用构造器，但必须将构造器置于最起始处。 123456789101112public class User&#123; private String name; private int age; public User(String name) &#123; this.name = name; &#125; public User(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super 关键字表示如果子类重写了父类的某个方法，可以通过 super 关键字来调用父类的方法实现，也可以用来调用父类的构造器。 123456789101112public class Person&#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void say() &#123; System.out.println(name + ":" + age); &#125;&#125; 12345678910111213141516171819public class Student extends Person &#123; private int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; @Override public void say() &#123; super.say(); System.out.println(name + ":" + age + "," + score); &#125; public static void main(String[] args) &#123; Student student = new Student("Timber", 20, 80); student.say(); &#125;&#125;// Timber:20// Timber:20,80 finalfinal 关键字可用于三种情况：变量、方法和类。 1.变量 对于基本类型时，final 使数值恒定不变；对于引用类型时，final 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。 另外，在参数列表中还可以将参数声明为 final，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。 2.方法 final 方法不可以被重写。 类中所有的 private 方法都隐式地指定为 final，所以 private 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。 3.类 final 类不能被继承，而且 final 类中的所有方法都隐式地被指定为 final，无法覆盖它们。 static当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 static 方法或访问其 static 域。 1.变量 当 static 作用于某个字段时，会改变数据的创建方式，因为 static 字段对每个类只有一份存储空间，存放在方法区中；而非 static 字段则对每个对象都有一个存储空间，存放在堆中。 2.方法 对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 this 关键字。而 static 方法就是没有 this 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 static 方法，实际上这正是 static 方法的主要用途。 3.静态块 Java 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。 123456public Class User &#123; private String name; static &#123; name = "Timber"; &#125;&#125; 这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。 重写与重载1.重写 重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。 1234567891011121314151617class Person &#123; public void doSomething() &#123; System.out.println("do something"); &#125;&#125; class Student extends Person&#123; @Override public void doSomething() &#123; System.out.println("studying"); &#125; public static void main(String[] args) &#123; Person person = new Student(); person.doSomething(); &#125;&#125;// studying 上面就是一个重写的例子。重写一般需要注意以下几点： 子类方法的方法签名必须和父类方法相同； 子类方法的返回类型必须小于等于父类的方法； 子类中的访问权限必须大于等于父类的方法； 子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常 不能重写被标识为 final 的方法 重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。 12345678910111213141516public class Person &#123; String s = "person";&#125;public class Student extends Person &#123; String s = "student";&#125;public class Test &#123; public static void main(String[] args) &#123; Person a1 = new Student(); System.out.println("a1.s: " + a1.s); Student a2 = new Student(); System.out.println("a2.s: " + a2.s); &#125;&#125;// a1.s: person// a2.s: student 2.重载 重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。 123456789class Person&#123; public void doSomething() &#123; System.out.println("studying"); &#125; public void doSomething(String thing) &#123; System.out.println("studying " + thing); &#125;&#125; 上面就是一个重载的例子。重载一般需要注意几点： 被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。 根据方法的返回值不能区分重载 重载涉及到基本类型的自动提升时可能会造成混淆。 构造器构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 new 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。 一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 new Person() 创建对象时就会报错。 对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 int 初始化为 0，引用类型初始化为 null等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。 对象的创建过程如下： 当首次创建类对象，或者类的静态方法/静态域被首次访问时，Java 解释器查找类文件； 然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。 如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 null； 然后执行出现于成员变量定义处的初始化动作； 然后再执行构造器。 多态多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件： 有类继承或接口实现 子类要重写父类的方法 父类的引用指向子类的对象 根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。 类实例化顺序类的初始化顺序如下： 按顺序执行父类静态变量和静态代码块 按顺序执行子类静态变量和子类静态代码块 按顺序执行父类非静态变量（父类实例变量）和动态代码块 执行父类构造函数 按顺序执行子类非静态变量（子类实例变量）和动态代码块 执行子类构造函数 举个栗子： 12345678910111213141516171819202122232425262728293031323334353637public class Student extends Person &#123; public static int i = 0; // 3 public int j = 0; // 8 public Student()&#123; // 10 System.out.println("Student Constructor"); &#125; &#123; // 9 System.out.println("Student not static block"); &#125; static &#123; // 4 System.out.println("Student static block"); &#125; public static void main(String[] args) &#123; new Student(); &#125;&#125;class Person &#123; static &#123; // 1 System.out.println("Person static block"); &#125; &#123; // 5 System.out.println("Person not static block"); &#125; public Person()&#123; // 7 System.out.println("Person Constructor"); &#125; public static int i = 0; // 2 public int j = 0; // 6&#125; 打印结果为： 123456Person static blockStudent static blockPerson not static blockPerson ConstructorStudent not static blockStudent Constructor 再看一个栗子： 1234567891011121314151617181920212223public class Son extends Father&#123; public static void main(String[] args) &#123; new Father(); &#125;&#125;class Father&#123; static &#123; // 1 System.out.println("Father static block"); &#125; &#123; // 3 6 System.out.println("Father not static block"); &#125; public Father()&#123; // 5 8 System.out.println("Father Constructor"); &#125; public static Father father = new Father(); // 2 public int j = 0; // 4 7 &#125; 打印结果是： 12345Father static blockFather not static blockFather ConstructorFather not static blockFather Constructor 这里，首先执行静态代码块，打印出 Father static block，然后执行静态变量 father，发现需要 new 一个 Father 对象，然后执行动态代码块、实例变量和构造器。 静态变量初始化后，再执行动态代码块和实例变量，最后执行构造器。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象思想与 Java 平台]]></title>
    <url>%2F2018%2F10%2F28%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%E4%B8%8EJava%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[学习 Java 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。 Java 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 Java 平台又该如何理解？今天就来学习一下。 面向对象思想所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。 而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。 在面向对象程序设计中会创建抽象数据类型，也就是类 class，它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。 三大特征1.封装 封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。 Java 用三个关键字在类内设定边界：public、protected、private，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。 2.继承 代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 private，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。 另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写 overriding。 那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。 3.多态 在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。 在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。 五大设计原则面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。 单一职责（Single Responsibility）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。 开关封闭（Open-Closed）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。 里氏替换（Liskov Substitution）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。 接口隔离（Interface-Segregation）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。 依赖倒置（Dependency Inversion）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。 对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。 解释型语言先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：C/C++ 等。 解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：Java、python 等。 严格来说，传统的 Java 是解释型语言，但加入了 JIT、AOT 编译器后，让 Java 也拥有了编译型语言的特性。它总共有三种执行的方式： Java 源代码首先经过 Javac 编译成 .class 文件，然后： 解释执行：.class 文件经过 JVM 内嵌的解释器解释执行。 编译执行：即时编译器（Just In Time 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热） 编译执行: Java 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成） Java 与 C++ 的区别Java 和 C++ 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：C++ 是编译型语言，Java 是解释型语言。 二者主要区别如下： - Java C++ 语言类型 解释型 编译型 平台相关性 跨平台 平台相关的 语言 纯粹的面向对象语言 既支持面向对象也支持面向过程 数字类型 在所有平台上基本类型有标准的范围限制和字节长度 对数字类型有标准的范围限制但字节长度跟具体实现有关 参数传递 只有值传递它的引用可以理解为安全指针 有值传递和引用传递 内存管理 自动垃圾回收 需要显示的内存管理，支持析构函数 继承与实现 支持多重继承 只允许单继承，但可以多实现 操作符 不支持操作符重载仅对 String 有两个内置的加法运算 支持操作符重载 JDK、JRE、JVM下图是 Oracle 官方文档中的 JDK、JRE、JVM 三者间的关系： 三者详细： JDK：Java Development Kit（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。 JRE: Java Runtime Enviroment（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。 JVM：Java Virtual Machine（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。 跨平台特性Java 的跨平台特性与 Java 虚拟机的存在密不可分。其实 Java 语言本身与其他编程语言没有特别大的差异，并不是说 Java 语言可以跨平台，而是在不同的平台都有可以让 Java 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 JDK，安装 JDK 也就有了 Java 的运行环境。 简单来说，Java 首先通过 javac 编译器将源码编译为字节码 .class 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 JVM 会可以根据不同的平台，使用不同的 JVM 映射规则，生成对应的机器码，让其与操作系统无关。所以 Java 才有了“编译一次，到处运行”的效果。 Java 平台Java 是一种面向对象的语言，最显著的特性有两个方面： 跨平台特性。也就是“编译一次，到处运行”（Compile once, run anywhere)，能够非常容易地获得跨平台能力； 垃圾回收机制。Java 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。 对于 Java 平台，有很多个方面可以谈： Java 语言特性：面向对象特性、泛型、Lamdba 等 基础类库：集合、IO/NIO、网络、并发等基础类库 JVM：类加载机制、垃圾回收、常用工具 Java 生态：JavaEE、Spring、Maven、Hadoop 等 下图是总结的一个蓝图： 参考资料 《Java 编程思想》 Hollis：牢记面向对象五个基本原则 十四期_李光：面向对象与面向过程的本质的区别]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
</search>
