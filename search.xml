<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[操作系统知识回顾(5)-内存管理]]></title>
    <url>%2F2019%2F01%2F11%2F%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%2F</url>
    <content type="text"><![CDATA[存储器管理的主要对象是内存。这篇文章总结了内存分配的两种方式，其中重点需要掌握非连续分配方式：即分页式、分段式、段页式分配的基本概念和地址转换。 连续内存分配在系统中运行程序，需要为其分配一定大小的内存空间。内存分配方式主要有连续分配和非连续分配两种。 动态分区分配是一种连续分配方式，它根据进程的实际需要，在程序被加载时，动态地为之建立一个大小可变的分区，这个分区的地址是连续的。 内存管理方式为实现动态分区分配，系统必须对空闲的内存进行管理，主要有两种方法：位图法和空闲区链表。 位图法 使用位图方法时，内存可能被划分为小到几个字或大到几千个字节的分配单元。每个分配单元对应位图中的一位，0 表示空闲，1 表示占用。 位图的缺点是如果想要调入一个占 k 个分配单元的进程，必须搜索位图，找出有 k 个连续 0 的串。查找位图中指定长度的连续 0 串的操作很耗时。 空闲区链表法 链表法是维护一个已分配内存段和空闲内存段的链表。链表的结点包括一个进程，或两个进程间的一块空闲区。 内存分配算法在将程序加载入内存时，需要按照一定的算法，从位图或空闲链表中选择分区分配给进程。 首次适配(first fit) 首次适配算法要求空闲区链表按照地址递增的顺序排序。在分配内存时，沿着链表进行搜索，直到找到一个足够大的分区，将其分为两部分，一部分供进程使用，一部分形成新的空闲区。 它的实现比较简单，但是低地址部分不断被划分，会留下许多小空闲分区。 下次适配(next fit) 下次适配算法和首次适配算法类似，只是不再像首次适配算法那样每次都从头开始，而是从上次找到的空闲分区的下一个空闲分区开始搜索。 最佳适配(best fit) 最佳适配算法要求将空闲分区按照其容量大小进行排序。在分配内存时，查找一个能满足要求、又是最小的的空闲分区，分配给进程。 这种算法的缺点是分区在每次分配后的剩余部分总是最小的，会留下许多难以利用的碎片。 最差适配(worst fit) 最差适配算法在分配内存时，总是选择一个最大的空闲分区，划分为两部分，一部分给进程使用，另一部分形成新的空闲分区。 最差适配算法使得剩下的空闲分区不至于产生太小的碎片；但是这样容易破坏大的空闲分区，后续难以找到大的分区。 快速适配(quick fit) 快速适配算法是将空闲分区按照其容量进行分类，为每一类相同容量的空闲分区单独维护一个链表。同时，设立一张管理索引表，表中每一项对应一种空闲分区类型。 快速适配算法的缺点是在进程被终止或换出释放分区时，有效地合并分区非常耗时。 非连续内存分配在非连续分配时，根据所分配地址空间的基本单位不同，可将其分为分页存储管理、分段存储管理、段页式存储管理三种方式。 分页存储管理在分页存储管理方式中，把用户程序的地址空间划分为若干个固定大小的页。典型的页面大小为 1KB。相应地，也将内存空闲分为若干个物理块，页和块大小相同，这样可以将用户程序的任一页放入任一物理快中实现非连续分配。 分页地址中的地址结构为： 地址长度为 32 位，其中 0~11 位为页内地址，即每页的大小为 4KB；12~31 位为页号，最多允许有 1M 页。 系统为每一个进程建立了一张页表，它负责逻辑页号到物理块号之间的地址转换。每一个页面对应一个页表项，记录了相应页在内存中对应的物理块号。 在 CPU 中设置一个页表基址寄存器，存储着页表的起始地址和页表的长度。 在进行地址转换时，首先将页号与页表长度进行比较，如果页号大于或等于页表长度，则表示本次所访问地址已超过进程的地址空间，产生越界中断。如果没有发生越界中断，则将页表始址与页号和页表项长度的乘积相加，得到该页表项在页表中的位置，于是可从中得到该页的物理块号，最后根据物理块号和页内地址便可得到物理地址。 分页式存储管理方式主要有两个缺点： 性能问题：访问一个内存单元需要两次内存访问，第一次访问获取页表项，第二次访问才访问数据。（快表） 如果每页太小，页表可能会非常大，较难找到连续的大内存空间。（多级页表） 页表改进快表 为提高地址转换速度，可在地址转换机构中增加一个可并行查询的缓冲寄存器，称为快表。 在进行地址转换时，首先将页号与快表中的所有页号进行比较，如果其中有与此相匹配的页号，便可直接从快表中读出该页所对应的物理块号。如果在快表中没有对应的页表项，则还需要去访问内存中的页表，在找到物理块号后，得到要访问的物理地址。另外，还要将此页表项存入到快表中。如果快表已满，则需要找到一个合适的页表项，将其换出。 两级页表或多级页表 两级页表或多级页表的方法，将页表进行分页，使每个页面的大小与内存物理块的大小相同，并为它们进行编号，然后离散地将各个页面分别存放在不同的物理块中。同样，建立一张外层页表，每个页表项中记录了页表层面的物理块号。 在进行地址变换时，需要增加一个外层页表寄存器，用于存放外层页表的起始地址。利用外层页表始址和逻辑地址中的外层页号找到指定页表分页的始址，再利用外层页内地址找到指定的页表项，从中得到该页在内存的物理块号，最终得到物理地址。访问一次内存单元一共需要 3 次内存访问。 分段式存储管理在分段式存储管理方式中，进程的地址空间被划分为若干个段，例如主代码段、子模块代码段、堆栈段、初始化数据段、符号表等。每个段都从 0 开始编址，采用连续的地址空间，各段的长度也并不相等。 分段地址中的地址结构如下： 该地址结构中，允许一个进程最多有 64K 个段，每个段的最大长度为 64KB。 系统为每个进程建立了一张段表，用于实现从逻辑段到物理内存区的映射。每个段在表中占有一个表项，其中记录了该段在内存中的基址和段的长度。 系统中设置了段表寄存器，用于存放段表始址和段表长度。在进行地址转换时，首先将段号与段表长度进行比较。如果段号大于段表长度，则访问越界。 如果没有越界，则根据段表的始址和该段的段号，得到该段对应段表项的位置，从中读出该段在内存的起始地址。再检查段内地址是否超过该段的段长。如果超过，同样产生越界中断；否则将该段的基址和段内地址相加，最后得到要访问的内存地址。 分页式和分段式比较 采用分页存储是为了提高内存的利用率；采用分段是为了更好地满足用户的需要。 分页存储中，页面的大小由系统决定，而且大小固定；分段存储中，段的长度由用户程序决定。 分页存储中，页表中主要存储物理块号；分段存储中，段表中主要存储段基址和段长。 段页式存储管理段页式存储是分段和分页的结合，先将用户程序分为若干个段，再把每个段分成若干个页。段页式的地址结构为段号、段内页号和页内地址三部分。 为实现地址转换，系统中需要同时设置段表和页表。不过这里的段表中存储的是页表始址和段长。 在进行地址转换时，首先将段号与段长进行比较，如果段号小于段长表示未越界，于是利用段表始址和段号求出该段所对应的段表项在段表中的位置，从中得到该段的页表始址，并利用逻辑地址中的段内页号来获得对应页的页表项位置，从中读出该页所在的物理块号，再利用块号和页内地址来得到物理地址。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(4)--死锁]]></title>
    <url>%2F2019%2F01%2F10%2F%E6%AD%BB%E9%94%81%2F</url>
    <content type="text"><![CDATA[死锁概念在两个或多个并发进程中，如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么该进程集合就产生了死锁。 死锁产生的根本原因是多个进程竞争资源时，进程的推进顺序出现不当。 出现死锁的四个必要条件： 互斥。在任何时刻一个资源只能被一个进程使用。 拥有和请求。已经得到某个资源的进程可以再请求新的资源； 不可抢占。已经分配给进程的资源不能被抢占，而只能被显式释放； 循环等待。系统中有两个或多个的进程组成一条环路，该环路中的每个进程都等待着另一个进程占有的资源。 对于死锁，有四种处理的策略：1. 忽略；2. 预防死锁；3. 避免死锁；4. 检测死锁并恢复。 死锁预防预防是指通过破坏死锁产生的四个必要条件的一个或多个，以避免发生死锁。 破坏互斥：不让资源被一个进程独占，可通过假脱机技术允许多个进程同时访问资源； 破坏拥有和请求：有两种方案： 已拥有资源的进程不能再去请求其他资源。一种实现方法是要求进程在开始执行前请求需要的所有资源。 要求进程请求资源时，先暂时释放其当前拥有的所有资源，再尝试一次获取所需的全部资源。 破坏不可抢占：有些资源可以通过虚拟化方式实现可抢占； 破坏循环等待：有两种方案： 一种方法是保证每个进程在任何时刻只能占用一个资源，如果要请求另一个资源，必须先释放第一个资源； 另一种方法是将所有资源进行统一编号，进程可以在任何时刻请求资源，但要求进程必须按照顺序请求资源。 死锁避免死锁避免是利用一些事先已知的信息，在分配资源时判断是否会出现死锁，如果不会出现死锁才会分配资源。 而判断是否会出现死锁就是看是否能找到一个安全序列，系统能按照这个安全序列，也就是进程的推进顺序为每个进程分配其所需资源，直到满足每个进程所需的资源，使每个进程都能顺序执行。 银行家算法为实现银行家算法，进程在进入系统时，要求进程声明需要资源的最大数目，但不能超过系统能提供的最大资源数目。当一个进程请求资源时，需要确定是否有足够资源分配给该进程，如果有，再检查在分配资源后，系统是否安全。 假定线程数量为 n，资源类型数量为 m，银行家算法的数据结构如下： Max (总需求量)：n*m 矩阵，表示进程 Ti 最多请求 Max[i, j] 个类型为 Rj 的资源； Available (剩余空闲量)：长度为 m 的向量，表示当前有 Available[i] 个类型 Rj 的可用资源； Allocation (已分配量)：n*m 矩阵，表示进程 Ti 当前分配了 Allocation[i, j] 个类型为 Rj 的资源； Need (未来需要量)：n*m 矩阵，表示进程 Ti 未来需要 Need[i, j] 个类型为 Rj 资源； 可以得出它们满足等式：Need[i, j] = Max[i, j] - Allocation[i, j]。 银行家算法的核心部分，安全状态的判断如下： 创建长度为 m 的向量 Work，表示当前资源剩余量，并进行初始化：Work = Avaiable; 在未运行的进程中寻找未来需要量 Need[i] 比当前可用量 Work 小的进程 Ti，如果找到则继续执行 3，否则转 4； 执行 Work = Work + Allocation[j]; ，将资源分配给进程 Ti 运行完毕后，回收其资源。转 2： 如果资源可以分配给所有进程，则系统处于安全状态； 如此完整的银行家算法如下：首先进行初始化，Request_i 表示进程 Ti 的资源请求向量，Request_i[j] 表示进程 Ti 请求资源 Rj 的实例。然后循环判断： 如果 Request_i &lt;= Need[i]，转到 2。否则拒绝资源请求，因为进程已经超过最大要求； 如果 Request_i &lt;= Available，转到 3。否则进程 Ti 必须等待，因为现在可用资源不足； 通过安全状态判断来确定是否分配资源给 Ti，如果安全则分配，否则拒绝 Ti 的资源请求。 死锁检测和恢复可以允许系统进入死锁状态，但会维护一个系统的资源分配图，定期调用死锁检测算法来检测途中是否存在死锁，检测到死锁发生后，采取死锁恢复算法进行恢复。 死锁检测方法如下： 在资源分配图中，找到不会阻塞又不独立的进程结点，使该进程获得其所需资源并运行，运行完毕后，再释放其所占有的全部资源。也就是消去该进程结点的请求边和分配边。 使用上面的算法进行一系列简化，若能消去所有边，则表示不会出现死锁，否则会出现死锁。 在检测死锁时，可以采用两种方法： 抢占资源。从一个或多个进程中抢占资源分配给死锁进程。 终止进程。可以终止所有的死锁进程；也可以按照某种顺序，逐个终止进程，释放其占有资源，直到死锁解除。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(3)--进程的同步和通信方式]]></title>
    <url>%2F2019%2F01%2F08%2F%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E4%B8%8E%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[进程间同步基本概念为避免竞争条件，操作系统需要利用同步机制在并发执行的同时，保证对临界区的互斥访问。进程同步的解决方案主要有：信号量和管程。 对于同步机制，需要遵循以下四个规则： 空闲则入：没有进程在临界区时，任何进程可以进入； 忙则等待：有进程在临界区时，其他进程均不能进入临界区； 有限等待：等待进入临界区的进程不能无限期等待； 让权等待（可选）：不能进入临界区的进程，应该释放 CPU，如转换到阻塞态； 信号量信号量机制（semaphore）是一种协调共享资源访问的方法。信号量由一个变量 semaphore 和两个原子操作组成，信号量只能通过 P 和 V 操作来完成，而且 P和 V 操作都是原子操作。 将信号量表示如下： 1234typedef struct &#123; int value; struct process_control_block *list;&#125; semaphore; 相应的 P(wait) 操作和 V(signal) 操作如下实现： 123456789101112wait(semaphore *S) &#123; S-&gt;value--; if(S-&gt;value &lt; 0) &#123; block(S-&gt;list); &#125;&#125;signal(semaphore *S) &#123; S-&gt;value++; if(S-&gt;value &lt;= 0) &#123; wakeup(S-&gt;list); &#125;&#125; 信号量可分为两类：互斥信号量，信号量大小为为 0 或 1，用来实现进程的互斥访问；资源信号量，信号量大小为资源数，用来表示系统资源数目。 资源信号量 代表资源信号量时，S-&gt;value 初值表示系统资源的数目，P 操作意味着进程请求一个资源，于是系统中可分配的资源数减一，如果 S-&gt;value &lt; 0，表示该类资源已分配完毕，因此阻塞该进程，并插入信号量链表 S-&gt;list 中。小于 0 时，S-&gt;value 的绝对值表示该信号量链表中阻塞的进程数。 V 操作表示进程释放一个资源，于是系统中可分配的资源数加一，如果增加一后仍然 S-&gt;value &lt;= 0，表示该信号量链表中仍然有阻塞的进程，因此调用 wakeup，将 S-&gt;list 中的第一个进程唤醒。 互斥信号量 代表互斥信号量时，S-&gt;value 初值为 1，表示只允许一个进程访问该资源。 利用信号量实现两个进程互斥描述如下： 123456semaphore mutex = 1;P() &#123; wait(mutex); 临界区； signal(mutex);&#125; 当 mutex = 1 时，表示两个进程都没有进入临界区，当 mutex = 0 时，表示一个进程进入临界区运行；当 mutex = -1 时，表示一个进程进入临界区运行，另一个进程被阻塞在信号量队列中。 管程管程采用面向对象思想，将表示共享资源的数据结构及相关的操作，包括同步机制，都集中并封装到一起。所有进程都只能通过管程间接访问临界资源，而管程只允许一个进程进入并执行操作，从而实现进程互斥。 12345678910111213Monitor monitor_name &#123; share variable declarations; condition declarations; public: void P1(···) &#123; ··· &#125; &#123; initialization code; &#125;&#125; 管程中设置了多个条件变量，表示多个进程被阻塞或挂起的条件，条件变量的形式为 condition x, y;，它也是一种抽象数据类型，每个变量保存了一条链表，记录因该条件而阻塞的进程，与条件变量相关的两个操作：condition.cwait 和 condition.csignal。 condition.cwait：正在调用管程的进程因 condition 条件需要被阻塞，则调用 condition.cwait 将自己插入到 condition 的等待队列中，并释放管程。此时其他进程可以使用该管程。 condition.csignal：正在调用管程的进程发现 condition 条件发生变化，则调用 condition.csignal 唤醒一个因 condition 条件而阻塞的进程。如果没有阻塞的进程，则不产生任何结果。 经典同步问题生产者-消费者问题生产者-消费者问题描述的是：生产者和消费者两个线程共享一个公共的固定大小的缓冲区，生产者在生成产品后将产品放入缓冲区；而消费者从缓冲区取出产品进行处理。 它需要保证以下三个问题： 在任何时刻只能有一个生产者或消费者访问缓冲区（互斥访问）； 当缓冲区已满时，生产者不能再放入数据，必须等待消费者取出一个数据（条件同步）； 而当缓冲区为空时，消费者不能读数据，必须等待生产者放入一个数据（条件同步）。 利用信号量解决 用信号量解决生产者-消费者问题，使用了三个信号量： 互斥信号量 mutex：用来保证生产者和消费者对缓冲区的互斥访问； 资源信号量 full：记录已填充的缓冲槽数目； 资源信号量 empty：记录空的缓冲槽数目。 12345678910111213141516171819202122232425262728#define N 10int in = 0, out = 0;item buffer[N];semaphere mutex = 1, full = 0, empty = N;void producer(void) &#123; while(TRUE) &#123; item nextp = produce_item(); wait(empty); wait(mutex); buffer[in] = nextp; in = (in + 1) % N; signal(mutex); signal(full); &#125;&#125;void consumer(void) &#123; while(TRUE) &#123; wait(full); wait(mutex); item nextc = buffer[out]; out = (out + 1) % N; signal(mutex); signal(empty); consume_item(nextc); &#125;&#125; 需要注意的是进程中的多个 wait 操作顺序不能颠倒，否则可能造成死锁。例如在生产者中，当系统中没有空的缓冲槽时，生产者进程的 wait(mutex) 获取了缓冲区的访问权，但 wait(empty) 会阻塞，这样消费者也无法执行。 利用管程解决 利用管程解决时，需要为它们建立一个管程，其中 count 表示缓冲区中已有的产品数目，条件变量 full 和 empty 有 cwait 和 csignal 两个操作，另外还包括两个过程： put(x)：生产者将自己生产的产品放入到缓冲区中，而如果 count &gt;= N，表示缓冲区已满，生产者需要等待； get(x)：消费者从缓冲区中取出一个产品，如果 count &lt;= 0，表示缓冲区为空，消费者应该等待； 12345678910111213141516171819202122232425262728Monitor producerconsumer &#123; item buffer[N]; int in, out; condition full, emtpy; int count; public: void put(item x) &#123; if(count &gt;= N) &#123; cwait(full); &#125; buffer[in] = x; in = (in + 1) % N; count++; csignal(emtpy); &#125; item get() &#123; if(count &lt;= 0) &#123; cwait(emtpy); &#125; x = buffer[out]; out = (out + 1) % N; count--; csignal(full); &#125; &#123; in = 0; out = 0; count = 0; &#125;&#125; 于是生产者和消费者可描述为： 123456789101112void producer() &#123; while(TRUE) &#123; item nextp = produce_item(); producerconsumer.put(nextp); &#125;&#125;void consumer() &#123; while(TRUE) &#123; item nextc = producerconsumer.get(); consume_item(nextc); &#125;&#125; 哲学家就餐问题哲学家就餐问题描述的是：有五个哲学家共用一个圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，他们交替地进行思考和进餐。哲学家在平时进行思考，在饥饿时试图获取左右两只筷子，拿到两只筷子才能进餐，进餐完后放下筷子继续思考。 为实现筷子的互斥使用，可以用一个信号量表示一只筷子，五个信号量构成信号量数组，也都被初始化为 1。 1semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;; 第 i 位哲学家的活动可描述为： 12345678910void philosopher(int i) &#123; while(TRUE) &#123; wait(chopstick[i]); wait(chopstick[(i + 1) % 5]); // eat signal(chopstick[i]); signal(chopstick[(i + 1) % 5]); // think &#125;&#125; 上述解法中，如果五位哲学家同时饥饿而都拿起左边的筷子，再试图去拿右边的筷子时，会出现无限期等待而引起死锁。 读者-写者问题读者-写者问题描绘的是：一个文件可以被多个进程共享，允许多个 Reader 进程同时读这个文件，但不允许 Wirter 进程和其他 Reader 进程或 Writer 进程同时访问这个文件。所以读者-写者需要保证一个 Writer 进程必须与其他进程互斥地访问共享对象。 解决这个问题需要设置两个互斥信号量和一个整形变量： 互斥信号量 wmutext：实现 Reader 进程和 Writer 进程在读或写时的互斥； 整形变量 readcount：正在读的进程数目； 互斥信号量 rmutext：实现多个 Reader 进程对 readcount 变量的互斥访问； 123456789101112131415161718192021222324252627semaphore rmutex = 1, wmutex = 1;int readcount = 0;void Reader() &#123; while(TRUE) &#123; wait(rmutex); if(readcount == 0) &#123; wait(wmutex); &#125; readcount++; signal(rmutex); // perform read opertaion wait(rmutex); readcount--; if(readcount == 0) &#123; signal(wmutex); &#125; signal(rmutex); &#125;&#125;void Writer() &#123; while(TRUE) &#123; wait(wmutex); // perform wirte opertaion signal(wmutex); &#125; &#125; 只要有一个 Reader 进程在读，便不允许 Writer 进程去写。所以，仅当 readcount = 0，表示没有 Reader 进程在读时，Reader 进程才需要执行 wait(wmutex) 操作，而 readcount != 0 时，表示有其他 Reader 进程在读，也就肯定没有 Writer 在写。同理，仅当 readcount = 0 时，才执行 signal(wmutex) 类似。 进程通信进程通信是指进程之间的信息交换。在进程间要传送大量数据时，应利用高级通信方法。 共享内存在共享内存系统中，多个通信的进程共享某些数据结构或存储区，进程之间能够通过这些空间进行通信。 可分为两种类型： 基于共享数据结构的通信方式。多个进程共用某些数据结构，实现进程之间的信息交换，例如生产者-消费者问题中的缓冲区。这种方式仅适用于少量的数据，通信效率低下。 基于共享存储区的通信方式。在内存中分配一块共享存储区，多个进程可通过对该共享区域的读或写交换信息。通信的进程在通信前，需要先向系统申请共享存储区的一个分区，以便对其中的数据进行读写。 管道管道（Pipe）是指用于连接一个读进程和一个写进程以实现进程间通信的一个共享文件。发送进程以字符形式将数据送入管道，而接收进程则从管道中接收数据。 管道机制提供了三方面的协调能力： 互斥：当一个进程对管道执行读或写操作时，其他进程必须等待； 同步：当写进程把一定数量的数据写入管道，便睡眠等待，直到读进程取走数据后再把它唤醒； 确定对方是否存在，只有确定对方存在才能通信。 消息传递消息传递机制中，进程以格式化的消息为单位，将通信的数据封装在消息中，并利用操作系统提供的原语，在进程之间进行消息传递，完成进程间数据交换。 按照实现方式，可分为两类： 直接通信方式：发送进程利用操作系统提供的发送原语，直接把消息发送给进程，接收进程则利用接收原语来接收消息； 间接通信方式：发送和接收进程，通过共享中间实体方式进行消息的发送和接收，完成进程间的通信。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(2)--进程和线程]]></title>
    <url>%2F2019%2F01%2F07%2F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程什么是进程进程（process）是具有一定独立功能的程序关于某个数据集合上的一次运行活动。在传统 OS 中，进程是系统进行资源分配和调度的基本单位。进程是一个正在运行程序的实例，包括程序代码、程序计数器和寄存器的值以及系统资源（如打开的文件）等。 在某一瞬间，一个 CPU 中只能运行一个进程，它是在各个进程之间来回切换的，每个进程执行的速度也不确定。进程和程序间的联系和区别如下： 程序是一段静态的代码；进程是一个动态运行的过程； 程序是产生进程的基础；进程是程序功能的体现； 程序的每次执行都构成了不同的进程，通过多次运行，一个程序可对应多个进程；通过调用关系，一个进程可包括多个程序； 进程的实现为了实现进程，操作系统维护了一张进程表（结构数组），每个进程占用一个进程表项（进程控制块 PCB），它是进程存在的唯一标志。该表项包含了进程状态的重要信息，包括进程标识符、状态、优先级、程序计数器、堆栈指针、寄存器等； 对进程的管理就是对通过 PCB 的组织管理来实现的。由于保存了在进程的状态变化时的必要信息，在中断一个正在执行的进程，并在后来恢复时，就好像进程从未中断过。它是支持多进程和提供多处理的关键。 进程的状态及转换如下图是进程的三种状态的状态图。一个进程的三种状态是： 运行态：进程正在占用 CPU 执行； 就绪态：进程处于准备运行状态，已经获得除 CPU 外的所有资源； 阻塞态：进程由于等待某种外部事件而暂停运行，即使获得 CPU，也不能运行。 进程之间主要有四种转换关系： 由运行态转换为就绪态：在时间片用完后，不得不让出 CPU； 由就绪态转换为运行态：进程被调度，获得处理机资源； 由阻塞态转换为就绪态：进程的 I/O 请求完成； 由运行态转换为阻塞态：进程发出 I/O 请求； 线程什么是线程线程（thread）是进程中的一条执行流程。在引入线程的操作系统中，进程是拥有资源的基本单位；而线程是 CPU 调度和分派的基本单位。 一个进程中可以有多个线程，多个线程可以并发执行，它们之间共享相同的地址空间。但如果一个线程崩溃，可能会导致其所属进程的所有线程崩溃。 进程和线程的区别 调度性：传统 OS 中，进程是调度和分派的基本单位，但在引入线程后，线程是调度和分派的基本单位； 并发性：在引入线程后，多个进程可以并发执行，一个进程中的多个线程也可以并发执行； 拥有资源：进程是拥有资源的基本单位，而线程本身并不拥有资源； 系统开销：进程切换付出的系统开销明显大于线程； 线程实现的三种方式有三种线程的实现方式： 用户线程：用户空间实现，由用户线程库管理； 内核线程：内核中实现，由操作系统管理； 轻量级进程：内核中实现，支持用户线程； 用户线程 用户线程是把整个线程包放在用户空间中，不依赖于操作系统的内核，所以它可以在不支持线程的操作系统上实现。可以用一组用户级的线程函数库来实现线程。 每个进程都需要私有的线程表，用来跟踪记录该进程中线程的状态信息，不过仅记录每个线程的程序计数器、堆栈指针、寄存器和状态等，该线程表由运行时系统管理。而且用户线程的切换由线程库函数来完成，不需要用户态、核心态切换，所以线程调度速度特别快。另外，也允许每个进程都拥有自定义的线程调度算法。 但如果一个线程发起系统调用而阻塞，尽管其他线程可以运行，但整个进程都会阻塞。当一个线程开始运行后，除非它主动较交出 CPU，否则它所在的进程中的其他线程将无法运行。 内核线程 内核线程在操作系统的内核中实现，由内核来完成对线程的创建、终止和管理。 由于线程的创建、终止和切换通过系统调用执行，由内核完成的，其系统开销比较大； 但在一个进程中，如果某个内核线程发起系统调用而被阻塞，并不会影响其他使用内核线程的运行； 轻量级进程 轻量级进程是内核支持的用户线程。一个进程可以有一个或多个轻量级进程，每个轻量级进程由一个单独的内核线程来支持。而轻量级进程内部可以对应多个用户线程。 CPU 调度调度概念处理机调度是当有多个进程（线程）竞争 CPU 时，调度程序需要从从就绪队列中挑选下一个占用 CPU 运行的进程。 调度算法是为了解决通过什么样的准则来挑选就绪对列中的哪一个进程来执行。在每次调度时需要决定在下一个 CPU 计算时将哪个进程交给 CPU。 调度算法先来先服务算法FCFS 根据进程进入就绪态的先后顺序排列。当进程进入阻塞态或结束时，就绪队列中的下一个进程占用 CPU。 实现简单，但可能短进程排在长进程后面，导致平均等待时间波动较大。 短进程优先算法SJF 选择就绪队列中执行时间最短的进程占用 CPU 运行。 可抢占系统改进：短剩余时间优先算法，即选择剩余运行时间最短的进程运行。 短进程优先算法有最优的平均周转时间，但连续的短进程可能会使长进程无法获得 CPU 资源，导致饥饿；运行时间不可预估，并不可靠。 最高响应比优先算法HRN 选择就绪队列中响应比最高的进程。它是基于短进程优先算法的改进，它不允许抢占，另外等待时间越长，响应比越高，可以避免长时间地等待。 1R = (w+s)/s // 其中 w 为等待时间，s 为执行时间。 时间片轮转算法RR 按时间片分配给进程运行。在轮转中，每个进程分到执行 1/n 的时间，时间片结束时，按先来先服务算法切换到下一个就绪进程，每隔 n-1 个时间片进程会再次执行。 如果时间片过大，进程等待时间过长，极限情况下会退化为先来先服务算法；如果时间片过小，虽然反应迅速，但上下文切换开销较大，会影响系统吞吐量。 多级反馈队列算法 就绪队列被划分为多个独立的子队列，而且每个队列可以有自己的调度策略，在队列之间可以设置优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短。 在执行时，进程在不同队列间移动，如果进程在当前优先级的时间片下没有完成，则下降到低一优先级的队列，以此类推。只有当一个队列为空时才会去执行下一个队列中的进程。 这种算法对于 CPU 密集型进程的优先级下降很快，而 I/O 密集型进程停留在高优先级。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统知识回顾(1)--操作系统概述]]></title>
    <url>%2F2019%2F01%2F06%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[勿以浮沙筑高台。重视基础，这是无数前辈对新人反复强调的，操作系统恰是其中之一，它对日常程序开发或是面试都非常重要。接下来这一系列文章是对操作系统重点知识的总结与学习。 参考学习： 书籍：《现代操作系统》、《深入理解计算机系统》 视频：学堂在线 - 操作系统（自主模式） 操作系统知识点 操作系统概述： 操作系统的定义以及功能； 计算机系统体系结构； 操作系统的四个特性：并发、共享、虚拟、异步； 用户态和核心态的区别； 进程和线程： 进程的几种状态及其转换； 进程与线程的区别； 进程调度的算法； 进程同步的方式； 进程通信的方式； 死锁： 死锁的概念、导致死锁的原因； 导致死锁的四个必要条件； 处理死锁的四种方式：预防、避免、检测、解除； 存储器： 内存连续分配方式采用的算法及优缺点； 分页存储管理方式； 分段存储管理方式； 段页式存储管理方法； 几种存储方式的比较及各自优缺点； 从逻辑地址到物理地址的转换过程； 虚拟存储器： 虚拟存储器的定义与实现方式； 页面置换算法，计算所需换页数； 文件系统： 文件系统基本概念； 文件分配方式； 什么是操作系统计算机系统一般由一个或多个处理器、内存、I/O 设备等组成，而操作系统就是这些硬件之上的一种软件，它为应用程序提供了一个抽象，并管理这些计算机资源。具体可以从功能上来认识操作系统。 作为扩展机器，它隐藏硬件底层实现细节，对硬件提供抽象，方便程序或用户的使用： 进程是对 CPU、主存及 I/O 设备的抽象； 虚拟内存（虚拟地址空间）是对主存和 I/O 设备的抽象； 文件是对 I/O 设备的抽象； 作为资源管理器，它在多个竞争程序之间合理地控制对处理器、存储器及 I/O 设备的分配，避免资源使用冲突。有两种共享资源的方式： 时间复用：不同程序或用户轮流使用； 空间复用：每个程序或用户得到资源的一部分； 内核态和用户态如下图是一般计算机系统的简化图。多数计算机有两种运行模式：内核态和运行态。 操作系统运行在内核态，它对所有硬件具有访问权，可以执行任何指令。用户接口程序和其余软件运行在用户态，它只能执行机器指令中的一个子集。 四大特性操作系统主要有四大特性，分别为： 并发：在宏观上有多个程序在同时运行，需要 OS 管理和调度，而在微观上是分时交替运行； 注意并发和并行的区别： 并发指的是在一段时间内有多个应用程序可以运行； 并行指的是在一个时间点有多个应用程序可以执行，并行需要计算机有多个 CPU； 共享：资源可以供内存中多个并发执行的进程共同使用，在宏观上是同时访问该资源，而在微观上是采用互斥共享。 虚拟：利用多道程序设计，让每个应用程序都觉得有一个计算机专门为它服务。 异步：程序的执行不是连贯的，而是间断性的，其速度也不可知，但只要运行环境相同，其运行结果需要保证相同。 计算机体系结构计算机系统主要由处理器、主存、I/O 设备及系统总线组成。 处理器 也称中央处理单元（CPU），是用来解释或执行主存中的指令的引擎。在任何时候，处理器一直在不断执行程序计数器指向的指令，再更新程序计数器，指向下一条指令。 主存 主存，是一个临时存储设备，用来存放程序和程序要处理的数据。存储系统大多采用分层次的存储结构。如下图： 存储层次最顶层是寄存器。下一层是两层高速缓存 L1、L2。再下一层是主存，所有不能再高速缓存行命中的访问请求会转到内存。如果内存中还没有，可能还会到虚拟内存中查找。 在层次结构中，较高层次的存储设备可以作为较低层次设备的高速缓存。更高层次的存储设备比底层的更快，但价格也更昂贵。 I/O 设备 I/O 设备是系统与外界联系的通道。主要包括磁盘、显示器、键盘等。每个 I/O 设备都通过一个控制器或适配器与 I/O 总线相连，来传递信息。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象类和接口]]></title>
    <url>%2F2018%2F11%2F06%2F%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[抽象类抽象方法指的是仅有声明而没有方法体的方法。使用 abstract 关键字进行声明：1abstract void f() 而包含一个或多个抽象方法的类，就叫抽象类，用 abstract关键字来限定这个类。如果继承一个抽象类，要不就为基类中的所有方法提供该方法定义；要不导出类也被强制为抽象类。抽象类的主要目的是代码重用。大多用于抽象相关 Java 类的共用方法实现或共同成员变量，然后通过继承实现代码复用。在 Collection 框架中，很多通用部分被抽取为抽象类，例如 java.util.AbstractList。 接口接口就是一个完全抽象的类，没有任何的具体实现，它是对行为的抽象，使用接口可以达到 API 定义和实现分离的目的。接口不能进行实例化；接口中被定义的方法默认都是 public 的；接口中也可以使用域，但这些域隐式地都是 static 和 final 的，在 JavaSE 5 之前，可使用接口来创建常量组，而现在使用 enum 枚举类。 接口也不仅仅限于抽象方法的集合，还有一类没有任何方法的接口，它的目的就是为了声明某些东西，例如熟知的 Cloneable、Serializable，表示这个类可以克隆或者可以序列化。 Java 中，在定义一个类时，不能同时继承多个类，但是可以实现多个接口，也就是单继承、多实现，并且具体类必须放在前面，接口跟在后面。 12345678910111213141516171819202122232425interface Study &#123; void study();&#125;interface Play &#123; void play();&#125;Class Person &#123; public void doSomething() &#123; System.out.println("person doSomething"); &#125;&#125;public class Student extends Person implements Study, Play &#123; @Override public void doSomething() &#123; System.out.println("student doSomething"); &#125; void study() &#123; System.out.println("study"); &#125; void play() &#123; System.out.println("play"); &#125;&#125; 抽象类可以实现接口，也可以继承具体的类，但一般不建议这样使用，通常基类更加抽象，子类更加具体。而接口也可以继承接口（支持多继承），另外也可以在接口中添加新的方法声明。 1234567891011121314151617181920212223interface Diner &#123; void eat();&#125;interface Sleeper &#123; void sleep();&#125;// 接口可以继承接口（支持多继承）interface Student extends Diner, Sleeper &#123; void study();&#125;// 抽象类可以实现接口abstract class Undergraduate implements Student &#123; @Override public void eat() &#123; System.out.println("eat"); &#125; @Override public void sleep() &#123; System.out.println("sleep"); &#125; public abstract void study();&#125; 抽象类与接口比较 一个类只能继承一个抽象类，但可以实现多个接口； 接口中的字段只能是 static 和 final 的，而抽象类的字段没有限制； 接口中的方法只能是 public 的，而抽象类的方法则没有限制。 一般来说，接口优于抽象类，因为接口没有抽象类严格的类层次接口要求，可以灵活地为类添加性为。所以一般会把接口暴露给外部，然后在业务代码中实现接口。而且从 Java8 开始也增加了默认方法，使得修改接口的成本也降低很多。 如果多个实现类中有相同可复用的代码，则可以在接口和实现类中间加一层抽象类，将公用部分代码抽出到抽象类中。 默认方法在 Java8 之前，如果一个接口想要添加新的方法，就要修改所有实现了该接口的类，如此维护成本实在太高了。 所以从 Java8 中开始，接口支持默认方法，它表示实现接口的类如果不显式地提供该方法的具体实现，就会自动继承默认的实现，主要用于帮助库设计者以兼容的方法演进库函数。 1234567public interface Sized &#123; int size(); default boolean isEmpty() &#123; return size() == 0; &#125;&#125; 例如，Java 8 中 List 接口的 sort 方法就是默认方法。 123456789default void sort(Comparator&lt;? super E&gt; c) &#123; Object[] a = this.toArray(); Arrays.sort(a, (Comparator) c); ListIterator&lt;E&gt; i = this.listIterator(); for (Object e : a) &#123; i.next(); i.set((E) e); &#125;&#125; 1.可选方法 默认方法还可以用于可选方法。有时类实现了接口，但通常却为某些方法的实现留白。可以为其提供一个默认的实现，这样实体类就无需在实现中显示提供一个空方法。 例如，在 Java8 中，Iterator 接口为 remove 方法提供了默认实现，这样就可以减少无效的模板代码，不需要为实现 Iterator 接口的每一个类都声明一个空的 remove 方法。 1234567interface Iterator&lt;T&gt; &#123; boolean hasNext(); T next(); default void remove() &#123; throw new UnSupportedOperationException(); &#125;&#125; 2.行为的多继承 默认方法还可以实现行为的多继承，即让类拥有从多个来源重用代码的能力。例如：下面的两个接口都包含了默认实现，然后通过组合接口创建实体类，就可以调用不同的方法: 1234567891011121314151617interface Moveable &#123; int getX(); void setX(int x); default void moveHorizontally(int distance) &#123; setX(getX() + distance); &#125;&#125;interface Resizable &#123; int getWidth(); void setWidth(int width); default void resizeWidth(int distance) &#123; setWidth(getWidth() + distance); &#125;&#125; 12345678public class Change implements Moveable, Resizable &#123; public static void main(String[] args) &#123; Change c = new Change(); c.moveHorizontally(10); c.resizeWidth(10); &#125;&#125; 解决冲突Java 中一个类可以实现多个接口，在引入默认方法后有可能出现一个类继承多个方法签名相同的方法，在这种情况下，类选择执行的函数有三条规则。 第一条规则 在方法签名相同时，会优先选择类中的方法。也就是类或父类中声明的方法的优先级高于任何声明为默认方法的优先级。 1234567891011121314151617interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;class B &#123; public void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C extends B implements A &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125; 上面的例子中，由于 B 是 C 的父类，所以 B 中声明的方法优先级高于接口 A 中的默认方法。 第二条规则 如果无法根据第一条判断，那么在方法签名相同时，会优先选择拥有最具体实现的默认方法的接口，也就是子接口的优先级更高。 123456789101112131415161718interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B extends A &#123; default void hello() &#123; System.out.println("hello form B"); &#125;&#125;public class C implements A, B &#123; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello form B 在上面的例子中，由于 B 比 A 更具体，所以会选择 B 的 hello 方法。 第三条规则 如果上面两条规则无法判断，那么继承了多个接口的类必须显式地覆盖默认方法，并调用你希望调用的方法，如此显式地选择使用哪一个默认方法的实现。 1234567891011121314151617181920212223interface A &#123; default void hello() &#123; System.out.println("hello from A"); &#125;&#125;interface B &#123; default void hello() &#123; System.out.println("hello from B"); &#125;&#125;public class C implements A, B &#123; @Override public void hello() &#123; A.super.hello(); &#125; public static void main(String[] args) &#123; new C().hello(); &#125;&#125;// hello from A 上面的例子中，接口 A 和 B 无法判断谁更具体，所以必须覆盖 hello 方法，并且在调用时，使用 X.super.f() 这种语法，显式地指定使用哪一个接口中的方法。 参考资料 《Java 编程思想》 《Java8 实战》]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 中的运算]]></title>
    <url>%2F2018%2F11%2F05%2FJava%E4%B8%AD%E7%9A%84%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[值传递与引用传递先来看一下值传递与引用传递的概念： 值传递：指在调用函数时将实际参数复制一份传递到函数中，那么在函数中如果对参数进行修改，不会影响到实际参数。 引用传递：指在调用函数时将实际参数的地址直接传递到函数中，那么在函数中如果对参数进行修改，将会影响到实际参数。 那么 Java 中到底是值传递还是引用传递？先来看下面的例子： 123456789101112public static void change(int j) &#123; j = 2; System.out.println("change: j = " + j);&#125;public static void main(String[] args) &#123; int i = 1; change(i); System.out.println("main: i = " + i);&#125;// change: j = 2// main: i = 1 可以看到，change 方法内部并没有改变实际参数的值，那么 Java 就是值传递吗？再来看下面的例子： 1234567891011121314public static void change(User user) &#123; user.setAge(21); System.out.println("change: " + user);&#125;public static void main(String[] args) &#123; User user = new User(); user.setName("Timber"); user.setAge(20); change(user); System.out.println("main: " + user);&#125;// change: User&#123;name='Timber', age=21&#125;// main: User&#123;name='Timber', age=21&#125; 可以看到，实际参数的值被改变了，那么 Java 在传递基本类型时是值传递，在传递对象类型是引用类型。其实，这种表述也不对，看下面的例子： 123456789101112public static void change(String name2) &#123; name2 = "TimberLiu"; System.out.println("change: " + name2);&#125;public static void main(String[] args) &#123; String name1 = "Timber"; change(name1); System.out.println("main: " + name1);&#125;// change: TimberLiu// main: Timber 可以看到，实际参数的值又被改变了，这又作何解释呢？ Java 的值传递其实，上面的例子，关注的重点不对。对于值传递与引用传递，区别的重点在于 传递参数时是否会进行拷贝，创建一个副本。 再来看一下上面的第二个例子，是如何传递的呢？ 可以看到，当把 user 传递给 change 方法时，实际参数的地址被拷贝给了形参，而在修改内容时，并没有修改形参本身，而是修改了形参指向的地址中存储的内容。那么真正的修改形参是怎样的呢？ 12345678910111213141516public static void change(User user2) &#123; user2 = new User(); user2.setName("TimberLiu"); user2.setAge(21); System.out.println("change:" + user2);&#125;public static void main(String[] args) &#123; User user1 = new User(); user1.setName("Timber"); user1.setAge(20); change(user1); System.out.println("main: " + user1);&#125;// change: User&#123;name='TimberLiu', age=21&#125;// main: User&#123;name='Timber', age=20&#125; 这个过程发生了什么呢？看下图： 可以看到，这里把 user1 传递给 change 方法时，实际上是把实际参数的地址复制了一份，传递给了形式参数。在 change 方法中修改参数时，重新了开辟一块内存，此时形参已经指向了新的数据区域，后面对 user2 的修改并不会影响到 user1 中的内容。 所以，上面的参数其实是值传递，只是把实际参数引用的地址复制了一份当做值传递给了形式参数。 那么，为什么上面在传递 String 对象和 User 对象结果不一样呢？这是因为 String 类型是不可变的，在赋值 name2 = &quot;TimberLiu&quot; 时，会重新创建一个 String，而并没有修改实际参数的值。 所以，Java 中参数传递方式是值传递，只不过对于对象参数，值的内容是对象的引用。 类型转换Java 中除了布尔类型之外，允许把任何基本类型转换成别的基本数据类型。类型转换图如下： 在将较小的数据类型赋值给较大的数据类型时，会进行自动类型转换，但如上图中虚线的转换，可能会损失精度；而在将较大的数据类型赋值给较小的数据类型时，必须进行强制类型转换，这种转换通常都会损失精度。 另外，在对基本数据进行运算时，所有 byte、short、char 类型的值都会自动被提升为 int。而且表达式中最终结果的数据类型是由出现的最大的数据类型决定。 在计算中还有可能会超出表示范围，即溢出。对于溢出，不会抛出异常，也没有提示，所以一定要注意数据溢出问题。例如下面的例子： 123456789public class Overflow &#123; public static void main(String[] args) &#123; int big = Integer.MAX_VALUE; System.out.println("big = " + big); System.out.println("bigger = " + (big + 1)); &#125;&#125;// big = 2147483647// bigger = -2147483648 switch 对 String 的支持switch 原本只支持整型，而 byte、short、char 可以转换为 int 型，所以也可以使用。但从 Java7 开始，在 switch 条件判断语句中也可以使用 String 类型了。 123456789101112public void decompile(String str) &#123; switch(str) &#123; case "aaa": System.out.println("aaa"); break; case "bbb": System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 在反编译后，可以看到： 12345678910111213141516171819202122232425public void decompile(String str) &#123; byte var3 = -1; switch(str.hashCode()) &#123; case 96321: if (str.equals("aaa")) &#123; var3 = 0; &#125; break; case 97314: if (str.equals("bbb")) &#123; var3 = 1; &#125; &#125; switch(var3) &#123; case 0: System.out.println("aaa"); break; case 1: System.out.println("bbb"); break; default: System.out.println("other"); &#125;&#125; 可以看到，String 的 switch 还是比较的 byte 类型。先声明了一个 byte 类型，然后通过 hashCode 和 equals 两个方法先后进行比较来赋予 byte 变量不同的值，最后 switch 来执行不同的代码。这里在 hash 之后再进行 equals 判断是有必要的，因为 hash 可能发生碰撞。 参考资料 Hollis：为什么说Java中只有值传递 SEU_Calvin：Java技术——Java中的参数传值方式]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本数据类型]]></title>
    <url>%2F2018%2F11%2F03%2F%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[基本数据类型Java 中有 8 种基本数据类型，分为三类：字符型、布尔型、数值型。它们的大小、最大最小值、包装类型、默认值如下： Java 中的 char 使用 Unicode 编码，占两个字节。所以在 Unicode 编码中存在的中文，都可以用 char 存储。 在整型中，每个类型都有一定的表示范围，对于数据类型的最小最大值的计算方式可参考：Java中，为什么 byte 类型的取值范围为-128~127?。 浮点是一种对于实数的近似数值表示法，由一个有效数字和幂数来表示。Java 中使用 IEEE754表示法，分为单精度和双精度两种，也就是 float 和 double，分别占 4 个或 8 个字节。由于保存的小数近似近似值，所以在代码中不使用浮点数来表示金额等重要指标。 包装类型每一种基本类型都对应着一个包装类型，包装类就是把基本类型包装在一个类里，并提供一些常用的操作。与基本类型主要有以下区别： 默认值不同。基本类型的默认值为 0、false 等；而包装类默认为 null 初始化不同。基本类型不需要初始化；而包装类需要 new。 存储方式不同。基本类型直接存储在栈中；而包装类存储在堆中 元素类型不同。基本类型直接使用；而包装类中通过成员变量和方法 基本类型与包装类在使用时，会涉及自动拆箱和自动装箱，这是 Java5 提供的一个语法糖。自动装箱就是 Java自动将原始类型值转换为对应的对象；自动拆箱就是 Java 自动将对象转换为对应的基本类型。例如： 1234public static void main(String[] args) &#123; int i = 1; Integer n = i;&#125; 在反编译后，代码如下： 1234public static void main(String[] args) &#123; int i = 1; Integer n = Integer.valueOf(i);&#125; 可以看到，自动装箱就是调用 Integer 的 valueOf() 方法实现的；而自动拆箱是调用 Integer 的 xxxValue() 方法实现的。 整型的缓存机制Java5 中，Integer 引入了一个新功能来节省内存和提高性能。在使用 Integer.valueOf()方法时会使用缓存池中的对象，多次调用时会取得同一个对象的引用。 valueOf() 方法的实现如下： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 可以看到，缓存池中有一个默认的大小，如果值在缓存池中，会直接返回缓存池的内容，否则才会创建新的 Integer 对象。 IntegerCache 是 Integer 的一个内部类，缓存池的大小默认为 -128~127。最大值可通过 -XX:AutoBoxCacheMax=xxx 修改。这个缓存在 Integer 类第一次被使用时，通过一个 for 循环存储在一个整数数组中。 1234567891011121314151617181920212223242526272829303132private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; try &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127); // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1); &#125; catch( NumberFormatException nfe) &#123; // If the property cannot be parsed into an int, ignore it. &#125; &#125; high = h; cache = new Integer[(high - low) + 1]; int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++); // range [-128, 127] must be interned (JLS7 5.1.7) assert IntegerCache.high &gt;= 127; &#125; private IntegerCache() &#123;&#125;&#125; 由于编译器在自动装箱时会调用 valueOf 方法，所以创建多个相同的值时，会引用相同的对象。 123456public static void main(String[] args) &#123; Integer i = 123; Integer j = 123; System.out.println(i == j);&#125;// true 所有的包装类都有类似的缓存机制： ByteCache 可以缓存 Byte 对象 ShortCache 可以缓存 Short 对象 LongCache 可以缓存 Long 对象 CharacterCache 可以缓存 Character 对象 Byte、Short、Long 的缓存范围都是固定的，为 -128~127。而 CharacterCache 的范围为 0~127。除了 Integer，这个范围都不能改变。 高精度类型Java 还提供了两个用于高精度计算的类：BigInteger 和 BigDecimal。 BigInteger 支持任意精度的整数，在运算中，可以准确表示任意大小的整数值。 BigDecimal 支持任意精度的定点数。可以用它进行精确的货币运算。 在 Java 中，对于金额的运算和在数据库中的存储，一般有两种方式： 以元为单位。Java 中存储类型为 BigDecimal，在数据库中的存储类型为 number(10, 2)，表示总共占 10 位，小数位占 2 位。对于应该保留几位小数，保留时按照四舍五入还是向上、向下取整，根据业务情况决定。 以分为单位。Java 中存储类型为 Long，在数据库中存储类型为 big int。取整和保留方式如前面一样。 看一下下面的例子： 123456public static BigDecimal div(double v1, double v2) &#123; BigDecimal b1 = new BigDecimal(Double.toString(v1)); BigDecimal b2 = new BigDecimal(Double.toString(v2)); // 保留两位小数，使用四舍五入模式 return b1.divide(b2, 2, BigDecimal.ROUND_HALF_UP);&#125; 在进行金额运算时，使用 BigDecimal 类，并且将 double 转为 String 类型进行运算。在使用 divide 方法时，第二位参数为保留几位小数，第三位参数为保留小数的方式，这里使用的是四舍五入模式。 参考资料 Hollis：[译]Java中整型的缓存机制]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象中的一些概念]]></title>
    <url>%2F2018%2F11%2F01%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[this、superthis 关键字只能在方法内部使用，表示对“调用方法的那个对象“的引用。还可以用 this 调用构造器，但必须将构造器置于最起始处。 123456789101112public class User&#123; private String name; private int age; public User(String name) &#123; this.name = name; &#125; public User(String name, int age) &#123; this(name); this.age = age; &#125;&#125; super 关键字表示如果子类重写了父类的某个方法，可以通过 super 关键字来调用父类的方法实现，也可以用来调用父类的构造器。 123456789101112public class Person&#123; protected String name; protected int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public void say() &#123; System.out.println(name + ":" + age); &#125;&#125; 12345678910111213141516171819public class Student extends Person &#123; private int score; public Student(String name, int age, int score) &#123; super(name, age); this.score = score; &#125; @Override public void say() &#123; super.say(); System.out.println(name + ":" + age + "," + score); &#125; public static void main(String[] args) &#123; Student student = new Student("Timber", 20, 80); student.say(); &#125;&#125;// Timber:20// Timber:20,80 finalfinal 关键字可用于三种情况：变量、方法和类。 1.变量 对于基本类型时，final 使数值恒定不变；对于引用类型时，final 使引用恒定不变，也就是说无法指向其他对象，但是对象其本身却可以修改。 另外，在参数列表中还可以将参数声明为 final，所以在方法中无法修改参数引用指向的对象。这一特性在向匿名内部类传递数据时特别常用。 2.方法 final 方法不可以被重写。 类中所有的 private 方法都隐式地指定为 final，所以 private 方法也就无法覆盖。如果在子类中定义一个和基类中方法签名相同的方法，此时子类并不是重写了基类的方法，而是在子类中添加了一个新的方法。 3.类 final 类不能被继承，而且 final 类中的所有方法都隐式地被指定为 final，无法覆盖它们。 static当声明一个事物时，意味着这个域或方法不会与包含它的那个类的任何对象实例关联在一起。所以，即时从未创建某个类的任何对象，也可以调用其 static 方法或访问其 static 域。 1.变量 当 static 作用于某个字段时，会改变数据的创建方式，因为 static 字段对每个类只有一份存储空间，存放在方法区中；而非 static 字段则对每个对象都有一个存储空间，存放在堆中。 2.方法 对于普通方法，编译器会暗自把所操作对象的引用作为第一个参数，也就是 this 关键字。而 static 方法就是没有 this 的方法，在方法内部不能调用非静态方法。而且仅能通过类本身来调用 static 方法，实际上这正是 static 方法的主要用途。 3.静态块 Java 允许将多个静态初始化动作组成一个特殊的静态子句，即静态块。 123456public Class User &#123; private String name; static &#123; name = "Timber"; &#125;&#125; 这段代码仅当首次生成这个对象或首次访问这个类的静态成员时执行一次。 重写与重载1.重写 重写指的是在父类和继承它的子类中有两个方法名和参数列表都相同的情况。由于方法签名相同，子类中的方法会覆盖父类中原有的方法。 1234567891011121314151617class Person &#123; public void doSomething() &#123; System.out.println("do something"); &#125;&#125; class Student extends Person&#123; @Override public void doSomething() &#123; System.out.println("studying"); &#125; public static void main(String[] args) &#123; Person person = new Student(); person.doSomething(); &#125;&#125;// studying 上面就是一个重写的例子。重写一般需要注意以下几点： 子类方法的方法签名必须和父类方法相同； 子类方法的返回类型必须小于等于父类的方法； 子类中的访问权限必须大于等于父类的方法； 子类方法不能抛出新的检查异常，声明的检查异常也不能比父类方法声明的检查异常更广泛；但是可以抛出更少或更有限的异常 不能重写被标识为 final 的方法 重写指的仅是方法，对于成员变量，它则会被隐藏，也就是说，父类中的成员变量不能用子类的引用来访问，而必须用父类的引用来获得子类被隐藏的成员变量。 12345678910111213141516public class Person &#123; String s = "person";&#125;public class Student extends Person &#123; String s = "student";&#125;public class Test &#123; public static void main(String[] args) &#123; Person a1 = new Student(); System.out.println("a1.s: " + a1.s); Student a2 = new Student(); System.out.println("a2.s: " + a2.s); &#125;&#125;// a1.s: person// a2.s: student 2.重载 重载就是方法有同样的名称，但是参数列表不同的情况。参数的个数和顺序都可以区分两个方法。 123456789class Person&#123; public void doSomething() &#123; System.out.println("studying"); &#125; public void doSomething(String thing) &#123; System.out.println("studying " + thing); &#125;&#125; 上面就是一个重载的例子。重载一般需要注意几点： 被重载方法的参数列表不同。可以是参数类型不同，甚至参数顺序的不同也可以区分。 根据方法的返回值不能区分重载 重载涉及到基本类型的自动提升时可能会造成混淆。 构造器构造器是一种特殊的方法，构造器名必须与类名相同，但是它没有返回类型，不会被继承，且可以有范围修饰符。它总是与 new 运算符一起在创建对象的语句中使用，主要用来在创建对象时初始化对象。 一个类可以有多个构造器，可根据其参数个数或顺序的不同来区分它们，即构造器的重载。将没有参数的构造器称为默认构造器，如果类中没有构造器，编译器会自动创建一个默认构造器。但如果定义了构造器，编译器就不会帮你创建默认构造器，而你这样 new Person() 创建对象时就会报错。 对于方法的局部变量，必须进行初始化。而对于类的成员变量，如果没有进行初始化，就会把成员变量初始化为默认值，如 int 初始化为 0，引用类型初始化为 null等。并且成员变量会在任何方法（包括构造器）被调用之前得到初始化，按照变量定义的先后顺序所决定。 对象的创建过程如下： 当首次创建类对象，或者类的静态方法/静态域被首次访问时，Java 解释器查找类文件； 然后将类载入，此时会进行有关静态初始化的所有动作，包括静态块、静态变量等。 如果创建对象，会在堆上分配存储空间，将存储空间清零，然后将对象默认初始化，即基本类型数据设置为默认值，引用类型设置为 null； 然后执行出现于成员变量定义处的初始化动作； 然后再执行构造器。 多态多态，简单来说就是同一段代码作用于不同的对象，可以有不同的解释，以产生不同的执行结果。一般需要满足三个条件： 有类继承或接口实现 子类要重写父类的方法 父类的引用指向子类的对象 根据上面的定义，认为重写属于多态，而重载只认为它是一种语法特性。但另外一种说法，重写是动态多态，只有在运行期才能确定真正调用的是哪个对象的方法，而重载是静态多态，在编译器就已经确定具体调用哪个方法。这个问题引起很多人讨论，但并没有定论。]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对 Java 平台的理解]]></title>
    <url>%2F2018%2F10%2F30%2FJava%E5%B9%B3%E5%8F%B0%2F</url>
    <content type="text"><![CDATA[Java 是一种面向对象的语言，最显著的特性有两个方面： 跨平台特性。也就是“编译一次，到处运行”（Compile once, run anywhere)，能够非常容易地获得跨平台能力； 垃圾回收机制。Java 通过垃圾收集器回收垃圾，一般来说不需要操心内存的分配和回收。 解释型语言先来说一下编译型语言，这种语言直接将源代码编译为机器语言，然后机器就可以直接运行机器码。在以后运行程序，不需要再进行编译，执行速度快、效率高；依赖于编译器，跨平台性差。例如：C/C++ 等。 解释型语言是将源代码先编译为中间代码，再由解释器对中间代码进行解释生成机器代码，然后运行程序。相对来说，这种语言在运行时才将中间代码解释为机器代码，执行速度慢、效率低；依赖于解释器，跨平台性好。例如：Java、python 等。 严格来说，传统的 Java 是解释型语言，但加入了 JIT、AOT 编译器后，让 Java 也拥有了编译型语言的特性。它总共有三种执行的方式： Java 源代码首先经过 Javac 编译成 .class 文件，然后： 解释执行：.class 文件经过 JVM 内嵌的解释器解释执行。 编译执行：即时编译器（Just In Time 编译器）把热点代码编译成与本地平台相关的机器码执行，并进行各种层次的优化。（在运行期生成，需要预热） 编译执行: Java 9 提供的 AOT 编译器直接将代码编译成机器码执行。（在编译期，静态生成） Java 与 C++ 的区别Java 和 C++ 同为面向对象语言，它们主要区别是它们分别代表了两种类型的语言：C++ 是编译型语言，Java 是解释型语言。 二者主要区别如下： - Java C++ 语言类型 解释型 编译型 平台相关性 跨平台 平台相关的 语言 纯粹的面向对象语言 既支持面向对象也支持面向过程 数字类型 在所有平台上基本类型有标准的范围限制和字节长度 对数字类型有标准的范围限制但字节长度跟具体实现有关 参数传递 只有值传递它的引用可以理解为安全指针 有值传递和引用传递 内存管理 自动垃圾回收 需要显示的内存管理，支持析构函数 继承与实现 支持多重继承 只允许单继承，但可以多实现 操作符 不支持操作符重载仅对 String 有两个内置的加法运算 支持操作符重载 JDK、JRE、JVM下图是 Oracle 官方文档中的 JDK、JRE、JVM 三者间的关系： 三者详细： JDK：Java Development Kit（Java 开发包）。JDK 是整个 Java 的核心，包括了 Java 运行环境（Java Runtime Enviroment），Java 工具（java、javac、jdb等）和 Java 的基础类库（即 Java API，包括 rt.jar）。 JRE: Java Runtime Enviroment（Java 运行环境）。JRE 是 Java 的运行环境，所有的 Java 程序都要在 JRE 下才能运行。包括 JVM（Java Virtual Machine）、Java 核心类库和其他组件。 JVM：Java Virtual Machine（Java 虚拟机）。JVM 是一个虚构的计算机，通过在实际的计算机上模拟各种计算机功能来实现的，它有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令集。JVM 的主要工作就是解释字节码，并将其映射到本地的 CPU 的指令集或 OS 的系统调用。 跨平台特性Java 的跨平台特性与 Java 虚拟机的存在密不可分。其实 Java 语言本身与其他编程语言没有特别大的差异，并不是说 Java 语言可以跨平台，而是在不同的平台都有可以让 Java 语言运行的环境，例如，Windows 平台和 Linux 平台都有相应的 JDK，安装 JDK 也就有了 Java 的运行环境。 简单来说，Java 首先通过 javac 编译器将源码编译为字节码 .class 文件，然后通过解释器将字节码解释为机器码执行。它的跨平台性主要与解释中间代码时有关，不同操作系统的 JVM 会可以根据不同的平台，使用不同的 JVM 映射规则，生成对应的机器码，让其与操作系统无关。所以 Java 才有了“编译一次，到处运行”的效果。 Java 平台对于 Java 平台，有很多个方面可以谈： Java 语言特性：面向对象特性、泛型、Lamdba 等 基础类库：集合、IO/NIO、网络、并发等基础类库 JVM：类加载机制、垃圾回收、常用工具 Java 生态：JavaEE、Spring、Maven、Hadoop 等 下图是总结的一个蓝图：]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解面向对象思想]]></title>
    <url>%2F2018%2F10%2F28%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[学习 Java 有段时间了，但有时总感觉好像懂，又说不明白。一番询问之后，终于决定开始开个博客，从读书笔记开始，从基础开始，将自己的理解写下来。 Java 是一种面向对象的语言，那到底什么是面向对象，它与面向过程有什么区别，有什么特性，有什么基本的设计原则呢？对于 Java 平台又该如何理解？今天就来学习一下。 面向对象思想所有编程语言都提供抽象机制。汇编语言是对底层机器的轻微抽象。之后的命令式语言都是对汇编语言的抽象，它们都是面向过程语言，就是把问题分解成一个一个的步骤，然后每个步骤用函数进行实现，在使用时依次调用即可。一般都是自顶向下，逐步求精。 而面向对象语言抽象化程度更高，把问题分解为一个一个的步骤，然后对每个步骤进行抽象形成对象，通过对象之间的组合和调用来解决问题。对象具有状态和行为，也就是说，每一个对象都可以拥有内部数据（给出了对象的状态）和操作数据的方法（产生了行为）。 在面向对象程序设计中会创建抽象数据类型，也就是类 class，它描述了具有相同特性（数据）和行为（方法）的对象集合。一旦类被建立，就可以创建类的任意个对象，然后去操作它们。面向对象的挑战之一就是如何在实际要解决的问题和对象之间建立映射关系。 三大特征1.封装 封装就是隐藏对象内部的属性和实现细节，仅对外公开接口，控制程序中属性读写的访问级别。也就是将属性和方法封装起来形成类，通过访问修饰符来控制访问权限。这样做有两个好处：一是可以让客户端程序员无法触及他们不该触及的部分；二是允许库设计者可以改变类内部的工作方式而不用担心影响到客户端程序员。 Java 用三个关键字在类内设定边界：public、protected、private，还有一个默认的包访问权限，来决定紧跟其后被定义的东西可以被谁使用。 2.继承 代码复用有两种方式，一种是直接在现有类中使用新的类，这称为组合。组合带来了很大的灵活性，通常新类成员对象被声明为 private，使得使用新类的客户端不能访问它们；也可以在不干扰现有客户端代码情况下，修改这些成员。 另一种方式就是以现有类为基础，然后通过添加和修改代码来创建新类，这称为继承。当继承现有类型时，新的类型不仅包括现有类型的所有成员，而且复制了基类的接口，也就是说，所有可以发送给基类对象的消息同时也可以发送给导出类消息，也就意味着导出类与基类具有相同的类型，这也是多态实现的基础之一。有两种方法可以使基类与导出类产生差异：1、直接在导出类添加新方法；2、改变现有基类的方法，即重写 overriding。 那在建立新类时这两种方法该如何抉择呢？如果继承使用过多，会导致难以使用并过分复杂的设计，所以应该首先考虑组合，因为它更加简单灵活。 3.多态 在处理类型的层次结构时，经常将一个导出类型的对象当作其基类的对象来对待，这个过程称为向上转型，如此可以编写出不依赖于特定类型的代码。当添加新的子类型时，不需要更改调用方法，就能够执行不同代码，这称为多态。 在面向对象语言中，使用了后期绑定的概念，也就是当向对象发送消息时，编译器只确保被调用方法的存在，并对调用参数和返回值进行类型检查，被执行的确切代码直到运行时才能确定。为执行后期绑定，只需要在对象中存储某种类型信息来替代绝对地址的调用，在运行时决定具体的方法体，如此每一个对象就可以有不同的行为表现。 五大设计原则面向对象编程，需要掌握基本的设计原则，主要有以下五个，也就是 S.O.L.I.D 原则。 单一职责（Single Responsibility）：一个类最好只做一件事，这可以看作低耦合、高内聚的引申。在程序设计中如果发现某个类担任多种任务，可以考虑进行拆分。 开关封闭（Open-Closed）：设计时要对扩展开放，对修改关闭。主要体现在两个方面：1. 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2. 对修改关闭，意味着类一旦设计完成，就可以独立完成工作，而不要对其再进行修改。 里氏替换（Liskov Substitution）：面向对象的基本要素之一，进行继承关系抽象时，凡是可以用基类的地方，都可以用子类替换。 接口隔离（Interface-Segregation）：使用多个小的接口，而不要使用一个大的总接口。如果在接口内定义太多方法，其子类可能只有部分方法有意义，这就破坏了程序的内聚性。可以将其拆分为多个功能单一的接口，进行解耦。 依赖倒置（Dependency Inversion）：实体应该依赖于抽象而不是实现。也就是说，高层模块不应该依赖于底层模块，二者都应该依赖于抽象，也就是当两个模块存在紧耦合时，在依赖之间定义一个抽象的接口，高层模块调用接口，而底层模块实现接口的定义，以此来保证代码之间适当的耦合度。 对于以上设计原则，遵守它们可以增强代码的重用性，扩展性等。但在实践中还是应该根据具体情况进行利弊分析，而不是一味地遵守原则。 参考资料 《Java 编程思想》 Hollis：牢记面向对象五个基本原则 十四期_李光：面向对象与面向过程的本质的区别]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
</search>
